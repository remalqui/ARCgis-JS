/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as t}from"../../chunks/tslib.es6.js";import e from"../../core/Accessor.js";import{property as s}from"../../core/accessorSupport/decorators/property.js";import"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{subclass as o}from"../../core/accessorSupport/decorators/subclass.js";import{f as i,c as a}from"../../chunks/mat3f64.js";import{f as r,c as l}from"../../chunks/vec3f64.js";import{m as n,t as h}from"../../chunks/mat3.js";import{e as m,A as u,b as g,t as c}from"../../chunks/vec3.js";import p from"../../geometry/Point.js";import{projectBuffer as d}from"../../geometry/projection.js";import f from"../../geometry/SpatialReference.js";import{WGS84ECEFSpatialReference as V}from"../../geometry/spatialReferenceEllipsoidUtils.js";import{earth as _}from"../../geometry/support/Ellipsoid.js";import{VideoMetadataEntryId as v}from"./videoUtils.js";const A=Math.PI/180;let M=class extends e{constructor(t){super(),this.averageElevation=0,this.imageHeight=0,this.imageWidth=0,this.metadataSupportsTransforms=!1,this.platformHeadingAngle=0,this.platformPitchAngle=0,this.platformRollAngle=0,this.sensorHeadingAngle=0,this.sensorAltitude=0,this.sensorHorizontalFieldOfView=0,this.sensorLatitude=0,this.sensorLongitude=0,this.sensorPitchAngle=0,this.sensorRollAngle=0,this.sensorVerticalFieldOfView=0,this.vttMetadata=new Map,this._createMat3FromValues=t=>{const e=t[0],s=t[1],o=t[2];return i(e[0],s[0],o[0],e[1],s[1],o[1],e[2],s[2],o[2])},this._multiplyMat3=(t,e)=>{const s=a();return n(s,t,e),s},this._transposeMat3=t=>{const e=a();return h(e,t),e},this._calculateCameraFovForward=()=>this._createMat3FromValues([[0,0,1],[Math.tan(.5*this.sensorHorizontalFieldOfView*A),0,0],[0,Math.tan(.5*this.sensorVerticalFieldOfView*A),0]]),this._calculateCameraFovReverse=()=>this._createMat3FromValues([[0,1/Math.tan(.5*this.sensorHorizontalFieldOfView*A),0],[0,0,1/Math.tan(.5*this.sensorVerticalFieldOfView*A)],[1,0,0]]),this._calculateCameraLook=()=>this._getRotationMatrixZYX(this.sensorHeadingAngle*A,this.sensorPitchAngle*A,this.sensorRollAngle*A),this._calculateImageDimensionsForward=()=>this._createMat3FromValues([[2/this.imageWidth,0,-1],[0,-2/this.imageHeight,-1],[0,0,1]]),this._calculateImageDimensionsReverse=()=>this._createMat3FromValues([[this.imageWidth/2,0,this.imageWidth/2],[0,-this.imageHeight/2,-this.imageHeight/2],[0,0,1]]),this._calculatePlatformPositionMatrix=()=>{const t=Math.sin(this.sensorLatitude*A),e=Math.cos(this.sensorLatitude*A),s=Math.sin(this.sensorLongitude*A),o=Math.cos(this.sensorLongitude*A);return this._createMat3FromValues([[-t*o,-s,-e*o],[-t*s,o,-e*s],[e,0,-t]])},this._calculatePlatformOrientation=()=>this._getRotationMatrixZYX(this.platformHeadingAngle*A,this.platformPitchAngle*A,this.platformRollAngle*A),this._extractValues=t=>{this.imageWidth=t.get(v.EsriVideoWidth)?.Value,this.imageHeight=t.get(v.EsriVideoHeight)?.Value;const e=t.get(v.SensorEllipsoidHeight)?.Value;this.sensorAltitude=e??t.get(v.SensorTrueAltitude)?.Value,this.sensorLatitude=t.get(v.SensorLatitude)?.Value,this.sensorLongitude=t.get(v.SensorLongitude)?.Value,this.sensorHeadingAngle=t.get(v.SensorAzimuthAngle)?.Value,this.sensorPitchAngle=t.get(v.SensorElevationAngle)?.Value,this.sensorRollAngle=t.get(v.SensorRollAngle)?.Value,this.sensorHorizontalFieldOfView=t.get(v.SensorHorizontalFOV)?.Value,this.sensorVerticalFieldOfView=t.get(v.SensorVerticalFOV)?.Value,this.platformHeadingAngle=t.get(v.PlatformHeadingAngle)?.Value,this.platformPitchAngle=t.get(v.PlatformPitchAngle)?.Value,this.platformRollAngle=t.get(v.PlatformRollAngle)?.Value,this.averageElevation=t.get(v.FrameCenterElevation)?.Value||0},this._getRotationMatrixZYX=(t,e,s)=>{const o=Math.cos(t),i=Math.sin(t),a=Math.cos(e),r=Math.sin(e),l=Math.cos(s),n=Math.sin(s);return this._createMat3FromValues([[o*a,o*r*n-l*i,i*n+o*l*r],[a*i,o*l+i*r*n,l*i*r-o*n],[-r,a*n,a*l]])},this._initCameraSensor=()=>{const t=this._calculateCameraFovForward(),e=this._calculateCameraFovReverse(),s=this._calculateCameraLook(),o=this._calculateImageDimensionsForward(),i=this._calculateImageDimensionsReverse(),a=this._calculatePlatformPositionMatrix(),r=this._calculatePlatformOrientation(),l=this._multiplyMat3(this._multiplyMat3(a,r),s);this._imageToEarthTransform=this._multiplyMat3(this._multiplyMat3(l,t),o);const n=this._multiplyMat3(i,e);this._earthToImageTransform=this._multiplyMat3(n,this._transposeMat3(l)),this._platformPositionEcef=this._projectPointToECEF(this.sensorLongitude,this.sensorLatitude,this.sensorAltitude||this.averageElevation)},this._metadataSupportsTransforms=t=>{if(!t?.size)return!1;const e=t.get(v.EsriVideoWidth)?.Value??0,s=t.get(v.EsriVideoHeight)?.Value??0;if(e<=0||s<=0)return!1;const o=t.get(v.SensorEllipsoidHeight)?.Value,i=t.get(v.SensorTrueAltitude)?.Value,a=t.get(v.SensorLatitude)?.Value,r=t.get(v.SensorLongitude)?.Value;if(null==o&&null==i||null==a||null==r)return!1;const l=t.get(v.PlatformHeadingAngle)?.Value,n=t.get(v.PlatformPitchAngle)?.Value,h=t.get(v.PlatformRollAngle)?.Value;if(null==l||null==n||null==h)return!1;const m=t.get(v.SensorHorizontalFOV)?.Value,u=t.get(v.SensorVerticalFOV)?.Value;if(null==m||null==u)return!1;const g=t.get(v.SensorAzimuthAngle)?.Value,c=t.get(v.SensorElevationAngle)?.Value,p=t.get(v.SensorRollAngle)?.Value;return null!=g&&null!=c&&null!=p},this._projectPointToECEF=(t,e,s)=>{const o=[];return d([t,e,s],f.WGS84,0,o,V,0,1),new p({x:o[0],y:o[1],z:o[2],spatialReference:V})},this._projectImageVectorToEllipsoid=(t,e)=>{const s=_.semiMajorAxis+e,o=_.semiMinorAxis+e,i=o/s,a=s/o,{x:n,y:h,z:g}=this._platformPositionEcef,c=g??this.averageElevation,p=r(n,h,a*c),d=m(t,t),f=m(t,p),V=m(p,p)-s*s,v=(-f-Math.sqrt(f*f-d*V))/d;if(v<0)return[NaN,NaN,NaN];const A=l();return u(A,p,t,v),A[2]=A[2]*i,A};const e=t?.videoMetadata;this._set("metadataSupportsTransforms",this._metadataSupportsTransforms(e)),this.metadataSupportsTransforms&&(this._extractValues(e),this._initCameraSensor())}transformGeoToImage(t,e,s){const o=this._platformPositionEcef;if(!o)return[0,0];const{x:i,y:a,z:n}=o,h=r(i,a,n),m=this._projectPointToECEF(t,e,s||this.averageElevation),u=l(),p=r(m.x,m.y,m.z);g(u,p,h),c(u,u,this._earthToImageTransform);const d=u[0],f=u[1],V=u[2];let _=r(NaN,NaN,NaN);return isNaN(V)||(_=r(d/V,f/V,V/V)),[_[0],_[1]]}transformImageToGeo(t,e){const s=r(t,e,1),o=l();c(o,s,this._imageToEarthTransform);const i=this._projectImageVectorToEllipsoid(o,this.averageElevation);let a;if(!isNaN(i[0])){const t=[];d([i[0],i[1],i[2]],V,0,t,f.WGS84,0,1),a=new p({x:t[0],y:t[1],z:t[2],spatialReference:f.WGS84})}return a}};t([s()],M.prototype,"averageElevation",void 0),t([s()],M.prototype,"imageHeight",void 0),t([s()],M.prototype,"imageWidth",void 0),t([s({readOnly:!0})],M.prototype,"metadataSupportsTransforms",void 0),t([s()],M.prototype,"platformHeadingAngle",void 0),t([s()],M.prototype,"platformPitchAngle",void 0),t([s()],M.prototype,"platformRollAngle",void 0),t([s()],M.prototype,"sensorHeadingAngle",void 0),t([s()],M.prototype,"sensorAltitude",void 0),t([s()],M.prototype,"sensorHorizontalFieldOfView",void 0),t([s()],M.prototype,"sensorLatitude",void 0),t([s()],M.prototype,"sensorLongitude",void 0),t([s()],M.prototype,"sensorPitchAngle",void 0),t([s()],M.prototype,"sensorRollAngle",void 0),t([s()],M.prototype,"sensorVerticalFieldOfView",void 0),t([s()],M.prototype,"vttMetadata",void 0),M=t([o("esri.layers.video.VideoCameraSensorModel")],M);const y=M;export{y as default};
