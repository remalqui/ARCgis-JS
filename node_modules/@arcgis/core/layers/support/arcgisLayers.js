/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{getFilename as r,urlToObject as a}from"../../core/urlUtils.js";import{parse as t,parseNonStandardSublayerUrl as s}from"./arcgisLayerUrl.js";import{fetchFeatureService as l}from"./fetchService.js";import{sceneServiceLayerTypeToClassName as n}from"./layerUtils.js";import{layerLookupMap as o}from"./lazyLayerLoader.js";import{fetchArcGISServiceJSON as u}from"../../support/requestPresets.js";const c={FeatureLayer:!0,SceneLayer:!0};async function i(e){const r=e.properties?.customParameters,a=await p(e.url,r),t={...e.properties,url:e.url};if(!a.sublayerIds)return null!=a.layerOrTableId&&(t.layerId=a.layerOrTableId,t.sourceJSON=a.sourceJSON),new a.Constructor(t);const s=new(0,(await import("../GroupLayer.js")).default)({title:a.parsedUrl.title});return m(s,a,t),s}function y(e,r){return e?e.find((e=>e.id===r)):null}function m(e,r,a){function t(e,t){const s={...a,layerId:e,sublayerTitleMode:"service-name"};return null!=t&&(s.sourceJSON=t),new r.Constructor(s)}r.sublayerIds.forEach((a=>{const s=t(a,y(r.sublayerInfos,a));e.add(s)})),r.tableIds.forEach((a=>{const s=t(a,y(r.tableInfos,a));e.tables.add(s)}))}async function p(r,a){let s=t(r);if(null==s&&(s=await d(r,a)),null==s)throw new e("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:r});const{serverType:l,sublayer:o}=s;let i;const y={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(l){case"MapServer":if(null!=o)i="FeatureLayer";else{i=await S(r,a)?"TileLayer":"MapImageLayer"}break;case"ImageServer":{const e=await u(r,{customParameters:a}),{tileInfo:t,cacheType:s}=e;i=t?"LERC"!==t?.format?.toUpperCase()||s&&"elevation"!==s.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer";break}case"SceneServer":{const e=await u(s.url.path,{customParameters:a});if(i="SceneLayer",e){const r=e?.layers;if("Voxel"===e?.layerType)i="VoxelLayer";else if(r?.length){const e=r[0]?.layerType;null!=e&&null!=n[e]&&(i=n[e])}}break}default:i=y[l]}const m="FeatureServer"===l,p={parsedUrl:s,Constructor:null,layerOrTableId:m?o:void 0,sublayerIds:null,tableIds:null};if(c[i]&&null==o){const e=await I(r,l,a);m&&(p.sublayerInfos=e.layerInfos,p.tableInfos=e.tableInfos);1!==e.layerIds.length+e.tableIds.length?(p.sublayerIds=e.layerIds,p.tableIds=e.tableIds):m&&(p.layerOrTableId=e.layerIds[0]??e.tableIds[0],p.sourceJSON=e.layerInfos?.[0]??e.tableInfos?.[0])}return p.Constructor=await b(i),p}async function d(e,t){const l=await u(e,{customParameters:t});let n=null,o=null;const c=l.type;if("Feature Layer"===c||"Table"===c?(n="FeatureServer",o=l.id??null):"indexedVector"===c?n="VectorTileServer":l.hasOwnProperty("mapName")?n="MapServer":l.hasOwnProperty("bandCount")&&l.hasOwnProperty("pixelSizeX")?n="ImageServer":l.hasOwnProperty("maxRecordCount")&&l.hasOwnProperty("allowGeometryUpdates")?n="FeatureServer":l.hasOwnProperty("streamUrls")?n="StreamServer":f(l)?(n="SceneServer",o=l.id):l.hasOwnProperty("layers")&&f(l.layers?.[0])&&(n="SceneServer"),!n)return null;const i=null!=o?s(e):null;return{title:null!=i&&l.name||r(e),serverType:n,sublayer:o,url:{path:null!=i?i.serviceUrl:a(e).path}}}function f(e){return null!=e&&e.hasOwnProperty("store")&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function I(e,r,a){let t,s=!1;if("FeatureServer"===r){const r=await l(e,{customParameters:a});s=!!r.layersJSON,t=r.layersJSON||r.serviceJSON}else t=await u(e,{customParameters:a});const n=t?.layers,o=t?.tables;return{layerIds:n?.map((e=>e.id)).reverse()||[],tableIds:o?.map((e=>e.id)).reverse()||[],layerInfos:s?n:[],tableInfos:s?o:[]}}async function b(e){return(0,o[e])()}async function S(e,r){return(await u(e,{customParameters:r})).tileInfo}export{i as fromUrl};
