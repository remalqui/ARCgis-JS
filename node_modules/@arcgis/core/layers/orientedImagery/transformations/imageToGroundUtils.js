/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{z as e}from"../../../chunks/vec3f64.js";import{w as t,a}from"../../../chunks/vec3.js";import r from"../../../geometry/Point.js";import{project as n}from"../../../geometry/projection.js";import{geographicToWebMercator as i,webMercatorToGeographic as s}from"../../../geometry/support/webMercatorUtils.js";import x from"../core/ExposurePoint.js";import{transformPoints as c,updateElevation as y}from"./groundToImageUtils.js";import{ltpToGeographic as o,computeHFOVAndVFOV as l,projectiveTransform2 as f,scaleWithFactor as z,scaleAndAddWithFactor as p,calculateRotationMatrix as m,transformMat3 as u,projectiveTransform as w,getPlaneLineIntersectionPoint as R}from"./utils.js";import h from"../../../geometry/SpatialReference.js";import g from"../../../geometry/Polygon.js";const P=Math.PI/180;function b(e,t){if(!e)return Promise.resolve([]);const a=t.feature;let r=a.attributes;return r instanceof x||(r=x.fromJSON(a),r&&(a.attributes=r)),M(e,t)}function M(e,t){const{attributes:a}=t.feature;return a.isSpherical||360===a.horizontalFieldOfView?[]:S(e,t)}async function S(e,t){const{feature:a,imageProperties:x}=t,{attributes:z}=a;let p=new r(z.location);if(4===z.cameraOrientation?.type){const e=z.cameraOrientation;p=new r(o(p,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))}let m=!1;p.spatialReference.isWGS84&&(m=!0,p=i(p));const u=p.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*p.y/6378137))):1,w=d(t,p,u),R=4===z.cameraOrientation?.type?w.map((e=>s(new r(e)))):w,h=await c(R,t,!0),P=await Promise.all(h);P.forEach((e=>{e.z=1,e.x=e.x*x.pixelSize.x+x.extent.xmin,e.y=x.extent.ymax-e.y*x.pixelSize.y}));const b=l(z.horizontalFieldOfView,z.verticalFieldOfView,z.cameraRoll??0).vfov;return Promise.all(e.map((async e=>{e.z=1;let i,o=f(e,P,R);if(i=4===z.cameraOrientation?.type?await(await c([s(new r({...o,spatialReference:p.spatialReference}))],t,!0))[0]:await(await c([new r({...o,spatialReference:p.spatialReference})],t,!0))[0],!i)return null;i.x=i.x*x.pixelSize.x+x.extent.xmin,i.y=x.extent.ymax-i.y*x.pixelSize.y;let l,w=Math.abs(e.x-i.x)+Math.abs(e.y-i.y);if(w>1){const a=await H(e,i,P,R,p,o,t);o=a.point,w=a.error}if(a.layer.elevationSource){let a=await v(t);if(a&&a.extent){let i=F(a,p,o);if(!i)return null;const f={x:i.x,y:i.y,z:i.z,hasZ:!0,spatialReference:p.spatialReference},w=new r(f);if(i){const f=n(w,t.currentCoveragePolygon.geometry?.spatialReference),R=y([f],t,!1);let h;h=R instanceof Promise?await R:R,w.z=i.z=h[0].z;const P=await c([4===z.cameraOrientation?.type?s(w):w],t);if(!P[0])return null;P[0].x=P[0].x*x.pixelSize.x+x.extent.xmin,P[0].y=x.extent.ymax-P[0].y*x.pixelSize.y;let M=Math.abs(e.x-P[0].x)+Math.abs(e.y-P[0].y);if(l=i.z,M>1){let f=0;const w=async R=>{if(M>1){const h=R.width/10,P=R.height/10;if(!R||h<1||P<1)return o=O(o,p,u,l,z.cameraPitch,b,m),o;const S=[{x:i.x-h,y:i.y-P,spatialReference:p.spatialReference},{x:i.x+h,y:i.y-P,spatialReference:p.spatialReference},{x:i.x+h,y:i.y+P,spatialReference:p.spatialReference},{x:i.x-h,y:i.y+P,spatialReference:p.spatialReference}].map((e=>new r(e))),d=await y(S,t,!1);if(a=new g({rings:[[[d[0].x,d[0].y,d[0].z],[d[1].x,d[1].y,d[1].z],[d[2].x,d[2].y,d[2].z],[d[3].x,d[3].y,d[3].z],[d[0].x,d[0].y,d[0].z]]],spatialReference:p.spatialReference}),i=F(a,p,o),i){const y=n(new r({x:i.x,y:i.y,z:i.z,spatialReference:p.spatialReference}),t.currentCoveragePolygon.geometry?.spatialReference),R=await c([4===z.cameraOrientation?.type?s(y):y],t);if(R[0])return R[0].x=R[0].x*x.pixelSize.x+x.extent.xmin,R[0].y=x.extent.ymax-R[0].y*x.pixelSize.y,M=Math.abs(e.x-R[0].x)+Math.abs(e.y-R[0].y),l=i.z,M<=1||8===f?O(o,p,u,l,z.cameraPitch,b,m):(f+=1,w(a.extent))}return O(o,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)}return O(o,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)};return w(a.extent)}return O(o,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)}return O(o,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)}}return O(o,p,u,p.z-z.cameraHeight,z.cameraPitch,b,m)})))}function O(a,n,i,x,c,y,o){const l=Math.sqrt((a.z-n.z)**2+(Math.sqrt((a.x-n.x)**2+(a.y-n.y)**2)/i)**2)*i,f=z(t(e(),[a.x,a.y,a.z],[n.x,n.y,n.z]),1/l,1/i);if(a.z<x||c+y/2<90){const e=Math.abs((n.z-x)/-f[2])*i,t=p([n.x,n.y,n.z],f,e,i);a={x:t[0],y:t[1],z:t[2]}}else a.z=x;return a.spatialReference=n.spatialReference,a=new r(a),o&&(a=s(a)),a}function d(n,i,s){const{feature:x}=n,{attributes:c}=x,y=2*Math.tan(c.verticalFieldOfView*P/2)*c.farDistance*s,o=2*Math.tan(c.horizontalFieldOfView*P/2)*c.farDistance*s,l=m("HPR",[c.cameraHeading,c.cameraPitch,c.cameraRoll??0]),f=u([0,0,-1],l),w=p([i.x,i.y,i.z],f,c.farDistance*s,s),R=u([0,1,0],l),h=u([1,0,0],l),g=z(R,y/2,s),b=z(h,o/2,s),M=t(e(),g,b),S=a(e(),g,b);return[a(e(),w,M),a(e(),w,S),t(e(),w,M),t(e(),w,S)].map((e=>{const[t,a,n]=e;return new r({x:t,y:a,z:n,spatialReference:i.spatialReference})}))}function v(e){const{feature:t}=e,a=j(e);if(!a)return Promise.resolve(null);const r=t.attributes.location.spatialReference.isWGS84?new h({wkid:102100}):t.attributes.location.spatialReference;return y(a,e,!1).then((e=>{const t=e.map((e=>n(e,r)));return new g({hasZ:!0,rings:[t.map((e=>[e.x,e.y,e.z]))],spatialReference:r})}))}function j(e){if(!e.currentCoveragePolygon.geometry)return null;const{xmin:t,xmax:a,ymin:n,ymax:i,spatialReference:s}=e.currentCoveragePolygon.geometry.extent.toJSON();return[new r({x:t,y:i,spatialReference:s}),new r({x:a,y:i,spatialReference:s}),new r({x:a,y:n,spatialReference:s}),new r({x:t,y:n,spatialReference:s})]}async function H(e,t,a,n,i,x,y){const{feature:{attributes:o},imageProperties:l}=y;let f=Math.abs(e.x-t.x)+Math.abs(e.y-t.y);if(f>1)for(let z=0;z<9;z++)if(f>1){let t,p={x:e.x-f,y:e.y-f,z:1},m={x:e.x+f,y:e.y-f,z:1},u={x:e.x+f,y:e.y+f,z:1},R={x:e.x-f,y:e.y+f,z:1};p=w(p,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),m=w(m,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),u=w(u,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),R=w(R,a[0],a[1],a[2],a[3],{x:n[0].x,y:n[0].y,z:n[0].z},{x:n[1].x,y:n[1].y,z:n[1].z},{x:n[2].x,y:n[2].y,z:n[2].z},{x:n[3].x,y:n[3].y,z:n[3].z}),p.spatialReference=i.spatialReference,m.spatialReference=i.spatialReference,u.spatialReference=i.spatialReference,R.spatialReference=i.spatialReference,t=4===o.cameraOrientation?.type?await c([s(new r(p)),s(new r(m)),s(new r(u)),s(new r(R))],y,!0):await c([new r(p),new r(m),new r(u),new r(R)],y,!0);const h=await Promise.all(t);h.forEach((e=>{e.z=0,e.x=e.x*l.pixelSize.x+l.extent.xmin,e.y=l.extent.ymax-e.y*l.pixelSize.y}));const g=w(e,h[0],h[1],h[2],h[3],p,m,u,R);let P;if(P=4===o.cameraOrientation?.type?await(await c([s(new r({x:g.x,y:g.y,z:g.z,spatialReference:i.spatialReference}))],y,!0))[0]:await(await c([new r({x:g.x,y:g.y,z:g.z,spatialReference:i.spatialReference})],y,!0))[0],f=Math.abs(e.x-P.x)+Math.abs(e.y-P.y),f<=1||8===z){x=g;break}}return{error:f,point:x}}function F(e,t,a){const r={x:e.rings[0][0][0],y:e.rings[0][0][1],z:e.rings[0][0][2]},n={x:e.rings[0][1][0],y:e.rings[0][1][1],z:e.rings[0][1][2]},i={x:e.rings[0][1][0],y:e.rings[0][1][1],z:e.rings[0][1][2]},s={x:e.rings[0][2][0],y:e.rings[0][2][1],z:e.rings[0][2][2]},x=(s.z-i.z)*(n.y-r.y)-(s.y-i.y)*(n.z-r.z),c=-((s.z-i.z)*(n.x-r.x)-(n.z-r.z)*(s.x-i.x)),y=(s.y-i.y)*(n.x-r.x)-(n.y-r.y)*(s.x-i.x),o=-(x*r.x+c*r.y+y*r.z);return R(t.toJSON(),a,x,c,y,o)}export{b as transformPoints};
