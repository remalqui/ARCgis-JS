/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{j as t}from"../../../chunks/mat3.js";import a from"../../../geometry/Point.js";import{project as r}from"../../../geometry/projection.js";import{geographicToWebMercator as i}from"../../../geometry/support/webMercatorUtils.js";import n from"../../ElevationLayer.js";import{calculateRotationMatrix as o,geographicToLTP as s}from"./utils.js";function c(e){return"esri.Graphic"===e?.declaredClass}const l=Math.PI/180;async function m(e,t,r=!1){if(!e)return[];e=e.map((e=>"esri.geometry.Point"===e.declaredClass?e:a.fromJSON(e)));const{feature:i}=t,{attributes:n}=i;if(isNaN(parseFloat(n.elevation))){const e=await u([i.geometry],t);i.attributes.elevation=e[0].z}return u(e,t,r).then((e=>p(e,t)))}async function u(e,t,a=!1){if(a)return f(e,1);const{feature:i,options:o,currentCoveragePolygon:s}=t,l=i.attributes.elevationSource;if(!l?.url&&!l?.constantElevation)return e;const{url:m,constantElevation:u}=l;if(u)return f(e,u);if(!i.elevationSample){const e=c(s)?s.geometry?.extent:s.extent;if(e){const t=e.clone(),a=new n(m);t.xmin/=2,t.xmax*=2,t.ymin/=2,t.ymax*=2,i.elevationSample=await a.createElevationSampler(t,o),a.destroy()}}return Promise.all(e.map((async e=>{e.z=1;const t=i.elevationSample?.queryElevation(r(e,i.elevationSample.spatialReference));return t?.z&&(e.z=t.z),e})))}function f(e,t){return e.map((e=>(e.z=t,e)))}function p(e,t){const{attributes:a}=t.feature;return a.isSpherical||360===a.horizontalFieldOfView?{}:a.cameraOrientation?.isAdvanced?d(e,t):Promise.resolve(y(e,t))}function y(e,r){const{feature:n,imageProperties:c}=r,{width:m,height:u}=c,{attributes:f}=n,p=o("HPR",[f.cameraHeading,f.cameraPitch,f.cameraRoll]),y=Math.sin(f.imageRotation??0*l),d=Math.cos(f.imageRotation??0*l),h=m??1,g=u??1,v=[Math.abs(d*h+y*g),Math.abs(d*g-y*h)],w={horizontal:1/(2*Math.tan(f.horizontalFieldOfView*l/2)),vertical:1/(2*Math.tan(f.verticalFieldOfView*l/2))},x=[-w.horizontal,0,.5,0,w.vertical,.5,0,0,1];let M=new a(f.geometry);M.spatialReference.isWGS84&&4!==f.cameraOrientation?.type&&(M=i(M));const P=M.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*M.y/6378137))):1,R=t(new Array(9),p,x);return e.map((e=>{let t=new a(e);if(t.spatialReference.isWGS84)if(4===f.cameraOrientation?.type){const e=f.cameraOrientation;t=new a(s(t,[e.latitude,e.longitude,e.ellipsoidRadius,e.squaredEccentricity]))}else t=new a(i(t));const r=(t.z??0)-(M.z??0),n=(t.x-M.x)/P,o=(t.y-M.y)/P,c=(R[0]*n+R[1]*o+R[2]*r)/(R[6]*n+R[7]*o+R[8]*r),l=(R[3]*n+R[4]*o+R[5]*r)/(R[6]*n+R[7]*o+R[8]*r),m={x:c*v[0],y:l*v[1]};return{x:d*(m.x-v[0]/2)+y*(m.y-v[1]/2)+h/2,y:-y*(m.x-v[0]/2)+d*(m.y-v[1]/2)+g/2}}))}function d(t,n){const{feature:c}=n,{attributes:l}=c,m=l.cameraOrientation;if(!m)throw new e("groundToImageUtils:missing-camera-orientation-parameters","CameraOrientation Parameters are required to perform advanced transformations");let u=new a(l.location);u.spatialReference.isWGS84&&4!==l.cameraOrientation?.type&&(u=i(u));const f=u.spatialReference.isWebMercator?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*u.y/6378137))):1;let p;if("esri.layers.orientedImagery.core.CameraOrientationOPK"===m.declaredClass){const{omega:e,phi:t,kappa:a}=m;p=o("OPK",[e,t,a])}else{const{cameraHeading:e,cameraPitch:t,cameraRoll:a}=l;p=o("HPR",[e,t,a])}const{principalOffsetPoint:y,focalLength:d,radialDistortionCoefficients:h,affineTransformations:g,tangentialDistortionCoefficients:v}=m;return Promise.all(t.map((e=>{let t;return e.spatialReference.equals(u.spatialReference)?(t=new a(e),n(t)):(t=r(e,u.spatialReference),t?n(t):null);function n(e){if(e.spatialReference.isWGS84)if(4===l.cameraOrientation?.type){const t=l.cameraOrientation;e=new a(s(e,[t.latitude,t.longitude,t.ellipsoidRadius,t.squaredEccentricity]))}else e=new a(i(e));const t=(e.z??0)-(u.z??0),r=(e.x-u.x)/f,n=(e.y-u.y)/f,o=(p[0]*r+p[1]*n+p[2]*t)/(p[6]*r+p[7]*n+p[8]*t),c=(p[3]*r+p[4]*n+p[5]*t)/(p[6]*r+p[7]*n+p[8]*t),m=o**2+c**2;let w=0,x=0,M=0,P=0,R=0,b=0,O=0;h&&(w=h[0]??0,x=h[1]??0,M=h[2]??0),v&&(P=v[0],R=v[1]),y&&(b=y[0]??0,O=y[1]??0);const z=1+(w||0)*m+(x||0)*m*m+(M||0)*m*m*m;let S=o*z+(P||0)*(m+2*o**2)+2*(R||0)*o*c,j=c*z+(R||0)*(m+2*c**2)+2*(P||0)*o*c;S=-(d??0)*S+b,j=-(d??0)*j+O;return{x:Number(g[0])+Number(g[1])*S+Number(g[2])*j,y:Number(g[3])+Number(g[4])*S+Number(g[5])*j}}})))}export{m as transformPoints,u as updateElevation};
