/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import{result as i}from"../../../core/asyncUtils.js";import r from"../../../core/Collection.js";import has from"../../../core/has.js";import s from"../../../core/Error.js";import a from"../../../core/Handles.js";import{clone as l}from"../../../core/lang.js";import n from"../../../core/Logger.js";import{destroyMaybe as o,removeMaybe as h,abortMaybe as c}from"../../../core/maybe.js";import{EsriPromiseMixin as u}from"../../../core/Promise.js";import{createAbortError as d,isAbortError as m,eachAlways as p}from"../../../core/promiseUtils.js";import{initial as _,whenOnce as f,watch as y,syncAndInitial as g,sync as x}from"../../../core/reactiveUtils.js";import{property as F}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as v}from"../../../core/accessorSupport/decorators/subclass.js";import{WatchUpdatingTracking as T}from"../../../core/support/WatchUpdatingTracking.js";import{isHostedAgolService as E}from"../../support/arcgisLayerUrl.js";import{getEffectiveLayerCapabilities as w}from"../../support/layerUtils.js";import{projectGeometry as C}from"../../../portal/support/geometryServiceUtils.js";import b from"../../../rest/support/StatisticDefinition.js";import{FeatureTileFetcher3D as D}from"../../../views/3d/layers/support/FeatureTileFetcher3D.js";import{FeatureTileFetcher3DDebugger as S}from"../../../views/3d/layers/support/FeatureTileFetcher3DDebugger.js";import O from"../../../views/3d/support/debugFlags.js";let I=class extends(u(t)){set extent(e){if(null!=e&&!e.spatialReference.equals(this.layerView.view.spatialReference))return void n.getLogger(this).error("#extent=","extent needs to be in the same spatial reference as the view");const t=this._get("extent");if(t===e)return;if(null!=t&&e&&t.equals(e))return;const i=null!=e?e.clone():null;this._set("extent",i)}get updating(){return!!(null!=this._tileFetcher&&this._tileFetcher.updating||null!=this._fetchDataInfoPromise||"tiles"===this.mode&&this.layerView.view.featureTiles&&this.layerView.view.featureTiles.updating||this._watchUpdatingTracking&&this._watchUpdatingTracking.updating)}get updatingTotal(){return this.updating&&null!=this._tileFetcher?this._tileFetcher.updatingTotal:0}get updatingRemaining(){return this.updating&&null!=this._tileFetcher?this._tileFetcher.updatingRemaining:0}get expectedFeatureDiff(){return this.updating&&null!=this._tileFetcher?this._tileFetcher.expectedFeatureDiff:0}get memoryForUnusedFeatures(){return null!=this._tileFetcher?this._tileFetcher.memoryForUnusedFeatures:0}get maximumNumberOfFeaturesExceeded(){return!(null==this._tileFetcher||!this._tileFetcher.maximumNumberOfFeaturesExceeded)}get maximumNumberOfFeatures(){return null!=this.displayFeatureLimit?this.displayFeatureLimit.maximumNumberOfFeatures:0}set maximumNumberOfFeatures(e){e!==this.maximumNumberOfFeatures&&this._overrideIfSome("maximumNumberOfFeatures",e)}get hasMaximumNumberOfFeaturesOverride(){return this._isOverridden("maximumNumberOfFeatures")}get mode(){const e=this.layerView.layer;if("feature"===e.type&&null!=e.infoFor3D)return"snapshot";if(!1===this.layerView.view.qualitySettings?.graphics3D?.snapshotAvailable||this.serviceDataCount===P.NO_SERVICE_DATA_COUNT||this.vertexLimitExceeded)return"tiles";const t=this.layerView.view,i=t&&t.featureTiles,r=i&&i.tilingScheme;if(e&&e.minScale&&this.serviceDataExtent&&r){const t=this._approximateExtentSizeAtScale(e.minScale,r);if((this.serviceDataExtent.width/t+this.serviceDataExtent.height/t)/2>P.MAX_SNAPSHOT_MIN_SCALE_FACTOR)return"tiles"}return!this.maximumNumberOfFeatures||this.serviceDataCount<=this.maximumNumberOfFeatures?"snapshot":"tiles"}get maxTotalSnapshotVertices(){const e=this._get("maxTotalSnapshotVertices")||0,t="snapshot"===this.mode&&null!=this._tileFetcher&&this._tileFetcher.totalVertices||0;return Math.max(e,t)}_approximateExtentSizeAtScale(e,t){const i=this.layerView.view,r=Math.ceil((i.width/t.pixelSize+i.height/t.pixelSize)/2),s=t.levels[0];return r*((s.tileSize[0]/(s.scale/e)+s.tileSize[1]/(s.scale/e))/2)}get tileDescriptors(){return"snapshot"===this.mode?new r([{id:"dummy-tile-full-extent",lij:[0,0,0]}]):this.layerView.view.featureTiles?this.layerView.view.featureTiles.tiles:new r}get test(){return{fetchDataInfoPromise:this._fetchDataInfoPromise,tileFetcher:this._tileFetcher}}constructor(e){super(e),this.type="feature-tile-3d",this._watchUpdatingTracking=new T,this.serviceDataExtent=null,this.serviceDataCount=P.NO_SERVICE_DATA_COUNT,this.vertexLimitExceeded=!1,this.displayFeatureLimit=null,this._suspended=!1,this._tileFetcher=null,this._handles=new a,this._fetchDataInfoPromise=null,this._fetchDataInfoAbortController=null,this._lifeCycleAbortController=new AbortController}initialize(){this._watchUpdatingTracking.add((()=>this.vertexLimitInfo),(()=>this._watchUpdatingTracking.addPromise(this._updateVertexLimitExceeded(null,this._lifeCycleAbortController.signal)))),this._watchUpdatingTracking.add((()=>this.mode),(()=>this._modeChanged()),_),this.addResolvingPromise(Promise.resolve().then((()=>this._verifyCapabilities())).then((()=>this._watchUpdatingTracking.addPromise(this._fetchServiceDataInfo()))).then((()=>this._initializeTileFetcher())))}_verifyCapabilities(){const e=this.layerView.layer;if("ogc-feature"!==e.type&&!w(e)?.operations.supportsQuery)throw new s("graphicscontroller:query-capability-required","Service requires query capabilities to be used as a feature layer",{layer:e})}destroy(){this._cancelFetchServiceDataInfo(),this._tileFetcher=o(this._tileFetcher),this._handles=o(this._handles),this._tilesHandle=h(this._tilesHandle),this._lifeCycleAbortController=c(this._lifeCycleAbortController),this._watchUpdatingTracking.destroy(),this._set("_watchUpdatingTracking",null)}suspend(){this._suspended||(this._suspended=!0,null!=this._tileFetcher&&this._tileFetcher.suspend())}resume(){this._suspended&&(this._suspended=!1,null!=this._tileFetcher&&this._tileFetcher.resume())}restart(){const e=()=>{null!=this._tileFetcher&&this._tileFetcher.restart()};this._watchUpdatingTracking.addPromise(this._fetchServiceDataInfo().then(e,e))}refetch(){const e=()=>{null!=this._tileFetcher&&this._tileFetcher.refetch()};this._watchUpdatingTracking.addPromise(this._fetchServiceDataInfo().then(e,e))}_initializeTileFetcher(){const e=this.layerView.view;if(!e)return;const t=f((()=>e.featureTiles?.tilingScheme),this._lifeCycleAbortController.signal);this._watchUpdatingTracking.addPromise(t),t.then((()=>{const{layerView:t,tileDescriptors:i}=this,r=t.layer,s=new D({context:this.context,filterExtent:this.extent,tileDescriptors:i,features:this.graphics});this._tileFetcher=s,this._suspended?this._tileFetcher.suspend():this._tileFetcher.resume();const a=this.layerView.view.resourceController;a&&this._handles.add(y((()=>a.memoryController?.memoryFactor),(e=>s.memoryFactor=e),g));const l="polygon"===this.context.geometryType?"polygonLodFactor":"polyline"===this.context.geometryType?"polylineLodFactor":null;l&&this._handles.add(y((()=>this.layerView.view?.qualitySettings?.graphics3D?.[l]),(e=>s.lodFactor=e||1),_));const n=e=>{s.maximumNumberOfFeatures=e,s.useTileCount=this.serviceDataCount>e},o=e=>s.useTileCount=e>this.maximumNumberOfFeatures;"ogc-feature"!==r.type&&this._watchUpdatingTracking.add((()=>r.createQueryVersion),(()=>this._dataFilterChanged())),this._watchUpdatingTracking.add((()=>t.availableFields),((e,t)=>this._availableFieldsChanged(t,e))),this._watchUpdatingTracking.add((()=>t.requiredFields),((e,t)=>this._requiredFieldsChanged(t,e))),this._handles.add([r.on("apply-edits",(e=>this._applyEdits(e))),y((()=>this.extent),(e=>s.filterExtent=e),x),y((()=>this.tileDescriptors),(e=>s.tileDescriptors=e),x),y((()=>this.maximumNumberOfFeatures),n,g),y((()=>this.serviceDataCount),o,g),y((()=>O.FEATURE_TILE_FETCH_SHOW_TILES),(t=>{t&&s&&!s.debugger?(s.debugger=new S(s,e.featureTiles.tilingScheme.toTileInfo(),e),s.debugger.update()):!t&&this._tileFetcher&&s.debugger&&(s.debugger.destroy(),s.debugger=null)}),g)]),this._supportsExceedsLimitQuery||this._watchUpdatingTracking.add((()=>this.maxTotalSnapshotVertices),(()=>this._watchUpdatingTracking.addPromise(this._updateVertexLimitExceeded(null,this._lifeCycleAbortController.signal))))})).catch((()=>{}))}_modeChanged(){switch(this.mode){case"tiles":this._tilesHandle||(this._tilesHandle=this.layerView.view.featureTiles.addClient());break;default:n.getLogger(this).warn("Unhandled feature layer mode "+this.mode);case"snapshot":null!=this._tilesHandle&&(this._tilesHandle.remove(),this._tilesHandle=null)}}_dataFilterChanged(){this._set("maxTotalSnapshotVertices",0),this.notifyChange("maxTotalSnapshotVertices"),this.refetch()}_applyEdits(e){null!=this._tileFetcher&&this._tileFetcher.applyEdits(e).then((e=>{if(e){if(!this._lifeCycleAbortController)throw d();e.exceededTransferLimit?this.layerView.layer.refresh():(e.deletedFeatures.length||e.updatedFeatures.length||e.addedFeatures.length)&&this._watchUpdatingTracking.addPromise(this._updateServiceDataExtent(this._lifeCycleAbortController.signal))}})).catch((e=>{if(!m(e))throw e}))}_availableFieldsChanged(e,t){null!=this._tileFetcher&&L(this._tileFetcher.availableFields,t)&&this.refetch()}_requiredFieldsChanged(e,t){null!=this._tileFetcher&&L(this._tileFetcher.availableFields,t)&&this.restart()}_createVertexLimitExceededQuery(e){const t=this.layerView.layer,i=t.createQuery();return i.returnGeometry=!1,i.outStatistics=[new b({statisticType:"exceedslimit",maxVertexCount:e,outStatisticFieldName:"exceedslimit",maxPointCount:1e8,maxRecordCount:1e8})],t.capabilities?.query.supportsCacheHint&&(i.cacheHint=!0),i}_createDataInfoQuery(){const e=this.layerView.layer,t=e.createQuery();return t.returnGeometry=!1,t.outSpatialReference=this.layerView.view.spatialReference,e.capabilities?.query.supportsCacheHint&&(t.cacheHint=!0),t}_fullExtentIsAccurate(){const e=this.layerView.layer;if(e.definitionExpression)return!1;switch(e.type){case"feature":case"oriented-imagery":return E(e.url);case"csv":case"geojson":case"ogc-feature":case"wfs":return!0;default:return}}async _updateServiceDataExtent(e){try{await this._tryUpdateServiceDataExtent(e)}catch(t){m(t)||this._set("serviceDataExtent",l(this.layerView.fullExtentInLocalViewSpatialReference))}}async _tryUpdateServiceDataExtent(e){const t=this.layerView,i=t.layer,r=i.capabilities?.query.supportsExtent??!1,s=l(t.fullExtentInLocalViewSpatialReference),a=i.fullExtent,n=this._fullExtentIsAccurate(),o=this.serviceDataCount;if(r&&o<=P.MAX_FEATURE_COUNT_FOR_EXTENT&&(!s||!n)&&"queryExtent"in i){const t=this._createDataInfoQuery(),r=await i.queryExtent(t,{timeout:P.QUERY_EXTENT_TIMEOUT,signal:e});this._set("serviceDataExtent",r.extent)}else if(s)this._set("serviceDataExtent",s);else if(null!=a){const r="portalItem"in i?i.portalItem:null,s=await C(a,t.view.spatialReference,r,e);this._set("serviceDataExtent",s)}else this._set("serviceDataExtent",null)}async _updateServiceDataCount(e){const t=this.layerView.layer;if(!("queryFeatureCount"in t)||!has("featurelayer-snapshot-enabled"))return void this._set("serviceDataCount",P.NO_SERVICE_DATA_COUNT);const r=await i(t.queryFeatureCount(this._createDataInfoQuery(),{timeout:P.QUERY_STATISTICS_TIMEOUT,signal:e}));if(!0===r.ok)this._set("serviceDataCount",r.value);else{if(m(r.error))throw r.error;this._set("serviceDataCount",P.NO_SERVICE_DATA_COUNT)}}get vertexLimitInfo(){if(null==this.displayFeatureLimit||null==this.displayFeatureLimit.averageSymbolComplexity)return null;const{averageSymbolComplexity:e,maximumTotalNumberOfPrimitives:t}=this.displayFeatureLimit,{primitivesPerCoordinate:i,primitivesPerFeature:r}=e,s=this._get("vertexLimitInfo");return null==s||s.maximumTotalNumberOfPrimitives!==t||s.primitivesPerCoordinate!==i||s.primitivesPerFeature!==r?{primitivesPerCoordinate:i,primitivesPerFeature:r,maximumTotalNumberOfPrimitives:t}:s}get _supportsExceedsLimitQuery(){const e=this.layerView.layer;return null!=e.capabilities&&e.capabilities.operations&&e.capabilities.operations.supportsExceedsLimitStatistics}get _minimumNumberOfVerticesForGeometry(){switch(this.layerView.layer.geometryType){case"point":case"multipoint":return 1;case"polygon":return 4;case"polyline":return 2;case"multipatch":case"mesh":return 3;default:return 0}}async _updateVertexLimitExceeded(e,t){const r=this.vertexLimitInfo;if(null==r)return void this._set("vertexLimitExceeded",!1);const s=r.primitivesPerFeature<=0,a=this._minimumNumberOfVerticesForGeometry>1;if(!s&&!a)return void this._set("vertexLimitExceeded",!1);const{primitivesPerFeature:l,primitivesPerCoordinate:n,maximumTotalNumberOfPrimitives:o}=r;let h;0!==l&&null!=e&&await e;const c=this.serviceDataCount,u=c!==P.NO_SERVICE_DATA_COUNT;if(h=u?Math.ceil((o-c*l)/(n||1)):Math.ceil(o/(n||1)),a&&(h=Math.min(h,N)),u&&this._minimumNumberOfVerticesForGeometry*c>h)return void this._set("vertexLimitExceeded",!0);if(!this._supportsExceedsLimitQuery||!has("featurelayer-snapshot-enabled"))return void this._set("vertexLimitExceeded",this.maxTotalSnapshotVertices>h);const d=await i(this.layerView.layer.queryFeatures(this._createVertexLimitExceededQuery(h),{timeout:P.QUERY_STATISTICS_TIMEOUT,signal:t}));if(!1===d.ok){if(m(d.error))throw d.error;return void this._set("vertexLimitExceeded",!1)}const p=d.value.features[0];p&&p.attributes?this._set("vertexLimitExceeded",!!p.attributes.exceedslimit):this._set("vertexLimitExceeded",!1)}async _fetchServiceDataInfo(){this._cancelFetchServiceDataInfo();let e=new AbortController;const t=e.signal,i=this._updateServiceDataCount(t),r=p([i,this._updateVertexLimitExceeded(i,t)]),s=r.then((()=>this._updateServiceDataExtent(t))).catch((e=>{m(e)||n.getLogger(this).error("#fetchServiceDataInfo()",e)})).then((()=>{s===this._fetchDataInfoPromise&&(this._fetchDataInfoPromise=null,this._fetchDataInfoAbortController=null),e=null}));return e&&(this._fetchDataInfoPromise=s),this._fetchDataInfoAbortController=e,r.then((()=>{}),(()=>{}))}_cancelFetchServiceDataInfo(){const e=this._fetchDataInfoAbortController;e&&(this._fetchDataInfoAbortController=null,this._fetchDataInfoPromise=null,e.abort())}get debug(){return{storedFeatures:null!=this._tileFetcher?this._tileFetcher.storedFeatures:0,totalFeatures:null!=this._tileFetcher?this._tileFetcher.totalFeatures:0,totalVertices:null!=this._tileFetcher?this._tileFetcher.totalVertices:0,missingTiles:null!=this._tileFetcher?this._tileFetcher.missingTiles:0}}};e([F({readOnly:!0})],I.prototype,"type",void 0),e([F({constructOnly:!0})],I.prototype,"graphics",void 0),e([F({constructOnly:!0})],I.prototype,"layerView",void 0),e([F({constructOnly:!0})],I.prototype,"context",void 0),e([F()],I.prototype,"extent",null),e([F()],I.prototype,"updating",null),e([F({readOnly:!0})],I.prototype,"_watchUpdatingTracking",void 0),e([F()],I.prototype,"updatingTotal",null),e([F()],I.prototype,"updatingRemaining",null),e([F()],I.prototype,"expectedFeatureDiff",null),e([F()],I.prototype,"memoryForUnusedFeatures",null),e([F()],I.prototype,"maximumNumberOfFeaturesExceeded",null),e([F({readOnly:!0})],I.prototype,"serviceDataExtent",void 0),e([F({readOnly:!0})],I.prototype,"serviceDataCount",void 0),e([F({readOnly:!0})],I.prototype,"vertexLimitExceeded",void 0),e([F()],I.prototype,"displayFeatureLimit",void 0),e([F({type:Number})],I.prototype,"maximumNumberOfFeatures",null),e([F({readOnly:!0})],I.prototype,"mode",null),e([F({readOnly:!0})],I.prototype,"maxTotalSnapshotVertices",null),e([F({readOnly:!0,dependsOn:["mode"]})],I.prototype,"tileDescriptors",null),e([F()],I.prototype,"_tileFetcher",void 0),e([F()],I.prototype,"_fetchDataInfoPromise",void 0),e([F({readOnly:!0})],I.prototype,"vertexLimitInfo",null),I=e([v("esri.layers.graphics.controllers.FeatureTileController3D")],I);const V=1e4,U=12e3,A=1e4,N=5e6;function L(e,t){if(!t)return!1;for(const i of t)if(!e.has(i))return!0;return!1}var P;!function(e){function t(){e.MAX_FEATURE_COUNT_FOR_EXTENT=V,e.QUERY_STATISTICS_TIMEOUT=U,e.QUERY_EXTENT_TIMEOUT=A}e.NO_SERVICE_DATA_COUNT=1/0,e.MAX_SNAPSHOT_MIN_SCALE_FACTOR=5,e.reset=t}(P||(P={})),P.reset();export{I as FeatureTileController3D,P as FeatureTileController3DConstants};
