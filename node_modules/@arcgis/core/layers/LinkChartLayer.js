/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../geometry.js";import t from"../core/Collection.js";import a from"../core/Error.js";import i from"../core/Logger.js";import{throwIfAborted as o}from"../core/promiseUtils.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import"../core/accessorSupport/ensureType.js";import"../core/arrayUtils.js";import"../core/has.js";import{subclass as r}from"../core/accessorSupport/decorators/subclass.js";import{encodeGeohash as s}from"../geohash/geohashUtils.js";import h from"./Layer.js";import{convertFromGeometry as l}from"./graphics/featureConversionUtils.js";import c from"./graphics/OptimizedGeometry.js";import{KnowledgeGraphLayerDataManager as p,MOCK_OID_FIELD_NAME as d,MOCK_ORIGIN_ID_FIELD_NAME as u,MOCK_DESTINATION_ID_FIELD_NAME as y,MOCK_LAYOUT_GEOMETRY_FIELD_NAME as m,GEOHASH_ENCODING_PRECISION as f}from"./knowledgeGraph/KnowledgeGraphLayerDataManager.js";import g from"./knowledgeGraph/KnowledgeGraphSublayer.js";import{BlendLayer as k}from"./mixins/BlendLayer.js";import{ScaleRangeLayer as C}from"./mixins/ScaleRangeLayer.js";import{LCSimpleLayout as L,LCSmartTreeLayout as b,LCRadialTreeLayout as M,LCHierarchicalLayout as w,LCCommunityLayout as x,LCForceDirectedLayout as E,NodeFlag as D,load as T}from"../libs/linkchartlayout/LinkChartLayout.js";import{fetchKnowledgeGraph as G}from"../rest/knowledgeGraphService.js";import I from"../rest/knowledgeGraph/EntityType.js";import A from"../rest/knowledgeGraph/RelationshipType.js";import N from"../geometry/Extent.js";import R from"../geometry/Point.js";import _ from"../geometry/Polyline.js";const v=(e,t,a)=>(e.has(t)||e.set(t,a()),e.get(t));let j=class extends(k(C(h))){constructor(e){if(super(e),this.dataPreloadedInLocalCache=!1,this._currentLinkChartConfig={layoutMode:"RADIAL_TREE",xScaleFactor:1,yScaleFactor:1},this._graphTypeLookup=new Map,this.layers=new t,this.linkChartDiagramLookup=new Map,this.linkChartExtent=new N({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7}),this.linkChartGeohashLookup=new Map,this.sublayerIdsCache=new Map,this.tables=new t,this.type="link-chart",this._originalInclusionList=e.inclusionModeDefinition,e.dataPreloadedInLocalCache&&!e.inclusionModeDefinition)throw new a("knowledge-graph:linkchart-layer-constructor","If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it")}normalizeCtorArgs(e){return{url:e.url,title:e.title,dataPreloadedInLocalCache:e.dataPreloadedInLocalCache,defaultLinkChartConfig:e.defaultLinkChartConfig}}_initializeLayerProperties(e){if(!this.title&&this.url){const e=this.url.split("/");this.title=e[e.length-2]}const t=new Set;let o=[],n=[];if(e.inclusionModeDefinition&&(!e.inclusionModeDefinition.namedTypeDefinitions||e.inclusionModeDefinition.namedTypeDefinitions.size<1))throw new a("knowledge-graph:composite-layer-constructor","If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");e.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&this._graphTypeLookup.set(e.name,e)})),e.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&this._graphTypeLookup.set(e.name,e)})),e.inclusionModeDefinition?.generateAllSublayers?(o=e.knowledgeGraph.dataModel.entityTypes??[],n=e.knowledgeGraph.dataModel.relationshipTypes??[]):e.inclusionModeDefinition?.namedTypeDefinitions&&e.inclusionModeDefinition?.namedTypeDefinitions.size>0?e.inclusionModeDefinition?.namedTypeDefinitions.forEach(((a,r)=>{if(!this._graphTypeLookup.get(r))return i.getLogger(this).warn(`A named type, ${r}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(r);this._graphTypeLookup.get(r)instanceof A||"strictOrigin"in this._graphTypeLookup.get(r)?t.has(r)||(t.add(r),n.push(this._graphTypeLookup.get(r))):this._graphTypeLookup.get(r)instanceof I||"properties"in this._graphTypeLookup.get(r)?t.has(r)||(t.add(r),o.push(this._graphTypeLookup.get(r))):(i.getLogger(this).warn(`A named type, ${r}, was in the inclusion list that wasn't properly modeled and will be removed`),e.inclusionModeDefinition?.namedTypeDefinitions.delete(r))})):(o=e.knowledgeGraph.dataModel.entityTypes??[],n=e.knowledgeGraph.dataModel.relationshipTypes??[]);const r=new p({knowledgeGraph:e.knowledgeGraph,inclusionModeDefinition:e.inclusionModeDefinition});this.knowledgeGraph=e.knowledgeGraph,this.memberEntityTypes=o,this.memberRelationshipTypes=n,this.dataManager=r}load(e){return this.addResolvingPromise(new Promise((t=>{G(this.url).then((a=>{if(this._initializeLayerProperties({knowledgeGraph:a,inclusionModeDefinition:this._originalInclusionList}),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.size||(this.dataManager.inclusionModeDefinition={generateAllSublayers:!1,namedTypeDefinitions:new Map},this.dataManager.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e.name,{useAllData:!0})})),this.dataManager.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.set(e.name,{useAllData:!0})}))),this.dataPreloadedInLocalCache)this.loadLayerAssumingLocalCache(),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach((e=>{e.useAllData=!1,e.members?.forEach((e=>{let t;t=e.linkChartLocation instanceof c?e.linkChartLocation:e.linkChartLocation?l(e.linkChartLocation):null,this.linkChartDiagramLookup.set(e.id,t),t&&2===t.coords.length&&0===t.lengths.length?this.linkChartGeohashLookup.set(e.id,s(t.coords[1],t.coords[0],f)):this.linkChartGeohashLookup.set(e.id,"")})),this.addResolvingPromise(this._initializeDiagram().then((async()=>{this.layers.forEach((async e=>{await e.refreshCachedQueryEngine()})),this.tables.forEach((async e=>{await e.refreshCachedQueryEngine()}))})))}));else{const t="GEOGRAPHIC"===this.defaultLinkChartConfig?.layoutMode;this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0,!1,t,!0).then((async()=>{o(e);const t=[],a=[];this.loadLayerAssumingLocalCache(),this.dataManager.inclusionModeDefinition&&(this.dataManager.inclusionModeDefinition.generateAllSublayers=!1,this.dataManager.inclusionModeDefinition.namedTypeDefinitions.forEach((e=>{e.useAllData=!1}))),await this._initializeDiagram(),this.layers.forEach((e=>{a.push(e.refreshCachedQueryEngine()),t.push(new Promise((t=>{e.on("layerview-create",(()=>{t(null)}))})))})),this.tables.forEach((e=>{a.push(e.refreshCachedQueryEngine())})),await Promise.all(a)})))}t(null)}))}))),Promise.resolve(this)}async addRecords(e){await this._handleNewRecords(e)}async expand(e){const t=await this.dataManager.getConnectedRecordIds(e),a=t.filter((e=>!this.sublayerIdsCache.get(e.typeName)?.has(e.id)));return await this._handleNewRecords(t),{records:a}}loadLayerAssumingLocalCache(){this.memberRelationshipTypes.forEach((e=>{const t=new g({objectType:e,parentCompositeLayer:this,graphType:"relationship",title:e.name});t.geometryType?this.layers.push(t):this.tables.push(t),this.dataManager.sublayerCaches.has(e.name)||this.dataManager.sublayerCaches.set(e.name,new Map)})),this.memberEntityTypes.forEach((e=>{const t=new g({objectType:e,parentCompositeLayer:this,graphType:"entity",title:e.name});t.geometryType?this.layers.push(t):this.tables.push(t),this.dataManager.sublayerCaches.has(e.name)||this.dataManager.sublayerCaches.set(e.name,new Map)})),this.dataManager.inclusionModeDefinition?.namedTypeDefinitions&&this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{const a=v(this.sublayerIdsCache,t,(()=>new Set));e.members?.forEach((e=>{if(a.add(e.id),e.linkChartLocation)if(e.linkChartLocation instanceof c)this.linkChartDiagramLookup.set(e.id,e.linkChartLocation),2===e.linkChartLocation.coords.length&&0===e.linkChartLocation.lengths.length?this.linkChartGeohashLookup.set(e.id,s(e.linkChartLocation.coords[1],e.linkChartLocation.coords[0],f)):this.linkChartGeohashLookup.set(e.id,"");else{const t=l(e.linkChartLocation);this.linkChartDiagramLookup.set(e.id,e.linkChartLocation?t:null),"x"in e.linkChartLocation&&"y"in e.linkChartLocation?this.linkChartGeohashLookup.set(e.id,s(e.linkChartLocation.x,e.linkChartLocation.y,f)):this.linkChartGeohashLookup.set(e.id,"")}}))}))}async calculateLinkChartLayout(e="RADIAL_TREE",t){const o=[],n=[];this.dataManager.sublayerCaches.forEach(((e,t)=>{this.dataManager.entityTypeNames.has(t)?e.forEach((e=>{o.push({typeName:t,feature:e})})):this.dataManager.relationshipTypeNames.has(t)&&e.forEach((e=>{n.push({typeName:t,feature:e})}))})),this.linkChartDiagramLookup=new Map;const r=new Map,h=new Map,c=new Map,p=new Map,g=new Uint8Array(o.length),k=new Float64Array(o.length),C=new Float64Array(o.length),G=new Uint32Array(n.length),I=new Uint32Array(n.length),A=[],v="FORCE_DIRECTED",j=t?.xScaleFactor??1,S=t?.yScaleFactor??1,P=new N({xmin:-1e-7,ymin:-1e-7,xmax:1e-7,ymax:1e-7});let F,z="FORCE_DIRECTED",O=0,U=0;switch(z="GEOGRAPHIC"===e?v:e,z){case"FORCE_DIRECTED":F=E.apply;break;case"COMMUNITY":F=x.apply;break;case"HIERARCHICAL":F=w.apply;break;case"RADIAL_TREE":F=M.apply;break;case"SMART_TREE":F=b.apply;break;default:F=L.apply}o.forEach((({typeName:a,feature:i})=>{if(t?.lockedNodeLocations?.has(i.attributes[d])){"GEOGRAPHIC"===e&&this.dataManager.geographicLookup.has(a)?g[O]=D.IsGeographic:g[O]=D.None;const o=t.lockedNodeLocations.get(i.attributes[d]);k[O]=o.x,C[O]=o.y}else if("GEOGRAPHIC"===e&&this.dataManager.geographicLookup.has(a)){g[O]=D.IsGeographic;let e=null;const t=i.attributes[this.dataManager.geographicLookup.get(a).name],o=this.dataManager.geographicLookup.get(a)?.geometryType;switch(o){case"esriGeometryPoint":k[O]=t?.x,C[O]=t?.y;break;case"esriGeometryPolygon":e=t?.centroid,null!=e?.x&&null!=e?.y?(k[O]=e.x,C[O]=e.y):g[O]=D.IsMovable;break;case"esriGeometryPolyline":case"esriGeometryMultipoint":e=t?.extent?.center,null!=e?.x&&null!=e?.y?(k[O]=e.x,C[O]=e.y):g[O]=D.IsMovable;break;default:g[O]=D.IsMovable}(null==k[O]||null==C[O]||Number.isNaN(k[O])||Number.isNaN(C[O]))&&(g[O]=D.IsMovable,k[O]=0,C[O]=0)}else g[O]=D.IsMovable,k[O]=0,C[O]=0;p.set(i.attributes[d],O),A[O]={feature:i,typeName:a},O++}));let H=!1;n.forEach((e=>{const t=p.get(e.feature.attributes[u]),a=p.get(e.feature.attributes[y]);void 0!==t&&void 0!==a?(G[U]=t,I[U]=a,U++):(H=!0,this.linkChartDiagramLookup.set(e.feature.attributes[u],null),this.linkChartGeohashLookup.set(e.feature.attributes[u],null))})),H&&i.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null"),await T();if(!F(g,k,C,G,I))throw new a("knowledge-graph:layout-failed","Attempting to arrange the records in the specified layout failed");for(let a=0;a<A.length;a++){if(g[a]===D.IsMovable&&(k[a]=k[a]*j,C[a]=C[a]*S),C[a]>84.9999&&(C[a]=84.9999),C[a]<-84.9999&&(C[a]=-84.9999),k[a]>179.9999&&(k[a]=179.9999),k[a]<-179.9999&&(k[a]=-179.9999),A[a].feature.attributes[m]=new R(k[a],C[a]),r.has(A[a].typeName)){const e=r.get(A[a].typeName);e?.set(A[a].feature.attributes[d],A[a].feature)}else{const e=new Map;e.set(A[a].feature.attributes[d],A[a].feature),r.set(A[a].typeName,e)}c.set(A[a].feature.attributes[d],A[a].feature);const e=l(A[a].feature.attributes[m]);this.linkChartDiagramLookup.set(A[a].feature.attributes[d],A[a].feature.attributes[m]?e:null),this.linkChartGeohashLookup.set(A[a].feature.attributes[d],s(A[a].feature.attributes[m].y,A[a].feature.attributes[m].x,f)),A[a].feature.attributes[m].x<P.xmin&&(P.xmin=A[a].feature.attributes[m].x),A[a].feature.attributes[m].x>P.xmax&&(P.xmax=A[a].feature.attributes[m].x),A[a].feature.attributes[m].y<P.ymin&&(P.ymin=A[a].feature.attributes[m].y),A[a].feature.attributes[m].y>P.ymax&&(P.ymax=A[a].feature.attributes[m].y)}return this.linkChartExtent.xmin=P.xmin,this.linkChartExtent.xmax=P.xmax,this.linkChartExtent.ymin=P.ymin,this.linkChartExtent.ymax=P.ymax,n.forEach((e=>{const t=A[p.get(e.feature.attributes[u])]?.feature.attributes[m],a=A[p.get(e.feature.attributes[y])]?.feature.attributes[m];if(!t||!a)return;const i=new _({paths:[[t.x,t.y],[a.x,a.y]]});if(e.feature.attributes[m]=i,h.has(e.typeName)){const t=h.get(e.typeName);t?.set(e.feature.attributes[d],e.feature)}else{const t=new Map;t.set(e.feature.attributes[d],e.feature),h.set(e.typeName,t)}c.set(e.feature.attributes[d],e.feature);const o=l(e.feature.attributes[m]);this.linkChartDiagramLookup.set(e.feature.attributes[d],e.feature.attributes[m]?o:null),this.linkChartGeohashLookup.set(e.feature.attributes[d],"")})),this._currentLinkChartConfig={layoutMode:e,xScaleFactor:j,yScaleFactor:S},{nodes:r,links:h,idMap:c}}async applyNewLinkChartLayout(e="RADIAL_TREE",t){const a=[];await this.calculateLinkChartLayout(e,t),this.layers.forEach((e=>{a.push(e.refreshCachedQueryEngine())})),await Promise.all(a),this.layers.forEach((e=>{e.emit("refresh",{dataChanged:!0})}))}getCurrentNodeLocations(){const e=new Map;return this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((t=>{t?.members?.forEach((t=>{const a=t.linkChartLocation;let i;const o=t.id;a&&(i="x"in a?{x:a.x,y:a.y}:{x:a.coords[0],y:a.coords[1]},e.set(o,new R({x:i.x,y:i.y})))}))})),e}async synchronizeInclusionListWithCache(){return new Promise((e=>{this.dataManager.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{if(e.useAllData=!1,e.members&&e.members.size>0){if(!this.dataManager.sublayerCaches.get(t))return;const a=Array.from(this.dataManager.sublayerCaches.get(t).keys());Array.from(e.members.keys()).filter((e=>!a.includes(e))).forEach((t=>{e.members?.delete(t)}))}})),e()}))}async refreshLinkChartCache(e){await this.dataManager.refreshCacheContent(e);const t=[];this.layers.forEach((e=>{t.push(e.refreshCachedQueryEngine())})),await Promise.all(t),this.layers.forEach((e=>{e.emit("refresh",{dataChanged:!0})}))}async _handleNewRecords(e){const t=[];this.dataManager.addToLayerInclusionSet(e);for(const a of e)this.sublayerIdsCache.has(a.typeName)||(this.sublayerIdsCache.set(a.typeName,new Set),t.push(a.typeName)),this.sublayerIdsCache.get(a.typeName).add(a.id);for(const a of t)if(this._graphTypeLookup.has(a)){const e=this._graphTypeLookup.get(a),t="endPoints"in e?"relationship":"entity",i=new g({objectType:e,parentCompositeLayer:this,graphType:t,title:a});"entity"===t?this.dataManager.entityTypeNames.add(a):this.dataManager.relationshipTypeNames.add(a),i.geometryType?this.layers.push(i):this.tables.push(i),this.dataManager.sublayerCaches.set(a,new Map)}await this.dataManager.refreshCacheContent(e.map((e=>e.id))),await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode,{xScaleFactor:this._currentLinkChartConfig.xScaleFactor,yScaleFactor:this._currentLinkChartConfig.xScaleFactor})}async _initializeDiagram(){this.defaultLinkChartConfig?this.defaultLinkChartConfig.doNotRecalculateLayout?(this.dataManager.inclusionModeDefinition?.namedTypeDefinitions?.forEach((e=>{e?.members?.forEach((e=>{const t=e.linkChartLocation;let a;const i=e.id;if(!t)return;a="x"in t?{x:t.x,y:t.y}:{x:t.coords[0],y:t.coords[1]};const o=l(a);this.linkChartDiagramLookup.set(i,o),this.linkChartGeohashLookup.set(i,s(a.x,a.y,f)),this.linkChartExtent.xmin>a.x&&(this.linkChartExtent.xmin=a.x),this.linkChartExtent.xmax<a.x&&(this.linkChartExtent.xmax=a.x),this.linkChartExtent.ymin>a.y&&(this.linkChartExtent.ymin=a.y),this.linkChartExtent.ymax<a.y&&(this.linkChartExtent.ymax=a.y)}))})),this.memberRelationshipTypes.forEach((e=>{e.name&&this.dataManager.sublayerCaches.get(e.name)?.forEach((e=>{const t=this.linkChartDiagramLookup.get(e.attributes[u]),a=this.linkChartDiagramLookup.get(e.attributes[y]);if(t&&a){const i=l(new _({paths:[[t.coords[0],t.coords[1]],[a.coords[0],a.coords[1]]]}));this.linkChartDiagramLookup.set(e.attributes[d],i)}else this.linkChartDiagramLookup.set(e.attributes[d],null);this.linkChartGeohashLookup.set(e.attributes[d],"")}))}))):await this.calculateLinkChartLayout(this.defaultLinkChartConfig.layoutMode,{xScaleFactor:this.defaultLinkChartConfig.xScaleFactor,yScaleFactor:this.defaultLinkChartConfig.yScaleFactor,lockedNodeLocations:this.getCurrentNodeLocations()}):await this.calculateLinkChartLayout("RADIAL_TREE",{lockedNodeLocations:this.getCurrentNodeLocations()})}};e([n()],j.prototype,"dataPreloadedInLocalCache",void 0),e([n()],j.prototype,"defaultLinkChartConfig",void 0),e([n()],j.prototype,"dataManager",void 0),e([n()],j.prototype,"knowledgeGraph",void 0),e([n()],j.prototype,"layers",void 0),e([n()],j.prototype,"linkChartDiagramLookup",void 0),e([n()],j.prototype,"linkChartExtent",void 0),e([n()],j.prototype,"linkChartGeohashLookup",void 0),e([n()],j.prototype,"memberEntityTypes",void 0),e([n()],j.prototype,"memberRelationshipTypes",void 0),e([n()],j.prototype,"sublayerIdsCache",void 0),e([n()],j.prototype,"tables",void 0),e([n({json:{read:!1}})],j.prototype,"type",void 0),j=e([r("esri.layers.LinkChartLayer")],j);const S=j;export{S as default};
