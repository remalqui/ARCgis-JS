/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import"../geometry.js";import t from"../Graphic.js";import r from"../request.js";import o from"../core/Error.js";import a from"../core/Loadable.js";import s from"../core/Logger.js";import{MultiOriginJSONMixin as i}from"../core/MultiOriginJSONSupport.js";import{isAbortError as n}from"../core/promiseUtils.js";import{urlToObject as l}from"../core/urlUtils.js";import{property as d}from"../core/accessorSupport/decorators/property.js";import"../core/accessorSupport/ensureType.js";import"../core/arrayUtils.js";import"../core/has.js";import{subclass as u}from"../core/accessorSupport/decorators/subclass.js";import p from"../geometry/Extent.js";import{fromJSON as c}from"../geometry/support/jsonUtils.js";import{emitApplyEditsEvent as m}from"../layers/mixins/EditBusLayer.js";import{parse as y}from"../layers/support/arcgisLayerUrl.js";import f from"./support/TopologyValidationJobInfo.js";import{networkFromPortalItem as h}from"./support/utils.js";import g from"../rest/networks/support/QueryNamedTraceConfigurationsParameters.js";import w from"../geometry/SpatialReference.js";let v=class extends(i(a)){static fromPortalItem(e){return h(e)}constructor(e){super(e),this.id=null,this.title=null,this.layerUrl=null,this.dataElement=null,this.fullExtent=null,this.spatialReference=null,this.type=null,this.sourceJSON=null}initialize(){this.when().catch((e=>{n(e)||s.getLogger(this).error("#load()",`Failed to load layer (title: '${this.title??"no title"}', id: '${this.id??"no id"}')`,{error:e})}))}get datasetName(){return this.dataElement?.name??null}get owner(){return this.dataElement?.userIdentity??null}get schemaGeneration(){return this.dataElement?.schemaGeneration??null}get parsedUrl(){return l(this.layerUrl)}get featureServiceUrl(){const e=y(this.parsedUrl?.path);return e?.url?.path??null}get networkServiceUrl(){return this.featureServiceUrl?this.featureServiceUrl.replace(/\/FeatureServer/i,"/UtilityNetworkServer"):null}get layerId(){const e=this.parsedUrl&&y(this.parsedUrl.path);return null!=e?e.sublayer:null}get networkSystemLayers(){return null}async load(e){return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl,this.layerId.toString(),e)),this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl,e)),this}getLayerIdBySourceId(e){if(this.dataElement){const t=this.dataElement.domainNetworks;for(const r of t){for(const t of r.edgeSources??[])if(t.sourceId===e)return t.layerId;for(const t of r.junctionSources??[])if(t.sourceId===e)return t.layerId}return null}return null}async queryNamedTraceConfigurations(e,t){const{queryNamedTraceConfigurations:r}=await import("../rest/networks/queryNamedTraceConfigurations.js"),o=this.networkServiceUrl,a=new g({...e});return(await r(o,a,{...t}))?.namedTraceConfigurations??null}async validateTopology(e,t){if(!e.validateArea)throw new o("network:undefined-validateArea","the network must have validateArea defined in the validate network topology parameters.");const[{validateNetworkTopology:r},{default:a}]=await Promise.all([import("../rest/networks/validateNetworkTopology.js"),import("../rest/networks/support/ValidateNetworkTopologyParameters.js")]),s=a.from(e),i=this.networkServiceUrl,n=this.featureServiceUrl,l=m(n,null,!0),d=await r(i,s,{...t});if(d?.serviceEdits){const e=[];for(const t of d.serviceEdits){const{editedFeatures:r}=t,o=r?.spatialReference?new w(r.spatialReference):null;e.push({layerId:t.layerId,editedFeatures:{adds:r?.adds?.map((e=>this._createEditedFeature(e,o)))||[],updates:r?.updates?.map((e=>({original:this._createEditedFeature(e[0],o),current:this._createEditedFeature(e[1],o)})))||[],deletes:r?.deletes?.map((e=>this._createEditedFeature(e,o)))||[],spatialReference:o}})}l.resolve({edits:null,addedFeatures:[],updatedFeatures:[],deletedFeatures:[],addedAttachments:[],updatedAttachments:[],deletedAttachments:[],editedFeatures:e,exceededTransferLimit:!1})}return d}async submitTopologyValidationJob(e,t){if(!e.validateArea)throw new o("network:undefined-validateArea","the network must have validateArea defined in the validate network topology parameters.");if(!e.gdbVersion)throw new o("network:undefined-gdb-version","version must be defined");const[{submitValidateNetworkTopologyJob:r},{default:a}]=await Promise.all([import("../rest/networks/validateNetworkTopology.js"),import("../rest/networks/support/ValidateNetworkTopologyParameters.js")]),s=a.from(e),i=this.networkServiceUrl,n=this.featureServiceUrl?m(this.featureServiceUrl,null,!0):void 0,l=await r(i,s,{...t});return new f({statusUrl:l,editsResolver:n})}_createEditedFeature(e,r){return new t({attributes:e.attributes,geometry:c({...e.geometry,spatialReference:r})})}async _fetchLayerMetaData(e,t){const o=await r(e,{responseType:"json",query:{f:"json"},...t});this.sourceJSON=o.data,this.read(o.data,{origin:"service"})}async _fetchDataElement(e,t,o){if(this.dataElement)return;const a=await r(`${e}/queryDataElements`,{responseType:"json",query:{layers:JSON.stringify([t]),f:"json"},...o}).then((e=>e.data.layerDataElements?.[0]));a&&this.read(a,{origin:"service"})}};e([d({type:String,nonNullable:!0,json:{origins:{"web-map":{read:!0,write:{isRequired:!0}},service:{read:!0}},read:!1}})],v.prototype,"id",void 0),e([d({type:String,nonNullable:!0,json:{origins:{"web-map":{read:!0,write:{isRequired:!0}},service:{read:{source:"name"}}},read:!1}})],v.prototype,"title",void 0),e([d({type:String,nonNullable:!0,json:{origins:{"web-map":{read:{source:"url"},write:{target:"url",isRequired:!0}}},read:!1}})],v.prototype,"layerUrl",void 0),e([d({type:Object,json:{origins:{service:{read:!0}},read:!1}})],v.prototype,"dataElement",void 0),e([d({type:p,json:{origins:{service:{read:{source:"extent"}}},read:!1}})],v.prototype,"fullExtent",void 0),e([d({type:w,json:{origins:{service:{read:{source:"extent.spatialReference"}}},read:!1}})],v.prototype,"spatialReference",void 0),e([d({type:["utility","trace"],readOnly:!0,json:{read:!1,write:!1}})],v.prototype,"type",void 0),e([d({readOnly:!0})],v.prototype,"datasetName",null),e([d({readOnly:!0})],v.prototype,"owner",null),e([d({readOnly:!0})],v.prototype,"schemaGeneration",null),e([d({readOnly:!0})],v.prototype,"parsedUrl",null),e([d({readOnly:!0})],v.prototype,"featureServiceUrl",null),e([d({readOnly:!0})],v.prototype,"networkServiceUrl",null),e([d({readOnly:!0})],v.prototype,"layerId",null),e([d()],v.prototype,"sourceJSON",void 0),e([d({readOnly:!0})],v.prototype,"networkSystemLayers",null),v=e([u("esri.networks.Network")],v);const j=v;export{j as default};
