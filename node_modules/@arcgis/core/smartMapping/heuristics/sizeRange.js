/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../../core/has.js";import e from"../../core/Error.js";import{px2pt as s}from"../../core/screenUtils.js";import{getScale as l}from"../../geometry/support/scaleUtils.js";import n from"../../renderers/visualVariables/SizeVariable.js";import i from"./scaleRange.js";import{verifyBinningParams as a}from"../support/binningUtils.js";import{binningCapableLayerTypes as t,featureCapableLayerTypes as o,createLayerAdapter as r,getLayerTypeLabels as c}from"../support/adapters/support/layerUtils.js";const u=1e8,p=1128.497176,m=591657527.591555,v=[10,8,4,2],f=[100,100,60,30],w=[2,1,.75,.5],g=[32,18,12,6],S=[{level:0,resolution:156543.03392800014,scale:591657527.591555},{level:1,resolution:78271.51696399994,scale:295828763.795777},{level:2,resolution:39135.75848200009,scale:147914381.897889},{level:3,resolution:19567.87924099992,scale:73957190.948944},{level:4,resolution:9783.93962049996,scale:36978595.474472},{level:5,resolution:4891.96981024998,scale:18489297.737236},{level:6,resolution:2445.98490512499,scale:9244648.868618},{level:7,resolution:1222.992452562495,scale:4622324.434309},{level:8,resolution:611.4962262813797,scale:2311162.217155},{level:9,resolution:305.74811314055756,scale:1155581.108577},{level:10,resolution:152.87405657041106,scale:577790.554289},{level:11,resolution:76.43702828507324,scale:288895.277144},{level:12,resolution:38.21851414253662,scale:144447.638572},{level:13,resolution:19.10925707126831,scale:72223.819286},{level:14,resolution:9.554628535634155,scale:36111.909643},{level:15,resolution:4.77731426794937,scale:18055.954822},{level:16,resolution:2.388657133974685,scale:9027.977411},{level:17,resolution:1.1943285668550503,scale:4513.988705},{level:18,resolution:.5971642835598172,scale:2256.994353},{level:19,resolution:.29858214164761665,scale:1128.497176}];async function h(s){const{view:l}=s;if(!(s&&l&&s.layer))throw new e("size-range:missing-parameters","'view' and 'layer' parameters are required");s.forBinning&&a(s,"size-range");const{layer:n,...i}=s,u=s.forBinning?t:o,p=r(n,u,s.forBinning);if(!p)throw new e("size-range:invalid-parameters","'layer' must be one of these types: "+c(u).join(", "));const m={layerAdapter:p,...i,view:l};await l.when();const v=null!=m.signal?{signal:m.signal}:null;await p.load(v);const f=p.geometryType;if("point"!==f&&"multipoint"!==f&&"polyline"!==f&&"polygon"!==f)throw new e("size-range:not-supported",`sizeRange is not supported for geometryType: ${f}`);return m}function x(e,s){const l=Math.ceil(e/s);let n=Math.ceil(l/4);n<4?n=4:n>16&&(n=16);const i=5*n;return{min:n,max:i<50?50:i}}function y(s,l){const{view:n}=s;if(!n)throw new e("scale-range:invalid-parameters","'view' is required");const i=l.minScale||u,a=n.constraints&&"effectiveLODs"in n.constraints&&n.constraints.effectiveLODs||S,t=[];for(const e in a){if(a[e].scale>i)continue;const s=Number(e),l=[s-3,s,s+3,s+6];for(const e of l)e>-1&&e<a.length&&t.push(a[e].scale);break}return t.sort(((e,s)=>e-s))}function z(s,n){const{view:i,layerAdapter:a}=s;if(!i)throw new e("scale-range:invalid-parameters","'view' is required");const t=a.fullExtent,o=a.minScale||p,r=a.maxScale||m,c=n.minScale||0,u=n.maxScale||0;let v=null!=t?l(i,t):0;v=v<o&&v>r?v:0;return{scales:[o,r,c,u,v].map(Math.round).sort(((e,s)=>e-s)).filter(((e,s,l)=>!!e&&l.indexOf(e)===s)).filter(((e,s,l)=>!s||Math.abs(e-l[s-1])>5)),fullExtentScale:v}}function d(l,i){const{minScale:a,maxScale:t}=i,o=y(l,{minScale:a,maxScale:t});if(!o.length)throw new e("scale-range:insufficient-info","not enough scale values");return{minSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(v[l])})))}),maxSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(f[l])})))})}}function E(l,i){const{minScale:a,maxScale:t}=i,o=y(l,{minScale:a,maxScale:t});if(!o.length)throw new e("scale-range:insufficient-info","not enough scale values");return{minSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(w[l])})))}),maxSize:new n({valueExpression:"$view.scale",stops:o.map(((e,l)=>({value:e,size:s(g[l])})))})}}function j(l,i){const{spatialStatistics:a,minScale:t,maxScale:o}=i;if(!("avgSize"in a)||!a.avgSize)throw new e("size-range:insufficient-info","average polygon size is invalid");const r=a.avgSize,{view:c}=l;if(!c)throw new e("scale-range:invalid-parameters","'view' is required");const{resolution:u,scale:p}=c,m=u/p,{scales:v,fullExtentScale:f}=z(l,{minScale:t,maxScale:o}),w=[],g=[];v.forEach(((e,l)=>{const{min:n,max:i}=x(r,m*e),a=v.indexOf(f),t=a>-1&&l>a?2:1;w.push({value:e,size:s(n/t)}),g.push({value:e,size:s(i/t)})}));return{minSize:new n({valueExpression:"$view.scale",stops:w}),maxSize:new n({valueExpression:"$view.scale",stops:g})}}async function b(e){const s=await h(e),{view:l,layerAdapter:n,signal:a}=s,t=await i({layer:n,view:l,signal:a});switch(n.geometryType){case"point":case"multipoint":return d(s,t);case"polyline":return E(s,t);case"polygon":return j(s,t);case"mesh":case"multipatch":return null}return null}export{b as default};
