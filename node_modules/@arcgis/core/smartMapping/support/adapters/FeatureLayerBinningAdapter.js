/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import{pickRandom as t}from"../../../core/arrayUtils.js";import a from"../../../core/Error.js";import{throwIfAborted as r}from"../../../core/promiseUtils.js";import"../../../core/Logger.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/has.js";import{subclass as i}from"../../../core/accessorSupport/decorators/subclass.js";import{kebabDict as s}from"../../../layers/support/fieldType.js";import{isDateField as o}from"../../../layers/support/fieldUtils.js";import{getArcadeForPredominantCategory as n}from"../../statistics/support/predominanceUtils.js";import{summaryStatistics as l,uniqueValues as u,histogram as m,classBreaks as p}from"../../statistics/support/statsWorker.js";import{mergeWhereClauses as g}from"../../statistics/support/utils.js";import{WorkerClient as y}from"../../statistics/support/WorkerClient.js";import{getFieldsList as d,FIELD_DELIMITER as f}from"../utils.js";import c from"./FeatureLayerAdapter.js";import{getMissingFieldsForBinning as h,updateQueryWithFeatureFilter as w,getFeatureReductionFields as F,getViewInfoParams as v,getDomainsForFields as S,getPredominantCategoriesFromUVInfos as q}from"./support/utils.js";let V=class extends c{constructor(){super(...arguments),this.adapterName="feature-layer-binning-adapter"}async _getNormalizationTotalFromMemory(e,t,r){const{featuresJSON:i,graphics:s,layerView:o,query:n}=t,u=(!i&&!s&&o&&"queryAggregateSummaryStatistics"in o?await o.queryAggregateSummaryStatistics(n,{field:e},{signal:r}):i?await this.workerClient.summaryStatistics({field:e},i):await l({attribute:{field:e},features:s})).sum;if(null==u)throw new a(`${this.adapterName}:invalid`,"invalid normalizationTotal");return u}async _processStatsFromMemoryParams(e){const{features:t,filter:r}=e;if(t?.length)return this._getFilteredFeatures(t,r);const{view:i,field:s,field2:o,field3:n,normalizationField:l,valueExpression:u,returnGeometry:m,layerViewFunc:p,signal:g}=e;let y=null,f=null,c=null,v=null,S=null;if(i)try{if(y=await i.whenLayerView(this.layer),f=null!=p&&p in y&&"function"==typeof y[p],f){await this._waitForLayerViewUpdate(y);const e=await d({field:s,field2:o,field3:n,normalizationField:l,valueExpression:u});h(this,e).length?f=!1:(c="createAggregateQuery"in y?y.createAggregateQuery():null,c?(c.outFields=e,c.returnGeometry=!1,w(c,r)):f=!1),y.suspended&&(f=!1)}}catch{f=!1}if(!f&&(S=F(this.layer).map((e=>e.toJSON())),v=await this._fetchFeaturesForStats({field:s,field2:o,field3:n,valueExpression:u,normalizationField:l,returnGeometry:m,filter:r,view:i,signal:g},"json"),!v?.length))throw new a(`${this.adapterName}:insufficient-data`,"No features are available to calculate statistics");return{layerView:y,query:c,featuresJSON:v,fieldInfos:S}}async _summaryStatsFromMemory(e,t){const{view:a,field:r,valueExpression:i,normalizationType:o,signal:n}=e,u={field:r,valueExpression:i,normalizationType:o,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue},{featuresJSON:m,graphics:p,layerView:g,query:y,fieldInfos:d}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateSummaryStatistics"});return i&&a&&(m||p)&&(u.fieldType=t?.type?s.toJSON(t.type):null,u.viewInfoParams=v(a),u.fieldInfos=d),"percent-of-total"===o&&null==e.normalizationTotal&&(u.normalizationTotal=await this._getNormalizationTotalFromMemory(r,{featuresJSON:m,graphics:p,layerView:g,query:y},n)),!m&&!p&&g&&"queryAggregateSummaryStatistics"in g?g.queryAggregateSummaryStatistics(y,u,{signal:n}):m?this.workerClient.summaryStatistics(u,m):l({attribute:u,features:p})}async _uvFromMemory(e,t){const{view:a,field:r,valueExpression:i,returnAllCodedValues:s,signal:o}=e,{featuresJSON:n,graphics:l,layerView:m,query:p,fieldInfos:g}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateUniqueValues"}),y={field:r,field2:e.field2,field3:e.field3,fieldDelimiter:f,valueExpression:i,domains:t,returnAllCodedValues:s};return i&&a&&(n||l)&&(y.viewInfoParams=v(a),y.fieldInfos=g),!n&&!l&&m&&"queryAggregateUniqueValues"in m?m.queryAggregateUniqueValues(p,y,{signal:o}):n?this.workerClient.uniqueValues(y,n):u({attribute:y,features:l})}async _histogramFromMemory(e){const{view:t,field:a,valueExpression:r,signal:i}=e,{featuresJSON:s,graphics:o,layerView:n,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateHistogram"}),p={field:a,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numBins:e.numBins};return r&&t&&(s||o)&&(p.viewInfoParams=v(t),p.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(p.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:s,graphics:o,layerView:n,query:l},i)),!s&&!o&&n&&"queryAggregateHistogram"in n?n.queryAggregateHistogram(l,p,{signal:i}):s?this.workerClient.histogram(p,s):m({attribute:p,features:o})}async _classBreaksFromMemory(e){const{view:t,field:a,valueExpression:r,signal:i}=e,{featuresJSON:s,graphics:o,layerView:n,query:l,fieldInfos:u}=await this._processStatsFromMemoryParams({...e,layerViewFunc:"queryAggregateClassBreaks"}),m={field:a,valueExpression:r,normalizationType:e.normalizationType,normalizationField:e.normalizationField,normalizationTotal:e.normalizationTotal,minValue:e.minValue,maxValue:e.maxValue,standardDeviationInterval:e.standardDeviationInterval,classificationMethod:e.classificationMethod,numClasses:e.numClasses};return r&&t&&(s||o)&&(m.viewInfoParams=v(t),m.fieldInfos=u),"percent-of-total"===e.normalizationType&&null==e.normalizationTotal&&(m.normalizationTotal=await this._getNormalizationTotalFromMemory(a,{featuresJSON:s,graphics:o,layerView:n,query:l},i)),!s&&!o&&n&&"queryAggregateClassBreaks"in n?n.queryAggregateClassBreaks(l,m,{signal:i}):s?this.workerClient.classBreaks(m,s):p({attribute:m,features:o})}getField(e=""){const t=F(this.layer);return t?.find((t=>t.name.toLowerCase()===e?.toLowerCase()))}getFieldUsageInfo(e){return this.getField(e)?{supportsLabelingInfo:!0,supportsRenderer:!0,supportsPopupTemplate:!0,supportsLayerQuery:!1,supportsStatistics:!0}:null}getFieldDomain(e,t){return null}async summaryStatistics(e){const{field:t}=e,r=t?this.getField(t):null,i=o(r),s=e.sqlExpression&&!e.valueExpression&&!t;if(i||s)throw new a(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._summaryStatsFromMemory(e,r)}async uniqueValues(e){const t=await S(e,this);return this._uvFromMemory(e,t)}async histogram(e){const{field:t}=e,r=t?this.getField(t):null,i=o(r),s=e.sqlExpression&&!e.valueExpression&&!t;if(i||s)throw new a(`${this.adapterName}:not-supported`,"Date field and sqlExpression are not supported");return this._histogramFromMemory(e)}async classBreaks(e){return(!1!==e.analyzeData?this._classBreaksFromMemory(e):this._classBreaksFromInterpolation(e)).catch((()=>(r(e.signal),this._classBreaksFromMemory(e))))}async queryFeatureCount(e){const t=await(e.view?.whenLayerView(this.layer));if(!t||!("queryAggregateCount"in t)||!t.queryAggregateCount)throw new a(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(t);const r=t.createAggregateQuery();return r.where=g(r.where,e.whereClause),w(r,e.filter),t.queryAggregateCount(r,{signal:e.signal})}generateRenderer(e,t){throw new a(`${this.adapterName}:not-supported`,"'generateRenderer' is not supported.")}heatmapStatistics(e){throw new a(`${this.adapterName}:not-supported`,"'heatmapStatistics' is not supported.")}async predominantCategories(e){const{fields:t,view:a,signal:r}=e,i=n(t),s=await this._uvFromMemory({valueExpression:i,view:a,signal:r});return q(s.uniqueValueInfos,t)}async getSampleFeatures(e,r){const{view:i,sampleSize:s,requiredFields:o,returnGeometry:n,filter:l,signal:u}=e;if(!i)throw new a(`${this.adapterName}:not-supported`,"'view' is required to get sample features for binning.");if("3d"===i.type)throw new a(`${this.adapterName}:not-supported`,"3d 'view' is not supported to get sample features for binning.");const m=await i.whenLayerView(this.layer);if(!("queryAggregateJSON"in m&&m.queryAggregateJSON&&"queryAggregates"in m&&m.queryAggregates))throw new a(`${this.adapterName}:not-supported`,"LayerView is not supported.");await this._waitForLayerViewUpdate(m);if(h(this,o).length)throw new a(`${this.adapterName}:insufficient-data`,"Layer does not have required fields");const p=1,g="json"===r,y=m.createAggregateQuery();y.outSpatialReference=e.spatialReference||i&&i.spatialReference,y.returnGeometry=!!n,y.outFields=o,w(y,l);const{features:d}=g?await m.queryAggregateJSON(y,{signal:u}):await m.queryAggregates(y,{signal:u});return d.length&&null!=s&&s>0&&s<=d.length?t(d,s,p):d}load(e){const t=this.layer.load(e).then((async t=>{if(this.geometryType="polygon",this.objectIdField=null,this.supportsSQLExpression=!1,this._hasLocalSource=!1,this.hasQueryEngine=!0,this.minScale=t.minScale,this.maxScale=t.maxScale,this.fullExtent=t.fullExtent,"geometryType"in t&&"point"!==t.geometryType)throw new a(`${this.adapterName}:invalid-parameters`,"Only 'point' geometry type is supported");const r="featureReduction"in t?t.featureReduction:null;if("binning"!==r?.type&&"cluster"!==r?.type)throw new a(`${this.adapterName}:invalid-parameters`,`Feature reduction type ${r?.type} is not supported`);this.workerClient=y.getInstance(),await this.workerClient.open(e.signal)}));return this.addResolvingPromise(t),Promise.resolve(this)}};V=e([i("esri.smartMapping.support.adapters.FeatureLayerBinningAdapter")],V);const z=V;export{z as default};
