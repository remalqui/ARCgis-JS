/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import e from"../../renderers/PointCloudRGBRenderer.js";import o from"../../renderers/PointCloudStretchRenderer.js";import"../../renderers/PointCloudUniqueValueRenderer.js";import i from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import r from"../../core/Error.js";import{fetchMessageBundle as a}from"../../intl/messages.js";import{substitute as n}from"../../intl/substitute.js";import l from"../../renderers/support/AuthoringInfo.js";import s from"../../renderers/support/AuthoringInfoVisualVariable.js";import{createColorStops as t,setLabelsForClassBreaks as m}from"../../renderers/support/utils.js";import d from"../../renderers/visualVariables/ColorVariable.js";import u from"../heuristics/ageUnit.js";import p from"../heuristics/outline.js";import c from"../heuristics/sizeRange.js";import{getSummaryStatistics as y,getClassBreaks as f,errorCallback as h,getPointSizeAlgorithm as b,formatDate as w,updateAgeRendererAuthoringInfoVV as v,verifyBasicFieldValidity as g,isValidPointSize as T,createColors as x,getDefaultDataRange as V,createDefaultStopValues as E,createStopValues as z,getDataRange as S,createDataValues as M,createSymbol as I,getSymbolSizeFromScheme as j,getSymbolOutlineFromScheme as q,getBasemapInfo as C}from"./support/utils.js";import{getAgeExpressions as O,verifyDates as B,supportedAgeUnits as k}from"../statistics/support/ageUtils.js";import{verifyBinningParams as U}from"../support/binningUtils.js";import{getFieldsList as F,getNormalizationType as R}from"../support/utils.js";import{binningCapableLayerTypes as P,featureCapableLayerTypes as D,createLayerAdapter as L,getLayerTypeLabels as A,LayerType as G}from"../support/adapters/support/layerUtils.js";import{cloneScheme as W,getSchemes as $,getSchemeById as H}from"../symbology/color.js";const _="date",J="high-to-low",K=2**53-1,N=5;async function Q(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"color-visual-variable");const o={...e};if("90-10"===o.theme)throw new r("color-visual-variable:not-supported","Only 'high-to-low', 'above-and-below', 'centered-on', 'extremes', 'above', 'below' themes are supported.");const i=e.forBinning?P:D,a=L(o.layer,i,e.forBinning);if(!a)throw new r("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+A(i).join(", "));o.layer=a;const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);if("mesh"!==a.geometryType&&o.worldScale&&(!o.view||"3d"!==o.view.type))throw new r("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const l=await F({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),s=g(a,l,"color-visual-variable:invalid-parameters");if(s)throw s;return o}async function X(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"color-continuous-renderer");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled??=!0;const i=e.forBinning?P:D,a=L(o.layer,i,e.forBinning);if(!a)throw new r("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+A(i).join(", "));o.layer=a;const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);const l=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===l&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&o.sizeOptimizationEnabled,"mesh"===l)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==l)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await F({field:o.field,normalizationField:o.normalizationField,valueExpression:o.valueExpression}),t=g(a,s,"color-continuous-renderer:invalid-parameters");if(t)throw t;return o}async function Y(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new r("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new r("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&U(e,"color-class-breaks-renderer");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled??=!0,o.classificationMethod??="equal-interval",o.normalizationType=R(o);const i=e.forBinning?P:D,a=L(o.layer,i,e.forBinning);if(!a)throw new r("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+A(i).join(", "));o.layer=a;if(!(null!=o.minValue&&null!=o.maxValue)&&(null!=o.minValue||null!=o.maxValue))throw new r("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=o.signal?{signal:o.signal}:null;await a.load(n);const l=a.geometryType;if(o.outlineOptimizationEnabled="polygon"===l&&o.outlineOptimizationEnabled,"mesh"===l)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else{if("3d-volumetric-uniform"===o.symbolType&&"point"!==l)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await F({field:o.field,normalizationField:o.normalizationField}),t=g(a,s,"color-class-breaks-renderer:invalid-parameters");if(t)throw t;return o}function Z(e){const o={...e};delete o.basemap,delete o.colorScheme,delete o.legendOptions,delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const i=o;return i.analyzeData=!(null!=o.minValue&&null!=o.maxValue),i}async function ee(e){if(!e||!e.layer)throw new r("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const o={...e,layer:e.layer},i=[G.PointCloudLayer],a=L(o.layer,i);if(!a)throw new r("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+A(i).join(", "));if(o.layer=a,o.density=o.density||25,o.size=o.size||"100%",!T(o.size))throw new r("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=o.signal?{signal:o.signal}:null;return await a.load(n),o}async function oe(e){if(!(e&&e.layer&&e.field))throw new r("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const o=e.field.toLowerCase();if("intensity"!==o&&"elevation"!==o)throw new r("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const i={...e,layer:e.layer,field:e.field},a=[G.PointCloudLayer],n=L(i.layer,a);if(!n)throw new r("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+A(a).join(", "));if(i.layer=n,i.density=i.density||25,i.size=i.size||"100%",!T(i.size))throw new r("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const l=null!=i.signal?{signal:i.signal}:null;return await n.load(l),i}function ie(e){const o={...e},i=!!o.symbolType?.includes("3d-volumetric");delete o.symbolType,delete o.defaultSymbolEnabled,delete o.colorMixMode,delete o.edgesType;const r=o;return r.worldScale=i,r}async function re(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new r("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const o={...e};o.symbolType=o.symbolType||"2d",o.defaultSymbolEnabled??=!0;const i=L(o.layer,D);if(!i)throw new r("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+A(D).join(", "));o.layer=i;const a=null!=o.signal?{signal:o.signal}:null;await i.load(a);const n=i.geometryType;if(o.outlineOptimizationEnabled="polygon"===n&&o.outlineOptimizationEnabled,o.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&o.sizeOptimizationEnabled,"mesh"===n)o.symbolType="3d-volumetric",o.colorMixMode=o.colorMixMode||"replace",o.edgesType=o.edgesType||"none";else if("3d-volumetric-uniform"===o.symbolType&&"point"!==n)throw new r("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(o.symbolType.includes("3d-volumetric")&&(!o.view||"3d"!==o.view.type))throw new r("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const l=B(i,o.startTime,o.endTime,"color-age-renderer:invalid-parameters");if(l)throw l;if(o.unit&&!k.includes(o.unit))throw new r("color-age-renderer:invalid-unit",`Supported units are: ${k.join(", ")}`);return o}async function ae(e,o){let i=e.colorScheme,r=null,a=null;const n=await C(e.basemap,e.view);if(r=null!=n.basemapId?n.basemapId:null,a=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:W(i),basemapId:r,basemapTheme:a};const l=o||e.theme||J,s=$({theme:l,basemap:r,basemapTheme:a,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});if(s)if(r=s.basemapId,a=s.basemapTheme,e.schemeId){const o=l+"/"+r+"/"+e.schemeId;i=H({id:o,geometryType:e.geometryType})}else i=s.primaryScheme;return{scheme:i,basemapId:r,basemapTheme:a}}async function ne(e,o){const i=o.layer,a=await ae({basemap:o.basemap,colorScheme:o.colorScheme,geometryType:i.geometryType,schemeId:"elevation"===o.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),n=a.scheme;if(!n)throw new r("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const l=x(n.colors,N);if(l.length<N)throw new r("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const s=V(e,!1,!0),m=s?E(s[0],s[1],5):z(e);return{stops:t({values:m,isDate:!1,dateFormatOptions:null,colors:l,labelIndexes:[0,2,4]}),basemapId:a.basemapId,basemapTheme:a.basemapTheme,statistics:e,defaultValuesUsed:!!s,colorScheme:W(n)}}async function le(e,o,i,a,n){const{field:t,theme:m}=e,u=await ae({basemap:e.basemap,theme:e.theme,geometryType:a,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),p=u.scheme;if(!p)throw new r("color-visual-variable:insufficient-info","Unable to find color scheme");const c=x(p.colors,N);if(c.length<N)throw new r("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const y=p.id.includes("seq-"),f=S(o,i,m,n,"90-10"!==m),h=M(f,o,m,y),b=x(c,N),w=new d({field:t,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:h.map(((e,o)=>({value:e,color:b[o]}))),legendOptions:e.legendOptions}),v=new s({type:"color",minSliderValue:null!=e.minValue?e.minValue:o.min,maxSliderValue:null!=e.maxValue?e.maxValue:o.max,theme:p.theme}),g=new l({visualVariables:[v]});return{basemapId:u.basemapId,basemapTheme:u.basemapTheme,visualVariable:w,statistics:o,defaultValuesUsed:f.defaultValuesUsed,colorScheme:W(p),authoringInfo:g}}async function se(e,o,r,n,l,s,t){const m=await a("esri/smartMapping/t9n/smartMapping"),{field:d,defaultSymbolEnabled:u}=t,p=W(e.colorScheme),c=o&&o.opacity,y=[e.visualVariable.clone()];o&&o.visualVariables&&o.visualVariables.length&&y.push(...o.visualVariables.map((e=>e.clone()))),r&&r.minSize&&y.push(r.minSize);return{renderer:new i({classBreakInfos:[{minValue:-K,maxValue:K,symbol:I(s,{type:t.symbolType,color:p.noDataColor,size:j(p,s),outline:q(p,s,c),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:u?m.other:null,defaultSymbol:u?I(s,{type:t.symbolType,color:p.noDataColor,size:j(p,s),outline:q(p,s,c),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:d,normalizationType:n,normalizationField:l,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:y,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:W(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function te(e){const o=await Q(e),{view:i,field:r,valueExpression:a,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:m,statistics:d}=o,u=t?"field":void 0,[p,c]=await Promise.all([d??y({layer:s,field:r,valueExpression:a,sqlExpression:o.sqlExpression,sqlWhere:o.sqlWhere,normalizationType:u,normalizationField:t,minValue:n,maxValue:l,view:i,signal:m}),"90-10"===o.theme?f({layer:s,field:r,normalizationField:t,valueExpression:a,classificationMethod:"quantile",minValue:n,maxValue:l,view:i,numClasses:10,signal:m}):null]),h=s,b=r&&"function"!=typeof r?h.getField(r):null,w=b&&b.type===_;return le(o,p,c?.result,h.geometryType,!!w)}function me(e,o){const i=e.colorsForClassBreaks;let r;if(i&&i.length>0&&(i.some((e=>(e.numClasses===o&&(r=e.colors),!!r))),!r)){const e=i[i.length-1],a=o-e.numClasses;if(a>0){const o=e.colors[e.numClasses-1];r=e.colors.splice(0);for(let e=1;e<=a;e++)r.push(o)}}return r&&(r=x(r,r.length)),r}async function de(e,o){const n=await a("esri/smartMapping/t9n/smartMapping"),s=e.layer,t=e.defaultSymbolEnabled,d=s.geometryType,u=e.classificationMethod,p="standard-deviation"===u,c=await ae({basemap:e.basemap,geometryType:d,theme:p?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),y=c.scheme,{result:f,outlineResult:h}=o,b=f.classBreakInfos,w=e.normalizationType;if(!y)throw new r("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const v=me(y,b.length);if(!v||v.length!==b.length)throw new r("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=h&&h.opacity,T=new i({classBreakInfos:b.map(((o,i)=>({minValue:o.minValue,maxValue:o.maxValue,symbol:I(d,{type:e.symbolType,color:v[i],size:j(y,d),outline:q(y,d,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:o.label}))),defaultLabel:t?n.other:null,defaultSymbol:t?I(d,{type:e.symbolType,color:y.noDataColor,size:j(y,d),outline:q(y,d,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?f.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new l({type:"class-breaks-color",classificationMethod:u,standardDeviationInterval:e.standardDeviationInterval})});return p||m({classBreakInfos:T.classBreakInfos,classificationMethod:u,normalizationType:w,round:!0}),h&&h.visualVariables&&h.visualVariables.length&&(T.visualVariables=h.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:W(y),classBreaksResult:f,defaultValuesUsed:o.defaultValuesUsed,basemapId:c.basemapId,basemapTheme:c.basemapTheme}}async function ue(e){const o=await X(e),{layer:i,view:r,signal:a}=o,[n,l,s]=await Promise.all([te(ie(o)),o.outlineOptimizationEnabled?p({layer:i,view:r,signal:a}).catch(h):null,o.sizeOptimizationEnabled?c({layer:i,view:r,signal:a}).catch(h):null]),t=o.normalizationField;return se(n,l,s,t?"field":void 0,t,i.geometryType,o)}async function pe(e){const o=await Y(e);return de(o,await f(Z(o),o.outlineOptimizationEnabled))}function ce(o){return ee(o).then((o=>({renderer:new e({field:"RGB",pointsPerInch:o.density,pointSizeAlgorithm:b(o.size)})})))}async function ye(e){const i=await oe(e),r=i.statistics??await y({layer:i.layer,field:i.field,signal:i.signal}),a=await ne(r,i);return{renderer:new o({field:i.field,pointsPerInch:i.density,pointSizeAlgorithm:b(i.size),stops:a.stops}),basemapId:a.basemapId,basemapTheme:a.basemapTheme,statistics:a.statistics,defaultValuesUsed:a.defaultValuesUsed,colorScheme:a.colorScheme}}async function fe(e){const o=await a("esri/smartMapping/t9n/smartMapping"),i=await re(e),{defaultSymbolEnabled:r,view:l,startTime:s,endTime:t,symbolType:m,colorMixMode:d,edgesType:y,minValue:f,maxValue:b,signal:g}=i,T=i.layer,[x,V,E]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:u({view:l,layer:T,startTime:s,endTime:t,minValue:f,maxValue:b,signal:g}),i.outlineOptimizationEnabled?p({layer:T,view:l,signal:g}).catch(h):null,i.sizeOptimizationEnabled?c({layer:T,view:l,signal:g}).catch(h):null]),{unit:z,statistics:S}=x,M=O({layer:T,startTime:s,endTime:t,unit:z}).valueExpression,I=n(o[`ageInfo_${z}`],{unit:z,startTime:w(s,z,T),endTime:w(t,z,T)}),j=await te(ie({layer:T,basemap:i.basemap,valueExpression:M,symbolType:m,statistics:S,legendOptions:{title:I},colorScheme:i.colorScheme,theme:i.theme,view:l,minValue:i.minValue,maxValue:i.maxValue,signal:g})),q={layer:T,valueExpression:M,defaultSymbolEnabled:r,symbolType:m,colorMixMode:d,edgesType:y},C=await se(j,V,E,null,null,T.geometryType,q),B=C.renderer.authoringInfo?.visualVariables;return B?.forEach((e=>v(e,s,t,z))),{...C,unit:z}}export{fe as createAgeRenderer,pe as createClassBreaksRenderer,ue as createContinuousRenderer,ye as createPCContinuousRenderer,ce as createPCTrueColorRenderer,te as createVisualVariable};
