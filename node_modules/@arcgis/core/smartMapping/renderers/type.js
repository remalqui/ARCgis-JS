/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import"../../renderers/PointCloudRGBRenderer.js";import"../../renderers/PointCloudStretchRenderer.js";import e from"../../renderers/PointCloudUniqueValueRenderer.js";import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import r from"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import l from"../../core/Error.js";import{clone as i}from"../../core/lang.js";import{fetchMessageBundle as s}from"../../intl/messages.js";import{LegendOptions as n}from"../../renderers/support/LegendOptions.js";import{createUniqueValueLabel as o,calculateDateFormatInterval as t}from"../../renderers/support/utils.js";import a from"../heuristics/outline.js";import p from"../heuristics/sizeRange.js";import{errorCallback as u,getPointSizeAlgorithm as d,verifyBasicFieldValidity as m,isValidPointSize as c,createColors as y,getSymbolSizeFromScheme as f,getSymbolOutlineFromScheme as b,createSymbol as h,getBasemapInfo as v}from"./support/utils.js";import g from"../statistics/uniqueValues.js";import{verifyBinningParams as w}from"../support/binningUtils.js";import{getFieldsList as T,FIELD_DELIMITER as j}from"../support/utils.js";import{binningCapableLayerTypes as E,featureCapableLayerTypes as x,createLayerAdapter as V,getLayerTypeLabels as z,LayerType as I}from"../support/adapters/support/layerUtils.js";import{cloneScheme as M,getSchemes as S}from"../symbology/type.js";const R="date";async function C(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new l("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new l("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&w(e,"type-renderer");const r={...e,layer:e.layer};r.symbolType=r.symbolType||"2d",r.numTypes=null==r.numTypes?10:r.numTypes,r.defaultSymbolEnabled??=!0,r.sortBy??="count",r.sortEnabled??=!0,r.statistics=i(r.statistics);const s=e.forBinning?E:x,n=V(r.layer,s,e.forBinning);if(!n)throw new l("type-renderer:invalid-parameters","'layer' must be one of these types: "+z(s).join(", "));r.layer=n;const o=null!=r.signal?{signal:r.signal}:null;await n.load(o);const t=n.geometryType;if(r.outlineOptimizationEnabled="polygon"===t&&r.outlineOptimizationEnabled,r.sizeOptimizationEnabled=("point"===t||"multipoint"===t||"polyline"===t)&&r.sizeOptimizationEnabled,"mesh"===t)r.symbolType="3d-volumetric",r.colorMixMode=r.colorMixMode||"replace",r.edgesType=r.edgesType||"none";else{if("3d-volumetric-uniform"===r.symbolType&&"point"!==t)throw new l("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(r.symbolType.includes("3d-volumetric")&&(!r.view||"3d"!==r.view.type))throw new l("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const a=await T({field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression}),p=m(n,a,"type-renderer:invalid-parameters");if(p)throw p;return r}async function q(e){if(!(e&&e.layer&&e.field))throw new l("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const r={...e,layer:e.layer};r.statistics=i(r.statistics);const s=[I.PointCloudLayer],n=V(r.layer,s);if(!n)throw new l("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+z(s).join(", "));if(r.layer=n,r.density=r.density||25,r.size=r.size||"100%",!c(r.size))throw new l("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const o=null!=r.signal?{signal:r.signal}:null;await n.load(o);const t=await T({field:r.field}),a=m(n,t,"type-point-cloud-class-renderer:invalid-parameters");if(a)throw a;return r}async function O(e){let r=e.typeScheme,l=null,i=null;const s=await v(e.basemap,e.view);if(l=null!=s.basemapId?s.basemapId:null,i=null!=s.basemapTheme?s.basemapTheme:null,r)return{scheme:M(r),basemapId:l,basemapTheme:i};const n=S({basemap:l,basemapTheme:i,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return n&&(r=n.primaryScheme,l=n.basemapId,i=n.basemapTheme),{scheme:r,basemapId:l,basemapTheme:i}}function P(e,r){let l;return l=e.label<r.label?-1:e.label>r.label?1:0,l}function B(e,r){let l;return l=e.value<r.value?-1:e.value>r.value?1:0,l}function U(e,r){let l=r.count-e.count;return 0===l&&(l=P(e,r)),l}function D(e,r){let l=r.count-e.count;return 0===l&&(l=B(e,r)),l}function L(e,r,l){let i;"count"===r?(i=D,l&&"codedValues"in l&&l.codedValues&&(i=U)):"value"===r&&(i=B,l&&"codedValues"in l&&l.codedValues&&(i=P)),i&&e.sort(i)}async function A(e,l,i,a){const p=await s("esri/smartMapping/t9n/smartMapping"),{field:u,field2:d,field3:m}=l,c=e.uniqueValueInfos,v=l.layer,g=u?v.getField(u):null,w=g?v.getFieldDomain(g.name):null,T=-1===l.numTypes?c.length:l.numTypes,E=v.geometryType,x=await O({basemap:l.basemap,geometryType:E,typeScheme:l.typeScheme,worldScale:!!l.symbolType?.includes("3d-volumetric"),view:l.view}),V=x.scheme,z=new r({field:u,field2:d,field3:m,fieldDelimiter:u&&d?j:null}),I=[],S=[],C={value:null,domain:w,fieldInfo:g};c.forEach(((e,r)=>{C.value=e.value,e.label=o(C);const l=e.value;(null===l||"string"==typeof l&&l.toLowerCase().includes("<null>"))&&I.unshift(r)}));for(const r of I)S.unshift(c.splice(r,1)[0]);if(!1!==l.sortEnabled&&L(c,l.sortBy,w),g?.type===R){const e=c.filter(((e,r)=>r<T)).map((e=>e.value));C.dateFormatInterval=t(e)}const q=i&&i.opacity;let P=y(V.colors,c.length);const B=f(V,E),U=b(V,E,q);c.forEach(((e,r)=>{C.value=e.value,e.label=o(C),e.symbol=h(E,{type:l.symbolType,color:P[r],size:B,outline:U,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})})),l.valueExpression&&(z.valueExpression=l.valueExpression,z.valueExpressionTitle=l.valueExpressionTitle),l.legendOptions&&(z.legendOptions=new n(l.legendOptions)),P=y(V.colors,T);for(let r=0;r<T;r++){const e=c[r];e&&z.addUniqueValueInfo({value:e.value,label:e.label,symbol:h(E,{type:l.symbolType,color:P[r],size:B,outline:U,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}})})}l.defaultSymbolEnabled&&(z.defaultSymbol=h(E,{type:l.symbolType,color:V.noDataColor,size:B,outline:U,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}}),z.defaultLabel=p.other);for(const r of S)r.symbol=h(E,{type:l.symbolType,color:V.noDataColor,size:B,outline:U,meshInfo:{colorMixMode:l.colorMixMode,edgesType:l.edgesType}}),c.push(r);const D=[],A=z.uniqueValueInfos?.length??0,F=A===c.length?-1:A;if(F>-1)for(let r=F;r<c.length;r++)D.push({...c[r]});return i&&i.visualVariables&&i.visualVariables.length&&(z.visualVariables=i.visualVariables.map((e=>e.clone()))),a&&a.minSize&&(z.visualVariables?z.visualVariables.push(a.minSize):z.visualVariables=[a.minSize]),{renderer:z,uniqueValueInfos:c,excludedUniqueValueInfos:D,typeScheme:M(V),basemapId:x.basemapId,basemapTheme:x.basemapTheme}}async function F(e,r){const l=e.uniqueValueInfos,i=await O({basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:r}),s=i&&i.scheme,n="point-cloud-class"===s?.theme,o=n?s.colors:y(s?.colors??[],l.length);return L(l,"value"),l.map(((e,r)=>{const l=e.value;let i=null;return n?(i=o[l],i||(i=o[o.length-1])):i=o[r],{values:[l],color:i,label:e.label}}))}async function k(e){const r=await C(e),{layer:l,view:i,signal:s}=r,n={layer:l,field:r.field,field2:r.field2,field3:r.field3,valueExpression:r.valueExpression,returnAllCodedValues:r.returnAllCodedValues,view:i,signal:s},[o,t,d]=await Promise.all([null!=r.statistics?r.statistics:g(n),r.outlineOptimizationEnabled?a({layer:l,view:i,signal:s}).catch(u):null,r.sizeOptimizationEnabled?p({layer:l,view:i,signal:s}).catch(u):null]);return A(o,r,t,d)}async function G(r){const l=await q(r),i=null!=l.statistics?l.statistics:await g({layer:l.layer,field:l.field,signal:l.signal});return{renderer:new e({field:l.field,pointsPerInch:l.density,pointSizeAlgorithm:d(l.size),colorUniqueValueInfos:await F(i,l.typeScheme)})}}export{G as createPCClassRenderer,k as createRenderer};
