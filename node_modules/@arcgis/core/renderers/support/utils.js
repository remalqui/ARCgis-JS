/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{unique as e,isSome as l}from"../../core/arrayUtils.js";import t from"../../core/Logger.js";import{getOrCreateMapValue as i}from"../../core/MapUtils.js";import{convertDateFormatToIntlOptions as o,formatDate as a}from"../../intl/date.js";import{format as n,round as s}from"./numberUtils.js";import r from"../visualVariables/support/ColorStop.js";import{getColorFromSymbol as u}from"../../symbols/support/utils.js";import{getRampStops as f}from"../../widgets/Legend/support/colorRampUtils.js";import{getHeatmapRampStops as d}from"../../widgets/Legend/support/heatmapRampUtils.js";const p=t.getLogger("esri.renderers.support.utils"),m={lte:"<=",gte:">=",lt:"<",gt:">",pct:"%",ld:"â€“"},c={millisecond:0,second:1,minute:2,hour:3,day:4,month:5,year:6},y={millisecond:"long-month-day-year-long-time",second:"long-month-day-year-long-time",minute:"long-month-day-year-short-time",hour:"long-month-day-year-short-time",day:"long-month-day-year",month:"long-month-day-year",year:"year"},g=o("short-date");async function h(e,l,t){i(e,l,(()=>[])).push(...t)}async function b(l){const t=new Map;if(!l)return t;if("visualVariables"in l&&l.visualVariables){const e=l.visualVariables.filter((e=>"color"===e.type));for(const l of e){const e=(await f(l)??[]).map((e=>e.color));await h(t,l.field||l.valueExpression,e)}}if("heatmap"===l.type){const e=d(l).map((e=>e.color));await h(t,l.field||l.valueExpression,e)}else if("pie-chart"===l.type){for(const e of l.attributes)await h(t,e.field||e.valueExpression,[e.color]);await h(t,"default",[l?.othersCategory?.color,u(l.backgroundFillSymbol,null)])}else if("dot-density"===l.type){for(const e of l.attributes)await h(t,e.field||e.valueExpression,[e.color]);await h(t,"default",[l.backgroundColor])}else if("unique-value"===l.type)if("predominance"===l.authoringInfo?.type)for(const e of l.uniqueValueInfos??[])await h(t,e.value.toString(),[u(e.symbol,null)]);else{const e=(l.uniqueValueInfos??[]).map((e=>u(e.symbol,null))),{field:i,field2:o,field3:a,valueExpression:n}=l;(i||n)&&await h(t,i||n,e),o&&await h(t,o,e),a&&await h(t,a,e)}else if("class-breaks"===l.type){const e=l.classBreakInfos.map((e=>u(e.symbol,null))),{field:i,valueExpression:o}=l;await h(t,i??o,e)}else"simple"===l.type&&await h(t,"default",[u(l.symbol,null)]);return"defaultSymbol"in l&&l.defaultSymbol&&await h(t,"default",[u(l.defaultSymbol,null)]),t.forEach(((l,i)=>{const o=e(l.filter(Boolean),((e,l)=>JSON.stringify(e)===JSON.stringify(l)));t.set(i,o)})),t}async function v(e,l,t){const o=i(e,l,(()=>new Map));for(const i of t)o.set(i.value,i.color)}async function w(e){const l=new Map;if(!e)return l;if("unique-value"!==e.type||e.authoringInfo?.type)if("class-breaks"===e.type){const t=e.classBreakInfos.map((e=>({value:e.minValue,color:u(e.symbol,null)}))).reverse(),{field:i,valueExpression:o}=e;await v(l,i??o,t)}else"simple"===e.type&&await v(l,"default",[{value:"default",color:u(e.symbol,null)}]);else{const t=(e.uniqueValueInfos??[]).map((e=>({value:e.value,color:u(e.symbol,null)}))),{field:i,field2:o,field3:a,valueExpression:n,fieldDelimiter:s}=e,r=[i,o,a].filter(Boolean).join(s||"");(r||n)&&await v(l,r||n,t)}if("defaultSymbol"in e&&e.defaultSymbol&&await v(l,"default",[{value:"default",color:u(e.defaultSymbol,null)}]),"visualVariables"in e&&e.visualVariables){const t=e.visualVariables.filter((e=>"color"===e.type));for(const e of t){const t=await f(e)??[];await v(l,e.field||e.valueExpression,t)}}return l}function V(e,l,t){let i="";return 0===l?i=m.lt+" ":l===t&&(i=m.gt+" "),i+e}function x(e){const{values:l,colors:t,labelIndexes:i,isDate:o,dateFormatOptions:s}=e;return l.map(((e,u)=>{let f=null;if(!i||i.includes(u)){let t;t=o?a(e,s):n(e),t&&(f=V(t,u,l.length-1))}return new r({value:e,color:t[u],label:f})}))}function E(e){let l=e.minValue,t=e.maxValue;const i=e.isFirstBreak?"":m.gt+" ",o="percent-of-total"===e.normalizationType?m.pct:"";return l=null==l?"":n(l),t=null==t?"":n(t),i+l+o+" "+m.ld+" "+t+o}function F(e){const l=e.classBreakInfos,t=e.normalizationType;let i=[];if(l&&l.length)if("standard-deviation"!==e.classificationMethod)if(e.round){i.push(l[0].minValue);for(const e of l)i.push(e.maxValue);i=s(i),l.forEach(((e,l)=>{e.label=E({minValue:0===l?i[0]:i[l],maxValue:i[l+1],isFirstBreak:0===l,normalizationType:t})}))}else l.forEach(((e,l)=>{e.label=E({minValue:e.minValue,maxValue:e.maxValue,isFirstBreak:0===l,normalizationType:t})}));else p.warn("setLabelsForClassBreaks","cannot set labels for class breaks generated using 'standard-deviation' method.")}function z(e){const l=e.map((e=>new Date(e))),t=l.length;let i=1/0,o=null;for(let a=0;a<t-1;a++){const e=l[a];let n=1/0,s=null;for(let i=a+1;i<t;i++){const t=l[i],o=(e.getFullYear()!==t.getFullYear()?"year":e.getMonth()!==t.getMonth()&&"month")||e.getDate()!==t.getDate()&&"day"||e.getHours()!==t.getHours()&&"hour"||e.getMinutes()!==t.getMinutes()&&"minute"||e.getSeconds()!==t.getSeconds()&&"second"||"millisecond",a=c[o];a<n&&(n=a,s=o)}n<i&&(i=n,o=s)}return o}function I(e){const{value:l,domain:t,fieldInfo:i,dateFormatInterval:s}=e;let r=String(l);const u=t&&"codedValues"in t&&t.codedValues?t.getName(l):null;return u?r=u:"number"==typeof l&&(r=i&&"date"===i.type?a(l,s&&o(y[s])):n(l)),r}function S(e,l){return"normalizationField"in e&&e.normalizationField?j(e.field,e.normalizationField):"field"in e&&e.field?k(e.field):"valueExpression"in e&&e.valueExpression?B(e.valueExpression,e.valueExpressionTitle,l):null}function k(e){return{type:"field",field:e}}function j(e,l){return{type:"normalized-field",field:e,normalizationField:l}}function B(e,l,t){return{type:"expression",expression:e,title:l,returnType:t}}function M(t,i){const o=[];if("class-breaks"===t.type||"heatmap"===t.type)o.push(S(t,"number"));else if("unique-value"===t.type){const e=t.authoringInfo;if(e&&"relationship"===e.type){if(e.field1&&e.field2){const l=e.field1.field,t=e.field2.field,i=e.field1.normalizationField,a=e.field2.normalizationField;o.push(S({field:l,normalizationField:i})),o.push(S({field:t,normalizationField:a}))}}else{const e=t.uniqueValueInfos?.[0];let l=null;if(e&&e.value){const e=typeof t.uniqueValueInfos[0].value;"string"!==e&&"number"!==e||(l=e)}o.push(S(t,l)),[t.field2,t.field3].forEach((e=>e&&o.push(k(e))))}}else"attributes"in t&&t.attributes?.forEach((e=>o.push(S(e,"number"))));const a=i?i(t):"visualVariables"in t?t.visualVariables:null;return a&&a.forEach((e=>o.push(S(e,"number")))),e(o.filter(l),((e,l)=>"field"===e.type&&"field"===l.type?e.field===l.field:"normalized-field"===e.type&&"normalized-field"===l.type?e.field===l.field&&e.normalizationField===l.normalizationField:"expression"===e.type&&"expression"===l.type&&e.expression===l.expression))}export{z as calculateDateFormatInterval,E as createClassBreakLabel,x as createColorStops,I as createUniqueValueLabel,S as getAttribute,M as getAttributes,w as getColorsForRendererValues,b as getColorsFromRenderer,F as setLabelsForClassBreaks,g as timelineDateFormatOptions};
