/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{a as e,w as o}from"./mat4.js";import{c as r}from"./mat4f64.js";import{s as i}from"./vec2.js";import{Z as t,a}from"./vec2f64.js";import{n as l,m as s}from"./vec3.js";import{c as h}from"./vec3f64.js";import{ScreenSpacePass as d}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{unoccludedHighlightFlag as n}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{ReadLinearDepth as c}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js";import{ReadShadowMapDraw as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{CameraSpace as g}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{RgbaFloatEncoding as f}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{Float2PassUniform as m}from"../views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js";import{Float3PassUniform as v}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{Float4PassUniform as u}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as w}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as x}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{Matrix4PassUniform as P}from"../views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js";import{ShaderBuilder as D}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{Texture2DPassUniform as b}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{SnapshotSlot as M}from"../views/3d/webgl-engine/lib/ShadowMap.js";const S={highlightedThreshold:.99999,selfShadowThreshold:.025};function F(r){const a=new D;a.include(p,r);const h=a.fragment;return h.include(f),h.include(c),a.include(g),a.include(d),h.uniforms.add(new b("defaultDepthTex",((e,o)=>o.shadowMap.getSnapshot(M.Default))),new b("highlightDepthTex",((e,o)=>o.shadowMap.getSnapshot(M.Highlight))),new b("depthMap",((e,o)=>o.linearDepthTexture)),new b("highlightMap",((e,o)=>o.highlightColorTexture)),new u("uColor",(e=>e.shadowColor)),new m("nearFar",((e,o)=>o.camera.nearFar)),new w("opacity",(e=>e.shadowOpacity)),new w("occludedOpacity",(e=>e.occludedShadowOpacity)),new w("terminationFactor",(e=>e.opacityElevation*e.dayNightTerminator)),new v("lightingMainDirectionView",((e,o)=>l(z,s(z,o.lighting.mainLight.direction,o.camera.viewInverseTransposeMatrix)))),new m("texelSize",((e,o)=>null!=o.linearDepthTexture?i(T,1/o.linearDepthTexture.descriptor.width,1/o.linearDepthTexture.descriptor.height):t)),new P("inverseViewMatrix",((r,i)=>e(y,o(y,i.camera.viewMatrix,i.camera.center))))),h.constants.add("unoccludedHighlightFlag","vec4",n).add("highlightedThreshold","float",S.highlightedThreshold).add("selfShadowThreshold","float",S.selfShadowThreshold),h.code.add(x`vec3 normalFromDepth(vec3 pixelPos, vec2 fragCoord, vec2 uv, vec2 texelSize, sampler2D depthMap, vec2 nearFar) {
float leftPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(-1.0, 0.0) * texelSize, nearFar);
float rightPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(1.0, 0.0) * texelSize, nearFar);
float bottomPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, -1.0) * texelSize, nearFar);
float topPixelDepth = linearDepthFromTexture(depthMap, uv + vec2(0.0, 1.0) * texelSize, nearFar);
bool pickLeft = abs(pixelPos.z - leftPixelDepth) < abs(pixelPos.z - rightPixelDepth);
bool pickBottom = abs(pixelPos.z - bottomPixelDepth) < abs(pixelPos.z - topPixelDepth);
vec3 fragCoordHorizontal = pickLeft
? vec3(fragCoord + vec2(-1.0, 0.0), leftPixelDepth)
: vec3(fragCoord + vec2(1.0, 0.0), rightPixelDepth);
vec3 fragCoordVertical = pickBottom
? vec3(fragCoord + vec2(0.0, -1.0), bottomPixelDepth)
: vec3(fragCoord + vec2(0.0, 1.0), topPixelDepth);
vec3 verticalPixelPos = reconstructPosition(fragCoordHorizontal.xy, fragCoordHorizontal.z);
vec3 horizontalPixelPos = reconstructPosition(fragCoordVertical.xy, fragCoordVertical.z);
vec3 normal = normalize(cross(verticalPixelPos - pixelPos, horizontalPixelPos - pixelPos));
return pickLeft == pickBottom ? normal : -normal;
}`),h.code.add(x`void main(void) {
vec4 highlightInfo = texture(highlightMap, uv);
float visiblyHighlighted = (1.0 - clamp(distance(unoccludedHighlightFlag, highlightInfo), 0.0, 1.0)) * highlightInfo.a;
if (visiblyHighlighted > highlightedThreshold) {
discard;
}
float depth = rgba2float(texture(depthMap, uv));
if (depth == 0.0) {
discard;
}
float currentPixelDepth = linearDepthFromFloat(depth, nearFar);
if (-currentPixelDepth>nearFar.y || -currentPixelDepth<nearFar.x) {
discard;
}
vec4 currentPixelPos = vec4(reconstructPosition(gl_FragCoord.xy, currentPixelDepth), 1.0);
vec4 worldSpacePos = inverseViewMatrix * currentPixelPos;
mat4 shadowMatrix;
float linearDepth = -currentPixelDepth;
int i = chooseCascade(linearDepth, shadowMatrix);
if (i >= numCascades) {
discard;
}
vec3 lvpos = lightSpacePosition(worldSpacePos.xyz, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
discard;
}
vec2 uvShadow = cascadeCoordinates(i, lvpos);
float depthHighlight = readShadowMapDepth(uvShadow, highlightDepthTex);
bool shadowHighlight = depthHighlight < lvpos.z;
if (!shadowHighlight) {
discard;
}
float depthDefault = readShadowMapDepth(uvShadow, defaultDepthTex);
bool shadowDefault = depthDefault < lvpos.z;
vec3 normal = normalFromDepth(currentPixelPos.xyz, gl_FragCoord.xy, uv, texelSize, depthMap, nearFar);
bool shaded = dot(normal, lightingMainDirectionView) < selfShadowThreshold;
float fragOpacity = (shadowDefault || shaded) ? occludedOpacity : opacity;
fragColor = vec4(uColor.rgb, uColor.a * fragOpacity * terminationFactor);
}`),a}const y=r(),z=h(),T=a(),j=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:"Module"}));export{j as S,F as b};
