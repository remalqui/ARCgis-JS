/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import"../../../geometry.js";import e from"../../../Ground.js";import t from"../../../core/Logger.js";import{eachAlways as o}from"../../../core/promiseUtils.js";import{getMetersPerUnitForSR as r}from"../../../core/unitUtils.js";import n from"../../Mesh.js";import{project as i}from"../../projection.js";import{compactIndices as s}from"../Indices.js";import a from"../MeshComponent.js";import{MeshVertexAttributes as l}from"../MeshVertexAttributes.js";import m from"../../Point.js";async function c(o,r,n){let i;if(f(o)||o instanceof e){const e=await u(o);return i=await e.createElevationSampler(r,{demResolution:n?.demResolution??"finest-contiguous"}),p(i,r,{material:n?.material})}return"string"==typeof n?.demResolution?(t.getLogger("esri.geometry.support.meshUtils.elevation").error("create()","demResolution must be a number when used directly with a sampler"),null):p(o,r,{material:n?.material,demResolution:n?.demResolution})}function p(e,t,o){const m=r(t.spatialReference),c=(o?.demResolution??e.demResolution.min)/m,p=Math.round(t.width/c),u=Math.round(t.height/c),f=p+1,h=u+1,y=new Float64Array(f*h*3),R=new Float32Array(f*h*2);let w=0,g=0;const j=new Uint32Array(p*u*2*3);let v=0,A=0;const x=!e.spatialReference.equals(t.spatialReference);d.spatialReference=t.spatialReference;const{xmin:b,ymin:M,height:U,width:F}=t;for(let r=0;r<h;r++){const t=M+U*(r/u);for(let o=0;o<f;o++){const n=b+F*(o/p);if(y[w++]=n,y[w++]=t,x){d.x=n,d.y=t;const o=i(d,e.spatialReference);y[w++]=e.elevationAt(o.x,o.y)??0}else y[w++]=e.elevationAt(n,t)??0;const s=o/p,a=r/u;R[g++]=s,R[g++]=a,r!==u&&o!==p&&(j[A++]=v+1,j[A++]=v+f+1,j[A++]=v+f,j[A++]=v,j[A++]=v+1,j[A++]=v+f),v++}}return new n({vertexAttributes:new l({position:y,uv:R}),components:[new a({faces:s(j),shading:"smooth",material:o?.material??null})],spatialReference:t.spatialReference})}async function u(e){return f(e)?e.load():(await e.load(),await o(e.layers.map((e=>e.load()))),e)}function f(e){return"type"in e&&("elevation"===e.type||"base-elevation"===e.type)}const d=new m;export{c as create};
