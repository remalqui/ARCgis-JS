/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{whenOrAbort as t,throwIfAborted as s,eachAlwaysValues as r,isAborted as n,createAbortError as o}from"../../../core/promiseUtils.js";import{removeFile as i,makeRelative as a}from"../../../core/urlUtils.js";import l from"../../Point.js";async function c(e,r,n){const{source:o}=r,{loadGLTFMesh:i}=await t(import("./loadGLTFMesh.js"),n),a=await f(o,n);s(n);const c=i(new l({x:0,y:0,z:0,spatialReference:e.spatialReference}),a.url,{resolveFile:u(a),useTransform:!0,signal:n?.signal});c.then((()=>a.dispose()),(()=>a.dispose()));const{vertexAttributes:m,components:p}=await c;e.vertexAttributes=m,e.components=p}function u(e){const t=i(e.url);return s=>{const r=a(s,t,t),n=r?r.replace(/^ *\.\//,""):null;return(n?e.files.get(n):null)??s}}async function f(t,s){if(Array.isArray(t)){if(!t.length)throw new e("mesh-load-external:missing-assets","There must be at least one file to load");return t[0]instanceof File?h(t):w(t,s)}return p(t)}async function m(e,t){const{parts:r}=e;if(1===r.length)return new b(r[0].partUrl);const n=await e.toBlob(t);return s(t),b.fromBlob(n)}function p(e){return b.fromBlob(e)}function h(e){return g(e.map((e=>({name:e.name,mimeType:e.type,source:p(e)}))))}async function w(e,t){const i=await r(e.map((async e=>{const r=await m(e);return s(t),{name:e.assetName,mimeType:e.assetMimeType,source:r}})));if(n(t))throw i.forEach((e=>e.source.dispose())),o();return g(i)}const y=/^(model\/gltf\+json)|(model\/gltf-binary)$/,d=/\.(gltf|glb)/i;function g(t){const s=new Map;let r=null;for(const{name:e,mimeType:n,source:o}of t)(null==r||y.test(n)||d.test(e))&&(r=o.url),s.set(e,o.url),o.files.forEach(((e,t)=>s.set(t,e)));if(null==r)throw new e("mesh-load-external:missing-files","Missing files to load external mesh source");return new b(r,(()=>t.forEach((({source:e})=>e.dispose()))),s)}class b{constructor(e,t=(()=>{}),s=new Map){this.url=e,this.dispose=t,this.files=s}static fromBlob(e){const t=URL.createObjectURL(e);return new b(t,(()=>URL.revokeObjectURL(t)))}}export{c as loadExternal};
