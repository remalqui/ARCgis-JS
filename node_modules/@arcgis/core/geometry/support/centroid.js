/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{collectPath as t}from"../geometryCursorCollectUtils.js";import{getLength as n,getMidpoint as e,getRingAreaCursor as r}from"./coordsUtils.js";function l(t){return t?t.hasZ?[t.xmax-t.xmin/2,t.ymax-t.ymin/2,t.zmax-t.zmin/2]:[t.xmax-t.xmin/2,t.ymax-t.ymin/2]:null}function o(t){return t?u(t.rings,t.hasZ??!1):null}function u(t,n){if(!t||!t.length)return null;const e=[],r=[],l=n?[1/0,-1/0,1/0,-1/0,1/0,-1/0]:[1/0,-1/0,1/0,-1/0];for(let o=0,u=t.length;o<u;o++){const e=s(t[o],n,l);e&&r.push(e)}if(r.sort(((t,e)=>{let r=t[2]-e[2];return 0===r&&n&&(r=t[4]-e[4]),r})),r.length&&(e[0]=r[0][0],e[1]=r[0][1],n&&(e[2]=r[0][3]),(e[0]<l[0]||e[0]>l[1]||e[1]<l[2]||e[1]>l[3]||n&&(e[2]<l[4]||e[2]>l[5]))&&(e.length=0)),!e.length){const r=t[0]&&t[0].length?I(t[0],n):null;if(!r)return null;e[0]=r[0],e[1]=r[1],n&&r.length>2&&(e[2]=r[2])}return e}function s(t,n,e){let r=0,l=0,o=0,u=0,s=0;const I=t.length?t[0][0]:0,i=t.length?t[0][1]:0,h=t.length&&n?t[0][2]:0;for(let N=0;N<t.length;N++){const c=t[N],f=t[(N+1)%t.length],[m,x,g]=c,P=m-I,T=x-i,[a,E,y]=f,b=a-I,F=E-i,V=P*F-b*T;if(u+=V,r+=(P+b)*V,l+=(T+F)*V,n&&c.length>2&&f.length>2){const t=g-h,n=y-h,e=P*n-b*t;o+=(t+n)*e,s+=e}m<e[0]&&(e[0]=m),m>e[1]&&(e[1]=m),x<e[2]&&(e[2]=x),x>e[3]&&(e[3]=x),n&&(g<e[4]&&(e[4]=g),g>e[5]&&(e[5]=g))}if(u>0&&(u*=-1),s>0&&(s*=-1),!u)return null;u*=.5,s*=.5;const c=[r/(6*u)+I,l/(6*u)+i,u];return n&&(e[4]===e[5]||0===s?(c[3]=(e[4]+e[5])/2,c[4]=0):(c[3]=o/(6*s)+h,c[4]=s)),c}function I(t,r){const l=r?[0,0,0]:[0,0],o=r?[0,0,0]:[0,0];let u=0,s=0,I=0,i=0;for(let h=0,c=t.length;h<c-1;h++){const c=t[h],N=t[h+1];if(c&&N){l[0]=c[0],l[1]=c[1],o[0]=N[0],o[1]=N[1],r&&c.length>2&&N.length>2&&(l[2]=c[2],o[2]=N[2]);const t=n(l,o);if(t){u+=t;const n=e(c,N);s+=t*n[0],I+=t*n[1],r&&n.length>2&&(i+=t*n[2])}}}return u>0?r?[s/u,I/u,i/u]:[s/u,I/u]:t.length?t[0]:null}function i(n){const{hasZ:e,numPaths:r}=n;if(0===r)return null;const l=[],o=[],u=e?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY];for(n.reset();n.nextPath();){const e=s(t(n),n.hasZ,u);e&&o.push(e)}if(o.sort(((t,n)=>{let r=t[2]-n[2];return 0===r&&e&&(r=t[4]-n[4]),r})),o.length&&(l[0]=o[0][0],l[1]=o[0][1],e&&(l[2]=o[0][3]),(l[0]<u[0]||l[0]>u[1]||l[1]<u[2]||l[1]>u[3]||e&&(l[2]<u[4]||l[2]>u[5]))&&(l.length=0)),!l.length){n.reset(),n.nextPath();const t=n.numPoints?h(n):null;if(!t)return null;l[0]=t[0],l[1]=t[1],e&&t.length>2&&(l[2]=t[2])}return l}function h(t){const{hasZ:r}=t,l=r?[0,0,0]:[0,0],o=r?[0,0,0]:[0,0];let u=0,s=0,I=0,i=0;if(t.nextPoint()){let h=t.x,c=t.y,N=t.z;for(;t.nextPoint();){const f=t.x,m=t.y,x=t.z;l[0]=h,l[1]=c,o[0]=f,o[1]=m,r&&(l[2]=N,o[2]=x);const g=n(l,o);if(g){u+=g;const t=e(l,o);s+=g*t[0],I+=g*t[1],r&&t.length>2&&(i+=g*t[2])}h=f,c=m,N=x}}return u>0?r?[s/u,I/u,i/u]:[s/u,I/u]:t.numPoints?(t.seekPathStart(),t.nextPoint(),[t.x,t.y]):null}const c=1e-6;function N(t){let n=0;for(t.reset();t.nextPath();)n+=r(t);if(n<c){const n=i(t);return n?[n[0],n[1]]:null}const e=[0,0];if(t.reset(),!t.nextPath()||!t.nextPoint())return null;const l=[t.x,t.y];for(t.reset();t.nextPath();)m(e,l,t);return e[0]*=1/n,e[1]*=1/n,e[0]+=l[0],e[1]+=l[1],e}const f=1/3;function m(t,n,e){if(!t||!e||e.numPoints<3)return null;e.nextPoint();const l=e.x,o=e.y;e.nextPoint();let u,s=e.x-l,I=e.y-o,i=0,h=0;for(;e.nextPoint();)i=e.x-l,h=e.y-o,u=.5*f*(i*I-h*s),t[0]+=u*(s+i),t[1]+=u*(I+h),s=i,I=h;const c=r(e),N=[l,o];return N[0]-=n[0],N[1]-=n[1],N[0]*=c,N[1]*=c,t[0]+=N[0],t[1]+=N[1],t}export{l as extentCentroid,I as lineCentroid,h as lineCentroidCursor,o as polygonCentroid,s as ringCentroid,u as ringsCentroid,i as ringsCentroidCursor,N as weightedAreaCentroid};
