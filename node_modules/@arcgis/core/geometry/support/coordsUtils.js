/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{equals as t}from"../../core/arrayUtils.js";import{getInfo as n}from"./spatialReferenceUtils.js";function e(t){if(!t)return null;if(Array.isArray(t))return t;const n=t.hasZ,e=t.hasM;if("point"===t.type)return e&&n?[t.x,t.y,t.z,t.m]:n?[t.x,t.y,t.z]:e?[t.x,t.y,t.m]:[t.x,t.y];if("polygon"===t.type)return t.rings.slice(0);if("polyline"===t.type)return t.paths.slice(0);if("multipoint"===t.type)return t.points.slice(0);if("extent"===t.type){const n=t.clone().normalize();if(!n)return null;let e=!1,r=!1;return n.forEach((t=>{t.hasZ&&(e=!0),t.hasM&&(r=!0)})),n.map((t=>{const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(e&&t.hasZ){const e=.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(e)}if(r&&t.hasM){const e=.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(e)}return n}))}return null}function r(t,n){const e=n[0]-t[0],r=n[1]-t[1];if(t.length>2&&n.length>2){const i=t[2]-n[2];return Math.sqrt(e*e+r*r+i*i)}return Math.sqrt(e*e+r*r)}function i(t,n,e){const r=t[0]+e*(n[0]-t[0]),i=t[1]+e*(n[1]-t[1]);return t.length>2&&n.length>2?[r,i,t[2]+e*(n[2]-t[2])]:[r,i]}function o(t,n,e,r){const[i,o]=n,[s,f]=e[r],[l,u]=e[r+1],c=l-s,h=u-f,a=c*c+h*h,p=(i-s)*c+(o-f)*h,y=Math.min(1,Math.max(0,p/a));return t[0]=s+c*y,t[1]=f+h*y,t}function s(t,n,e){let r,i,o,s,l=!1,u=1/0;for(e.reset();e.nextPath();)if(e.nextPoint())for(r=e.x,i=e.y;e.nextPoint();)o=e.x,s=e.y,i>n!=s>n&&t<(o-r)*(n-i)/(s-i)+r&&(l=!l),u=Math.min(u,f(t,n,r,i,o,s)),r=o,i=s;return 0===u?0:(l?1:-1)*Math.sqrt(u)}function f(t,n,e,r,i,o){let s=e,f=r,l=i-s,u=o-f;if(0!==l||0!==u){const e=((t-s)*l+(n-f)*u)/(l*l+u*u);e>1?(s=i,f=o):e>0&&(s+=l*e,f+=u*e)}return l=t-s,u=n-f,l*l+u*u}function l(t,n){return i(t,n,.5)}function u(t){const n=t.length;let e=0;for(let i=0;i<n-1;++i)e+=r(t[i],t[i+1]);return e}function c(t,n){if(n<=0)return t[0];const e=t.length;let o=0;for(let s=0;s<e-1;++s){const e=r(t[s],t[s+1]);if(n-o<e){const r=(n-o)/e;return i(t[s],t[s+1],r)}o+=e}return t[e-1]}function h(t,n,e){const r=t.length;let i=0,o=0,s=0;for(let f=0;f<r;f++){const l=t[f],u=t[(f+1)%r];let c=2;i+=l[0]*u[1]-u[0]*l[1],l.length>2&&u.length>2&&e&&(o+=l[0]*u[2]-u[0]*l[2],c=3),l.length>c&&u.length>c&&n&&(s+=l[0]*u[c]-u[0]*l[c])}return i<=0&&o<=0&&s<=0}function a(n){const e=n.length;return e>2&&t(n[0],n[e-1])}function p(t){if("rings"in t&&(y(t),t.rings.length>0&&!h(t.rings[0],t.hasM??!1,t.hasZ??!1)))for(const n of t.rings)n.reverse()}function y(t){if("rings"in t)for(const n of t.rings)a(n)||n.push(n[0].slice())}function g(t){if("polygon"!==t.type&&"polyline"!==t.type)return t;return m("polygon"===t.type?t.rings:t.paths,t.spatialReference),t}function m(t,e){const r=n(e);if(!r)return;const i=r.valid[0],o=r.valid[1],s=o-i;for(const n of t){let t=1/0,e=-1/0;for(const s of n){const n=x(s[0],i,o);t=Math.min(t,n),e=Math.max(e,n),s[0]=n}const r=e-t;s-r<r&&n.forEach((t=>{t[0]<0&&(t[0]+=s)}))}}function x(t,n,e){const r=e-n;return t<n?e-(n-t)%r:t>e?n+(t-n)%r:t}function M(t){if(!t||t.length<3)return 0;let n=0;const e=t.length-1;for(let r=0;r<e;r++)n+=(t[r][0]-t[r+1][0])*(t[r][1]+t[r+1][1]);return n+=(t[e][0]-t[0][0])*(t[e][1]+t[0][1]),-.5*n}function P(t){if(!t||t.numPoints<3)return 0;let n,e,r=0;if(t.seekPathStart(),!t.nextPoint())return 0;n=t.x,e=t.y;const i=n,o=e;for(;t.nextPoint();)r+=(n-t.x)*(e+t.y),n=t.x,e=t.y;return r+=(n-i)*(e+o),-.5*r}function z(t,n){if(t===n)return!0;if(t.type!==n.type)return!1;if("point"===t.type||"mesh"===t.type||"extent"===t.type)return!0;if("multipoint"===t.type)return t.points.length===n.points.length;const[e,r]="polyline"===t.type?[t.paths,n.paths]:[t.rings,n.rings];return e.length===r.length&&e.every(((t,n)=>t.length===r[n].length))}export{y as closeRings,p as closeRingsAndFixWinding,s as distanceFromPointToPolygon,f as distanceToSegmentSquared,e as geometryToCoordinates,r as getLength,l as getMidpoint,u as getPathLength,c as getPointOnPath,M as getRingArea,P as getRingAreaCursor,z as hasCompatibleTopology,h as isClockwise,a as isClosed,o as projectPointOnLine,g as unnormalizeGeometryOnDatelineCrossing,m as unnormalizeVerticesOnDatelineCrossing,x as unnormalizedCoordinate};
