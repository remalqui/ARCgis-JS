/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{isSome as t}from"../../../../../core/arrayUtils.js";import{HandleOwner as i}from"../../../../../core/HandleOwner.js";import{whenOrAbort as o}from"../../../../../core/promiseUtils.js";import{property as a}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/has.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import{WorkerHandle as n}from"../../../../../core/workers/WorkerHandle.js";import{featureGeometryTypeKebabDictionary as s}from"../../../../../geometry/support/typeUtils.js";import{makeDehydratedPoint as d}from"../../../../../layers/graphics/dehydratedFeatures.js";let l=class extends i{get updating(){return this.updatingHandles.updating||this._workerHandleUpdating}constructor(e){super(e),this.schedule=null,this.hasZ=!1,this.elevationAlignPointsInFeatures=async e=>{const t=[];for(const{points:i}of e)for(const{z:e}of i)t.push(e);return{elevations:t,drapedObjectIds:new Set,failedObjectIds:new Set}},this.queryForSymbologySnapping=async()=>({candidates:[],sourceCandidateIndices:[]}),this.availability=0,this._workerHandleUpdating=!0,this._editId=0}destroy(){this._workerHandle.destroy()}initialize(){this._workerHandle=new p(this.schedule,{alignElevation:async(e,{signal:t})=>({result:await this.elevationAlignPointsInFeatures(e.points,t)}),getSymbologyCandidates:async(e,{signal:t})=>({result:await this.queryForSymbologySnapping(e,t)})}),this.handles.add([this._workerHandle.on("notify-updating",(({updating:e})=>this._workerHandleUpdating=e)),this._workerHandle.on("notify-availability",(({availability:e})=>this._set("availability",e)))])}async setup(e,t){const i=this._serviceInfoFromLayer(e.layer);if(null==i)return;const o={configuration:this._convertConfiguration(e.configuration),serviceInfo:i,spatialReference:e.spatialReference.toJSON(),hasZ:this.hasZ,elevationInfo:e.layer.elevationInfo?.toJSON()};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("setup",o,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async configure(e,t){const i=this._convertConfiguration(e);await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("configure",i,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh",{},e)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const i=e.point,o={distance:e.distance,mode:e.mode,point:d(i[0],i[1],i[2],e.coordinateHelper.spatialReference.toJSON()),returnEdge:e.returnEdge,returnVertex:e.returnVertex,filter:null!=e.filter?e.filter.toJSON():null};return this._workerHandle.invoke(o,t)}async updateTiles(e,t){const i={tiles:e.tiles,tileInfo:null!=e.tileInfo?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles",i,t)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async applyEdits(e,i){const a=this._editId++,r={id:a};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("beginApplyEdits",r,i));const n=await this.updatingHandles.addPromise(o(e.result,i)),s={id:a,edits:{addedFeatures:n.addedFeatures?.map((({objectId:e})=>e)).filter(t)??[],deletedFeatures:n.deletedFeatures?.map((({objectId:e,globalId:t})=>({objectId:e,globalId:t})))??[],updatedFeatures:n.updatedFeatures?.map((({objectId:e})=>e)).filter(t)??[]}};await this.updatingHandles.addPromise(this._workerHandle.invokeMethod("endApplyEdits",s,i)),this.updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},i))}getDebugInfo(e){return this._workerHandle.invokeMethod("getDebugInfo",{},e)}async notifyElevationSourceChange(){await this._workerHandle.invokeMethod("notifyElevationSourceChange",{})}async notifySymbologyChange(){await this._workerHandle.invokeMethod("notifySymbologyChange",{})}async setSymbologySnappingSupported(e){await this._workerHandle.invokeMethod("setSymbologySnappingSupported",e)}_convertConfiguration(e){return{filter:null!=e.filter?e.filter.toJSON():null,customParameters:e.customParameters,viewType:e.viewType}}_serviceInfoFromLayer(e){return"multipatch"===e.geometryType||"mesh"===e.geometryType?null:{url:e.parsedUrl?.path??"",fields:e.fields.map((e=>e.toJSON())),geometryType:s.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,globalIdField:e.globalIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:e.timeInfo?.toJSON()}}};e([a({constructOnly:!0})],l.prototype,"schedule",void 0),e([a({constructOnly:!0})],l.prototype,"hasZ",void 0),e([a({constructOnly:!0})],l.prototype,"elevationAlignPointsInFeatures",void 0),e([a({constructOnly:!0})],l.prototype,"queryForSymbologySnapping",void 0),e([a({readOnly:!0})],l.prototype,"updating",null),e([a({readOnly:!0})],l.prototype,"availability",void 0),e([a()],l.prototype,"_workerHandleUpdating",void 0),l=e([r("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],l);class p extends n{constructor(e,t){super("FeatureServiceSnappingSourceWorker","fetchCandidates",{},e,{strategy:"dedicated",client:t})}}export{l as FeatureServiceSnappingSourceWorkerHandle};
