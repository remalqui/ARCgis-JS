/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Evented.js";import{HandleOwner as n}from"../../../core/HandleOwner.js";import{isAborted as i}from"../../../core/promiseUtils.js";import{watch as s,sync as r,syncAndInitial as a}from"../../../core/reactiveUtils.js";import{property as o}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import{subclass as p}from"../../../core/accessorSupport/decorators/subclass.js";import{project as c,initializeProjection as d}from"../../../geometry/projection.js";import{absoluteHeightElevationInfo as h}from"../../../support/elevationInfoUtils.js";import{defaults as l}from"./Settings.js";import{SnappingDomain as u}from"./SnappingDomain.js";import{defaultSnappingEnginesFactory as f}from"./snappingFactory.js";import _ from"./SnappingOptions.js";import{pointToSnappingPoint as g,snappingPointToSnappingOutput as S}from"./SnappingPoint.js";import{sortCandidatesInPlace as m,squaredScreenDistance as v}from"./snappingUtils.js";import{IntersectionSnappingCandidate as y}from"./candidates/IntersectionSnappingCandidate.js";import{vectorToScreenPoint as C}from"../support/viewUtils.js";let P=class extends(t.EventedMixin(n)){constructor(e){super(e),this.options=new _,this.snappingEnginesFactory=f,this._engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=T.MAIN}initialize(){this.handles.add([s((()=>{const{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:n,distance:i}=this.options;return{effectiveFeatureEnabled:e,effectiveSelfEnabled:t,touchSensitivityMultiplier:n,distance:i}}),(()=>{this.doneSnapping(),this.emit("changed")}),r),s((()=>this.options),(e=>{for(const t of this._engines)t.options=e}),r),s((()=>({viewReady:this.view.ready,viewSpatialReference:this.view.spatialReference,snappingEnginesFactory:this.snappingEnginesFactory})),(({viewReady:e,snappingEnginesFactory:t})=>this._recreateEngines(e,t)),a)])}destroy(){this._destroyEngines()}get updating(){return this._engines.some((e=>e.updating))}_recreateEngines(e,t){if(this._destroyEngines(),!e)return;const{view:n,options:i}=this;this._engines=t(n,i)}_destroyEngines(){for(const e of this._engines)e.destroy();this._engines=[]}get _squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,n=e*t;return n*n}get _squaredSatisfiesConstraintThreshold(){return l.satisfiesConstraintScreenThreshold*l.satisfiesConstraintScreenThreshold}async snap(e){return E(e)?this._snapMultiPoint(e):this._snapSinglePoint(e)}update(e){const{point:t,context:n}=e;this._removeVisualization();const i=this._currentMainCandidate;if(null==i)return t;const s=this._selectUpdateInput(e);if(null==s)return t;const{spatialReference:r}=n,a=c(s,r);if(null==a)return t;const{view:o}=this,{elevationInfo:p,visualizer:d}=n,h=[],l=g(a,o,n),u=i.constraint.closestTo(l);if(!this._arePointsWithinScreenThreshold(l,u,n))return this._resetSnappingState(),t;i.targetPoint=u,h.push(...i.hints);for(const c of this._currentOtherActiveCandidates)c.targetPoint=u,h.push(...c.hints);return null!=d&&this.handles.add(d.draw(h,{spatialReference:r,elevationInfo:I(n),view:o,selfSnappingZ:n.selfSnappingZ}),w),S(u,o,{z:t.z,m:t.m,spatialReference:t.spatialReference,elevationInfo:p})}doneSnapping(){this._removeVisualization(),this._resetSnappingState()}_selectUpdateInput({point:e,scenePoint:t}){switch(this._currentSnappedType){case T.MAIN:return e;case T.SCENE:return t}}_resetSnappingState(){this._currentMainCandidate=null,this._currentOtherActiveCandidates=[],this._currentSnappedType=T.MAIN}_removeVisualization(){this.handles.remove(w)}async _snapSinglePoint({point:e,context:t,signal:n}){const{view:i}=this,s=g(e,i,t),r=await this._fetchCandidates(s,u.ALL,t,n);return this._createSnapResult(s,T.MAIN,r,i,t,{z:e.z,m:e.m,spatialReference:e.spatialReference,elevationInfo:t.elevationInfo},n)}async _snapMultiPoint({point:e,scenePoint:t,context:n,signal:i}){const{view:s}=this,{coordinateHelper:r,spatialReference:a}=n;await d(t.spatialReference,a);const o=c(t,a),p=g(o,s,n),h=await this._fetchCandidates(p,u.FEATURE,n,i);if(h.length>0){const e=await this._fetchCandidates(p,u.SELF,n,i);return this._createSnapResult(p,T.SCENE,[...h,...e],s,n,{z:o.z,m:o.m,spatialReference:o.spatialReference,elevationInfo:n.elevationInfo},i)}const l=g(e,s,n),f=await this._fetchCandidates(l,u.SELF,n,i);return this._createSnapResult(l,T.MAIN,f,s,n,{z:r.hasZ()&&e.hasZ?e.z??0:void 0,m:r.hasM()&&e.hasM?e.m??0:void 0,spatialReference:e.spatialReference,elevationInfo:n.elevationInfo},i)}async _fetchCandidates(e,t,n,i){return(await Promise.all(this._engines.map((s=>s.fetchCandidates(e,t,n,i))))).flat()}_createSnapResult(e,t,n,s,r,a,o){return{get valid(){return!i(o)},apply:()=>{const{spatialReference:i}=r,{snappedPoint:o,hints:p}=this._processCandidates(e,t,n,r);return this._removeVisualization(),null!=r.visualizer&&this.handles.add(r.visualizer.draw(p,{spatialReference:i,elevationInfo:h,view:s,selfSnappingZ:r.selfSnappingZ}),w),S(o,s,a)}}}_processCandidates(e,t,n,i){if(n.length<1)return this.doneSnapping(),{snappedPoint:e,hints:[]};this._currentSnappedType!==t&&this._resetSnappingState(),m(e,n);const s=this._currentMainCandidate;if(null!=s){const r=this._findOldConstraintInNewCandidates(s,n);if(r>=0){if(!(n[r]instanceof y))return this._intersectWithOtherCandidates(r,n,e,t,i);if(this._arePointsWithinScreenThreshold(e,s.targetPoint,i))return this._updateSnappingCandidate(s,t,n,i)}}return this._intersectWithOtherCandidates(0,n,e,t,i)}_findOldConstraintInNewCandidates(e,t){return e instanceof y?this._findOldCandidateIndex(t,e.first)>=0&&this._findOldCandidateIndex(t,e.second)>=0?0:-1:this._findOldCandidateIndex(t,e)}_intersectWithOtherCandidates(e,t,n,i,s){const{coordinateHelper:r}=s,a=t[e],o=[];for(let p=0;p<t.length;++p){if(p===e)continue;const i=t[p];for(const e of a.constraint.intersect(i.constraint)){const t=e.closestTo(a.targetPoint);o.push([new y(t,a,i,i.isDraped),this._squaredScreenDistance(n,t,r)])}}return o.length>0&&(o.sort(((e,t)=>e[1]-t[1])),o[0][1]<this._squaredPointProximityThreshold(s.pointer))?this._updateSnappingCandidate(o[0][0],i,t,s):this._updateSnappingCandidate(a,i,t,s)}_updateSnappingCandidate(e,t,n,i){this.doneSnapping(),this._currentMainCandidate=e,this._currentSnappedType=t;const s=this._currentMainCandidate.targetPoint,r=[];r.push(...e.hints);for(const a of n){if(e instanceof y){if(a.constraint.equals(e.first.constraint)||a.constraint.equals(e.second.constraint))continue}else if(a.constraint.equals(e.constraint))continue;const t=a.constraint.closestTo(s);this._squaredScreenDistance(t,s,i.coordinateHelper)<this._squaredSatisfiesConstraintThreshold&&(a.targetPoint=s,this._currentOtherActiveCandidates.push(a),r.push(...a.hints))}return{snappedPoint:s,hints:r}}_squaredPointProximityThreshold(e){return"touch"===e?this._squaredTouchProximityThreshold:this._squaredMouseProximityTreshold}_arePointsWithinScreenThreshold(e,t,n){return this._squaredScreenDistance(e,t,n.coordinateHelper)<this._squaredPointProximityThreshold(n.pointer)}_squaredScreenDistance(e,t,n){return v(this._toScreen(e,n),this._toScreen(t,n))}_toScreen(e,t){return C(e,t.spatialReference,h,this.view)}_findOldCandidateIndex(e,t){let n=-1;for(let i=0;i<e.length;++i)if(t.constraint.equals(e[i].constraint)){n=i;break}return n}get test(){return{visualizationsActive:this.handles.has(w),engines:this._engines}}};var T;e([o({constructOnly:!0})],P.prototype,"view",void 0),e([o()],P.prototype,"options",void 0),e([o({readOnly:!0})],P.prototype,"updating",null),e([o()],P.prototype,"snappingEnginesFactory",void 0),e([o()],P.prototype,"_engines",void 0),e([o()],P.prototype,"_squaredMouseProximityTreshold",null),e([o()],P.prototype,"_squaredTouchProximityThreshold",null),e([o()],P.prototype,"_squaredSatisfiesConstraintThreshold",null),P=e([p("esri.views.interactive.snapping.SnappingManager")],P),function(e){e[e.MAIN=0]="MAIN",e[e.SCENE=1]="SCENE"}(T||(T={}));const w="visualization-handle";function E(e){return null!=e.scenePoint}function I({coordinateHelper:e,elevationInfo:t}){return e.hasZ()?h:t}export{P as SnappingManager};
