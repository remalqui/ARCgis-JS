/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{g as t,c as s}from"../../../chunks/vec2.js";import{a as e}from"../../../chunks/vec2f64.js";import{k as n}from"../../../chunks/vec3.js";import{f as r}from"../../../chunks/vec3f64.js";import{cloneSnappingPoint as i,asSnappingPoint as o}from"./SnappingPoint.js";import{projectPointToLineLike as c,projectPointToVerticalCylinder as u,projectPointToVerticalPlane as a,VerticalPlaneType as l,epsilon as h,intersectLineAndPoint as p,intersectVerticalCylinderAndPoint as f,intersectVerticalPlaneAndPoint as d,intersectLineLike as k,intersectLineLikeAndVerticalCylinder as L,intersectVerticalPlaneAndLineLike as m,intersectVerticalPlaneAndVerticalCylinder as y,intersectVerticalPlane as g}from"../../support/geometry3dUtils.js";import{LineType as q}from"../../support/geometry2dUtils.js";class x{intersect(t){return G(this,t)}}class T extends x{constructor(t){super(),this.point=t}equals(t){return U(t)&&n(this.point,t.point)}closestTo(){return i(this.point)}}class j extends x{constructor(t,s,e){super(),this.start=t,this.end=s,this.type=e,this.lineLike={start:this.start,end:this.end,type:this.type}}equals(t){return F(t)&&this.type===t.type&&n(this.start,t.start)&&n(this.end,t.end)}closestTo(t){const s=c(t,this.lineLike);return o(s)}}class P extends j{constructor(t,s){super(t,s,q.LINE)}}class Z extends x{constructor(t,s,e){super(),this.intersection=t,this.first=s,this.second=e}equals(t){return t instanceof Z&&this.first.equals(t.first)&&this.second.equals(t.second)}closestTo(){return i(this.intersection)}}class E extends x{constructor(t,s,e){super(),this.basePoint=t,this.first=s,this.second=e}equals(t){return t instanceof E&&this.first.equals(t.first)&&this.second.equals(t.second)}closestTo(t){const s=this.basePoint;return o(r(s[0],s[1],t[2]))}}class v extends x{constructor(t,s){super(),this.center=t,this.radius=s}equals(t){return H(t)&&this.center[0]===t.center[0]&&this.center[1]===t.center[1]&&this.radius===t.radius}closestTo(t){const s=u(t,this.center,this.radius);return o(s)}}class w extends x{constructor(t,s,e){super(),this.start=t,this.end=s,this.type=e,this.planeLike={start:t,end:s,type:e}}equals(t){return S(t)&&this.type===t.type&&n(this.start,t.start)&&n(this.end,t.end)}closestTo(t){return o(a(t,this.planeLike))}closestEndTo(e){const{start:n,end:r}=this;return Math.sign(t(s(z,r,n),s(B,e,n)))>0?r:n}}class A extends w{constructor(t,s){super(t,s,l.HALF_PLANE)}}class I extends w{constructor(t,s){super(t,s,l.PLANE)}}class N extends x{constructor(t,s,e){super(),this.start=t,this.end=s,this.getZ=e,this.planeLike={start:t,end:s,type:l.PLANE}}equals(t){return _(t)&&n(this.start,t.start)&&n(this.end,t.end)&&this.getZ===t.getZ}closestTo(t){return b(this,t)}addIfOnTheGround(t,s){for(const e of s){const s=this.getZ(e[0],e[1],e[2])??0;Math.abs(e[2]-s)<h&&(e[2]=s,t.push(e))}}}function b(t,s){const e=a(s,t.planeLike);return e[2]=t.getZ(s[0],s[1],s[2])??C,o(e)}function G(t,s){let e=[];if(U(t)){const{point:n}=t;F(s)?e=p(s.lineLike,n):H(s)?e=f(s.center,s.radius,n):S(s)?e=d(s.planeLike,n):_(s)&&(e=O(s,t))}else if(F(t)){const{lineLike:n}=t;U(s)?e=p(n,s.point):F(s)?e=k(n,s.lineLike):H(s)?e=L(n,s.center,s.radius):S(s)?e=m(s.planeLike,n):_(s)&&(e=O(s,t))}else if(H(t)){const{center:n,radius:r}=t;if(F(s))e=L(s.lineLike,n,r);else if(U(s))e=f(n,r,s.point);else{if(S(s))return y(s.planeLike,n,r).map((e=>new E(e,t,s)));_(s)&&(e=O(s,t))}}else if(S(t)){const{planeLike:n}=t;if(S(s))return g(n,s.planeLike).map((e=>new E(e,t,s)));if(U(s))e=d(n,s.point);else if(F(s))e=m(n,s.lineLike);else{if(H(s))return y(n,s.center,s.radius).map((e=>new E(e,t,s)));_(s)&&(e=O(s,t))}}else _(t)&&(e=O(t,s));return M(e,t,s)}function O(t,s){const{planeLike:e,getZ:n}=t,i=[];if(U(s))t.addIfOnTheGround(i,d(e,s.point));else if(F(s))t.addIfOnTheGround(i,m(e,s.lineLike));else if(H(s))for(const[o,c]of y(e,s.center,s.radius)){const t=n(o,c,0);null!=t&&i.push(r(o,c,t))}else if(S(s)||_(s))for(const[o,c]of g(e,s.planeLike)){const t=n(o,c,0)??C;i.push(r(o,c,t))}return i}function M(t,s,e){return t.map((t=>new Z(o(t),s,e)))}function U(t){return t instanceof T}function F(t){return t instanceof j}function H(t){return t instanceof v}function S(t){return t instanceof w}function _(t){return t instanceof N}const z=e(),B=e(),C=0;export{N as DrapedLineConstraint,Z as IntersectionConstraint,P as LineConstraint,j as LineLikeConstraint,T as PointConstraint,x as SnappingConstraint,v as VerticalCylinderConstraint,A as VerticalHalfPlaneConstraint,E as VerticalLineIntersectionConstraint,I as VerticalPlaneConstraint,w as VerticalPlaneLikeConstraint};
