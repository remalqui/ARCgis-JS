/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{c as e,g as t,x as i,y as s}from"../../../chunks/vec2.js";import{a as r}from"../../../chunks/vec2f64.js";import{s as n,A as o}from"../../../chunks/vec3.js";import{a,c as p}from"../../../chunks/vec3f64.js";import{absoluteHeightElevationInfo as h}from"../../../support/elevationInfoUtils.js";import{SnappingAlgorithm as c}from"./SnappingAlgorithm.js";import{VerticalHalfPlaneConstraint as d}from"./SnappingConstraint.js";import{anyMapPointToSnappingPoint as g,asSnappingPoint as f}from"./SnappingPoint.js";import{squaredScreenDistance as l}from"./snappingUtils.js";import{RightAngleSnappingCandidate as m,OtherVertexType as x}from"./candidates/RightAngleSnappingCandidate.js";import{vectorToScreenPoint as E}from"../support/viewUtils.js";class V extends c{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.vertices.length,r=[];if(s<2)return r;const{view:n}=this,o=E(e,t.spatialReference,h,n),a=i.vertices[s-1];if(this.edgeExceedsShortLineThreshold(a.leftEdge,t)){const i=g(a.pos,n,t),s=g(a.leftEdge.leftVertex.pos,n,t);this._checkForSnappingCandidate(r,s,i,e,o,t)}const p=i.vertices[0];if(this.edgeExceedsShortLineThreshold(p.rightEdge,t)){const i=g(p.pos,n,t),s=g(p.rightEdge.rightVertex.pos,n,t);this._checkForSnappingCandidate(r,s,i,e,o,t)}return r}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:r}=this,n=E(e,t.spatialReference,h,r),o=s.leftEdge,a=s.rightEdge;if(o&&o.leftVertex.leftEdge){const s=o.leftVertex.leftEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const o=g(s.rightVertex.pos,r,t),a=g(s.leftVertex.pos,r,t);this._checkForSnappingCandidate(i,a,o,e,n,t)}}if(a&&a.rightVertex.rightEdge){const s=a.rightVertex.rightEdge;if(this.edgeExceedsShortLineThreshold(s,t)){const o=g(s.leftVertex.pos,r,t),a=g(s.rightVertex.pos,r,t);this._checkForSnappingCandidate(i,a,o,e,n,t)}}return i}_checkForSnappingCandidate(r,c,g,V,S,j){const{spatialReference:k,pointer:C}=j;e(v,g,c);const w=n(u,v[1],-v[0],0),T=t(w,e(v,V,g))/i(w),F=f(s(a(V),g,w,T));if(l(S,E(F,k,h,this.view))<this.squaredProximityThreshold(C)){if(this.isVertical(F,g)||this.isVertical(g,c))return;const e=o(p(),g,w,Math.sign(T));r.push(new m({targetPoint:F,constraint:new d(g,f(e)),previousVertex:c,otherVertex:g,otherVertexType:x.CENTER,isDraped:"on-the-ground"===j.elevationInfo?.mode}))}}}const v=r(),u=p();export{V as RightAngleSnapper};
