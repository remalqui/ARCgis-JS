/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{clamp as t}from"../../../../core/mathUtils.js";import{destroyMaybe as r}from"../../../../core/maybe.js";import{watch as o}from"../../../../core/reactiveUtils.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{property as i}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import{subclass as n}from"../../../../core/accessorSupport/decorators/subclass.js";import{e as a,F as c,c as p,h as d,b as h,n as l}from"../../../../chunks/vec3.js";import{c as u}from"../../../../chunks/vec3f64.js";import m from"../../../../geometry/Point.js";import{wrap as f}from"../../../../geometry/support/ray.js";import{PropertiesPool as y}from"../PropertiesPool.js";import{PointOfInterest as g}from"./PointOfInterest.js";import{PaddingSide as _}from"../../webgl-engine/lib/Camera.js";import{TaskPriority as O,Task as j}from"../../../support/Scheduler.js";const L=Array;let P=class extends g{constructor(e){super(e),this._propertiesPool=new y({location:m,renderLocation:L},this),this._dirty=!0,this.renderLocation=this._propertiesPool.get("renderLocation")}initialize(){this.handles.add([o((()=>this.centerOnSurface.renderLocation),(()=>this.updateRenderLocation())),o((()=>this.state.contentCamera),(()=>this.updateRenderLocation()))]),this.scheduler&&this.handles.add(this.scheduler.registerTask(O.POINT_OF_INTEREST_FREQUENT,this))}destroy(){this._propertiesPool=r(this._propertiesPool)}get updating(){return this._dirty||this.centerOnSurface.updating}get location(){const e=this._propertiesPool.get("location");return this.renderCoordsHelper.fromRenderCoords(this.renderLocation,e,this.state.spatialReference),e}get running(){return this._dirty}runTask(){const e=this._get("renderLocation"),r=this.centerOnSurface.renderLocation,o=this.renderCoordsHelper,s=this.state.contentCamera;this._dirty=!1,o.worldUpAtPosition(r,S);const i=Math.max(0,(Math.acos(a(S,s.viewForward))-.5*Math.PI)*(s.aboveGround?1:-1));if(Number.isNaN(i)){if(!e||!c(e,r)){const e=this._propertiesPool.get("renderLocation");p(e,r),this._set("renderLocation",e)}return j.YIELD}const n=1-t(i/(.5*Math.PI),0,1),h=n*n*n;this._calculateScreenHorizontalEdgeOnSurface(C);const l=this._propertiesPool.get("renderLocation");return d(l,r,C,h),e&&c(e,l)||this._set("renderLocation",l),j.YIELD}_calculateScreenHorizontalEdgeOnSurface(e){const t=this.state.contentCamera,r=t.getRenderCenter(s());if(r[1]=t.aboveGround?t.padding[_.BOTTOM]:t.fullHeight-t.padding[_.TOP],this.estimateSurfaceIntersectionAtRenderPoint(r,e))return e;const o=this.renderCoordsHelper.getAltitude(this.centerOnSurface.renderLocation);if(t.unprojectFromRenderScreen(r,v)){h(v,v,t.eye);const r=l(v,v);if(this.renderCoordsHelper.intersectManifold(f(t.eye,r),o,e))return e}return this.renderCoordsHelper.setAltitude(e,o,t.eye)}updateRenderLocation(){this._dirty=!0}};e([i()],P.prototype,"_dirty",void 0),e([i({constructOnly:!0})],P.prototype,"scheduler",void 0),e([i({constructOnly:!0})],P.prototype,"centerOnSurface",void 0),e([i({constructOnly:!0})],P.prototype,"estimateSurfaceIntersectionAtRenderPoint",void 0),e([i({readOnly:!0})],P.prototype,"updating",null),e([i({readOnly:!0})],P.prototype,"location",null),e([i({readOnly:!0})],P.prototype,"renderLocation",void 0),P=e([n("esri.views.3d.support.pointsOfInterest.Focus")],P);const S=u(),v=u(),C=u();export{P as Focus};
