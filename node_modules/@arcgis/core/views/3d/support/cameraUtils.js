/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as n}from"../../../core/Cyclical.js";import t from"../../../core/Logger.js";import{deg2rad as r,rad2deg as i}from"../../../core/mathUtils.js";import{createResolver as o}from"../../../core/promiseUtils.js";import{g as a,a as l,j as s,c}from"../../../chunks/vec3.js";import{a as u,c as f}from"../../../chunks/vec3f64.js";import{getReferenceEllipsoid as m}from"../../../geometry/ellipsoidUtils.js";import p from"../../../geometry/Point.js";import{projectPointToVector as d,projectVectorToVector as v,projectVectorToPoint as h,project as g}from"../../../geometry/projection.js";import y from"../../../geometry/SpatialReference.js";import{ViewingMode as x}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as R}from"../camera/intersectionUtils.js";import{t as M,c as w}from"../../../chunks/cameraUtilsPlanar.js";import{t as S,c as j}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as T}from"./earthUtils.js";import{getElevationAtPoint as z}from"./ElevationProvider.js";import{isSpatialReferenceSupported as C}from"../../support/spatialReferenceSupport.js";const U=t.getLogger("esri.views.3d.support.cameraUtils"),P=39.37,b=96,A=1,D=8,H=5,L=1,G=f(),E={heading:0,tilt:0},O=new p,k=new n(-20037508.342788905,20037508.342788905),I=new n(-180,180);var q;function J(e){return e.spatialReference||y.WGS84}function F(e){return"global"===e.viewingMode?j:w}function W(e,n,t,r,i){return F(e).headingTiltToDirectionUp(n,t,r,i)}function X(e,n){if(null==n)return null;const t=e.renderSpatialReference,i=F(e).headingTiltToDirectionUp,o=f();if(!d(n.position,o,t))return null;const s=i(o,n.heading,n.tilt);a(s.direction,s.direction,e.state.camera.distance),l(s.direction,s.direction,o);const c=R(e,o,s.direction,s.up);return c.fov=r(n.fov),c}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(q||(q={}));const K=f();function Y(n,t,r){const o=n.renderSpatialReference,a=Q(n,t.eye,t.viewForward,t.up,E);let l=J(n);return v(t.eye,o,K,l)||(l=y.WGS84,v(t.eye,o,K,l)),null==r?new e(new p(K,l),a.heading,a.tilt,i(t.fov)):(r.position.x=K[0],r.position.y=K[1],r.position.z=K[2],r.position.spatialReference=l,r.heading=a.heading,r.tilt=a.tilt,r.fov=i(t.fov),r)}function N(e,n,t){const i=e.state.camera,o=i.width/2/i.pixelRatio;e.renderCoordsHelper.viewingMode===x.Global&&null!=t&&(n*=Math.cos(r(t))),n/=e.renderCoordsHelper.unitInMeters;return o/(b*P/n)/Math.tan(i.fovX/2)}function V(e,n,t){const i=e.state.camera,o=n*Math.tan(i.fovX/2),a=i.width/2/i.pixelRatio;let l=b*P/(a/o);return e.renderCoordsHelper.viewingMode===x.Global&&null!=t&&(l/=Math.cos(r(t))),l*e.renderCoordsHelper.unitInMeters}function Z(e,n,t,r,i,o){return B(e,n,N(e,t,n.latitude),r,i,o)}function B(e,n,t,r,i,o){if(ye(o)){const a=new ge(o.signal);return te(e,r.heading,r.tilt,n,t,i,a),void a.resolver.promise.then((n=>{const t=pe(e,n,r.fov);if(null!=t)return o.resolver.resolve(t);o.resolver.reject()}),(e=>o.resolver.reject(e)))}const a=te(e,r.heading,r.tilt,n,t,i);return pe(e,a,r.fov,o)}function Q(e,n,t,r,i){return F(e).directionToHeadingTilt(n,t,r,i)}function $(e,n){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(n,O,e.spatialReference)&&e.elevationProvider&&(z(e.elevationProvider,O)??0)>(O.z??0)-L)}async function _(e,n,t){if(!e.renderCoordsHelper.fromRenderCoords(n,O,e.spatialReference)||!e.elevationProvider)return!1;const r=O.z??0;return(await e.elevationProvider.queryElevation(O.x,O.y,r,O.spatialReference,"ground",t)??0)>r-L}async function ee(e,n,t){const r=f();if(n)if(n instanceof p){if(d(n,r,e.renderSpatialReference),null==n.z&&null!=e.basemapTerrain&&null!=e.elevationProvider){const i=await e.elevationProvider.queryElevation(n.x,n.y,n.z??0,n.spatialReference,"ground",t);return null!=i&&e.renderCoordsHelper.setAltitude(r,i),r}}else c(r,n);else c(r,e.state.camera.center);return r}function ne(e,n){const t=f();if(n&&n instanceof p){if(d(n,t,e.renderSpatialReference),null==n.z&&null!=e.basemapTerrain&&null!=e.elevationProvider){const r=z(e.elevationProvider,n);null!=r&&e.renderCoordsHelper.setAltitude(t,r)}}else c(t,n||e.state.camera.center);return t}function te(e,n,t,r,i,o,a){const l=r&&r instanceof p?r:null;if(ye(a))return ee(e,r,a.signal).then((r=>{re(e,n,t,l,r,i,o,a)}),(e=>a.resolver.reject(e))),null;const s=ne(e,r);return re(e,n,t,l,s,i,o,a)}function re(e,n,t,r,i,o,a,l){if(null==r){const n=e.renderSpatialReference;if(null==(r=h(i,n,J(e))))return null}o=Math.max(o,e.state.constraints.minimumPoiDistance);const s=le(e,n,t,i,o,a),c=(0,F(e).eyeForCenterWithHeadingTilt)(i,o,s.heading,s.tilt);if(a===q.ADJUST&&"global"===e.viewingMode&&t>0){const s=()=>{const s=fe(e,i,o,ue(e,o,t,i));return a=t-s<1?q.LOCKED:q.ADJUST,re(e,n,s,r,i,o,a,l)},f=e.map.ground.navigationConstraint;if(!f||"stay-above"===f.type){if($(e,c.eye))return s();if(ye(l))return _(e,c.eye,l.signal).then((e=>e?s():(l.resolver.resolve({eye:c.eye,up:c.up,center:u(i),heading:c.heading,tilt:c.tilt}),null))),null}}const m=!l||ye(l)?{center:f(),eye:f(),up:f(),tilt:0,heading:0}:l;return m.eye=c.eye,m.up=c.up,m.center=u(i),m.heading=c.heading,m.tilt=c.tilt,ye(l)&&l.resolver.resolve(m),m}function ie(e,n,t,r,i,o=null){let a,l,s;if(e.state.isGlobal){if(!C(n.spatialReference,x.Global))return ye(o)&&o.resolver.reject(),null;const e=new p(n.xmin,n.ymin,n.spatialReference),t=new p(n.xmax,n.ymax,n.spatialReference),r=n.spatialReference.isGeographic?I:k;a=new p({x:r.center(e.x,t.x),y:(t.y+e.y)/2,z:null!=n.zmax&&null!=n.zmin?(n.zmax+n.zmin)/2:void 0,spatialReference:n.spatialReference});const i=m(n.spatialReference),c=T(a,e,t);l=c.lon,s=c.lat,r.diff(e.x,t.x)>r.range/2&&(l+=i.halfCircumference),l=Math.min(l,i.halfCircumference),s=Math.min(s,i.halfCircumference)}else{const t=e.renderSpatialReference??n.spatialReference;t.equals(n.spatialReference)||(n=g(n,t)),l=n.xmax-n.xmin,s=n.ymax-n.ymin;const r=null!=n.zmax&&null!=n.zmin?(n.zmax+n.zmin)/2:void 0;a=new p({x:n.xmin+.5*l,y:n.ymin+.5*s,z:r,spatialReference:t})}const c=null!=n.zmax&&null!=n.zmin?n.zmax-n.zmin:0,u=e.state.camera,f=1/Math.tan(u.fovX/2),d=1/Math.tan(u.fovY/2),v=1/Math.tan(u.fov/2),h=Math.max(.5*l*f,.5*s*d,.5*c*v)/A;if(ye(o)){const n=new ge(o.signal);return te(e,t,r,a,h,i,n),void n.resolver.promise.then((n=>{const t=pe(e,n,e.camera.fov);if(null!=t)return o.resolver.resolve(t);o.resolver.reject()}),(e=>o.resolver.reject(e)))}const y=te(e,t,r,a,h,i);return pe(e,y,e.camera.fov,o)}function oe(e,n,t){const r=e.renderSpatialReference,i=h(t,r,J(e));if(null==i)return null;const o=Math.tan(n.fovX/2),a=Math.tan(n.fovY/2),l=s(n.eye,t),c=2*l*o*A,u=2*l*a*A;return"global"===e.viewingMode?S(e,i,c,u):M(e,i,c,u)}function ae(e,n,t){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(t/r)/Math.LN2>D)return!0;const i=e.renderSpatialReference,o=J(e),a=h(n,i,o),l=h(e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation,i,o);if(null==a||null==l)return!1;const s=Math.tan(.5*e.state.camera.fov)*r;return l.distance(a)/s>H}function le(e,n,t,r,i,o){let a=0;return o===q.ADJUST&&ae(e,r,i)?(n=0,a=ce(e,i,t,r)):a=me(e,r,i,t),a=e.state.constraints.clampTilt(i,a),{heading:n,tilt:t=fe(e,r,i,a)}}const se=.7;function ce(e,n,t,r){const i=me(e,r,n,t);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(n);o.max=Math.min(o.max,.5*Math.PI);const a=o.min*(1-se)+o.max*se;return Math.min(i,a)}function ue(e,n,t,r){let i=me(e,r,n,t);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(n);return i=Math.min(i,.5*Math.PI),o.min*(1-se)+i*se}function fe(e,n,t,r){return F(e).lookAtTiltToEyeTilt(r,n,t)}function me(e,n,t,r){return F(e).eyeTiltToLookAtTilt(r,n,t)}function pe(n,t,r,i){if(null==t)return null;const o=n.renderSpatialReference,a=h(t.eye,o,J(n));return null==a?null:null!=i?(i.position=a,i.heading=t.heading,i.tilt=t.tilt,i.fov=r,i):new e(a,t.heading,t.tilt,r)}function de(e,n){const t=e.basemapTerrain?.tilingScheme;if(t)return t.levelAtScale(n);U.error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function ve(e,n){const t=e.basemapTerrain?.tilingScheme;if(t)return t.scaleAtLevel(n);U.error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}function he(e,n){return v(n.center,e.renderSpatialReference,G,y.WGS84),V(e,n.distance,G[1])}class ge{constructor(e){this.signal=e,this.resolver=o()}}function ye(e){return e&&"resolver"in e}export{ge as AsyncContext,q as OrientationMode,he as computeScale,Q as directionToHeadingTilt,V as distanceToScale,X as externalToInternal,B as fromCenterDistance,Z as fromCenterScale,ie as fromExtent,te as getObserverForPointAtDistance,W as headingTiltToDirectionUp,Y as internalToExternal,pe as observerToCamera,N as scaleToDistance,de as scaleToZoom,oe as toExtent,ve as zoomToScale};
