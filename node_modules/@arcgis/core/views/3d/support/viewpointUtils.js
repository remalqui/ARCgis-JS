/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import"../../../geometry.js";import t from"../../../Graphic.js";import n from"../../../Viewpoint.js";import{result as r}from"../../../core/asyncUtils.js";import"../../../core/has.js";import{cyclicalDegrees as a}from"../../../core/Cyclical.js";import o from"../../../core/Error.js";import{eachAlways as i}from"../../../core/promiseUtils.js";import{f as s,t as c}from"../../../chunks/mat3.js";import{c as l}from"../../../chunks/mat3f64.js";import{c as m}from"../../../chunks/mat4f64.js";import{g as u,a as f,i as p,c as g,b as h,s as y,t as d}from"../../../chunks/vec3.js";import{c as x}from"../../../chunks/vec3f64.js";import{projectVectorToPoint as w,projectPointToVector as v,projectBuffer as b,computeTranslationToOriginAndRotation as j,projectVectorToVector as R}from"../../../geometry/projection.js";import{create as G,empty as z,center as S,toRect as B,isPoint as k,expandWithVec3 as M,expandWithAABB as A,width as F,height as T,depth as E}from"../../../geometry/support/aaBoundingBox.js";import{create as U,isPoint as Z}from"../../../geometry/support/aaBoundingRect.js";import{intersectsPoint as D}from"../../../geometry/support/frustum.js";import{getResolutionInMetersForScale as O}from"../../../geometry/support/scaleUtils.js";import{project as C,canProject as P}from"../../../geometry/support/webMercatorUtils.js";import{cameraOnContentAlongViewDirection as I}from"../camera/intersectionUtils.js";import{internalToExternal as J,OrientationMode as K,scaleToDistance as L,fromCenterDistance as N,fromExtent as V,externalToInternal as W,computeScale as Y,AsyncContext as $,distanceToScale as q,fromCenterScale as X,directionToHeadingTilt as _,zoomToScale as H}from"./cameraUtils.js";import{getElevationAtPoint as Q}from"./ElevationProvider.js";import ee from"../../../geometry/Point.js";import te from"../../../geometry/SpatialReference.js";import ne from"../../../geometry/Extent.js";import re from"../../../geometry/Geometry.js";const ae=.66;function oe(e){return 360-a.normalize(e)}function ie(e){return a.normalize(360-e)}function se(e){return null!=e&&e.resolver&&e.resolver.reject(),null}function ce(e,t){return null!=e&&e.resolver&&e.resolver.resolve(t),t}function le(e,t,n,r=null){if(!t)return se(r);const a=e.spatialReference||te.WGS84;if(null!=t.camera){const e=C(t.camera.position,a);if(null==e)return se(r);const n=t.camera.clone();return n.position=e.clone(),ce(r,n)}if(null==t.targetGeometry)return se(r);const o=t.get("targetGeometry.spatialReference");if(o&&!P(o,a))return se(r);const i=J(e,e.state.camera);let s=K.ADJUST;if(null!=t.rotation&&(i.heading=oe(t.rotation),s=K.LOCKED),null!=n&&(i.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const o=t.targetGeometry.clone();return a=null!=t.scale?L(e,t.scale,n.latitude):e.state.camera.distance,N(e,o,a,i,s,r)}const c=t.targetGeometry.extent;return c?V(e,c,i.heading,i.tilt,s,r):se(r)}function me(e,t,r=null){return null==r&&(r=new n),he(e,null,t.clone(),r)}async function ue(t,r,a){const i=ke(t,r);if(!i)throw new o("viewpointutils-create:no-target","Missing target for creating viewpoint");const s=new e({fov:t.camera.fov}),c=new n({camera:s});if(i.target instanceof n){return Me(await we(t,i.target,i,a,c))}if(i.target instanceof e)return Me(ve(t,i.target,c));const l=null!=i.scale||null!=i.zoom;if(i.target instanceof ne){const e=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return Me(l||e?await je(t,i,i.target.center,s,a,c):await ze(t,i,i.target,s,a,c))}const m={boundingBox:z(),hasZ:!1,screenSpaceObjects:[]},u=l?pe(t,i):void 0;if(await xe(t,i.target,u,m),isFinite(m.boundingBox[0])){let e;if(S(m.boundingBox,Fe),Ie.x=Fe[0],Ie.y=Fe[1],Ie.z=Fe[2],Ie.spatialReference=t.spatialReference,isFinite(Ie.z)&&m.hasZ?e=k(m.boundingBox):(Ie.z=void 0,e=Z(B(m.boundingBox,Ze))),l||e)return Me(await je(t,i,Ie,s,a,c));const n=Ae(t,m.screenSpaceObjects);return Me(await Be(t,i,Ie,m.boundingBox,n,s,a,c))}return i.position?Me(Re(t,i,s,c)):Me(await Ge(t,i,s,a,c))}function fe(e,t){return null==t.scale&&null!=t.zoom?H(e,t.zoom):t.scale}function pe(e,t){const n=fe(e,t);return n?O(n):void 0}function ge(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=oe(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function he(e,t,n,r){const a=e.spatialReference||te.WGS84;return null==(t=null!=t?t:W(e,n))||(r.targetGeometry=w(t.center,e.renderSpatialReference,a),r.scale=Y(e,t),r.rotation=ie(n.heading),r.camera=n),r}function ye(e,t,n){const r=()=>new o("viewpointutils:invalid-geometry","The target is missing a valid geometry");if(!t)throw r();if(!P(t.spatialReference,e.spatialReference))throw new o("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference?.wkid})`,{geometry:t});const a=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent?.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&null!=e.basemapTerrain.spatialReference&&P(n,e.basemapTerrain.spatialReference)&&e.elevationProvider?Fe[2]=Q(e.elevationProvider,n)??0:Fe[2]=0}(0,Je[t.type])(t,(e=>{a.push(e[0],e[1],e[2])}),Fe);const i=a.length/3;if(0===i)throw r();const s=new Array(a.length);if(b(a,t.spatialReference,0,s,e.spatialReference,0,i)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<s.length;e+=3)t.hasZ?(Fe[0]=s[e],Fe[1]=s[e+1],Fe[2]=s[e+2]):(Fe[0]=s[e],Fe[1]=s[e+1]),M(n.boundingBox,Fe)}}async function de(e,t,n,a){const o=await r(e.whenViewForGraphic(t));if(!1===o.ok||null==o.value||!("whenGraphicBounds"in o.value))return void ye(e,t.geometry,a);const i=o.value,s=await r(i.whenGraphicBounds(t,{minDemResolution:n}));if(!1===s.ok)return void ye(e,t.geometry,a);const{screenSpaceObjects:c,boundingBox:l}=s.value;A(a.boundingBox,l),c&&c.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(l[2])&&(a.hasZ=!0)}async function xe(e,n,r,a){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return Ie.x=t,Ie.y=r,Ie.z=void 0,Ie.spatialReference=e.spatialReference?.isGeographic?e.spatialReference:te.WGS84,void ye(e,Ie,a)}n&&"map"in n&&"function"==typeof n.map?await i(n.map((t=>xe(e,t,r,a)))):n instanceof re?ye(e,n,a):n instanceof t&&await de(e,n,r,a)}async function we(e,t,n,r,a){if(null!=t.camera)return ve(e,t.camera,a);a.scale=t.scale,a.rotation=t.rotation,a.targetGeometry=null!=t.targetGeometry?t.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=ie(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const o=fe(e,n);null!=o&&(a.scale=o);const i=new $(r);return le(e,a,n.tilt,i),a.camera=await i.resolver.promise,a}function ve(e,t,n){const r=e.spatialReference,a=C(t.position,r);return null==a?null:((t=t.clone()).fov=e.camera.fov,t.position=a,he(e,null,t,n))}function be(e,t,n,r,a,o){const i=e.renderSpatialReference;return v(n,Oe,i),v(t,Ce,i),o.targetGeometry=new ee(t),a.position=new ee(n),h(De,Ce,Oe),_(e,Oe,De,r.up,a),o.scale=q(e,p(Oe,Ce),o.targetGeometry.latitude),o.rotation=ie(a.heading),o.camera=a,o}async function je(e,t,n,r,a,i){if(null==n)throw new o("createfromcenter","invalid point");i.targetGeometry=n.clone();const s=I(e);if(t.position)return be(e,i.targetGeometry,t.position,s,r,i);if(t.zoomFactor){const r=s.distance/t.zoomFactor,a=u(Fe,s.viewForward,-r);s.eye=f(Fe,s.center,a),i.scale=q(e,r,n.latitude)}J(e,s,r);const c=ge(r,t)?K.LOCKED:K.ADJUST;if(!t.zoomFactor){const o=fe(e,t);null==o?(v(n,Fe,e.renderSpatialReference),D(s.frustum,Fe)?i.scale=q(e,p(s.eye,Fe),n.latitude):i.scale=Y(e,s)):i.scale=o;const l=new $(a);X(e,i.targetGeometry,i.scale,r,c,l),i.camera=await l.resolver.promise}return i}function Re(e,t,n,r){const a=I(e);return g(De,a.viewForward),_(e,a.eye,De,a.up,Pe),n.position=new ee(t.position),n.heading=null!=t.heading?t.heading:Pe.heading,n.tilt=null!=t.tilt?t.tilt:Pe.tilt,he(e,null,n,r)}async function Ge(e,t,n,r,a){const o=I(e);return je(e,t,w(o.center,e.renderSpatialReference,e.spatialReference),n,r,a)}async function ze(e,t,n,r,a,o){o.targetGeometry=n.clone();const i=I(e);J(e,i,r);const s=ge(r,t)?K.LOCKED:K.ADJUST,c=new $(a);return V(e,n,r.heading,r.tilt,s,c),o.camera=await c.resolver.promise,o}function Se(e,t,n,r,a){let o=0;null!=n.z?o=n.z:e.basemapTerrain&&e.elevationProvider&&(o=Q(e.elevationProvider,n)),y(Fe,n.x,n.y,o),j(e.spatialReference,Fe,Te,e.renderSpatialReference),s(Ee,Te),c(Ee,Ee),z(Ue);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let s=0;s<i.length;s++){const t=i[s];let n=r[t[2]];isFinite(n)||(n=o),y(Fe,r[t[0]],r[t[1]],n),R(Fe,e.spatialReference,Fe,e.renderSpatialReference),M(Ue,d(Fe,Fe,Ee))}const l=F(Ue),m=T(Ue),u=E(Ue),f=1/Math.tan(t.fovX/2),p=1/Math.tan(t.fovY/2),g=.5*Math.sqrt(l*l+u*u)*Math.max(p,f)+.5*m,h=.5*m*p+.5*Math.max(l,u);return Math.max(g,h)/a}async function Be(e,t,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=I(e),l=Se(e,c,n,r,a);J(e,c,o);const m=ge(o,t)?K.LOCKED:K.ADJUST;s.scale=q(e,l,s.targetGeometry.latitude);const u=new $(i);return X(e,s.targetGeometry,s.scale,o,m,u),s.camera=await u.resolver.promise,s}function ke(e,t){if(!t||!e.spatialReference)return null;const n={target:void 0};return"declaredClass"in t||Array.isArray(t)?n.target=t:(Object.assign(n,t),t.center&&!n.target&&(n.target=t.center)),n}function Me(e){return e&&null!=e.camera&&(e.rotation=ie(e.camera.heading)),e}function Ae(e,t){const n=ae;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a++){const e=t[a].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const Fe=x(),Te=m(),Ee=l(),Ue=G(),Ze=U(),De=x(),Oe=x(),Ce=x(),Pe={heading:0,tilt:0},Ie=new ee,Je={point(e,t,n){n[0]=e.x,n[1]=e.y,null!=e.z&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const o=e.rings[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const o=e.paths[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let o=0;o<r.length;o++)n[0]=r[o][0],n[1]=r[o][1],a&&(n[2]=r[o][2]),t(n)},extent(e,t,n){null!=e.zmin&&null!=e.zmax?(t(y(n,e.xmin,e.ymin,e.zmin)),t(y(n,e.xmax,e.ymin,e.zmin)),t(y(n,e.xmin,e.ymax,e.zmin)),t(y(n,e.xmax,e.ymax,e.zmin)),t(y(n,e.xmin,e.ymin,e.zmax)),t(y(n,e.xmax,e.ymin,e.zmax)),t(y(n,e.xmin,e.ymax,e.zmax)),t(y(n,e.xmax,e.ymax,e.zmax))):(t(y(n,e.xmin,e.ymin,n[2])),t(y(n,e.xmax,e.ymin,n[2])),t(y(n,e.xmin,e.ymax,n[2])),t(y(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let a=0;a<r.length;a+=3)t(y(n,r[a],r[a+1],r[a+2]))}};export{ue as create,me as fromCamera,ie as headingToRotation,oe as rotationToHeading,le as toCamera};
