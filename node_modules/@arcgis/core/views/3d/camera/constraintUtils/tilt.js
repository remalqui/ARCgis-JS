/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{neverReached as e}from"../../../../core/compilerUtils.js";import{clamp as t,acosClamped as n,asinClamped as r,deg2rad as i}from"../../../../core/mathUtils.js";import{d as s}from"../../../../chunks/mat4.js";import{c as a}from"../../../../chunks/mat4f64.js";import{b as o,m as c,g as u,a as l,i as m,e as d,n as f,l as p,p as y}from"../../../../chunks/vec3.js";import{c as h}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as M}from"../../../../geometry/ellipsoidUtils.js";import{b as C,e as T,t as I}from"../../../../chunks/sphere.js";import{defaultConstraintOptions as O,hasConstraintType as A,adjustRangeForInteraction as D}from"./common.js";import{ConstraintTypes as S}from"./ConstraintTypes.js";import{InteractionType as R}from"./InteractionType.js";import{TiltMode as w}from"./TiltMode.js";import{viewAngle as j}from"../../state/utils/viewUtils.js";function x(t,n,r=O,i=!0){V.eyeCenterDistance=0,V.requiresTwoSteps=!1;const a=U(t,n,r,void 0,V);if(0===a)return!1;switch(s(_,-a,n.viewRight),r.tiltMode){case w.LOOK_AROUND:c(K,n.viewForward,_),u(K,K,V.eyeCenterDistance),n.center=l(z,n.eye,K);break;case w.TUMBLE:o(K,n.center,n.eye),c(K,K,_),n.eye=o(z,n.center,K);break;default:e(r.tiltMode)}return n.up=c(z,n.up,_),!V.requiresTwoSteps||!i||x(t,n,r,!1)}function U(e,t,n=O,r=O,i){if(!e.state.constraints.tilt)return 0;const s=t.distance,a=e.state.constraints.tilt(s,J);return N(e,n,a),r.interactionType===R.TUMBLE&&A(r.selection,S.ALTITUDE)&&B(e,r.interactionStartCamera,a),n.tiltMode===w.LOOK_AROUND||r.tiltMode===w.LOOK_AROUND?L(e,t,a,i):P(e,t,a)}function P(e,n,r){const i=j(e.renderCoordsHelper,n.center,n.eye),s=i-t(i,r.min,r.max);return k(s)?s:0}function L(e,t,n,r){switch(r&&(r.requiresTwoSteps=!1),e.viewingMode){case"global":return v(e,t,n,r);case"local":return q(e,t,n,r)}}function q(e,n,r,i){const s=j(e.renderCoordsHelper,n.center,n.eye),a=t(s,r.min,r.max),o=s-a;if(!k(o))return 0;if(i){const t=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,r=e.renderCoordsHelper.getAltitude(n.eye)-t,s=Math.cos(a);Math.abs(s)>1e-4?i.eyeCenterDistance=r/s:i.eyeCenterDistance=n.distance}return o}function v(e,n,r,i){const s=b(e,n,Q),a=t(s.tiltAtCenter,r.min,r.max);if(!k(s.tiltAtCenter-a))return 0;let o,c;return s.centerIsOnSurface?(o=H(s),c=E(s,o)):(o=s.constraints.clampTilt(s.eyeCenterDistance,s.tiltAtCenter),i&&o<Math.PI/2&&(i.requiresTwoSteps=!0,o=Math.PI/2-1e-5),c=F(s,o)),i&&(i.eyeCenterDistance=g(s,o)),c}function b(e,t,r){const i=e.pointsOfInterest.centerOnSurfaceFrequent.estimatedSurfaceAltitude,s=i+M(e.spatialReference).radius,a=e.renderCoordsHelper.intersectManifold(t.ray,i,z);return r.eyeCenterDistance=t.distance,r.centerIsOnSurface=!1,null!=a?(r.eyeCenterDistance=m(t.eye,a),r.tiltAtCenter=j(e.renderCoordsHelper,a,t.eye),r.centerIsOnSurface=!0):e.state.isLocal?r.tiltAtCenter=j(e.renderCoordsHelper,t.center,t.eye):(C(T(I,s),t.ray,z),r.eyeCenterDistance=m(t.eye,z),r.tiltAtCenter=n(-d(t.viewForward,f(z,z)))),r.radius=s,r.eyeRadius=p(t.eye),r.constraints=e.state.constraints,r}function k(e){return Math.abs(e)>1e-9}function H(e){const{constraints:t,eyeCenterDistance:n,tiltAtCenter:r}=e;let i=r,s=t.clampTilt(n,r);const a=g(e,s);if(t.clampTilt(a,r)===s)return s;let o=0;for(;o<10&&k(s-i);){const n=(i+s)/2,r=g(e,n);k(t.clampTilt(r,n)-n)?i=n:s=n,o++}return s}function g(e,n){if(!e.centerIsOnSurface)return e.eyeCenterDistance;const i=Math.PI-t(n,0,Math.PI),s=r(e.radius/e.eyeRadius*Math.sin(i)),a=Math.PI-i-s,o=Math.sin(a)/Math.sin(i);if(e.eyeRadius<e.radius&&o>1){const t=Math.PI-s,n=Math.PI-i-t;return Math.sin(n)/Math.sin(i)*e.eyeRadius}return o*e.eyeRadius}function E(e,t){const n=r(e.radius/e.eyeRadius*Math.sin(e.tiltAtCenter)),i=r(e.radius/e.eyeRadius*Math.sin(t));return e.eyeRadius>e.radius?n-i:i-n}function F(e,t){return e.tiltAtCenter-Math.PI/2-(t-Math.PI/2)}function N(e,t,n){if(t.interactionType===R.NONE)return;const{interactionStartCamera:r,interactionFactor:i}=t;if(!r)return;const{min:s,max:a}=n,o=U(e,r,O,t),c=0===o?0:j(e.renderCoordsHelper,r.center,r.eye);n.min=s,n.max=a,t.interactionType===R.TUMBLE?(A(t.selection,S.ALTITUDE)&&B(e,r,n),D(o,c,!0,i,G,n)):D(o,c,!1,i,G,n)}function B(e,t,r){const i=e.state.constraints;if(e.state.isLocal||!i.altitude||!t)return;const s=y(t.center),a=Math.sqrt(s),o=t.distance,c=M(e.spatialReference).radius,u=i.altitude.min+c,l=i.altitude.max+c,m=(u*u-o*o-s)/(-2*a*o),d=(l*l-o*o-s)/(-2*a*o);r.min=Math.max(r.min,Math.min(Math.PI-n(d),r.max)),r.max=Math.min(r.max,Math.PI-n(m))}const K=h(),_=a(),z=h(),G=i(5),J={min:0,max:0},Q={constraints:null,radius:0,eyeRadius:0,centerIsOnSurface:!0,eyeCenterDistance:0,tiltAtCenter:0},V={eyeCenterDistance:0,requiresTwoSteps:!1};export{x as applyTiltConstraint,U as getTiltConstraintError};
