/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{b as o}from"../../../../../../chunks/mat3.js";import{c as r}from"../../../../../../chunks/mat3f64.js";import{I as e}from"../../../../../../chunks/mat4f64.js";import{addNearFar as t}from"../ForwardLinearDepth.glsl.js";import{ShaderOutput as i}from"../ShaderOutput.js";import{SliceDraw as a}from"../Slice.glsl.js";import{Transform as s}from"../Transform.glsl.js";import{NormalAttribute as l,NormalType as d}from"../attributes/NormalAttribute.glsl.js";import{ObjectAndLayerIdColor as n}from"../attributes/ObjectAndLayerIdColor.glsl.js";import{TextureCoordinateAttribute as m}from"../attributes/TextureCoordinateAttribute.glsl.js";import{VertexNormal as c}from"../attributes/VertexNormal.glsl.js";import{OutputDepth as u}from"../output/OutputDepth.glsl.js";import{OutputHighlight as p}from"../output/OutputHighlight.glsl.js";import{VisualVariables as v}from"../shading/VisualVariables.glsl.js";import{DiscardOrAdjustAlphaPass as f}from"../util/AlphaDiscard.glsl.js";import{addProjViewLocalOrigin as h}from"../util/View.glsl.js";import{glsl as g}from"../../shaderModules/interfaces.js";import{Matrix3PassUniform as x}from"../../shaderModules/Matrix3PassUniform.js";import{Matrix4PassUniform as j}from"../../shaderModules/Matrix4PassUniform.js";import{Texture2DPassUniform as w}from"../../shaderModules/Texture2DPassUniform.js";import{AlphaDiscardMode as T}from"../../../lib/basicInterfaces.js";function b(b,C){const{vertex:O,fragment:y}=b,V=C.hasModelTransformation;if(V){const t=r();O.uniforms.add(new j("model",(o=>o.modelTransformation??e))),O.uniforms.add(new x("normalTransform",(r=>(o(t,r.modelTransformation??e),t))))}const A=C.hasColorTexture&&C.alphaDiscardMode!==T.Opaque;switch(C.output){case i.Depth:case i.Shadow:case i.ShadowHighlight:case i.ShadowExcludeHighlight:case i.ObjectAndLayerIdColor:h(O,C),b.include(s,C),b.include(m,C),b.include(v,C),b.include(u,C),b.include(a,C),b.include(n,C),t(b),b.varyings.add("depth","float"),A&&y.uniforms.add(new w("tex",(o=>o.texture))),O.code.add(g`
          void main(void) {
            vpos = calculateVPos();
            ${V?"vpos = (model * vec4(vpos, 1.0)).xyz;":""}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
            forwardTextureCoordinates();
            forwardObjectAndLayerIdColor();
          }
        `),b.include(f,C),y.code.add(g`
          void main(void) {
            discardBySlice(vpos);
            ${A?g`
                    vec4 texColor = texture(tex, ${C.hasColorTextureTransform?g`colorUV`:g`vuv0`});
                    discardOrAdjustAlpha(texColor);`:""}
            ${C.output===i.ObjectAndLayerIdColor?g`outputObjectAndLayerIdColor();`:g`outputDepth(depth);`}
          }
        `);break;case i.Normal:{h(O,C),b.include(s,C),b.include(l,C),b.include(c,C),b.include(m,C),b.include(v,C),A&&y.uniforms.add(new w("tex",(o=>o.texture))),C.normalType===d.ScreenDerivative&&b.varyings.add("vPositionView","vec3");const o=C.normalType===d.Attribute||C.normalType===d.Compressed;O.code.add(g`
          void main(void) {
            vpos = calculateVPos();
            ${V?"vpos = (model * vec4(vpos, 1.0)).xyz;":""}

            ${o?g`vNormalWorld = ${V?"normalize(normalTransform * dpNormal(vvLocalNormal(normalModel())))":"dpNormalView(vvLocalNormal(normalModel()))"};`:g`
                  // Get vertex position in camera space for screen-space derivative normals
                  vPositionView = (view * vec4(vpos, 1.0)).xyz;
                `}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `),b.include(a,C),b.include(f,C),y.code.add(g`
          void main() {
            discardBySlice(vpos);
            ${A?g`
                    vec4 texColor = texture(tex, ${C.hasColorTextureTransform?g`colorUV`:g`vuv0`});
                    discardOrAdjustAlpha(texColor);`:""}

            ${C.normalType===d.ScreenDerivative?g`vec3 normal = screenDerivativeNormal(vPositionView);`:g`
                  vec3 normal = normalize(vNormalWorld);
                  if (gl_FrontFacing == false){
                    normal = -normal;
                  }`}
            fragColor = vec4(0.5 + 0.5 * normal, 1.0);
          }
        `);break}case i.Highlight:h(O,C),b.include(s,C),b.include(m,C),b.include(v,C),A&&y.uniforms.add(new w("tex",(o=>o.texture))),O.code.add(g`
          void main(void) {
            vpos = calculateVPos();
            ${V?"vpos = (model * vec4(vpos, 1.0)).xyz;":""}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `),b.include(a,C),b.include(f,C),b.include(p,C),y.code.add(g`
          void main() {
            discardBySlice(vpos);
            ${A?g`
                    vec4 texColor = texture(tex, ${C.hasColorTextureTransform?g`colorUV`:g`vuv0`});
                    discardOrAdjustAlpha(texColor);`:""}
            outputHighlight();
          }
        `)}}export{b as DefaultMaterialAuxiliaryPasses};
