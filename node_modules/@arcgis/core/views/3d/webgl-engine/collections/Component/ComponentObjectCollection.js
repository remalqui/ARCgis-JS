/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import has from"../../../../../core/has.js";import e from"../../../../../core/Logger.js";import{applySome as t}from"../../../../../core/maybe.js";import o from"../../../../../core/PooledArray.js";import{isArray as n}from"../../../../../core/typedArrayUtil.js";import{e as r,t as i}from"../../../../../chunks/mat3.js";import{c as s}from"../../../../../chunks/mat3f32.js";import{d as a,w as c,t as m}from"../../../../../chunks/vec3.js";import{a as l,c as f}from"../../../../../chunks/vec3f64.js";import{compactIndices as p}from"../../../../../geometry/support/Indices.js";import{b as h}from"../../../../../chunks/vec32.js";import{c as u}from"../../../../../chunks/vec33.js";import{ViewingMode as b}from"../../../../ViewingMode.js";import{ColorMixModeEnum as g,encodeSymbolColor as d}from"../../../layers/support/symbolColorUtils.js";import{clone as y,computeOffsetObb as j,radius as C}from"../../../support/orientedBoundingBox.js";import{glLayout as v}from"../../../support/buffer/glUtil.js";import{newLayout as _}from"../../../support/buffer/InterleavedLayout.js";import w from"./ComponentData.js";import{State as M,ComponentObject as O}from"./ComponentObject.js";import x from"./IntersectionGeometry.js";import{Renderable as A}from"./Renderable.js";import{RenderGeometry as D}from"./RenderGeometry.js";import{RenderSubmitSystem as S}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as I}from"./SourceGeometry.js";import{UniformComponentParameters as P}from"./UniformComponentParameters.js";import{ComponentParametersVarying as E,ComponentParametersUniform as L,ComponentParameterSummary as R,ComponentMaterial as U}from"./Material/ComponentMaterial.js";import{attributeLocations as B}from"./Material/ComponentTechnique.js";import{encodeElevationOffset as T}from"./Material/shader/ComponentData.glsl.js";import{getVisibility as V,updateVisibilityWithCount as k}from"../../lib/ComponentUtils.js";import{assert as G}from"../../lib/Util.js";import{VertexAttribute as N}from"../../lib/VertexAttribute.js";import{getVerticalOffsetI3S as q}from"../../lib/verticalOffsetUtils.js";import{EdgeInputBufferLayout as H}from"../../lib/edgeRendering/bufferLayouts.js";import{extractComponentsEdgeLocationsLayout as W}from"../../lib/edgeRendering/edgeProcessing.js";import{BufferManager as X}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as Y}from"../../../../webgl/BufferObject.js";import{Usage as z,PrimitiveType as F}from"../../../../webgl/enums.js";import{VertexArrayObject as J}from"../../../../webgl/VertexArrayObject.js";const K=e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class Q{constructor(e,t){this._renderManager=e,this._viewingMode=t,this._objects=[new o,new o],this._renderSubmit=new S(this),this._renderManager.register(this._renderSubmit),this._hasObjectAndLayerId=has("enable-feature:objectAndLayerId-rendering"),this._componentBufferManager=new X(e.rctx,2+(this._hasObjectAndLayerId?1:0))}destroy(){G(0===this._objects[M.Hidden].length&&0===this._objects[M.Visible].length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy();const e=this._objects.flatMap((e=>e.toArray()));for(const t of e)t?.destroy()}createObject(e){const t=new O;return t.toMapSpace=e.toMapSpace,t.transform=e.transform,t.obb=y(e.obb),t.components=new w(this._componentBufferManager,p(e.geometry.componentOffsets)),t.renderable=this._createRenderable(e,t.components),t.intersectionGeometry=new x(e.geometry.positionData,t.components),this._objects[t.visible].push(t),t}destroyObject(e){const t=e;this._objects[t.visible].removeUnordered(t),t.destroy(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(this._objects[o.visible].removeUnordered(o),this._objects[t].push(o),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>e.renderable.meta.cameraDepthSquared=a(t,e.obb.center)))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount();return{visible:o,invisible:t.components.count-o}}setComponentData(e,t){const o=e,n=o.renderable.material,r=o.components,i=r.materialDataBuffer,s=r.materialDataIndices,a=new P,c=i.textureBuffer,m=new Uint8Array(4),l=new Uint32Array(m.buffer);let f=0,p=0,h=0,u=r.verticalOffsets,b=1/0,C=-1/0,v=!1,_=!1,w=0;for(let y=0;y<r.count;y++){t(y,a),f+=+(a.externalColor[3]<1),p+=+(a.externalColorMixMode===g.Replace&&1===a.externalColor[3]),h+=+a.castShadows,d(a.externalColor,a.externalColorMixMode,m),m[2]=254&m[2]|+a.castShadows,c.setData(s[y],0,m[0],m[1],m[2],m[3]),v||=y>0&&w!==l[0],w=l[0],_||=0!==a.elevationOffset,_&&null==u&&(u=new Array(y).fill(0)),null!=u&&(u[y]=a.elevationOffset),b=Math.min(b,a.elevationOffset),C=Math.max(C,a.elevationOffset),T(a.elevationOffset,m),c.setData(s[y],1,m[0],m[1],m[2],m[3]);const e=a.objectAndLayerIdColor;null!=e&&c.setData(s[y],2,e[0],e[1],e[2],e[3]),a.pickable!==V(r.pickability,y)&&(r.pickability=k(r.pickability,r.count,y,a.pickable))}r.verticalOffsets=_?u:null,o.offsetObb=_?j(o.obb,b,C,this._viewingMode,null!=o.offsetObb?o.offsetObb:y(o.obb)):null,v||_||this._hasObjectAndLayerId?(n.componentParameters=new E,n.componentParameters.castShadows=$(h,r.count),n.componentParameters.transparent=$(f,r.count),n.componentParameters.opaqueOverride=$(p,r.count),n.componentParameters.texture=c,c.updateTexture()):(n.componentParameters=new L,n.componentParameters.castShadows=a.castShadows?R.All:R.None,n.componentParameters.externalColor=a.externalColor,n.componentParameters.externalColorMixMode=a.externalColorMixMode),this._notifyDirty()}getComponentAabb(e,t,o,n=!1){e.intersectionGeometry.getComponentAabb(t,o);const r=e,i=r.components.verticalOffsets;if(n||null==i)return o;const s=i[t];if(this._viewingMode===b.Local||0===s)return o[2]+=s,o[5]+=s,o;const a=q(s);return a.localOrigin=r.transform.position,a.applyToAabb(o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}intersect(e,t,o,n,s,a){const l=e;null!=s&&(s.localOrigin=l.transform.position);const f=r(ee,l.transform.rotationScale);c(te,t,l.transform.position),c(oe,o,l.transform.position),m(te,te,f),m(oe,oe,f);const p=i(ee,f);return l.intersectionGeometry.intersect(te,oe,n,p,s,l.components.verticalOffsets,a)}addEdges(e,t,o,n){const r=e,{indices:i,positions:s}=r.intersectionGeometry,a=r.components.offsets;return t.addComponentObject(e,r.transform,{center:r.obb.center,radius:C(r.obb)},s,i,a,o,n)}async extractEdgeInformation(e,t,o){const n=e,r=n.components.visibility;if(r.allInvisible())return{buffer:W.createBuffer(0),origin:[0,0,0]};const{indices:i,positions:s}=n.intersectionGeometry,a=n.components.offsets,c=H.createBuffer(s.length/3);u(c.position.typedBuffer,s,c.position.typedBufferStride,3),h(c.position,c.position,n.transform.rotationScale),this._setComponentIndices(c.componentIndex,i,a);const m=c.count,f=this._computeVisibilityIndices(i,r,a,m);return{origin:l(n.transform.position),buffer:await t.extractComponentsEdgeLocations({indices:f,indicesLength:f.length,skipDeduplicate:!0,data:c,writerSettings:{reducedPrecision:!1,variants:0}},o)}}_setComponentIndices(e,t,o){let n=0;for(let r=0;r<o.length-1;r++){const i=o[r],s=o[r+1];for(let o=i;o<s;o++){const r=t?t[o]:o;e.set(r,n)}n++}}_computeVisibilityIndices(e,t,o,r){if(e&&t.allVisible())return e;let i=0;t.forEachComponentRange(((e,t)=>(i+=o[t]-o[e],!0)));const s=n(e)?new Array(i):2===e?.BYTES_PER_ELEMENT||r<=65536?new Uint16Array(i):new Uint32Array(i);let a=0;return t.forEachComponentRange(((t,n)=>{const r=o[t],i=o[n];for(let o=r;o<i;o++)s[a++]=e?e[o]:o;return!0})),s}addComponentHighlight(e,t){const o=e.components;null==o.highlightCounts&&(o.highlightCounts=new Uint32Array(o.count+1));0===o.highlightCounts[t]++&&(o.highlightsDirty(),this._notifyDirty()),o.highlightCounts[o.count]++}removeComponentHighlight(e,t){const o=e.components;if(null==o.highlightCounts)return void K.warn("Removing non-existing highlight.");const n=o.highlightCounts[t],r=o.highlightCounts[o.count];if(0!==n){if(n>1)return o.highlightCounts[t]=n-1,void(o.highlightCounts[o.count]=r-1);o.highlightCounts[t]=0,o.highlightsDirty(),this._notifyDirty(),1===r?o.highlightCounts=null:o.highlightCounts[o.count]=r-1}else K.warn("Removing non-existing highlight.")}clearHighlights(e){const t=e.components;null!=t.highlightCounts&&(t.highlightCounts=null,t.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects[M.Visible]}_createRenderable(e,o){const n=this._renderManager.rctx,r=e.geometry,i=r.vertices.layoutParameters,s=Y.createVertex(n,z.STATIC_DRAW,r.vertices.data),a=t(r.indices,(e=>Y.createIndex(n,z.STATIC_DRAW,e))),c=v(I(i)),m=new Uint16Array(r.vertices.count);for(let t=0;t<o.count;t++){const e=o.offsets[t],n=o.offsets[t+1],i=o.materialDataIndices[t];if(null!=r.indices)for(let t=e;t<n;t++){m[r.indices[t]]=i}else for(let t=e;t<n;t++)m[t]=i}const l=Y.createVertex(n,z.STATIC_DRAW,m.buffer),f=new U(e.transform,e.toMapSpace),p=new J(n,B,{data:c,componentIndices:Z},{data:s,componentIndices:l},a),h=new D(p,F.TRIANGLES,i,null!=a),u={cameraDepthSquared:.5,gpuMemoryEstimate:s.byteLength+l.byteLength+(null!=a?a.byteLength:0)};return new A(f,h,u)}_notifyDirty(){this._renderManager.notifyDirty()}}const Z=v(_().u16(N.COMPONENTINDEX));function $(e,t){return e===t?R.All:0===e?R.None:R.Some}const ee=s(),te=f(),oe=f();export{Q as ComponentObjectCollection};
