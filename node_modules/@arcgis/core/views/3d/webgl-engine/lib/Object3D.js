/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{c as t,m as e,y as i}from"../../../../chunks/mat4.js";import{I as s,c as o}from"../../../../chunks/mat4f64.js";import{h as r,m as a,i as n,s as h,a as m,k as c,c as l}from"../../../../chunks/vec3.js";import{f as d,c as u}from"../../../../chunks/vec3f64.js";import{c as _}from"../../../../chunks/sphere.js";import{maxScale as f}from"../../support/mathUtils.js";import{Object3DState as g}from"./basicInterfaces.js";import{ContentObject as b}from"./ContentObject.js";import{ContentObjectType as p}from"./ContentObjectType.js";import{Object3DStateID as v}from"./Object3DStateID.js";import{assert as j}from"./Util.js";import{addObject3DStateID as y,removeObject3DStateID as S}from"../materials/renderers/utils.js";class V extends b{get geometries(){return this._geometries}get transformation(){return this._transformation??s}set transformation(e){this._transformation=t(this._transformation??o(),e),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}get shaderTransformation(){return this._shaderTransformation??this.transformation}set shaderTransformation(e){this._shaderTransformation=t(this._shaderTransformation??o(),e),this._invalidateBoundingVolume(),this._emit("objectShaderTransformation",this)}clearShaderTransformation(){this._shaderTransformation=void 0,this._invalidateBoundingVolume(),this._emit("objectShaderTransformation",this)}constructor(t={}){super(),this.type=p.Object,this._hasVolatileTransformation=!1,this._parentLayer=null,this._visible=!0,this.castShadow=t.castShadow??!0,this.usesVerticalDistanceToGround=t.usesVerticalDistanceToGround??!1,this.graphicUid=t.graphicUid,this.layerUid=t.layerUid,t.isElevationSource&&(this.lastValidElevationBB=new T),this._geometries=t.geometries?Array.from(t.geometries):new Array}dispose(){this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){j(null==this._parentLayer||null==t,"Object3D can only be added to a single Layer"),this._parentLayer=t}addGeometry(t){t.visible=this._visible,this._geometries.push(t),this._hasVolatileTransformation=this._hasVolatileTransformation||t.hasVolatileTransformation,this._emit("objectGeometryAdded",{object:this,geometry:t}),this._invalidateBoundingVolume()}removeGeometry(t){const e=this._geometries.splice(t,1)[0];e&&(this._emit("objectGeometryRemoved",{object:this,geometry:e}),this._invalidateBoundingVolume())}removeAllGeometries(){for(;this._geometries.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(t){this._emit("objectGeometryUpdated",{object:this,geometry:t}),this._invalidateBoundingVolume()}get visible(){return this._visible}set visible(t){if(this._visible!==t){this._visible=t;for(const t of this._geometries)t.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new v(g.MaskOccludee);for(const e of this._geometries)e.occludees=y(e.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const e of this._geometries)e.occludees=S(e.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new v(g.Highlight);for(const e of this._geometries)e.highlights=y(e.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const e of this._geometries)e.highlights=S(e.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,i){return e(i,this.transformation,t.transformation)}getCombinedShaderTransformation(t,i=o()){return e(i,this.shaderTransformation,t.shaderTransformation)}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._bvWorldSpace&&!this._hasVolatileTransformation||(this._bvWorldSpace=this._bvWorldSpace||new x,this._validateBoundingVolume(this._bvWorldSpace,U.WorldSpace)),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._bvObjectSpace&&!this._hasVolatileTransformation||(this._bvObjectSpace=this._bvObjectSpace||new x,this._validateBoundingVolume(this._bvObjectSpace,U.ObjectSpace)),this._bvObjectSpace}_validateBoundingVolume(t,e){const i=e===U.ObjectSpace;for(const s of this._geometries){const e=s.boundingInfo;e&&O(e,t,i?s.shaderTransformation:this.getCombinedShaderTransformation(s))}r(t.bounds,t.min,t.max,.5);for(const s of this._geometries){const e=s.boundingInfo;if(null==e)continue;const o=i?s.shaderTransformation:this.getCombinedShaderTransformation(s),r=f(o);a(B,e.center,o);const h=n(B,t.bounds),m=e.radius*r;t.bounds[3]=Math.max(t.bounds[3],h+m)}}_invalidateBoundingVolume(){const t=this._bvWorldSpace?.bounds;this._bvObjectSpace=this._bvWorldSpace=void 0,this._parentLayer&&t&&this._parentLayer.notifyObjectBBChanged(this,t)}_emit(t,e){this._parentLayer&&this._parentLayer.events.emit(t,e)}get test(){const t=this;return{hasGeometry:e=>t._geometries.includes(e),getGeometryIndex:e=>t._geometries.indexOf(e)}}}class T{constructor(){this.min=d(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=d(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class x extends T{constructor(){super(...arguments),this.bounds=_()}}function O(t,e,s){const o=t.bbMin,r=t.bbMax;if(i(s)){const t=h(M,s[12],s[13],s[14]);m(A,o,t),m(L,r,t);for(let i=0;i<3;++i)e.min[i]=Math.min(e.min[i],A[i]),e.max[i]=Math.max(e.max[i],L[i])}else if(a(A,o,s),c(o,r))for(let i=0;i<3;++i)e.min[i]=Math.min(e.min[i],A[i]),e.max[i]=Math.max(e.max[i],A[i]);else{a(L,r,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],A[t],L[t]),e.max[t]=Math.max(e.max[t],A[t],L[t]);for(let t=0;t<3;++t){l(A,o),l(L,r),A[t]=r[t],L[t]=o[t],a(A,A,s),a(L,L,s);for(let t=0;t<3;++t)e.min[t]=Math.min(e.min[t],A[t],L[t]),e.max[t]=Math.max(e.max[t],A[t],L[t])}}}const M=u(),A=u(),L=u(),B=u();var U;!function(t){t[t.WorldSpace=0]="WorldSpace",t[t.ObjectSpace=1]="ObjectSpace"}(U||(U={}));export{V as Object3D};
