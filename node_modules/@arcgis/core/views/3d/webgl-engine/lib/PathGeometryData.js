/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{s as t,h as e,e as i,g as s,a as r,i as o}from"../../../../chunks/vec2.js";import{a as n}from"../../../../chunks/vec2f64.js";import{s as a,f as h}from"../../../../chunks/vec3.js";import{c as l}from"../../../../chunks/vec3f64.js";import{f as u}from"../../../../chunks/vec4f64.js";import{newFloatArray as c}from"../../../../geometry/support/FloatArray.js";import{getZeroIndexArray as b}from"../../../../geometry/support/Indices.js";import{Attribute as d}from"./Attribute.js";import{compressNormal as v}from"./Normals.js";import{VertexAttribute as A}from"./VertexAttribute.js";import{intersectTriangles as p}from"../materials/internal/MaterialUtil.js";class m{constructor(t){this.builder=t}onPathChanged(t){this.builder.onPathChanged()}}class x extends m{constructor(t){super(t),this.vertexAttributeColor=u(255,255,255,255),this.size=new Array,this.vertexAttributePosition=c(3*this.builder.numVerticesTotal),this.vertexAttributeNormal=new Int16Array(2*this.builder.numVerticesTotal)}bakeVertexColors(t){this.vertexAttributeColor[0]=255*t[0],this.vertexAttributeColor[1]=255*t[1],this.vertexAttributeColor[2]=255*t[2],this.vertexAttributeColor[3]=255*(t.length>3?t[3]:1)}bake(n){this.size=n;const{numVerticesTotal:l,pathVertexData:u,path:c,positions:b,profileRightAxes:d,profileUpAxes:A,profileVertexAndNormals:p}=this.builder;for(let m=0;m<l;++m){let l=u[m];const x=0===l||l===c.vertices.length-1;l*=3;const I=E;let P=0,V=0;const w=4*m,D=a(C,d[w],d[w+1],d[w+2]),L=a(N,A[w],A[w+1],A[w+2]),T=t(f,p[w]*n[0],p[w+1]*n[1]);if(x)h(I,L,D),P=d[w+3]*n[0],V=A[w+3];else{const n=O,h=R;t(n,d[w+3],A[w+3]);const l=e(n);i(n,n);const u=s(T,n);if(Math.abs(u)>l){t(h,-n[1],n[0]);const e=s(T,h);r(n,n,l*Math.sign(u)),r(h,h,e),o(T,n,h)}a(I,0,0,0)}const j=a(g,D[0]*T[0]+L[0]*T[1],D[1]*T[0]+L[1]*T[1],D[2]*T[0]+L[2]*T[1]),M=3*m;this.vertexAttributePosition[M]=b[l]+j[0]+I[0]*P,this.vertexAttributePosition[M+1]=b[l+1]+j[1]+I[1]*P,this.vertexAttributePosition[M+2]=b[l+2]+j[2]+I[2]*P;const k=t(f,p[w+2],p[w+3]);v(this.vertexAttributeNormal,m,D[0]*k[0]+L[0]*k[1]+I[0]*V,D[1]*k[0]+L[1]*k[1]+I[1]*V,D[2]*k[0]+L[2]*k[1]+I[2]*V)}}createGeometryData(){const t=this.builder.vertexIndices.length;return new P([[A.POSITION,new d(this.vertexAttributePosition,3,!0)],[A.NORMALCOMPRESSED,new d(this.vertexAttributeNormal,2,!0)],[A.COLOR,new d(this.vertexAttributeColor,4)]],[[A.POSITION,this.builder.vertexIndices],[A.NORMALCOMPRESSED,this.builder.normalIndices],[A.COLOR,b(t)]])}onPathChanged(t){super.onPathChanged(t),this.bake(this.size)}intersect(t,e,i){const s=this.builder.vertexIndices,r=new d(this.vertexAttributePosition,3),o=s.length/3;p(t,e,0,o,s,r,void 0,void 0,i)}}class I extends m{constructor(t,e,i,s){super(t),this.sizeAttributeValue=e,this.colorAttributeValue=i,this.opacityAttributeValue=s,this.vvData=null,this.baked=new x(t),this.vvData=c(4*this.builder.path.vertices.length);for(let r=0;r<this.builder.path.vertices.length;++r){this.vvData[4*r]=e,this.vvData[4*r+1]=i,this.vvData[4*r+2]=s;const t=0===r||r===this.builder.path.vertices.length-1;this.vvData[4*r+3]=t?1:0}}createGeometryData(){return new P([[A.POSITION,new d(this.builder.positions,3,!0)],[A.PROFILERIGHT,new d(this.builder.profileRightAxes,4,!0)],[A.PROFILEUP,new d(this.builder.profileUpAxes,4,!0)],[A.PROFILEVERTEXANDNORMAL,new d(this.builder.profileVertexAndNormals,4,!0)],[A.FEATUREVALUE,new d(this.vvData,4,!0)]],[[A.POSITION,this.builder.pathVertexIndices],[A.PROFILERIGHT,this.builder.vertexIndices],[A.PROFILEUP,this.builder.vertexIndices],[A.PROFILEVERTEXANDNORMAL,this.builder.vertexIndices],[A.FEATUREVALUE,this.builder.pathVertexIndices]])}onPathChanged(t){super.onPathChanged(t);const e=t.getMutableAttribute(A.POSITION);e&&(e.data=this.builder.positions)}}class P{constructor(t,e){this.vertexAttributes=t,this.indices=e}}const f=n(),O=n(),R=n(),g=l(),E=l(),C=l(),N=l();export{I as FastUpdatePathGeometry,m as PathGeometryData,x as StaticPathGeometry};
