/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{I as t,b as e}from"../../../../chunks/mat4f64.js";import{m as i}from"../../../../chunks/vec3.js";import{getContinuousIndexArray as s,compactIndices as n}from"../../../../geometry/support/Indices.js";import{cloneAttributeData as r}from"./AttributeArray.js";import{Object3DState as o}from"./basicInterfaces.js";import{BoundingInfo as h}from"./BoundingInfo.js";import{ContentObject as a}from"./ContentObject.js";import{ContentObjectType as u}from"./ContentObjectType.js";import{computeAttachmentOriginTriangles as g,computeAttachmentOriginLines as c,computeAttachmentOriginPoints as l}from"./geometryDataUtils.js";import{Object3DStateID as m}from"./Object3DStateID.js";import{assert as d}from"./Util.js";import{VertexAttribute as f}from"./VertexAttribute.js";import{addObject3DStateID as I,removeObject3DStateID as _}from"../materials/renderers/utils.js";class b extends a{constructor(t,e,i=[],r=null,o=u.Mesh,h=null,a=-1){super(),this.material=t,this.mapPositions=r,this.type=o,this.objectAndLayerIdColor=h,this.edgeIndicesLength=a,this.visible=!0,this._vertexAttributes=new Map,this._indices=new Map,this._boundingInfo=null;for(const[s,n]of e)n&&this._vertexAttributes.set(s,{...n});if(null==i||0===i.length){const t=p(this._vertexAttributes),e=s(t);this.edgeIndicesLength=this.edgeIndicesLength<0?t:this.edgeIndicesLength;for(const i of this._vertexAttributes.keys())this._indices.set(i,e)}else for(const[s,u]of i)u&&(this._indices.set(s,n(u)),s===f.POSITION&&(this.edgeIndicesLength=this.edgeIndicesLength<0?this._indices.get(s).length:this.edgeIndicesLength))}instantiate(t={}){const e=new b(t.material||this.material,[],void 0,this.mapPositions,this.type,this.objectAndLayerIdColor,this.edgeIndicesLength);return this._vertexAttributes.forEach(((t,i)=>{t.exclusive=!1,e._vertexAttributes.set(i,t)})),this._indices.forEach(((t,i)=>e._indices.set(i,t))),e._boundingInfo=this._boundingInfo,e.transformation=t.transformation||this.transformation,e}get vertexAttributes(){return this._vertexAttributes}getMutableAttribute(t){let e=this._vertexAttributes.get(t);return e&&!e.exclusive&&(e={...e,exclusive:!0,data:r(e.data)},this._vertexAttributes.set(t,e)),e}setAttributeData(t,e){const i=this._vertexAttributes.get(t);i&&this._vertexAttributes.set(t,{...i,exclusive:!0,data:e})}get indices(){return this._indices}get indexCount(){const t=this._indices.values().next().value;return t?t.length:0}get faceCount(){return this.indexCount/3}get boundingInfo(){return null==this._boundingInfo&&(this._boundingInfo=this._calculateBoundingInfo()),this._boundingInfo}computeAttachmentOrigin(t){return!!(this.type===u.Mesh?this._computeAttachmentOriginTriangles(t):this.type===u.Line?this._computeAttachmentOriginLines(t):this._computeAttachmentOriginPoints(t))&&(null!=this._transformation&&i(t,t,this._transformation),!0)}_computeAttachmentOriginTriangles(t){const e=this.indices.get(f.POSITION),i=this.vertexAttributes.get(f.POSITION);return g(i,e,t)}_computeAttachmentOriginLines(t){const e=this.vertexAttributes.get(f.POSITION),i=this.indices.get(f.POSITION);return c(e,i,i&&v(this.material.parameters,e,i),t)}_computeAttachmentOriginPoints(t){const e=this.indices.get(f.POSITION),i=this.vertexAttributes.get(f.POSITION);return l(i,e,t)}invalidateBoundingInfo(){this._boundingInfo=null}_calculateBoundingInfo(){const t=this.indices.get(f.POSITION),e=this.vertexAttributes.get(f.POSITION);if(!t||0===t.length||!e)return null;const i=this.type===u.Mesh?3:1;d(t.length%i==0,"Indexing error: "+t.length+" not divisible by "+i);const n=s(t.length/i);return new h(n,i,t,e)}get transformation(){return this._transformation??t}set transformation(i){this._transformation=i&&i!==t?e(i):null}get shaderTransformation(){return null!=this._shaderTransformer?this._shaderTransformer(this.transformation):this.transformation}get shaderTransformer(){return this._shaderTransformer}set shaderTransformer(t){this._shaderTransformer=t}get hasVolatileTransformation(){return null!=this._shaderTransformer}addHighlight(){const t=new m(o.Highlight);return this.highlights=I(this.highlights,t),t}removeHighlight(t){this.highlights=_(this.highlights,t)}}function p(t){const e=t.values().next().value;return null==e?0:e.data.length/e.size}function v(t,e,i){return!(!("isClosed"in t)||!t.isClosed)&&(i?i.length>2:e.data.length>6)}export{b as Geometry};
