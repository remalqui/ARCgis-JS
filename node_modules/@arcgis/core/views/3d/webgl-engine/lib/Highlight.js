/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{releaseMaybe as e,disposeMaybe as r}from"../../../../core/maybe.js";import{s as t}from"../../../../chunks/vec2.js";import{c as i}from"../../../../chunks/vec4.js";import{c as s}from"../../../../chunks/vec4f64.js";import{Default3D as a}from"./DefaultVertexAttributeLocations.js";import{Pos2Tex as o}from"./DefaultVertexBufferLayouts.js";import{createQuadVAO as h}from"./glUtil3D.js";import{VertexArrayObject as l}from"./VertexArrayObject.js";import{HighlightApplyTechnique as p}from"../shaders/HighlightApplyTechnique.js";import{H as u}from"../../../../chunks/HighlightBlur.glsl.js";import{HighlightBlurTechnique as m}from"../shaders/HighlightBlurTechnique.js";import{H as c}from"../../../../chunks/HighlightDownsample.glsl.js";import{HighlightDownsampleTechnique as _}from"../shaders/HighlightDownsampleTechnique.js";import{HighlightPassParameters as n}from"../shaders/HighlightPassParameters.js";import{BufferObject as g}from"../../../webgl/BufferObject.js";import{TextureWrapMode as b,ClearBufferBit as d,PixelFormat as w,PixelType as v,Usage as f,PrimitiveType as T}from"../../../webgl/enums.js";import{FramebufferObject as M}from"../../../webgl/FramebufferObject.js";import{TextureDescriptor as q}from"../../../webgl/TextureDescriptor.js";import{vertexCount as x}from"../../../webgl/Util.js";const P=32;class F{constructor(e,r){this._techniqueRep=e,this._rctx=r,this._viewportToRestore=s(),this._passParameters=new n,this._downsampleDrawParameters=new c,this._blurDrawParameters=new u,this._grid={coverageMipmap:null,vao:null,verticalCellCount:0,horizontalCellCount:0,cellPixelSize:0,mipmapLevels:0,viewportWidth:0,viewportHeight:0}}_assertResources(){if(this._quadVAO)return;this._quadVAO=h(this._rctx);const e=new q;e.wrapMode=b.CLAMP_TO_EDGE,this._blur0Fbo=new M(this._rctx,e),this._blur1Fbo=new M(this._rctx,e),this._blurTechnique=this._techniqueRep.acquire(m),this._downsampleTechnique=this._techniqueRep.acquire(_),this._applyTechnique=this._techniqueRep.acquire(p)}dispose(){if(this._blurTechnique=e(this._blurTechnique),this._downsampleTechnique=e(this._downsampleTechnique),this._applyTechnique=e(this._applyTechnique),this._grid.coverageMipmap)for(let e=1;e<this._grid.coverageMipmap.length;e++)this._grid.coverageMipmap[e].dispose();this._grid.vao&&this._grid.vao.dispose(),this._quadVAO&&(this._quadVAO.dispose(),this._quadVAO=null),this._blur0Fbo=r(this._blur0Fbo),this._blur1Fbo=r(this._blur1Fbo)}setDefaultOptions(e){this._passParameters={...new n,...e}}render(e,r,s){this._passParameters.highlightColorTexture=r.colorTexture,this._assertResources();const a=e.camera;i(this._viewportToRestore,a.fullViewport);const o=a.fullWidth,h=a.fullHeight,l=a.pixelRatio,p=Math.ceil(o/l),u=Math.ceil(h/l);this._blur0Fbo.resize(p,u),this._blur1Fbo.resize(p,u);const m=this._rctx;m.bindVAO(this._quadVAO);let c=null;this._gridUpdateResources(r,P),this._gridComputeMipmap(e),this._passParameters.coverageTexture=this._grid.coverageMipmap[this._grid.mipmapLevels].colorTexture,c=this._grid.vao;const _=m.bindTechnique(this._blurTechnique,this._passParameters,e);m.bindVAO(c),m.bindFramebuffer(this._blur0Fbo),m.setViewport(0,0,p,u),m.setClearColor(0,0,0,0),m.clear(d.COLOR_BUFFER_BIT),this._blurDrawParameters.blurInputTexture=r.colorTexture,t(this._blurDrawParameters.blurSize,1/p,0),_.bindDraw(this._blurDrawParameters,e,this._passParameters),m.drawArrays(this._blurTechnique.primitiveType,0,x(c,"geometry")),m.bindFramebuffer(this._blur1Fbo),m.clear(d.COLOR_BUFFER_BIT),this._blurDrawParameters.blurInputTexture=this._blur0Fbo.colorTexture,t(this._blurDrawParameters.blurSize,0,1/u),_.bindDraw(this._blurDrawParameters,e,this._passParameters),m.drawArrays(this._blurTechnique.primitiveType,0,x(c,"geometry")),m.bindFramebuffer(s),m.setViewport(this._viewportToRestore[0],this._viewportToRestore[1],this._viewportToRestore[2],this._viewportToRestore[3]),this._passParameters.blurColorTexture=this._blur1Fbo.colorTexture,m.bindTechnique(this._applyTechnique,this._passParameters,e),m.drawArrays(this._applyTechnique.primitiveType,0,x(c,"geometry")),m.bindVAO(null)}_gridUpdateResources(e,r){const t=this._rctx,i=this._grid;let s=!1;if(null===i.coverageMipmap&&(i.coverageMipmap=[e],s=!0),i.viewportWidth===e.width&&i.viewportHeight===e.height||(s=!0,i.viewportWidth=e.width,i.viewportHeight=e.height),i.coverageMipmap[0]=e,i.cellPixelSize!==r&&(i.cellPixelSize=r,s=!0),s){for(let e=1;e<i.coverageMipmap.length;e++)i.coverageMipmap[e].dispose();i.mipmapLevels=Math.ceil(Math.log(i.cellPixelSize)*Math.LOG2E),i.coverageMipmap.length=i.mipmapLevels+1;for(let e=0;e<i.mipmapLevels;e++){const r=i.coverageMipmap[e],s=new q(Math.ceil(r.width/2),Math.ceil(r.height/2));s.pixelFormat=w.RGB,s.dataType=v.UNSIGNED_SHORT_5_6_5,s.wrapMode=b.CLAMP_TO_EDGE,i.coverageMipmap[e+1]=new M(t,s)}}const h=Math.ceil(e.height/i.cellPixelSize),p=Math.ceil(e.width/i.cellPixelSize);if(!i.vao||i.verticalCellCount!==h||i.horizontalCellCount!==p){i.verticalCellCount=h,i.horizontalCellCount=p;const e=h+1,r=p+1,s=1/h,u=1/p,m=6,c=4,_=new Float32Array(m*c*e*r);let n=0;for(let t=0;t<e;t++)for(let e=0;e<r;e++)_[n]=(e-.5)*u*2-1,_[n+1]=(t-.5)*s*2-1,_[n+2]=e*u,_[n+3]=t*s,_[n+4]=(e+.5)*u*2-1,_[n+5]=(t-.5)*s*2-1,_[n+6]=e*u,_[n+7]=t*s,_[n+8]=(e-.5)*u*2-1,_[n+9]=(t+.5)*s*2-1,_[n+10]=e*u,_[n+11]=t*s,_[n+12]=(e-.5)*u*2-1,_[n+13]=(t+.5)*s*2-1,_[n+14]=e*u,_[n+15]=t*s,_[n+16]=(e+.5)*u*2-1,_[n+17]=(t-.5)*s*2-1,_[n+18]=e*u,_[n+19]=t*s,_[n+20]=(e+.5)*u*2-1,_[n+21]=(t+.5)*s*2-1,_[n+22]=e*u,_[n+23]=t*s,n+=m*c;i.vao&&i.vao.dispose(),i.vao=new l(t,a,{geometry:o},{geometry:g.createVertex(t,f.STATIC_DRAW,_)})}}_gridComputeMipmap(e){const r=this._rctx,i=this._grid,s=r.bindTechnique(this._downsampleTechnique,this._passParameters,e);r.bindVAO(this._quadVAO);for(let a=0;a<i.mipmapLevels;a++){r.bindFramebuffer(i.coverageMipmap[a+1]);const o=i.coverageMipmap[a+1].width,h=i.coverageMipmap[a+1].height;this._downsampleDrawParameters.inputTexture=i.coverageMipmap[a].colorTexture,t(this._downsampleDrawParameters.invFramebufferDim,1/o,1/h),s.bindDraw(this._downsampleDrawParameters,e,this._passParameters),r.setViewport(0,0,o,h),r.drawArrays(T.TRIANGLE_STRIP,0,x(this._quadVAO,"geometry"))}}get gpuMemoryUsage(){let e=(null!=this._blur0Fbo?this._blur0Fbo.gpuMemoryUsage:0)+(null!=this._blur1Fbo?this._blur1Fbo.gpuMemoryUsage:0);if(this._grid.coverageMipmap)for(const r of this._grid.coverageMipmap)e+=r.gpuMemoryUsage;return e}get test(){return{coverage:this._grid.coverageMipmap,blur:[this._blur0Fbo,this._blur1Fbo]}}}export{F as Highlight};
