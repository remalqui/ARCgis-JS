/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{removeUnordered as e,filterInPlace as t}from"../../../../../core/arrayUtils.js";import{someMap as r}from"../../../../../core/MapUtils.js";import{NestedMap as s}from"../../../../../core/NestedMap.js";import i from"../../../../../core/PooledArray.js";import{m as a,a as o,t as n}from"../../../../../chunks/mat4.js";import{c as l}from"../../../../../chunks/mat4f64.js";import{glLayout as h}from"../../../support/buffer/glUtil.js";import{ShaderOutput as u}from"../../core/shaderLibrary/ShaderOutput.js";import{GLMaterials as f}from"../../lib/GLMaterials.js";import{RenderOccludedFlag as c}from"../../lib/Material.js";import{DirtyState as d}from"../../lib/ModelDirtyTypes.js";import{assert as m,setMatrixTranslation3 as g}from"../../lib/Util.js";import{DrawParameters as p}from"../DrawParameters.js";import{WaterMaterial as y}from"../WaterMaterial.js";import{BufferRange as _,mergeAdjacentRanges as w}from"./BufferRange.js";import{Instance as b}from"./Instance.js";import{PerBufferData as v,hasVao as O}from"./PerBufferData.js";import{PerOriginData as C}from"./PerOriginData.js";import{VaoCache as B}from"./VaoCache.js";class E{constructor(e,t,r){this._rctx=e,this._materialRepository=t,this.material=r,this._dataByOrigin=new Map,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new f(this.material,this._materialRepository),this._bufferWriter=r.createBufferWriter(),this._vaoCache=new B(e,r.vertexAttributeLocations,h(this._bufferWriter.vertexBufferLayout))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach((e=>e.dispose())),this._dataByOrigin.clear(),this._vaoCache.dispose()}get isEmpty(){return 0===this._dataByOrigin.size}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this.material instanceof y}get rendersOccluded(){return!this.isEmpty&&this.material.renderOccluded!==c.Occlude}get numGeometries(){let e=0;return this._dataByOrigin.forEach((t=>e+=t.buffers.reduce(((e,t)=>e+t.instances.size),0))),e}forEachGeometry(e){this._dataByOrigin.forEach((t=>t.buffers.forEach((t=>t.instances.forEach((t=>e(t.geometry)))))))}modify(e){this._updateGeometries(e.updates),this._addAndRemoveGeometries(e.adds,e.removes),this._updateDrawCommands()}_updateGeometries(e){const t=this._bufferWriter,r=t.vertexBufferLayout.stride/4;for(const s of e){const e=s.renderGeometry,i=this._dataByOrigin.get(e.localOrigin.id),a=i?.findBuffer(e.id);if(null==a)return;const o=a.instances.get(e.id);if(s.updateType&(d.GEOMETRY|d.TRANSFORMATION)){const s=W(t.elementCount(o.geometry.geometry)*r),i=t.vertexBufferLayout.createView(s.buffer);this._writeGeometry(e,i,0),a.vao.vertexBuffers.geometry.setSubData(s,o.from*r,0,o.numElements*r),P()}s.updateType&(d.HIGHLIGHT|d.OCCLUDEE|d.VISIBILITY)&&(a.drawCommandsDirty=!0)}}_computeDeltas(e,t){const r=new s;for(const s of e){const e=s.localOrigin;if(null==e)continue;let t=r.get(e.id,null);null==t&&(t=new A(e.vec3),r.set(e.id,null,t)),t.changes.push(s)}for(const s of t){const e=s.localOrigin;if(null==e)continue;const t=this._dataByOrigin.get(e.id),i=t?.findBuffer(s.id);if(null==i)continue;let a=r.get(e.id,i);null==a&&(a=new A(e.vec3),r.set(e.id,i,a)),a.changes.push(s)}return r}_addAndRemoveGeometries(t,r){const{_bufferWriter:s,_dataByOrigin:i}=this,a=s.vertexBufferLayout.stride/4,o=this._computeDeltas(t,r);o.forEach(((t,r)=>{const n=t.get(null),l=null!=n?n.changes:[];o.delete(r,null);let h=i.get(r);if(t.forEach(((t,n)=>{if(o.delete(r,n),null==n)return void m(!1,"No VAO for removed geometries");if(n.instances.size===t.changes.length)return this._vaoCache.deleteVao(n.vao),e(h.buffers,n),void(0===h.buffers.length&&0===l.length&&i.delete(r));const u=n.numElements,f=n.vao.byteSize/4,c=l.reduce(((e,t)=>e+s.elementCount(t.geometry)),0),d=t.changes.reduce(((e,t)=>e+s.elementCount(t.geometry)),0),g=Math.min((u+c-d)*a,G),p=g>f;g>j&&g<f/2?(t.changes.forEach((({id:e})=>n.deleteInstance(e))),n.instances.forEach((({geometry:e})=>l.push(e))),this._vaoCache.deleteVao(n.vao),e(h.buffers,n)):p?this._applyAndRebuild(n,l,t):this._applyRemoves(n,t)})),l.length>0)for(null==h&&(h=new C(n.origin),i.set(r,h)),h.buffers.forEach((e=>this._applyAdds(e,l)));l.length>0;)h.buffers.push(this._applyAndRebuild(new v,l,null))}))}_updateDrawCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((e=>{e.buffers.forEach((e=>{e.drawCommandsDirty&&(e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,r(e.instances,(t=>(e.updateDrawState(t),e.hasHiddenInstances&&e.hasHighlights&&e.hasOccludees))),e.updateDrawCommands(this._bufferWriter.vertexBufferLayout.stride)),this._hasHighlights=this._hasHighlights||e.hasHighlights,this._hasOccludees=this._hasOccludees||e.hasOccludees}))}))}_applyAndRebuild(e,t,r){if(null!=r)for(const d of r.changes)e.deleteInstance(d.id);const s=this._bufferWriter,i=s.vertexBufferLayout.stride,a=i/4,o=Math.floor(G/a);let n=e.numElements;for(;t.length>0;){const r=t.pop(),i=s.elementCount(r.geometry);if(n+i>o&&n>0){t.push(r);break}n+=i;const a=new b(r,0,0);m(null==e.instances.get(r.id)),e.addInstance(r.id,a)}const l=n*a,h=W(l),u=s.vertexBufferLayout.createView(h.buffer);let f=0;e.hasHiddenInstances=!1,e.hasHighlights=!1,e.hasOccludees=!1,e.instances.forEach(((t,r)=>{this._writeGeometry(t.geometry,u,f);const i=f;f+=s.elementCount(t.geometry.geometry),e.updateInstance(r,i,f),e.updateDrawState(t)})),this._vaoCache.deleteVao(e.vao),e.vao=this._vaoCache.newVao(V(l)),e.vao.vertexBuffers.geometry.setSubData(h,0,0,f*a),P(),e.holes.clear();const c=e.holes.pushNew();return c.from=f,c.to=Math.floor(e.vao.byteSize/i),e.updateDrawCommands(i),e}_applyRemoves(e,t){if(0===t.changes.length)return;for(const o of t.changes){const t=o.id,r=e.instances.get(t);if(!r)continue;e.deleteInstance(t);const s=x.back();if(s){if(s.to===r.from){s.to=r.to;continue}if(s.from===r.to){s.from=r.from;continue}}const i=x.pushNew();i.from=r.from,i.to=r.to}w(x);const r=this._bufferWriter.vertexBufferLayout.stride/4,s=x.reduce(((e,t)=>Math.max(e,t.numElements)),0)*r,i=W(s);i.fill(0,0,s);const a=e.vao.vertexBuffers.geometry;x.forAll((e=>a.setSubData(i,e.from*r,0,e.numElements*r))),P(),e.holes.pushArray(x.data,x.length),x.forAll(((e,t)=>x.data[t]=null)),x.clear(),e.drawCommandsDirty=!0}_applyAdds(e,r){if(0===r.length)return;if(!O(e))return void this._applyAndRebuild(e,r,null);const s=this._bufferWriter,i=s.vertexBufferLayout.stride/4,a=e.numElements,o=r.reduce(((e,t)=>e+s.elementCount(t.geometry)),0),n=Math.min((a+o)*i,G),l=4*n;if(e.vao.byteSize<V(G-j)&&l>e.vao.byteSize)return void this._applyAndRebuild(e,r,null);w(e.holes);const h=new Array;for(const t of r){const r=s.elementCount(t.geometry),i=H(e.holes,r);h.push(i)}const u=e.vao.vertexBuffers.geometry;let f=0,c=0,d=0;const g=W(n),p=s.vertexBufferLayout.createView(g.buffer);r.forEach(((t,r)=>{const a=h[r];if(null==a)return;if(!(d===a)){const e=d-c;e>0&&u.setSubData(g,c*i,0,e*i),c=a,f=0}const o=s.elementCount(t.geometry);this._writeGeometry(t,p,f),f+=o,d=a+o;const n=new b(t,a,a+o);m(null==e.instances.get(t.id)),e.addInstance(t.id,n),e.drawCommandsDirty=!0}));const y=d-c;y>0&&u.setSubData(g,c*i,0,y*i),t(r,((e,t)=>null==h[t])),P()}_writeGeometry(e,t,r){const s=e.localOrigin.vec3;g(D,-s[0],-s[1],-s[2]);const i=a(S,D,e.transformation);o(M,i),n(M,M),this._bufferWriter.write(i,M,e.geometry,t,r)}updateAnimation(e){return this.material.update(e)}requiresSlot(e,t){return this.material.requiresSlot(e,t)}prepareTechnique(e){const{output:t,bindParameters:r}=e;if(!this.requiresSlot(r.slot,t))return null;const s=t===u.Highlight||t===u.ShadowHighlight;if(s&&!this._hasHighlights)return null;const i=t===u.ShadowExcludeHighlight,a=!(s||i);for(const o of this._dataByOrigin.values())for(const n of o.buffers){if(s&&!n.hasHighlights)continue;const o=(s?n.drawCommandsHighlight:i&&n.needsMultipleCommands()?n.drawCommandsShadowHighlightRest:n.drawCommandsDefault)||null,l=a&&n.drawCommandsOccludees||null;if(o?.length||l?.length){const s=this._glMaterials.load(e.rctx,r.slot,t),i=null!=s?s.beginSlot(r):null;if(null!=i)return i}}return null}render(e,t){const{output:r,bindParameters:s}=e,i=r===u.Highlight||r===u.ShadowHighlight,a=r===u.ShadowExcludeHighlight,o=!(i||a),n=this._rctx;n.appleAmdDriverHelper?.resetIndicesType(),n.bindTechnique(t,this.material.parameters,s);for(const l of this._dataByOrigin.values())for(const e of l.buffers){if(i&&!e.hasHighlights)continue;const r=(i?e.drawCommandsHighlight:a&&e.needsMultipleCommands()?e.drawCommandsShadowHighlightRest:e.drawCommandsDefault)||null,h=o&&e.drawCommandsOccludees||null;if(r?.length||h?.length){t.program.bindDraw(new p(l.origin),s,this.material.parameters),t.ensureAttributeLocations(e.vao),n.bindVAO(e.vao),r?.length&&(t.bindPipelineState(n,s.slot,!1),r.forAll((e=>n.drawArrays(t.primitiveType,e.first,e.count)))),h?.length&&(t.bindPipelineState(n,s.slot,!0),h.forAll((e=>n.drawArrays(t.primitiveType,e.first,e.count))))}}}get test(){return{material:this.material,glMaterials:this._glMaterials,dataByOrigin:this._dataByOrigin}}}class A{constructor(e){this.origin=e,this.changes=new Array}}function H(e,t){let r;if(!e.some((e=>!(e.numElements<t)&&(r=e,!0))))return null;const s=r.from;return r.from+=t,r.from>=r.to&&e.removeUnordered(r),s}const D=l(),S=l(),M=l(),x=new i({allocator:e=>e||new _,deallocator:null}),j=65536,I=4*j,L=1024,R=16777216,G=R/4;let T=new Float32Array(j);function W(e){return T.length<e&&(T=new Float32Array(e)),T}function V(e){const t=4*e;return t<=L?L:t<I?I:Math.max(Math.min(Math.ceil(1.5*t/I)*I,R),t)}function P(){T=new Float32Array(2)}export{E as MergedRenderer};
