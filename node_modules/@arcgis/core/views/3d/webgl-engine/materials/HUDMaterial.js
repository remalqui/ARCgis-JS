/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{f as t}from"../../../../chunks/mat3.js";import{c as r}from"../../../../chunks/mat3f64.js";import{a as s}from"../../../../chunks/mat4.js";import{c as i}from"../../../../chunks/mat4f64.js";import{j as a}from"../../../../chunks/vec2.js";import{a as n,f as o}from"../../../../chunks/vec2f64.js";import{s as c,m as l,n as f,b as u,g as p,c as h,l as m,i as d,t as g,e as O,a as S}from"../../../../chunks/vec3.js";import{c as v,f as A}from"../../../../chunks/vec3f64.js";import{c as b,f as P}from"../../../../chunks/vec4f64.js";import{isMat4 as x}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as _}from"../../../../geometry/support/aaBoundingRect.js";import{BufferViewVec4u8 as y}from"../../../../geometry/support/buffer/BufferView.js";import I from"../../support/debugFlags.js";import{newLayout as T}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as j}from"../core/shaderLibrary/ShaderOutput.js";import{HUDSpace as C}from"../core/shaderLibrary/hud/HUD.glsl.js";import{GLTextureMaterial as L,GLTextureMaterialBindParameters as z}from"../lib/GLTextureMaterial.js";import{Material as M,RenderOccludedFlag as R}from"../lib/Material.js";import{RenderSlot as U}from"../lib/RenderSlot.js";import{applyScaleFactor as E,applyPrecomputedScaleFactor as w,precomputeScaleFactor as D}from"../lib/screenSizePerspectiveUtils.js";import{assert as V}from"../lib/Util.js";import{VertexAttribute as N}from"../lib/VertexAttribute.js";import{ScaleInfo as B}from"./ScaleInfo.js";import{writePosition as X,writeNormal as H,writeColor as G,writeBufferVec4 as k,writeBufferVec4Zeros as F,writeObjectAndLayerIdColor as W}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as q}from"./internal/MaterialUtil.js";import{c as Z}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechnique as J}from"../shaders/HUDMaterialTechnique.js";import{HUDMaterialTechniqueConfiguration as Y}from"../shaders/HUDMaterialTechniqueConfiguration.js";class K extends M{constructor(e){super(e,new ve),this._configuration=new Y}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?C.Screen:C.World,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.isDraped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===U.OCCLUSION_PIXELS&&this.parameters.occlusionTest&&(e===j.Color||e===j.Alpha),e===j.Color&&(this._configuration.debugDrawLabelBorder=!!I.LABELS_SHOW_BORDER),e===j.Highlight&&(this._configuration.binaryHighlightOcclusionEnabled=this.parameters.binaryHighlightOcclusion),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassGeometry=t.multipassGeometry.enabled,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,r,i,a,n,o){if(!i.options.selectionMode||!i.options.hud||!e.visible)return;const g=this.parameters;let O=1,S=1;if(t(le,r),null!=e.shaderTransformer){const t=e.shaderTransformer(me);O=t[0],S=t[5],ee(le)}const A=e.vertexAttributes.get(N.POSITION),b=e.vertexAttributes.get(N.SIZE),P=e.vertexAttributes.get(N.NORMAL),x=e.vertexAttributes.get(N.AUXPOS1);V(A.size>=3);const _=i.point,y=i.camera,I=Z(g);O*=y.pixelRatio,S*=y.pixelRatio;const T="screen"===this.parameters.centerOffsetUnits;for(let t=0;t<A.data.length/A.size;t++){const e=t*A.size;c(ie,A.data[e],A.data[e+1],A.data[e+2]),l(ie,ie,r);const a=t*b.size;Oe[0]=b.data[a]*O,Oe[1]=b.data[a+1]*S,l(ie,ie,y.viewMatrix);const n=t*x.size;if(c(pe,x.data[n],x.data[n+1],x.data[n+2]),!T&&(ie[0]+=pe[0],ie[1]+=pe[1],0!==pe[2])){const e=pe[2];f(pe,ie),u(ie,ie,p(pe,pe,e))}const j=t*P.size;if(c(ae,P.data[j],P.data[j+1],P.data[j+2]),this._normalAndViewAngle(ae,le,y,he),this._applyVerticalOffsetTransformationView(ie,he,y,re),y.applyProjection(ie,ne),ne[0]>-1){ne[0]=Math.floor(ne[0]),ne[1]=Math.floor(ne[1]),T&&(pe[0]||pe[1])&&(ne[0]+=pe[0],0!==pe[1]&&(ne[1]+=E(pe[1],re.factorAlignment)),y.unapplyProjection(ne,ie)),ne[0]+=this.parameters.screenOffset[0],ne[1]+=this.parameters.screenOffset[1],w(Oe,re.factor,Oe);const e=de*y.pixelRatio;let t=0;if(g.textureIsSignedDistanceField&&(t=g.outlineSize*y.pixelRatio/2),_&&te(_,ne[0],ne[1],Oe,e,t,g,I)){const e=i.ray;if(l(ce,ie,s(ue,y.viewMatrix)),ne[0]=_[0],ne[1]=_[1],y.unprojectFromRenderScreen(ne,ie)){const t=v();h(t,e.direction);const r=1/m(t);p(t,t,r);o(d(e.origin,ie)*r,t,-1,!0,1,ce)}}}}}intersectDraped(e,t,r,s,i,a){const n=e.vertexAttributes.get(N.POSITION),o=e.vertexAttributes.get(N.SIZE),c=this.parameters,l=Z(c);let f=1,u=1;if(null!=e.shaderTransformer){const t=e.shaderTransformer(me);f=t[0],u=t[5]}f*=e.screenToWorldRatio,u*=e.screenToWorldRatio;const p=ge*e.screenToWorldRatio;for(let h=0;h<n.data.length/n.size;h++){const t=h*n.size,r=n.data[t],m=n.data[t+1],d=h*o.size;Oe[0]=o.data[d]*f,Oe[1]=o.data[d+1]*u;let g=0;c.textureIsSignedDistanceField&&(g=c.outlineSize*e.screenToWorldRatio/2),te(s,r,m,Oe,p,g,c,l)&&i(a.dist,a.normal,-1,!1)}}createBufferWriter(){return new Pe(this)}_normalAndViewAngle(e,r,s,i){return x(r)&&(r=t(fe,r)),g(i.normal,e,r),l(i.normal,i.normal,s.viewInverseTransposeMatrix),i.cosAngle=O(oe,Se),i}_updateScaleInfo(e,t,r){const s=this.parameters;null!=s.screenSizePerspective?D(r,t,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),null!=s.screenSizePerspectiveAlignment?D(r,t,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,r,s,i,a,n){const o=this._normalAndViewAngle(t,r,i,he);return this._applyVerticalGroundOffsetView(e,o,i,n),this._applyVerticalOffsetTransformationView(n,o,i,a),this._applyPolygonOffsetView(n,o,s[3],i,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,t,r,s,i){return this._applyCenterOffsetNDC(e,t,r,s),null!=i&&h(i,s),this._applyPolygonOffsetNDC(s,t,r,s),s}_applyPolygonOffsetView(t,r,s,i,a){const n=i.aboveGround?1:-1;let o=Math.sign(s);0===o&&(o=n);const c=n*o;if(this.parameters.shaderPolygonOffset<=0)return h(a,t);const l=e(Math.abs(r.cosAngle),.01,1),f=1-Math.sqrt(1-l*l)/l/i.viewport[2];return p(a,t,c>0?f:1/f),a}_applyVerticalGroundOffsetView(e,t,r,s){const i=m(e),a=r.aboveGround?1:-1,n=.5*r.computeRenderPixelSizeAtDist(i),o=p(ie,t.normal,a*n);return S(s,e,o),s}_applyVerticalOffsetTransformationView(e,t,r,s){const i=this.parameters;if(!i.verticalOffset||!i.verticalOffset.screenLength){if(i.screenSizePerspective||i.screenSizePerspectiveAlignment){const r=m(e);this._updateScaleInfo(s,r,t.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const a=m(e),n=i.screenSizePerspectiveAlignment??i.screenSizePerspective,o=q(r,a,i.verticalOffset,t.cosAngle,n);return this._updateScaleInfo(s,a,t.cosAngle),p(t.normal,t.normal,o),S(e,e,t.normal)}_applyCenterOffsetView(e,t,r){const s="screen"!==this.parameters.centerOffsetUnits;return r!==e&&h(r,e),s&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(f(ae,r),S(r,r,p(ae,ae,t[2])))),r}_applyCenterOffsetNDC(e,t,r,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&h(s,e),i||(s[0]+=t[0]/r.fullWidth*2,s[1]+=t[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(e,t,r,s){const i=this.parameters.shaderPolygonOffset;if(e!==s&&h(s,e),i){const e=r.aboveGround?1:-1,a=e*Math.sign(t[3]);s[2]-=(a||e)*i}return s}requiresSlot(e,t){if(t===j.Color||t===j.Alpha||t===j.Highlight||t===j.ObjectAndLayerIdColor){if(e===U.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:r}=this.parameters;return e===(t?U.LABEL_MATERIAL:U.HUD_MATERIAL)||r&&e===U.OCCLUSION_PIXELS}return!1}createGLMaterial(e){return new Q(e)}calculateRelativeScreenBounds(e,t,r=_()){return $(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}}class Q extends L{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(J,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function $(e,t,r,s=se){return a(s,e.anchorPosition),s[0]*=-t[0],s[1]*=-t[1],s[0]+=e.screenOffset[0]*r,s[1]+=e.screenOffset[1]*r,s}function ee(e){const t=e[0],r=e[1],s=e[2],i=e[3],a=e[4],n=e[5],o=e[6],c=e[7],l=e[8],f=1/Math.sqrt(t*t+r*r+s*s),u=1/Math.sqrt(i*i+a*a+n*n),p=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*f,e[1]=r*f,e[2]=s*f,e[3]=i*u,e[4]=a*u,e[5]=n*u,e[6]=o*p,e[7]=c*p,e[8]=l*p,e}function te(e,t,r,s,i,a,n,o){let c=t-i-(o[0]>0?s[0]*o[0]:0),l=c+s[0]+2*i,f=r-i-(o[1]>0?s[1]*o[1]:0),u=f+s[1]+2*i;const p=n.distanceFieldBoundingBox;return n.textureIsSignedDistanceField&&null!=p&&(c+=s[0]*p[0],f+=s[1]*p[1],l-=s[0]*(1-p[2]),u-=s[1]*(1-p[3]),c-=a,l+=a,f-=a,u+=a),e[0]>c&&e[0]<l&&e[1]>f&&e[1]<u}const re=new B,se=n(),ie=v(),ae=v(),ne=b(),oe=v(),ce=v(),le=r(),fe=r(),ue=i(),pe=v(),he={normal:oe,cosAngle:0},me=i(),de=1,ge=2,Oe=[0,0],Se=A(0,0,1);class ve extends z{constructor(){super(...arguments),this.renderOccluded=R.Occlude,this.color=P(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=o(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.outlineColor=P(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.binaryHighlightOcclusion=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.isDraped=!1}}const Ae=T().vec3f(N.POSITION).vec3f(N.NORMAL).vec2f(N.UV0).vec4u8(N.COLOR).vec2f(N.SIZE).vec4f(N.AUXPOS1).vec4f(N.AUXPOS2),be=Ae.clone().vec4u8(N.OBJECTANDLAYERIDCOLOR);class Pe{constructor(e){this._material=e,this.vertexBufferLayout=has("enable-feature:objectAndLayerId-rendering")?be:Ae}elementCount(e){return 6*e.indices.get(N.POSITION).length}write(e,t,r,s,i){X(r.indices.get(N.POSITION),r.vertexAttributes.get(N.POSITION).data,e,s.position,i,6),H(r.indices.get(N.NORMAL),r.vertexAttributes.get(N.NORMAL).data,t,s.normal,i,6);const a=r.vertexAttributes.get(N.UV0).data;let n,o,c,l;if(null==a||a.length<4){const e=this._material.parameters;n=0,o=0,c=e.texCoordScale[0],l=e.texCoordScale[1]}else n=a[0],o=a[1],c=a[2],l=a[3];c=Math.min(1.99999,c+1),l=Math.min(1.99999,l+1);let f=r.indices.get(N.POSITION).length,u=i;const p=s.uv0;for(let g=0;g<f;++g)p.set(u,0,n),p.set(u,1,o),u+=1,p.set(u,0,c),p.set(u,1,o),u+=1,p.set(u,0,c),p.set(u,1,l),u+=1,p.set(u,0,c),p.set(u,1,l),u+=1,p.set(u,0,n),p.set(u,1,l),u+=1,p.set(u,0,n),p.set(u,1,o),u+=1;G(r.indices.get(N.COLOR),r.vertexAttributes.get(N.COLOR).data,4,s.color,i,6);const h=r.indices.get(N.SIZE),m=r.vertexAttributes.get(N.SIZE).data;f=h.length;const d=s.size;u=i;for(let g=0;g<f;++g){const e=m[2*h[g]],t=m[2*h[g]+1];for(let r=0;r<6;++r)d.set(u,0,e),d.set(u,1,t),u+=1}if(r.indices.get(N.AUXPOS1)&&r.vertexAttributes.get(N.AUXPOS1)?k(r.indices.get(N.AUXPOS1),r.vertexAttributes.get(N.AUXPOS1).data,s.auxpos1,i,6):F(s.auxpos1,i,6*f),r.indices.get(N.AUXPOS2)&&r.vertexAttributes.get(N.AUXPOS2)?k(r.indices.get(N.AUXPOS2),r.vertexAttributes.get(N.AUXPOS2).data,s.auxpos2,i,6):F(s.auxpos2,i,6*f),null!=r.objectAndLayerIdColor){if(r.indices.get(N.POSITION)){const e=r.indices.get(N.POSITION).length,t=s.getField(N.OBJECTANDLAYERIDCOLOR,y);W(r.objectAndLayerIdColor,t,e,i,6)}}}}export{K as HUDMaterial,ve as Parameters};
