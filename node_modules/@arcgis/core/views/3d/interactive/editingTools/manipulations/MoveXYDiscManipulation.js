/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import t from"../../../../../Color.js";import{E as e}from"../../../../../chunks/mat4.js";import{c as i}from"../../../../../chunks/mat4f64.js";import{s as a}from"../../../../../chunks/vec3.js";import{f as r}from"../../../../../chunks/vec3f64.js";import{sv3d as s,sm4d as o}from"../../../../../geometry/support/vectorStacks.js";import{getGraphicEffectiveElevationInfo as n}from"../../../../../support/elevationInfoUtils.js";import{Manipulator3D as l}from"../../Manipulator3D.js";import{RenderObject as p}from"../../RenderObject.js";import{screenToMapXYAtLocation as c}from"../dragEventPipeline3D.js";import{ManipulatorType as u}from"../ManipulatorType.js";import{getSettings as m}from"../settings.js";import{DISC_RADIUS as h,GEOMETRY_SEGMENTS as d,DISC_HEIGHT as _,DISC_COLLISION_RADIUS as f}from"./config.js";import{Manipulation as g}from"./Manipulation.js";import{createGraphicMoveDragPipeline as M}from"./moveUtils.js";import{SnapToScene as j}from"../snapping/SnapToScene.js";import{CullFaceOptions as T}from"../../../webgl-engine/lib/basicInterfaces.js";import{createCylinderGeometry as v}from"../../../webgl-engine/lib/GeometryUtil.js";import{RenderOccludedFlag as S}from"../../../webgl-engine/lib/Material.js";import{ColorMaterial as w}from"../../../webgl-engine/materials/ColorMaterial.js";import{createManipulatorDragEventPipeline as y,dragAtLocation as b,addScreenDelta as E}from"../../../../interactive/dragEventPipeline.js";import{ManipulatorStateFlags as x}from"../../../../interactive/interfaces.js";class A extends g{constructor(t){super(),this._snapToScene=new j,this._discMaterial=this._createMaterial(),this._discMaterialTransparent=this._createMaterial(.5),this._scale=1,this._radius=h,this._view=t.view,this._tool=t.tool,null!=t.snapToScene&&(this.snapToScene=t.snapToScene),null!=t.radius&&(this._radius=t.radius),this._createManipulator(),this.forEachManipulator((t=>this._tool.manipulators.add(t)))}destroy(){this.forEachManipulator((t=>{this._tool.manipulators.remove(t),t.destroy()})),this._tool=null,this._view=null,this._manipulator=null}forEachManipulator(t){t(this._manipulator,u.TRANSLATE_XY)}get displayScale(){return this._scale}set displayScale(t){this._scale=t,this._updateManipulatorTransform()}get snapToScene(){return this._snapToScene.enabled}set snapToScene(t){this._snapToScene.enabled=t}get radius(){return this._radius}set radius(t){t!==this._radius&&(this._radius=t,this._updateManipulator())}createGraphicDragPipeline(t,e,i){const a=e.graphic,r=n(a),s=a.geometry.spatialReference;return M(e,i,(e=>this.createDragPipeline(((i,a,r,s,o)=>(({steps:a,cancel:r}=t(i,a,r,s,o)),e(i,a,r))),r,s,a)),this._view.state.viewingMode)}createDragPipeline(t,e,i,a){const r=this._view;return y(this._manipulator,((s,o,n,l,p)=>{const m=o.next(b(r,s.elevationAlignedLocation)).next(c(r,s.elevationAlignedLocation,e,i,a)).next(...this._snapToScene.createDragEventPipelineStep(r,e)).next((t=>({...t,manipulatorType:u.TRANSLATE_XY}))).next(E());t(s,m,n,l,p)}))}_updateManipulatorTransform(){const t=e(o.get(),a(s.get(),this.displayScale,this.displayScale,this.displayScale));this._manipulator.modelTransform=t}_createManipulator(){const t=this._view;this._manipulator=new l({view:t,worldSized:!1,autoScaleRenderObjects:!1,focusMultiplier:1,touchMultiplier:1,collisionType:{type:"disc",direction:r(0,0,1)},worldOriented:!0}),this._updateManipulator()}_updateManipulator(){const t=v(this._discMaterial,_,1,d,r(0,0,1),r(0,0,0));t.transformation=e(i(),r(this._radius,this._radius,this._radius)),this._manipulator.renderObjects=[new p(t,x.Focused),new p(t.instantiate({material:this._discMaterialTransparent}),x.Unfocused)],this._manipulator.radius=f*(this._radius/h)}_createMaterial(e=1){const i=m(this._view),a=t.toUnitRGBA(i.colors.accent);return a[3]*=e,new w({color:a,transparent:1!==e,cullFace:T.Back,renderOccluded:S.Transparent})}get test(){return{discManipulator:this._manipulator}}}export{A as MoveXYDiscManipulation};
