/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{handlesGroup as e,destroyHandle as t,refHandle as n}from"../../../../core/handleUtils.js";import{deg2rad as i}from"../../../../core/mathUtils.js";import{watch as o,initial as a}from"../../../../core/reactiveUtils.js";import{s as r}from"../../../../chunks/vec3.js";import{c as s}from"../../../../chunks/vec3f64.js";import{projectVectorToVector as l,projectPointToVector as p}from"../../../../geometry/projection.js";import{create as c,empty as m,getMin as u}from"../../../../geometry/support/aaBoundingBox.js";import{containsXY as h}from"../../../../geometry/support/aaBoundingRect.js";import{getGraphicEffectiveElevationInfo as d}from"../../../../support/elevationInfoUtils.js";import{GrabbingState as f}from"./GrabbingState.js";import{ManipulatorState as g}from"./ManipulatorState.js";import{getSettings as v}from"./settings.js";import{ExtendedLineVisualElement as y}from"../visualElements/ExtendedLineVisualElement.js";import{LaserlineVisualElement as E}from"../visualElements/LaserlineVisualElement.js";import{PointVisualElement as j}from"../visualElements/PointVisualElement.js";import{evaluateElevationAlignmentAtPoint as w}from"../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as b}from"../../layers/graphics/ElevationContext.js";import{GraphicState as S}from"../../layers/graphics/GraphicState.js";import{RenderOccludedFlag as x}from"../../webgl-engine/lib/Material.js";function A(t){const{view:n,graphic:i}=t,o=new S({graphic:i}),a=[],r=M(t,o,a);return L(t,o,a,r),a.push(n.trackGraphicState(o)),{visualElement:r,remove(){e(a).remove()}}}function L(e,n,a,s){const{view:p,graphic:c}=e,h=v(p),j=new y({view:p,extensionType:h.visualElements.zVerticalLine.extensionType,innerWidth:1,attached:!1,writeDepthEnabled:!1,renderOccluded:x.OccludeAndTransparent});h.visualElements.zVerticalLine.apply(j);const S=new E({view:p,intersectsLineInfinite:!0,attached:!1});h.visualElements.pointGraphics.shadowStyle.apply(S);const A=i(h.visualElements.heightPlaneAngleCutoff),L=new E({view:p,attached:!1,angleCutoff:A});h.visualElements.heightPlane.apply(L);const M=d(e.graphic),C=b.fromElevationInfo(M),G="on-the-ground"===M.mode||!M.offset&&"absolute-height"!==M.mode,R=new g;let V=1,B=1;const I=()=>{R.update(e);const t=P(c),i=G&&(n.isDraped||null==t||!t.hasZ);let o=!0;if(i||null==t)o=!1;else{const e=w(t,p.elevationProvider,C,p.renderCoordsHelper);r(U,t.x,t.y,e),l(U,t.spatialReference,U,p.renderCoordsHelper.spatialReference),j.setStartEndFromWorldDownAtLocation(U),S.intersectsWorldUpAtLocation=U}const a=R.grabbingState&f.Z?h.visualElements.laserlineAlphaMultiplier:1;a!==V&&(V=a,h.visualElements.heightPlane.apply(L,a));const d=m(D);!i&&n.displaying&&s.calculateMapBounds(d)&&l(u(d,U),p.spatialReference,U,p.renderCoordsHelper.spatialReference)?(L.heightManifoldTarget=U,L.attached=!0):L.attached=!1;const g=R.grabbingState&f.XY?h.visualElements.laserlineAlphaMultiplier:1;g!==B&&(B=g,h.visualElements.pointGraphics.shadowStyle.apply(S,g));const v=o&&n.displaying&&!i;S.attached=v,j.attached=v};a.push(o((()=>[n.displaying,n.isDraped]),I),n.on("changed",I)),e.forEachManipulator((e=>{a.push(e.events.on("grab-changed",I))})),a.push(t(S)),a.push(t(j)),a.push(t(L)),I()}function M(e,n,i){const{view:o,graphic:a}=e,r=new j({view:o,geometry:P(a),elevationInfo:d(a),attached:!1});return C(e,r,n,i),i.push(t(r)),r}function P(e){const t=e.geometry;return null==t?null:"point"===t.type?t:"mesh"===t.type?t.anchor.clone():null}function C(e,t,n,i){const r=()=>t.attached=n.displaying;G(e,t,n,i),v(e.view).visualElements.pointGraphics.outline.apply(t),i.push(o((()=>n.displaying),r,a))}function G(e,t,i,o){const{view:a,graphic:r}=e;let s=null;const l=e=>{null!=s&&(s.remove(),s=null),i.isDraped&&null!=e&&(s=R(a,e,(()=>{t.geometry=e})))},p=()=>{const e=P(r);l(e),t.geometry=e};o.push(i.on("changed",p),n((()=>s))),p()}function R(e,t,n){const i=e.elevationProvider.spatialReference;p(t,U,i);const o=U[0],a=U[1];return e.elevationProvider.on("elevation-change",(e=>{h(e.extent,o,a)&&n()}))}const U=s(),D=c();export{A as createVisualElements};
