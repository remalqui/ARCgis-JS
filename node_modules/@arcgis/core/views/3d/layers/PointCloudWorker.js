/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../core/arrayUtils.js";import{isArrayBuffer as r}from"../../../core/typedArrayUtil.js";import{c as e}from"../../../chunks/quat.js";import{c as a}from"../../../chunks/quatf32.js";import{q as o}from"../../../chunks/vec3.js";import{f as n,c as f}from"../../../chunks/vec3f32.js";import{projectBuffer as i}from"../../../geometry/projection.js";import s from"../../../geometry/SpatialReference.js";import{readGeometry as u,getAttributeValues as l,evaluateRenderer as b,filterInPlace as m}from"./i3s/PointCloudWorkerUtil.js";class c{transform(t){const e=this._transform(t),a=[e.points.buffer,e.rgb.buffer];null!=e.pointIdFilterMap&&a.push(e.pointIdFilterMap.buffer);for(const o of e.attributes)"buffer"in o.values&&r(o.values.buffer)&&o.values.buffer!==e.rgb.buffer&&a.push(o.values.buffer);return Promise.resolve({result:e,transferList:a})}_transform(r){const e=u(r.schema,r.geometryBuffer);let a=e.length/3,o=null;const n=new Array,f=l(r.primaryAttributeData,e,a);null!=r.primaryAttributeData&&f&&n.push({attributeInfo:r.primaryAttributeData.attributeInfo,values:f});const i=l(r.modulationAttributeData,e,a);null!=r.modulationAttributeData&&i&&n.push({attributeInfo:r.modulationAttributeData.attributeInfo,values:i});let c=b(r.rendererInfo,f,i,a);if(r.filterInfo&&r.filterInfo.length>0&&null!=r.filterAttributesData){const f=r.filterAttributesData.filter(t).map((t=>{const r=l(t,e,a),o={attributeInfo:t.attributeInfo,values:r};return n.push(o),o}));o=new Uint32Array(a),a=m(e,c,o,r.filterInfo,f)}for(const t of r.userAttributesData){const r=l(t,e,a);n.push({attributeInfo:t.attributeInfo,values:r})}3*a<c.length&&(c=new Uint8Array(c.buffer.slice(0,3*a))),this._applyElevationOffsetInPlace(e,a,r.elevationOffset);const p=this._transformCoordinates(e,a,r.obb,s.fromJSON(r.inSR),s.fromJSON(r.outSR));return{obb:r.obb,points:p,rgb:c,attributes:n,pointIdFilterMap:o}}_transformCoordinates(t,r,a,s,u){if(!i(t,s,0,t,u,0,r))throw new Error("Can't reproject");const l=n(a.center[0],a.center[1],a.center[2]),b=f(),m=f();e(p,a.quaternion);const c=new Float32Array(3*r);for(let e=0;e<r;e++)b[0]=t[3*e]-l[0],b[1]=t[3*e+1]-l[1],b[2]=t[3*e+2]-l[2],o(m,b,p),a.halfSize[0]=Math.max(a.halfSize[0],Math.abs(m[0])),a.halfSize[1]=Math.max(a.halfSize[1],Math.abs(m[1])),a.halfSize[2]=Math.max(a.halfSize[2],Math.abs(m[2])),c[3*e]=b[0],c[3*e+1]=b[1],c[3*e+2]=b[2];return c}_applyElevationOffsetInPlace(t,r,e){if(0!==e)for(let a=0;a<r;a++)t[3*a+2]+=e}}const p=a();function h(){return new c}export{h as default};
