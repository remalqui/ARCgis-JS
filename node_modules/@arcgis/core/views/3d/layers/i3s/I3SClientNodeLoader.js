/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{assertIsSome as t}from"../../../../core/maybe.js";import{MIN_PRIORITY as o}from"../../../../core/MemCache.js";import{throwIfAborted as n}from"../../../../core/promiseUtils.js";import{generateUUID as r}from"../../../../core/uuid.js";import{b as s}from"../../../../chunks/mat3.js";import{c as a}from"../../../../chunks/mat3f64.js";import{k as i}from"../../../../chunks/vec3.js";import{O as l}from"../../../../chunks/vec3f64.js";import{projectBoundingSphere as d}from"../../../../geometry/projection.js";import{k as u}from"../../../../chunks/sphere.js";import{ViewingMode as c}from"../../../ViewingMode.js";import{convertMeshMaterialToPBRMaterial as m}from"./I3SClientMaterialUtil.js";class h{constructor(e,t,o,n,r,s){this._uid=e,this._indexSR=t,this._renderSR=o,this._viewingMode=n,this._worker=s,this._id2Meta=new Map,this._oid2Meta=new Map,this._memCache=r.newCache(`sl-client-mesh-data-${this._uid}`)}get indexSR(){return this._indexSR}get renderSR(){return this._renderSR}createMeshNodeInfo(e,t){const o=`mesh${t}`,n=e.extent,r=n.spatialReference,s=this._indexSR,a=f(n,e.origin);d(a,r,a,s);return{type:"mesh",id:o,version:M(e),oid:t,mbs:a,componentNodeIds:[],unloadedMesh:e,nodeIndex:null,loadMeshPromise:null}}addMeshNode(t,o){if(null!=this.getMeshNodeIndex(o.oid))throw new e(`I3SClientNodeLoader: client side mesh for feature oid=${o.oid} already exists`);o.nodeIndex=t,this._id2Meta.set(o.id,o),this._oid2Meta.set(o.oid,o)}getMeshNodeIndex(e){const t=this._oid2Meta.get(e);return null==t||"mesh"!==t.type?null:t.nodeIndex}removeNode(e){if(null==e)return;const t=this._id2Meta.get(e);null!=t&&(this._id2Meta.delete(e),"mesh"===t.type&&this._oid2Meta.delete(t.oid))}async loadNodeJSON(t){const o=this._id2Meta.get(t);if(null==o)throw new e(`I3SClientNodeLoader::loadNodeJSON unable to find node ${t}`);switch(o.type){case"mesh":return this._loadMeshNodeJSON(o);case"mesh-component":return this._loadMeshComponentNodeJSON(o);default:throw new e(`I3SClientNodeLoader::loadNodeJSON unable to handle node ${t}`)}}async _loadMeshNodeJSON(e){const t=e.id,o=(await this._getMeshData(e)).loadedMesh;if(null==o.components||0===o.components.length)return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null};const n=[],r=o.components;for(let s=0;s<r.length;++s){const o=`${t}-component${s}`,r={type:"mesh-component",id:o,mbs:e.mbs,componentIndex:s,meshNodeInfo:e,textureData:new Map};this._id2Meta.set(r.id,r),e.componentNodeIds.push(o),n.push({id:r.id,href:null,mbs:r.mbs,obb:null})}return{id:t,version:null,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:n}}updateNodeIndex(e,t,o){if(null==e)return;const n=this._id2Meta.get(e);n&&"mesh"===n.type&&(n.nodeIndex=o)}async _loadMeshComponentNodeJSON(e){return{id:e.id,version:e.meshNodeInfo.version,mbs:e.mbs,obb:null,sharedResource:null,geometryData:null,attributeData:null,featureData:null,children:null,isEmpty:!1}}async loadNodeData(o,r){const s=o.id,a=this._id2Meta.get(s);if(null==a||"mesh-component"!==a.type)throw new e(`Failed to load client node data for node ${o.id} (unexpected node info)`);const i=a.meshNodeInfo,l=await this._getMeshData(i),d=l.loadedMesh,u=i.oid;if(null==d.components)throw new e(`Failed to load client node data for node ${o.id} (unexpected null reference)`);const h=d.components[a.componentIndex],{material:f,requiredTextures:x,textureData:M}=await m(h.material);if(null!=M)for(const e of M)null!=e&&a.textureData.set(e.id,e);const g={params:{material:f},type:"ArrayBufferView"},{vertexSpace:w,origin:_,transform:b}=d,N=[_.x,_.y,_.z??0],S={featureDataPosition:N,featureIds:[],geometries:[g]},D={attributeData:{},loadedAttributes:[]};l.projectionPromise||(t(this._worker,"SceneLayerWorker is needed to project mesh"),l.projectionPromise=this._worker.project({positions:d.vertexAttributes.position,localMatrix:b?.localMatrix,vertexSpace:w.toJSON(),origin:N,inSpatialReference:d.spatialReference.toJSON(),outSpatialReference:this._indexSR.toJSON(),local:this._viewingMode===c.Local},r));const{projected:v,original:I}=await l.projectionPromise;d.vertexAttributes.position=I;const{transformed:j,original:A}=await p(h,l,this._worker,r);d.vertexAttributes.normal=A,n(r);const{geometryBuffer:R,geometryDescriptor:P}=y(v,h.faces,j,d.vertexAttributes.uv,d.vertexAttributes.color,u);return{geometryData:S,attributeDataInfo:D,geometryBuffer:R,geometryDescriptor:P,requiredTextures:x,textureData:M}}async loadAttributes(e,t,o){const n=e.numFeatures,r={};for(const{field:{name:s}}of t)r[s]=new Array(n);return r}async loadTextures(e,t,o){const n=e.id,r=this._id2Meta.get(n);if(null==r||"mesh-component"!==r.type)throw new Error(`Failed to load textures for node ${e.id} (unexpected node info)`);const s=[];for(const a of t)s.push(r.textureData.get(a.id)||null);return s}async _getMeshData(e){const t=e.version,n=this._memCache.get(t);if(null==n){if(null!=e.loadMeshPromise)return e.loadMeshPromise;const n=async(n,r)=>{const s=e.unloadedMesh.clone();try{await s.load()}catch(l){r(l)}const a=s.memoryUsage,i={loadedMesh:s,projectionPromise:null,normalsTransformPromise:null,usedMemoryInBytes:a};this._memCache.put(t,i,a,o),e.loadMeshPromise=null,n(i)};return e.loadMeshPromise=new Promise(((e,t)=>n(e,t))),e.loadMeshPromise}return n}}function f(e,t){const{spatialReference:o}=e,n=[1,-1],r=[.5*e.width,.5*e.height,e.hasZ?.5*(e.zmax-e.zmin):0],s=o.isGeographic?o.metersPerUnit:1,a=e.center;let i=0;if(e.hasZ)for(let l=0;l<2;++l)for(let e=0;e<2;++e)for(let o=0;o<2;++o){const d=(a.x+n[l]*r[0]-t.x)*s,u=(a.y+n[e]*r[1]-t.y)*s,c=a.z+n[o]*r[2]-t.z;i=Math.max(d*d+u*u+c*c,i)}else for(let l=0;l<2;++l)for(let e=0;e<2;++e){const o=(a.x+n[l]*r[0]-t.x)*s,d=(a.y+n[e]*r[1]-t.y)*s;i=Math.max(o*o+d*d,i)}return u([t.x,t.y,t.z],Math.sqrt(i))}async function p(e,o,n,r){const{transform:d,vertexAttributes:u}=o.loadedMesh,c="source"===e.shading?u.normal:null;if(!(null!=c&&null!=d&&(0!==d.rotationAngle||!i(d.scale,l))))return{transformed:c,original:u.normal};if(!o.normalsTransformPromise){t(n,"SceneLayerWorker is needed to transform mesh normals");const e=a();s(e,d.localMatrix),o.normalsTransformPromise=n.transformNormals({normalMatrix:e,normals:c},r)}return o.normalsTransformPromise}function y(e,t,o,n,r,s){const a=1,i=t.length/3,l=3*i;let d=0,u=0,c=!1,m=0,h=!1,f=0,p=!1,y=0,M=0,N=0;d+=g,d+=g,u=d,d+=3*l*w,null!=o&&(c=!0,m=d,d+=3*l*w),null!=n&&(h=!0,f=d,d+=2*l*w),null!=r&&(p=!0,y=d,d+=4*l*_),M=d,d+=a*b,N=d,d+=2*a*g;const S=new ArrayBuffer(d),D=new Uint8Array(S);x(D,0,l),x(D,g,a);const v=new Float32Array(S,u),I=null!=o?new Float32Array(S,m):null,j=null!=n?new Float32Array(S,f):null,A=null!=r?new Uint8Array(S,y):null;for(let x=0;x<i;++x){const s=3*x;for(let a=0;a<3;++a){const i=t[s+a],l=3*i,d=9*x+3*a;if(v[d]=e[l],v[d+1]=e[l+1],v[d+2]=e[l+2],null!=I&&(I[d]=o[l],I[d+1]=o[l+1],I[d+2]=o[l+2]),null!=j){const e=2*i,t=6*x+2*a;j[t]=n[e],j[t+1]=n[e+1]}if(null!=A){const e=4*i,t=12*x+4*a;A[t]=r[e],A[t+1]=r[e+1],A[t+2]=r[e+2],A[t+3]=r[e+3]}}}x(D,M,s),x(D,M+g,s/2**32),x(D,N,0),x(D,N+g,i-1);return{geometryBuffer:S,geometryDescriptor:{isDraco:!1,isLegacy:!0,color:p,normal:c,uv0:h,uvRegion:!1,featureIndex:!0}}}function x(e,t,o){e[t]=255&o,e[t+1]=255&o>>8,e[t+2]=255&o>>16,e[t+3]=255&o>>24}function M(e){const t=e.metadata.displaySource?.source;if(null==t||!Array.isArray(t)||!t.length||t[0]instanceof File)return r();const o=t;let n="";for(const r of o)n+=r.makeHash();return n+JSON.stringify(null!=e.transform?e.transform.toJSON():"")+(e.vertexSpace.isRelative?JSON.stringify(e.vertexSpace.origin):"")}const g=4,w=4,_=1,b=8;export{h as I3SClientNodeLoader,f as createSphereFromExtent,p as transformNormals};
