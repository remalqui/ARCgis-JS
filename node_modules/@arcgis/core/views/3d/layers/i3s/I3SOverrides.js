/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../request.js";import s from"../../../../core/Accessor.js";import{splitIntoChunks as r}from"../../../../core/arrayUtils.js";import{resultOrAbort as i,result as o}from"../../../../core/asyncUtils.js";import{estimateStringByteSize as n,estimateNumberByteSize as a}from"../../../../core/byteSizeEstimations.js";import d from"../../../../core/Collection.js";import c from"../../../../core/Logger.js";import{destroyMaybe as h,abortMaybe as l}from"../../../../core/maybe.js";import{whenOrAbort as u,createResolver as m,ignoreAbortErrors as p,throwIfAborted as g}from"../../../../core/promiseUtils.js";import y from"../../../../core/ReactiveSet.js";import{watch as b,initial as _}from"../../../../core/reactiveUtils.js";import{property as f}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/has.js";import{subclass as O}from"../../../../core/accessorSupport/decorators/subclass.js";import{formatNumber as C}from"../../../../intl/number.js";import{getMaximumQuerySize as j,queryAllJSON as v}from"../../../../layers/support/featureQueryAll.js";import{assetMapFromAssetMapsJSON as I,extractMesh as A}from"../../../../rest/support/meshFeatureSet.js";import{direct3DObjectFeatureLayerDisplayEnabled as F,i3sPatchingEnabled as L,sceneLayerEditingEnabled as w}from"../../../../support/featureFlags.js";import{isTimeoutError as E}from"../../../../support/requestUtils.js";import x from"../FeatureLayerView3D.js";const G="esri.views.3d.layers.i3s.I3SOverrides";let D=class extends s{constructor(e){super(e),this._warnMaximumChangedObjectsExceeded=!1,this._maximumNumberOfEditOVerrides=T,this._original3DOFLDefinitionExpression=null,this._interactiveEditingSessions=new d,this.geometryOverrides=new d,this._clientGeometryCache=new Map,this._associatedLayerView=null,this._attributeChangedObjectIds=new y,this._geometryChangedObjectIds=new y,this._pendingFetchChangedObjectIds=null,this._pendingFetchAbortController=new AbortController,this._pendingAttributeQueriesCache=new Map}initialize(){this._memCache=this.memoryController.newCache(`i3s-attribute-overrides-${this.layer.uid}`),this._pendingFetchChangedObjectIds=this._fetchChangedObjectIds(this._pendingFetchAbortController?.signal),this._pendingFetchChangedObjectIds.finally((()=>{this._pendingFetchAbortController=null,this._pendingFetchChangedObjectIds=null})),this.is3DOFL&&null!=this._associatedLayer&&(F()?this._associatedLayer.load().then((e=>{this.destroyed||(this._original3DOFLDefinitionExpression=e.definitionExpression,this.addHandles(b((()=>this._definitionExpression),(t=>e.definitionExpression=t),_)),this._associatedLayerView=new x({layer:this._associatedLayer,view:this.view}))})):L())}destroy(){this.is3DOFL&&null!=this._associatedLayer&&(F()?null!=this._associatedLayerView&&(this._associatedLayer.definitionExpression=this._original3DOFLDefinitionExpression):L()),this._set("layer",null),this._memCache=h(this._memCache),this._pendingFetchAbortController=l(this._pendingFetchAbortController),this._pendingFetchChangedObjectIds=null,this._pendingAttributeQueriesCache.clear()}get is3DOFL(){return w()&&null!=this._associatedLayer&&null!=this._associatedLayer.infoFor3D}get sortedGeometryChangedObjectIds(){return this.is3DOFL?[...this._geometryChangedObjectIds].sort(((e,t)=>e-t)):[]}get _associatedLayer(){return null==this.layer?null:this.layer.associatedLayer}get hasGeometryChanges(){return this._geometryChangedObjectIds.size>0}get _definitionExpression(){const e=this.sortedGeometryChangedObjectIds;return 0===e.length?"1 = 0":`OBJECTID IN (${e.join(",")})`}get updating(){if(!this.is3DOFL)return!1;if(F()){return!(null!=this._associatedLayerView)||null!=this._associatedLayerView&&this._associatedLayerView.updating}return L(),!1}get isEmpty(){return null==this._pendingFetchChangedObjectIds&&0===this._attributeChangedObjectIds.size&&0===this._geometryChangedObjectIds.size}featureHasGeometryChanges(e){return this._geometryChangedObjectIds.has(e)}featureHasAttributeChanges(e){return this._attributeChangedObjectIds.has(e)}createInteractiveEditSession(e){this._attributeChangedObjectIds.add(e);const t=w()&&L()&&null!=this.is3DOFL,s=this._interactiveEditingSessions,r=new S(e,{rollback:()=>{s.remove(r)},commit:(s,r)=>{for(const[t,i]of s)this.updateAttributeValue(e,t,i);t&&null!=r&&this.updateGeometry(e,r)}});return s.unshift(r),r}async applyAttributeOverrides(e,t,s){if(null==t)return;const{loadedAttributes:r,attributeData:i}=t;if(null==r||0===r.length||null==i)return;if(this._pendingFetchChangedObjectIds&&await u(this._pendingFetchChangedObjectIds,s),0===this._attributeChangedObjectIds.size)return;const o={loadedAttributes:r,attributeData:i},n=this._getOverridesFromCache(e,o,this._attributeChangedObjectIds),{objectIds:a,fieldNames:d}=n;if(0===a.length||0===d.length)return;const c=await this._queryAttributeOverridesFromAssociatedLayer(a,d,s);null!=c&&this._processOverridesFromAssociatedLayer(e,c,d,o)}updateGeometry(e,t){this._geometryChangedObjectIds.add(e);const s=this._clientGeometryCache.get(e);if(null!=s&&(this.geometryOverrides.remove(s),this._clientGeometryCache.delete(e)),null!=t){const s={oid:e,mesh:t};this.geometryOverrides.add(s),this._clientGeometryCache.set(e,s)}}updateAttributeValue(e,t,s){this._attributeChangedObjectIds.add(e),this._cacheAttributeValue(e,t,s)}featureAdded(e){this.is3DOFL&&L()&&this._geometryChangedObjectIds.add(e),this._attributeChangedObjectIds.add(e)}_cacheAttributeValue(e,t,s){this._memCache.put(this._getAttributeCacheKey(e,t),s,this._memCacheAttributeValueSize(s))}_getOverridesFromCache(e,{loadedAttributes:t,attributeData:s},r){const i=new Set,o=new Array;for(const a of t)o[a.index]=s[a.name];const n=new Set;for(let a=0;a<e.length;a++){const s=e[a];if(r.has(s))for(const e of t){const t=this._attributeFromCache(s,e.index);void 0===t?(i.add(s),n.add(e.name)):o[e.index][a]=t}}return{objectIds:Array.from(i),fieldNames:Array.from(n)}}_attributeFromCache(e,t){const s=this._fromInteractiveEditingSession(e,t);if(void 0!==s)return s;const r=this._getAttributeCacheKey(e,t);return this._memCache.get(r)}_fromInteractiveEditingSession(e,t){if(null!=this._interactiveEditingSessions)for(const s of this._interactiveEditingSessions){if(s.objectId!==e)continue;const r=s.getAttribute(t);if(void 0!==r)return r}}_getAttributeCacheKey(e,t){return`${e}-${t}`}async _queryAttributeOverridesFromAssociatedLayer(e,t,s){if(0===e.length)return null;this._logWarningIfMaximumObjectsExceeded();const{associatedLayer:r}=this.layer;if(null==r)return null;const i=this._pendingAttributeQueriesCache,o=new Array,n=new Map;for(const g of e){const e=i.get(g);if(e)o.push(e);else{const e=m();p(e.promise),n.set(g,e),i.set(g,e.promise)}}const a=Array.from(n.keys()),d=r.createQuery(),{objectIdField:c}=r,h=[c,...t];d.where="1=1",d.returnGeometry=!1,d.outFields=h,d.cacheHint=!0,d.objectIds=a;const[l,u]=await Promise.all([this._executeBatchQuery(r,a,d,s),Promise.all(o)]).then((e=>(g(s),e))).catch((e=>{for(const[t,s]of n)i.delete(t),s.reject(e);throw e})),y=[];for(const m of l)if(m.ok)for(const e of m.value.features){const t=e,s=t.attributes[c];n.get(s)?.resolve(t),i.delete(s),n.delete(s),y.push(t)}for(const m of u)m&&y.push(m);for(const[m,p]of n)i.delete(m),p.resolve(null);return y}async _queryGeometryOverridesFromAssociatedLayer(e,t){if(0===e.length||!this.is3DOFL||!L())return null;this._logWarningIfMaximumObjectsExceeded();const s=this.layer.associatedLayer,{objectIdField:r,globalIdField:i}=s,o=[r,...null!=i?[i]:[]],n=s.createQuery();n.where="1=1",n.returnGeometry=!0,n.outFields=o,n.cacheHint=!0,n.objectIds=e,n.returnZ=s.hasZ,n.returnM=s.hasM;const a=await this._executeBatchQuery(s,e,n,t),d=s.infoFor3D,{spatialReference:c}=s,h=[];for(const l of a){if(!l.ok)continue;const e=l.value,{assetMaps:t,features:s,globalIdFieldName:r}=e;if(null==t)continue;const i=I(d,t);for(const o of s){const e=A(o,r,c,d,i),t=o;null!=e?(t.geometry=e,h.push(t)):t.geometry=null}}return h}_logWarningIfMaximumObjectsExceeded(){if(!this._warnMaximumChangedObjectsExceeded)return;this._warnMaximumChangedObjectsExceeded=!1;let e=`The number of edited objects that are not yet cached in the scene service exceeds the maximum limit. Attribute changes will only be available for the first ${C(this._maximumNumberOfEditOVerrides)} objects. Please consider re-caching the scene service`;const t=this.layer.portalItem;t&&t.loaded?e+=` (${t.portal.url}/home/item.html?id=${t.id}#settings)`:e+=` (${this.layer.parsedUrl.path})`,c.getLogger(G).warn("#queryOverrides()",this.layer.title,`${e}.`)}async _executeBatchQuery(e,t,s,o){if(0===t.length)return[];const n=j(e);t=[...t].sort(((e,t)=>e-t));const a=r(t,n).map((t=>{const r=s.clone();return r.objectIds=t,i(v(e,r,{signal:o}))}));return Promise.all(a)}_processOverridesFromAssociatedLayer(e,t,s,{loadedAttributes:r,attributeData:i}){const o=this._associatedLayer;if(null==o)return;const n=o.objectIdField,a=s.map((t=>(t in i||(i[t]=new Array(e.length)),i[t]))),d=new Map(r.map((e=>[e.name,e.index]))),c=s.map((e=>d.get(e))),h=new Map(Array.from(e,((e,t)=>[e,t])));for(const l of t){const e=l.attributes[n];for(let t=0;t<s.length;t++){const r=c[t],i=h.get(e),o=l.attributes[s[t]];a[t][i]=o,this._cacheAttributeValue(e,r,o)}}}_memCacheAttributeValueSize(e){return"string"==typeof e?n(e):a()}async _fetchChangedObjectIds(e){const s=this.layer;await s.load({signal:e}),this._geometryChangedObjectIds.clear(),this._attributeChangedObjectIds.clear();const{associatedLayer:r}=s;if(null==r||!r.capabilities?.operations?.supportsChangeTracking)return;const i=this._getFetchChangedObjectIdsServerGen();if(null==i)return;const n=r.layerId,a=this.is3DOFL,d={f:"json",returnIdsOnly:!0,layers:`[${n}]`,returnUpdates:!0,returnDeletes:a,returnInserts:a,layerServerGens:JSON.stringify([{id:n,serverGen:i}])};if(a){const e=r.infoFor3D;d.fieldsToCompare=JSON.stringify({fields:[...Object.values(e.transformFieldRoles),e.sourceHashField]})}const h=await o(t(`${r.url}/extractChanges`,{method:"post",query:d,timeout:M,signal:e}));if(!h.ok&&E(h.error)){const e=this.layer.title;c.getLogger(G).warn("extractChanges:timeout",e,`${e} could not obtain edited features that are not cached in the scene service. Display of features may not be up to date with the latest edits. Consider re-caching the scene service.`)}if(h.ok&&1===h.value.data?.edits?.length){const t=h.value.data.edits[0],s=t?.objectIds,i=t?.fieldUpdates,o=s?.adds??[],n=s?.updates??[],d=s?.deletes??[],c=[...o,...n,...d],l=a?[...o,...i??n,...d]:[],u=Math.min(this._maximumNumberOfEditOVerrides,c.length);u<c.length&&(this._warnMaximumChangedObjectsExceeded=!0);const m=c.sort(((e,t)=>e-t));for(let e=0;e<u;++e){const t=m[e];this._attributeChangedObjectIds.add(t)}for(const e of l)this._geometryChangedObjectIds.add(e);if(this.is3DOFL&&L()&&this._geometryChangedObjectIds.size>0){const t=await this._queryGeometryOverridesFromAssociatedLayer(Array.from(this._geometryChangedObjectIds),e);if(null!=t)for(const e of t)null!=e.geometry&&this.updateGeometry(e.attributes[r.objectIdField],e.geometry)}}}_getFetchChangedObjectIdsServerGen(){const e=this.layer;if(null!=e.serviceUpdateTimeStamp&&null!=e.serviceUpdateTimeStamp.lastUpdate)return e.serviceUpdateTimeStamp.lastUpdate;const t=e.associatedLayer;return null!=t&&null!=t.serverGens&&null!=t.serverGens.minServerGen?t.serverGens.minServerGen:null}get test(){const e=Array.from(this._attributeChangedObjectIds),t=this._pendingFetchChangedObjectIds,s=this;return{changedObjectIds:e,pendingFetchChangedObjectIds:t,get maximumNumberOfEditOVerrides(){return s._maximumNumberOfEditOVerrides},set maximumNumberOfEditOVerrides(e){s._maximumNumberOfEditOVerrides=e}}}};e([f({constructOnly:!0})],D.prototype,"view",void 0),e([f({constructOnly:!0})],D.prototype,"layer",void 0),e([f({readOnly:!0})],D.prototype,"is3DOFL",null),e([f()],D.prototype,"_interactiveEditingSessions",void 0),e([f({readOnly:!0})],D.prototype,"sortedGeometryChangedObjectIds",null),e([f({readOnly:!0})],D.prototype,"geometryOverrides",void 0),e([f()],D.prototype,"_clientGeometryCache",void 0),e([f()],D.prototype,"_associatedLayer",null),e([f()],D.prototype,"_associatedLayerView",void 0),e([f({constructOnly:!0})],D.prototype,"memoryController",void 0),e([f()],D.prototype,"_attributeChangedObjectIds",void 0),e([f()],D.prototype,"_geometryChangedObjectIds",void 0),e([f()],D.prototype,"hasGeometryChanges",null),e([f()],D.prototype,"_pendingFetchChangedObjectIds",void 0),e([f()],D.prototype,"_pendingFetchAbortController",void 0),e([f()],D.prototype,"_definitionExpression",null),e([f()],D.prototype,"updating",null),e([f()],D.prototype,"isEmpty",null),D=e([O(G)],D);class S{constructor(e,t){this.objectId=e,this._options=t,this._updates=new Map,this._updatedGeometry=void 0,this._state=V.ACTIVE}getAttribute(e){return this._updates.get(e)}setAttribute(e,t){this.isActive&&this._updates.set(e,t)}getGeometry(){return this._updatedGeometry}setGeometry(e){this.isActive&&(this._updatedGeometry=e)}rollback(){this.isActive&&(this._state=V.ROLLED_BACK,this._options.rollback(),this._updatedGeometry=void 0)}commit(){this.isActive&&(this._state=V.COMMITTED,this._options.commit(this._updates,this._updatedGeometry),this._updates.clear(),this._updatedGeometry=void 0)}get isActive(){return this._state===V.ACTIVE}}var V;!function(e){e[e.ACTIVE=0]="ACTIVE",e[e.COMMITTED=1]="COMMITTED",e[e.ROLLED_BACK=2]="ROLLED_BACK"}(V||(V={}));const M=1e4,T=5e4;export{D as I3SOverrides};
