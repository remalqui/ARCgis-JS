/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../symbols.js";import t from"../../../core/Accessor.js";import{filterInPlace as r}from"../../../core/arrayUtils.js";import s from"../../../core/Handles.js";import{equalsShallow as o}from"../../../core/lang.js";import{floatEqualUlp as i}from"../../../core/mathUtils.js";import{destroyMaybe as a}from"../../../core/maybe.js";import{watch as n}from"../../../core/reactiveUtils.js";import{generateUID as p}from"../../../core/uid.js";import{property as c}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as h}from"../../../core/accessorSupport/decorators/subclass.js";import{diff as l}from"../../../core/accessorSupport/diffUtils.js";import{projectBuffer as d}from"../../../geometry/projection.js";import{create as u,set as m,NEGATIVE_INFINITY as f,expandWithBuffer as g}from"../../../geometry/support/aaBoundingBox.js";import{newDoubleArray as y}from"../../../geometry/support/DoubleArray.js";import{makeDehydratedPoint as b}from"../../../layers/graphics/dehydratedFeatures.js";import{Graphics3DCore as _}from"./graphics/Graphics3DCore.js";import I from"./graphics/Graphics3DScaleVisibility.js";import{BOUNDING_BOX_CORNERS_POINTS_STRIDE as v,boundingBoxCornerPoints as M}from"./i3s/I3SGeometryUtil.js";import{LimitGraphicsMap as E}from"../support/LimitGraphicsMap.js";import{UpdatePolicy as j}from"../webgl-engine/lib/UpdatePolicy.js";import G from"../../../symbols/PointSymbol3D.js";class w{constructor(e,t){this.meta=e,this.index=t}}class D{constructor(e,t){this.graphic=e,this.geometry=t,this.components=[],this.overridesDirty=!1}}let C=class extends t{get updating(){return this._graphicsCore?.updating??!1}constructor(e){super(e),this.loadedGraphics=new E(5e4),this.slicePlaneEnabled=!1,this._renderingInfo={symbol:new G},this._handles=new s,this._featuresMap=new Map}initialize(){const e=this.view.basemapTerrain;this._graphicsCore=new _({owner:this,layer:this.layer,preferredUpdatePolicy:j.ASYNC,elevationFeatureExpressionEnabled:!1,graphicSymbolSupported:!1,getRenderingInfoWithoutRenderer:!0,hasZ:!0,hasM:!1,componentFactories:{deconflictor:e=>this.view.deconflictor.addGraphicsOwner(e),labeler:(e,t)=>this.view.labeler.addGraphicsOwner(e,t,{emptySymbolLabelSupported:!0,elevationInfoOverride:{mode:"absolute-height",offset:0},disablePlacement:{logEntityDescription:"3D Object Scene Layer features"}}),scaleVisibility:(t,r)=>new I({graphicsCoreOwner:this,layer:this.layer,queryGraphicUIDsInExtent:r,graphicsCore:t,basemapTerrain:e,layerScaleEnabled:!1})}}),this._graphicsCore.initializePromise.then((()=>this._graphicsCore.startCreateGraphics())).catch((()=>{})),this._handles.add(n((()=>this.layer.labelingInfo),((e,t)=>{l(e,t)&&this._graphicsCore.updateLabelingInfo()})))}destroy(){this._handles=a(this._handles),this._graphicsCore=a(this._graphicsCore),this.loadedGraphics=a(this.loadedGraphics),this.view=null}addNodeMeta(e,t){let r=0;const s=e.filteredIds,o=this.view.spatialReference,i=[];for(let a=0;a<e.featureIds.length;a++){const n=e.featureIds[a];let c=null==s;if(s&&r<s.length&&n===s[r]&&(c=!0,r++),!this._enabledForFeatureInNode(e,a))continue;const h=this._featuresMap.get(n);if(h){h.components.push(new w(e,a)),this._updateLabelPosition(n);continue}const l=t(a,e),d=b(0,0,0,o),u={objectId:n,uid:p(),attributes:l,visible:c,geometry:d},m=new D(u,d);m.components.push(new w(e,a)),this._featuresMap.set(n,m),this._updateLabelGeometry(n),i.push(u)}this.loadedGraphics.addMany(i)}updateLabelPositions(e){const t=this.view.renderCoordsHelper;this._forEachGraphic(e,((r,s,o)=>{const i=this._graphicsCore.getGraphics3DGraphicById(s.uid);null!=i&&this._updateLabelGeometry(e.featureIds[r])&&i.alignWithAbsoluteElevation(o.z??0,t,!1)}))}setNodeMetaAttributes(e,t){const r=new Array;this._forEachGraphic(e,((s,i)=>{const a=t(s,e);o(i.attributes,a)||(i.attributes=a,r.push(i.uid))})),this._graphicsCore.updateLabelingInfo(r)}applyFilterChange(e){this._forEachFeature(e,((t,r,s)=>{if(!this._enabledForFeatureInNode(e,t)){const s=e.featureIds[t];switch(this._removeFeature(r,e,t)){case O.REMOVED:this.loadedGraphics.removeManyByObjectId([s]);break;case O.MODIFIED:this._updateLabelPosition(s)}return}const o=r.graphic,i=o.visible;i!==s&&(o.visible=s,F.graphic=o,F.property="visible",F.oldValue=i,F.newValue=s,this._graphicsCore.graphicUpdateHandler(F))}))}removeNodeMeta(e){const t=[];this._forEachGraphic(e,(r=>{const s=e.featureIds[r],o=this._featuresMap.get(s);if(!o)return;switch(this._removeFeature(o,e,r)){case O.MODIFIED:this._updateLabelPosition(s);break;case O.REMOVED:t.push(s)}})),this.loadedGraphics.removeManyByObjectId(t)}_removeFeature(e,t,s){const o=e.components.length;return r(e.components,(e=>!(e.meta===t&&e.index===s))),0===e.components.length?(this._featuresMap.delete(t.featureIds[s]),O.REMOVED):o!==e.components.length?O.MODIFIED:O.UNMODIFIED}getRenderingInfo(){return this._renderingInfo}notifyGraphicGeometryChanged(){}notifyGraphicVisibilityChanged(){}_updateLabelPosition(e){const t=this._featuresMap.get(e);t&&this._updateLabelGeometry(e)&&(this.loadedGraphics.removeManyByObjectId([e]),this.loadedGraphics.addMany([t.graphic]))}_updateLabelGeometry(e){const t=this._featuresMap.get(e);if(!t)return!1;const r=t.geometry,s=this.view.spatialReference,o=this.view.renderCoordsHelper,a=r.x,n=r.y,p=r.z??0,c=t.components.length,h=y(c*v);let l=0;for(const{meta:i,index:d}of t.components)M(d,this.collection,i.objectHandle,h,l),l+=v;return d(h,o.spatialReference,0,h,s,0,h.length/3),m(L,f),g(L,h),r.x=(L[0]+L[3])/2,r.y=(L[1]+L[4])/2,r.z=L[5],!i(r.x,a)||!i(r.y,n)||!i(r.z,p)}_forEachGraphic(e,t){this._forEachFeature(e,((r,{graphic:s,geometry:o},i)=>{this._enabledForFeatureInNode(e,r)&&t(r,s,o,i)}))}_forEachFeature(e,t){let r=0;for(let s=0;s<e.featureIds.length;s++){const o=this._featuresMap.get(e.featureIds[s]);let i=null==e.filteredIds;e.filteredIds&&e.filteredIds[r]===e.featureIds[s]&&(i=!0,r++),o&&t(s,o,i)}}_enabledForFeatureInNode(e,t){return e.node.index<0||!this.overrides?.featureHasGeometryChanges(e.featureIds[t])}get updatePolicy(){return this._graphicsCore.effectiveUpdatePolicy}get usedMemory(){return this._graphicsCore.usedMemory}get unloadedMemoryEstimate(){return this._graphicsCore.unprocessedMemoryEstimate}get test(){return{graphicsCore:this._graphicsCore}}};e([c()],C.prototype,"view",void 0),e([c()],C.prototype,"layer",void 0),e([c()],C.prototype,"collection",void 0),e([c()],C.prototype,"loadedGraphics",void 0),e([c()],C.prototype,"overrides",void 0),e([c()],C.prototype,"updating",null),e([c()],C.prototype,"slicePlaneEnabled",void 0),e([c()],C.prototype,"_graphicsCore",void 0),C=e([h("esri.views.3d.layers.I3SMeshViewLabeler")],C);const F={graphic:null,property:null,oldValue:null,newValue:null};var O;!function(e){e[e.UNMODIFIED=0]="UNMODIFIED",e[e.MODIFIED=1]="MODIFIED",e[e.REMOVED=2]="REMOVED"}(O||(O={}));const L=u(),S=C;export{S as default};
