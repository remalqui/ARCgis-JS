/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../../Color.js";import"../../../../core/has.js";import{deg2rad as t}from"../../../../core/mathUtils.js";import{f as r,t as o}from"../../../../chunks/mat3.js";import{c as a}from"../../../../chunks/mat3f64.js";import{f as n,m as s,a as i}from"../../../../chunks/mat4.js";import{c as l,I as u,b as c}from"../../../../chunks/mat4f64.js";import{s as m,a as h,g as f,e as p,n as d,b as g,f as x}from"../../../../chunks/vec3.js";import{Z as _,O as T,c as b}from"../../../../chunks/vec3f64.js";import{O as y}from"../../../../chunks/vec4f64.js";import{computeTranslationToOriginAndRotation as v,projectVectorToDehydratedPoint as C,projectBuffer as O,canProjectWithoutEngine as w}from"../../../../geometry/projection.js";import{create as M,empty as j,expandWithBuffer as P,intersectsClippingArea as A}from"../../../../geometry/support/aaBoundingBox.js";import{newFloatArray as I}from"../../../../geometry/support/FloatArray.js";import{getContinuousIndexArray as R,getZeroIndexArray as E}from"../../../../geometry/support/Indices.js";import N from"../../../../geometry/support/MeshComponent.js";import F from"../../../../geometry/support/MeshMaterialMetallicRoughness.js";import B from"../../../../geometry/support/MeshTextureTransform.js";import{t as S,a as U}from"../../../../chunks/vec32.js";import{transformNormal as L,projectNormalToPCPF as $,transformTangent as G,projectTangentToPCPF as V}from"../../../../geometry/support/meshUtils/projection.js";import{makeDehydratedPoint as D}from"../../../../layers/graphics/dehydratedFeatures.js";import{MeshTransformUpdateAction as k}from"../../../../layers/graphics/sources/interfaces.js";import{ViewingMode as H}from"../../../ViewingMode.js";import{isEncodedMeshTexture as q}from"../../glTF/internal/resourceUtils.js";import{getTransformMatrix as W}from"../../glTF/internal/TextureTransformUtils.js";import{perObjectElevationAligner as z}from"./ElevationAligners.js";import{needsElevationUpdates3D as Y,evaluateElevationInfoAtPoint as Z}from"./elevationAlignmentUtils.js";import{ElevationContext as J}from"./ElevationContext.js";import{Graphics3DMeshObject3DGraphicLayer as K}from"./Graphics3DMeshObject3DGraphicLayer.js";import{Object3DEdgeState as Q}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as X}from"./Graphics3DSymbolLayer.js";import{MaterialInfoCache as ee,MeshFastUpdateProcessor as te}from"./MeshFastUpdateProcessor.js";import{createMaterial as re}from"../support/edgeUtils.js";import{parseColorMixMode as oe,encodeSymbolColor as ae}from"../support/symbolColorUtils.js";import ne from"../../support/debugFlags.js";import{Attribute as se}from"../../webgl-engine/lib/Attribute.js";import{AlphaDiscardMode as ie,CullFaceOptions as le}from"../../webgl-engine/lib/basicInterfaces.js";import{ContentObjectType as ue}from"../../webgl-engine/lib/ContentObjectType.js";import{Geometry as ce}from"../../webgl-engine/lib/Geometry.js";import{Object3D as me}from"../../webgl-engine/lib/Object3D.js";import{Texture as he}from"../../webgl-engine/lib/Texture.js";import{VertexAttribute as fe}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as pe}from"../../webgl-engine/materials/DefaultMaterial.js";import{NativeLineMaterial as de}from"../../webgl-engine/materials/NativeLineMaterial.js";import{useSchematicPBR as ge,defaultSchematicMRRFactors as xe,defaultAdvancedMRRFactors as _e}from"../../webgl-engine/materials/pbrUtils.js";import{TextureWrapMode as Te}from"../../../webgl/enums.js";const be=["mesh"];class ye extends X{constructor(e,t,r,o){super(e,t,r,o),this._materialInfoCache=new ee,this._fastUpdateProcessor=new te,this._textures=new Map,this.ensureDrapedStatus(!1)}async doLoad(){ne.DRAW_MESH_GEOMETRY_NORMALS&&(this._debugVertexNormalMaterial=new de({color:[1,0,1,1]}),this._debugFaceNormalMaterial=new de({color:[0,1,1,1]}))}destroy(){super.destroy(),this._context.stage.removeMany(this._materialInfoCache.materials),this._context.stage.removeMany(Array.from(this._textures.values())),this._materialInfoCache.clear(),this._textures.clear(),this._fastUpdateProcessor.destroy(this._context.stage)}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,be,"fill on mesh-3d"))return null;const r=this.setGraphicElevationContext(t,new J),o=e.renderingInfo;return this._createAs3DShape(t,o,r,t.uid)}onRemoveGraphic(e){this._fastUpdateProcessor.onRemoveGraphic(e,this._materialInfoCache,this._context)}layerOpacityChanged(e,t){const r=this._getLayerOpacity();this._updateMaterialParameters((e=>{e.material.setParameters({layerOpacity:r});const t=e.material.parameters;this._setMaterialTransparentParameter(t,e),e.material.setParameters({transparent:t.transparent})})),e.forEach((e=>{const o=t(e);null!=o&&o.layerOpacityChanged(r,this._context.isAsync)}))}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,Y)}slicePlaneEnabledChanged(e,t){return this._updateMaterialParameters((({material:e})=>{e.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),e.forEach((e=>{const r=t(e);null!=r&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){const e=this._usePBR();return this._updateMaterialParameters((({material:t})=>t.setParameters({usePBR:e}))),!0}updateTransform(e,t,r,o){const a=this._context.renderCoordsHelper.spatialReference,n=Ie,{origin:s,transform:i}=r;switch(v(t,m(Oe,s.x,s.y,s.z??0),n,a),o){case k.EnableFastUpdates:this._fastUpdateProcessor.enable(e,this._materialInfoCache,this._context);break;case k.DisableFastUpdates:this._fastUpdateProcessor.disable(e,this._materialInfoCache,this._context);break;case k.UpdateFastLocalOrigin:e.updateFastLocalOrigin(n,i,this._context.localOriginFactory)}const{elevationContext:l}=e;l.centerPointInElevationSR=this._getCenterPointInElevationSR(n);const{elevationProvider:u,renderCoordsHelper:c}=this._context,h=(e,t)=>Z(e,u,l,c,t);return e.alignedSampledElevation=z(e,l,u.spatialReference,h,c,n),e.updateTransform(n,i,this._context.isAsync),!0}_requiresSymbolVertexColors(){return this._drivenProperties.color||this._drivenProperties.opacity}_colorOrTextureUid(t){return null==t?"-":t instanceof e?t.toHex():t.contentHash}_materialPropertiesDefault(e,t){const r=this._requiresSymbolVertexColors(),o=!!e.vertexAttributes.color,a=!!e.vertexAttributes.tangent;return{hasSymbolVertexColors:r,hasVertexColors:o,hasVertexTangents:a,uid:`vc:${o},vt:${a},vct${t},svc:${r}`}}_textureTransformUid(e){const{offset:t,scale:r,rotation:o}=e??Ne;return`${t[0]},${t[1]},${o},${r[0]},${r[1]}`}_materialProperties(e,t,r){const o=this._materialPropertiesDefault(e,r);if(!t.material)return o;const{color:a,colorTexture:n,colorTextureTransform:s,normalTexture:i,normalTextureTransform:l,doubleSided:u,alphaCutoff:c,alphaMode:m}=t.material,h=this._colorOrTextureUid(a),f=this._colorOrTextureUid(n),p=this._textureTransformUid(s),d=this._colorOrTextureUid(i),g=this._textureTransformUid(l);if(o.color=a,o.colorTexture=n,o.normalTexture=i,o.uid=`${o.uid},cmuid:${h},ctmuid:${f},cttuid:${p},ntmuid:${d},nttuid:${g},ds:${u},ac:${c},am:${m}`,t.material instanceof F){const{metallic:e,roughness:r,metallicRoughnessTexture:a,metallicRoughnessTextureTransform:n,emissiveColor:i,emissiveTexture:u,emissiveTextureTransform:c,occlusionTexture:m,occlusionTextureTransform:h}=t.material,f=this._colorOrTextureUid(a),p=this._textureTransformUid(n),d=this._colorOrTextureUid(i),g=this._colorOrTextureUid(u),x=this._textureTransformUid(c),_=this._colorOrTextureUid(m),T=this._textureTransformUid(h);o.metallic=e,o.roughness=r,o.metallicRoughnessTexture=a,o.emissiveColor=i,o.emissiveTexture=u,o.occlusionTexture=m,o.colorTextureTransform=this._convertTextureTransform(s),o.normalTextureTransform=this._convertTextureTransform(l),o.emissiveTextureTransform=this._convertTextureTransform(c),o.occlusionTextureTransform=this._convertTextureTransform(h),o.metallicRoughnessTextureTransform=this._convertTextureTransform(n),o.uid=`${o.uid},mrm:${e},mrr:${r},mrt:${f},mrtt:${p},emuid:${d},etmuid:${g},ett:${x},otmuid:${_},ott:${T}`}return o}_convertTextureTransform(e){if(!e)return null;const{scale:r,offset:o,rotation:a}=e;return{scale:r,offset:o,rotation:t(a)}}_setInternalColorValueParameters(t,r){r.diffuse=e.toUnitRGB(t),r.opacity=t.a}_getLoadableTextureResource(e){return e.data?e.data:e.url}_getInternalTextureId(e){const t=this._getInternalTexture(e,ie.Opaque);return null!=t?t.id:null}_getInternalTexture(e,t){const r=this._getLoadableTextureResource(e);if(!r)return null;const o=`${e.contentHash}/${t}`;let a=this._textures.get(o);return a||(a=new he(q(r)?r.data:r,{mipmap:!0,wrap:this._castTextureWrap(e.wrap),noUnpackFlip:!0,preMultiplyAlpha:!q(r)&&t!==ie.Opaque,encoding:q(r)&&null!=r.encoding?r.encoding:void 0}),this._textures.set(o,a),this._context.stage.add(a),this._context.stage.loadImmediate(a)),a}_castTextureWrap(e="repeat"){if("string"==typeof e){const t=this._castTextureWrapIndividual(e);return{s:t,t}}return{s:this._castTextureWrapIndividual(e.horizontal),t:this._castTextureWrapIndividual(e.vertical)}}_castTextureWrapIndividual(e){switch(e){case"clamp":return Te.CLAMP_TO_EDGE;case"mirror":return Te.MIRRORED_REPEAT;default:return Te.REPEAT}}_setInternalMaterialParameters(t,r){if(null!=t.color&&this._setInternalColorValueParameters(t.color,r),null!=t.colorTexture){const e=this._getInternalTexture(t.colorTexture,r.textureAlphaMode);null!=e?(r.textureId=e.id,r.textureAlphaPremultiplied=!!e.parameters.preMultiplyAlpha):r.textureId=void 0}null!=t.normalTexture&&(r.normalTextureId=this._getInternalTextureId(t.normalTexture)),null!=t.emissiveColor&&(r.emissiveFactor=e.toUnitRGB(t.emissiveColor)),null!=t.emissiveTexture&&(r.emissiveTextureId=this._getInternalTextureId(t.emissiveTexture)),null!=t.occlusionTexture&&(r.occlusionTextureId=this._getInternalTextureId(t.occlusionTexture)),null!=t.metallicRoughnessTexture&&(r.metallicRoughnessTextureId=this._getInternalTextureId(t.metallicRoughnessTexture)),r.colorTextureTransformMatrix=W(t.colorTextureTransform),r.normalTextureTransformMatrix=W(t.normalTextureTransform),r.occlusionTextureTransformMatrix=W(t.occlusionTextureTransform),r.emissiveTextureTransformMatrix=W(t.emissiveTextureTransform),r.metallicRoughnessTextureTransformMatrix=W(t.metallicRoughnessTextureTransform)}_setExternalMaterialParameters(t){const r=this._drivenProperties.color;let o=null!=this.symbolLayer.material?this.symbolLayer.material.colorMixMode:null;if(r)t.externalColor=y;else{const r=null!=this.symbolLayer.material?this.symbolLayer.material.color:null;null!=r?t.externalColor=e.toUnitRGBA(r):(o=null,t.externalColor=y)}o&&(t.colorMixMode=o),t.castShadows=!!this.symbolLayer.castShadows}_hasTransparentVertexColors(e){const t=e.vertexAttributes.color;if(null==t)return!1;for(let r=3;r<t.length;r+=4)if(255!==t[r])return!0;return!1}_getOrCreateMaterial(t,r){const o=r.material?.color,a=r.material?.colorTexture,n=r.material?.alphaMode,s="blend"===n,i=!("opaque"===n)&&(this._hasTransparentVertexColors(t)||null!=o&&o.a<1||null!=a&&a.transparent||s),l=this._materialProperties(t,r,i),u=this._materialInfoCache.byUid(l.uid);if(u)return u.material;const c={uid:l.uid,material:null,isComponentTransparent:i,alphaMode:r.material?r.material.alphaMode:"opaque"},m=ge({normalTexture:l.normalTexture,metallicRoughnessTexture:l.metallicRoughnessTexture,metallicFactor:l.metallic,roughnessFactor:l.roughness,emissiveTexture:l.emissiveTexture,emissiveFactor:e.toUnitRGB(l.emissiveColor),occlusionTexture:l.occlusionTexture}),h={usePBR:this._usePBR(),isSchematic:m,hasVertexColors:l.hasVertexColors,hasSymbolColors:l.hasSymbolVertexColors,hasVertexTangents:l.hasVertexTangents,ambient:_,diffuse:T,opacity:1,doubleSided:!0,doubleSidedType:"winding-order",cullFace:le.None,layerOpacity:this._getLayerOpacity(),hasSlicePlane:this._context.slicePlaneEnabled,initTextureTransparent:!0};h.mrrFactors=m?[...xe]:[l.metallic,l.roughness,_e[2]],r.material&&(h.doubleSided=r.material.doubleSided,h.cullFace=r.material.doubleSided?le.None:le.Back,h.textureAlphaCutoff=r.material.alphaCutoff),this._setExternalMaterialParameters(h),this._setMaterialTransparentParameter(h,c),this._setInternalMaterialParameters(l,h);const f=new pe(h);return c.material=f,this._materialInfoCache.set(l.uid,c),this._context.stage.add(f),f}_usePBR(){return this._context.physicalBasedRenderingEnabled}_setMaterialTransparentParameter(e,t){e.transparent=this.needsDrivenTransparentPass||t.isComponentTransparent||e.layerOpacity<1||e.opacity<1||e.externalColor&&e.externalColor[3]<1,"auto"===t.alphaMode?e.textureAlphaMode=e.transparent?ie.MaskBlend:ie.Opaque:e.textureAlphaMode="opaque"===t.alphaMode?ie.Opaque:"mask"===t.alphaMode?ie.Mask:ie.Blend}_addDebugNormals(e,t){const r=t.length,o=e.spatialReference.isGeographic?20015077/180:1,a=.1*Math.max(e.extent.width*o,e.extent.height*o,e.extent.zmax-e.extent.zmin),n=[],s=[],i=[],l=[];for(let p=0;p<r;p++){const e=t[p],r=e.vertexAttributes.get(fe.POSITION),o=e.vertexAttributes.get(fe.NORMAL),u=e.indices.get(fe.POSITION),c=e.indices.get(fe.NORMAL),m=r.data,d=o.data;for(let t=0;t<u.length;t++){const e=3*u[t],r=3*c[t];for(let t=0;t<3;t++)n.push(m[e+t]);for(let t=0;t<3;t++)n.push(m[e+t]+d[r+t]*a);if(s.push(s.length),s.push(s.length),t%3==0){this._calculateFaceNormal(m,u,t,je),this._getFaceVertices(m,u,t,Oe,we,Me),h(Oe,Oe,we),h(Oe,Oe,Me),f(Oe,Oe,1/3);for(let e=0;e<3;e++)i.push(Oe[e]);for(let e=0;e<3;e++)i.push(Oe[e]+je[e]*a);l.push(l.length),l.push(l.length)}}}const u=t[0].transformation,c=new ce(this._debugVertexNormalMaterial,[[fe.POSITION,new se(n,3,!0)]],[[fe.POSITION,s]],null,ue.Line);t.push(c),c.transformation=u;const m=new ce(this._debugFaceNormalMaterial,[[fe.POSITION,new se(i,3,!0)]],[[fe.POSITION,l]],null,ue.Line);m.transformation=u,t.push(m)}_createAs3DShape(e,t,r,o){const a=e.geometry;if("mesh"!==a.type)return null;const n=this._createGeometryInfo(a,t,o);if(null==n)return null;const{geometries:s,objectTransformation:i}=n;ne.DRAW_MESH_GEOMETRY_NORMALS&&this._addDebugNormals(a,s);const l=new me({geometries:s,layerUid:this._context.layer.uid,graphicUid:o});l.transformation=i;const u=re(this.symbolLayer,{opacity:this._getLayerOpacity()}),c=null!=u?new Q(s[0].material,[u],{mergeGeometries:!0,hasSlicePlane:this._context.slicePlaneEnabled}):null,m=new K(this,l,s,null,null,z,r,c);this._fastUpdateProcessor.onAddGraphic(),m.needsElevationUpdates=Y(r.mode),m.useObjectOriginAsAttachmentOrigin=!0,r.centerPointInElevationSR=this._getCenterPointInElevationSR(l.transformation);const{elevationProvider:h,renderCoordsHelper:f}=this._context,p=(e,t)=>Z(e,h,r,f,t);return m.alignedSampledElevation=z(m,r,h.spatialReference,p,f),m}_getCenterPointInElevationSR(e){const t=D(0,0,0,null!=this._context.elevationProvider.spatialReference?this._context.elevationProvider.spatialReference:null);return C([e[12],e[13],e[14]],this._context.renderCoordsHelper.spatialReference,t),t}_createComponentNormals(e,t,r,o){switch(r.shading||"flat"){default:case"source":return this._createComponentNormalsSource(e,t,r,o);case"flat":return this._createComponentNormalsFlat(e,o);case"smooth":return this._createComponentNormalsSmooth(e,o)}}_createComponentNormalsSource(e,t,r,o){if(null==t)return this._createComponentNormalsFlat(e,o);let a=!1;if(!r.trustSourceNormals)for(let n=0;n<o.length;n+=3){this._calculateFaceNormal(e,o,n,je);for(let e=0;e<3;e++){const r=3*o[n+e];Oe[0]=t[r],Oe[1]=t[r+1],Oe[2]=t[r+2],p(je,Oe)<0&&(t[r]=-t[r],t[r+1]=-t[r+1],t[r+2]=-t[r+2],a=!0)}}return new ve(t,o,a)}_createComponentNormalsFlat(e,t){const r=I(t.length),o=new Array(3*t.length);for(let a=0;a<t.length;a+=3){const n=this._calculateFaceNormal(e,t,a,je);for(let e=0;e<3;e++)r[a+e]=n[e],o[a+e]=a/3}return new ve(r,o,!1)}_createComponentNormalsSmooth(e,t){const r={};for(let n=0;n<t.length;n+=3){const o=this._calculateFaceNormal(e,t,n,je);for(let e=0;e<3;e++){const a=t[n+e];let s=r[a];s||(s={normal:b(),count:0},r[a]=s),h(s.normal,s.normal,o),s.count++}}const o=I(3*t.length),a=new Array(3*t.length);for(let n=0;n<t.length;n++){const e=r[t[n]];1!==e.count&&(d(e.normal,e.normal),e.count=1);for(let t=0;t<3;t++)o[3*n+t]=e.normal[t];a[n]=n}return new ve(o,a,!1)}_getFaceVertices(e,t,r,o,a,n){const s=3*t[r],i=3*t[r+1],l=3*t[r+2];o[0]=e[s],o[1]=e[s+1],o[2]=e[s+2],a[0]=e[i],a[1]=e[i+1],a[2]=e[i+2],n[0]=e[l],n[1]=e[l+1],n[2]=e[l+2]}_calculateFaceNormal(e,t,r,o){return this._getFaceVertices(e,t,r,Oe,we,Me),g(we,we,Oe),g(Me,Me,Oe),x(Oe,we,Me),d(o,Oe),o}_getOrCreateComponents(e){return e.components??Ee}_createPositionBuffer(e,t){let r=e.vertexAttributes.position;const o=t.reprojection===Fe.ECEF?t.transformBeforeProject:null;if(null!=o&&(r=S(new Float64Array(r.length),r,o)),t.reprojection===Fe.NONE)return t.needsBufferCopy?new Float64Array(r):r;const a=null!=o?r:new Float64Array(r.length);return O(r,e.spatialReference,0,a,this._context.renderCoordsHelper.spatialReference,0,r.length/3),a}_createNormalBuffer(e,t,r){let o=e.vertexAttributes.normal;if(null==o)return null;const a=r.reprojection===Fe.ECEF?r.transformBeforeProject:null;null!=a&&(o=L(o,new Float32Array(o.length),a));if("local"===this._context.graphicsCoreOwner.view.viewingMode||r.reprojection===Fe.NONE)return r.needsBufferCopy&&e.vertexAttributes.normal===o?new Float32Array(o):o;const n=e.vertexAttributes.position,s=null!=a?o:new Float32Array(o.length);return $(o,n,t,e.spatialReference,s)}_createTangentBuffer(e,t,r){let o=e.vertexAttributes.tangent;if(null==o)return null;const a=r.reprojection===Fe.ECEF?r.transformBeforeProject:null;null!=a&&(o=G(o,new Float32Array(o.length),a));if("local"===this._context.graphicsCoreOwner.view.viewingMode||r.reprojection===Fe.NONE)return r.needsBufferCopy&&e.vertexAttributes.normal===o?new Float32Array(o):o;const n=e.vertexAttributes.position,s=null!=a?o:new Float32Array(o.length);return V(o,n,t,e.spatialReference,s)}_createColorBuffer(e){return e.vertexAttributes.color}_createSymbolColorBuffer(e){if(this._requiresSymbolVertexColors()){const t=this._getVertexOpacityAndColor(e),r=oe(this.symbolLayer?.material?.colorMixMode),o=new Uint8Array(4);return ae(t,r,o),o}return null}_createBuffers(e,t){const r=e.vertexAttributes&&e.vertexAttributes.position;if(!r)return this.logger.warn("Mesh geometry must contain position vertex attributes"),null;const o=e.vertexAttributes.normal,a=e.vertexAttributes.uv,n=e.vertexAttributes.tangent;if(null!=o&&o.length!==r.length)return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"),null;if(null!=n&&n.length/4!=r.length/3)return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"),null;if(null!=a&&a.length/2!=r.length/3)return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"),null;const s=this._computeReprojectionInfo(e),i=this._createPositionBuffer(e,s),u=this._createColorBuffer(e),c=this._createSymbolColorBuffer(t),m=this._createNormalBuffer(e,i,s),h=this._createTangentBuffer(e,i,s);return{positionBuffer:i,normalBuffer:m,tangentBuffer:h,uvBuffer:a,colorBuffer:u,symbolColorBuffer:c,objectTransformation:s.reprojection===Fe.NONE&&null!=s.objectTransformation?s.objectTransformation:this._transformOriginLocal(e,i,m,h),geometryTransformation:s.reprojection===Fe.NONE&&null!=s.geometryTransformation?s.geometryTransformation:l()}}_computeReprojectionInfo(e){const{vertexSpace:t}=e,r=t.isRelative,o=t.isGeoreferenced?this._context.renderCoordsHelper.viewingMode===H.Local?Fe.NONE:Fe.ECEF:Fe.NONE;if(r){const{origin:r}=t,a=l(),i=e.transform?.localMatrix??u;if(o===Fe.NONE){v(e.spatialReference,r,a,this._context.renderCoordsHelper.spatialReference);return{reprojection:o,objectTransformation:a,geometryTransformation:c(i),needsBufferCopy:!1}}const m=n(l(),r);return s(m,m,i),{reprojection:o,transformBeforeProject:m,needsBufferCopy:!0}}return{reprojection:o,needsBufferCopy:!0}}_transformOriginLocal(e,t,a,n){const s=this._context.renderCoordsHelper.spatialReference,u=e.anchor;Ce[0]=u.x,Ce[1]=u.y,Ce[2]=u.z??0;const c=l();return v(e.spatialReference,Ce,c,s),i(Pe,c),S(t,t,Pe),null==a&&null==n||(r(Ae,c),o(Ae,Ae),null!=a&&U(a,a,Ae),null!=n&&U(n,n,Ae,4)),c}_validateFaces(e,t){const r=e.vertexAttributes.position.length/3,o=t.faces;if(o){let e=-1;for(let t=0;t<o.length;t++){const r=o[t];r>e&&(e=r)}if(r<=e)return this.logger.warn(`Vertex index ${e} is out of bounds of the mesh position buffer`),!1}else if(r%3!=0)return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"),!1;return!0}_getOrCreateFaces(e,t){return t.faces??R(e.vertexAttributes.position.length/3)}_isOutsideClippingArea(e){if(!this._context.clippingExtent)return!1;const t=e.vertexAttributes&&e.vertexAttributes.position;if(!t)return!1;const r=this._context.elevationProvider.spatialReference;let o;const a=t.length/3;return null==r||e.spatialReference.equals(r)?o=t:(o=new Float64Array(t.length),O(e.vertexAttributes.position,e.spatialReference,0,o,r,0,a)),j(Re),P(Re,o,0,a),!A(Re,this._context.clippingExtent)}_createGeometryInfo(e,t,r){if(!w(e.spatialReference,this._context.graphicsCoreOwner.view.spatialReference))return this.logger.warn("Geometry spatial reference is not compatible with the view"),null;if(this._isOutsideClippingArea(e))return null;const o=this._createBuffers(e,t);if(null==o)return null;const{positionBuffer:a,uvBuffer:n,colorBuffer:s,symbolColorBuffer:i,normalBuffer:l,tangentBuffer:u,objectTransformation:c,geometryTransformation:m}=o,h=this._getOrCreateComponents(e),f=new Array;let p=!1;for(const d of h){if(!this._validateFaces(e,d))return null;const t=this._getOrCreateFaces(e,d);if(0===t.length)continue;const o=this._createComponentNormals(a,l,d,t);o.didFlipNormals&&(p=!0);const c=[[fe.POSITION,new se(a,3,!0)],[fe.NORMAL,new se(o.normals,3,!0)]],h=[[fe.POSITION,t],[fe.NORMAL,o.indices]];null!=s&&(c.push([fe.COLOR,new se(s,4,!0)]),h.push([fe.COLOR,t])),null!=i&&(c.push([fe.SYMBOLCOLOR,new se(i,4,!0)]),h.push([fe.SYMBOLCOLOR,E(t.length)])),null!=n&&(c.push([fe.UV0,new se(n,2,!0)]),h.push([fe.UV0,t])),null!=u&&(c.push([fe.TANGENT,new se(u,4,!0)]),h.push([fe.TANGENT,t]));const g=this._context.stage.renderView.getObjectAndLayerIdColor({graphicUid:r,layerUid:this._context.layer.uid}),x=this._getOrCreateMaterial(e,d),_=new ce(x,c,h,null,ue.Mesh,g);_.transformation=m,f.push(_)}return p&&this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."),{geometries:f,objectTransformation:c}}_updateMaterialParameters(e){this._materialInfoCache.forEachMaterialInfo(e),this._fastUpdateProcessor.forEachMaterialInfo(e),this._fastUpdateProcessor.forEachClonedMaterial(((e,t)=>{t.setParameters(e.parameters)}))}test(){return{...super.test(),materials:this._materialInfoCache.materials}}}class ve{constructor(e,t,r){this.normals=e,this.indices=t,this.didFlipNormals=r}}const Ce=b(),Oe=b(),we=b(),Me=b(),je=b(),Pe=l(),Ae=a(),Ie=l(),Re=M(),Ee=[new N],Ne=new B;var Fe;!function(e){e[e.NONE=0]="NONE",e[e.ECEF=1]="ECEF"}(Fe||(Fe={}));export{ye as Graphics3DMeshFillSymbolLayer};
