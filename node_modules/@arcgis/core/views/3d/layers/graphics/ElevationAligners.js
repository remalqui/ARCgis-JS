/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{c as t}from"../../../../chunks/mat4.js";import{c as e}from"../../../../chunks/mat4f64.js";import{s as n}from"../../../../chunks/vec3.js";import{c as o}from"../../../../chunks/vec3f64.js";import{computeTranslationToOriginAndRotation as a,projectBuffer as r}from"../../../../geometry/projection.js";import{SampleElevationInfo as s}from"./elevationAlignmentUtils.js";import{updateVertexAttributeAuxpos1w as i}from"./graphicUtils.js";import l from"../../support/debugFlags.js";import{SamplePosition as c}from"../../support/ElevationProvider.js";import{isGeometryWithMapPositions as m}from"../../webgl-engine/lib/GeometryWithMapPositions.js";import{VertexAttribute as f}from"../../webgl-engine/lib/VertexAttribute.js";function u(t,e,n,o,a){const r=t.stageObject,s=r.geometries;let i=0;for(const l of s){if(!m(l))continue;const{update:t,averageGeometrySampledElevation:s}=A(l,e,n,o,a);i+=s,t&&r.geometryVertexAttrsUpdated(l)}return i/s.length}function p(e,o,r,s,c,m){const f=e.stageObject,u=o.centerPointInElevationSR;let p=0;if(f.usesVerticalDistanceToGround)s(u,M),i(f,M.verticalDistanceToGround),p=M.sampledElevation;else{s(u,M);"absolute-height"!==o.mode&&(p=M.sampledElevation)}const g=t(d,m??f.transformation),I=n(E,g[12],g[13],g[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=u.x,T[1]=u.y,T[2]=M.z,a(u.spatialReference,T,g,c.spatialReference)&&(m?t(m,g):f.transformation=g)):c.setAltitudeOfTransformation(M.z,g);const h=b/c.unitInMeters;return(Math.abs(g[12]-I[0])>=h||Math.abs(g[13]-I[1])>=h||Math.abs(g[14]-I[2])>=h)&&(m?t(m,g):f.transformation=g),p}const d=e();function g(t,e,o,r,s){const i=t.graphics3DSymbolLayer.lodRenderer;if(null==i)return 0;const c=e.centerPointInElevationSR;r(c,M);const m="absolute-height"!==e.mode?M.sampledElevation:0,f=i.instanceData,u=t.instanceIndex,p=v;f.getGlobalTransform(u,p);const d=n(E,p[12],p[13],p[14]);l.TESTS_DISABLE_OPTIMIZATIONS?(T[0]=c.x,T[1]=c.y,T[2]=M.z,a(c.spatialReference,T,p,s.spatialReference)&&f.setGlobalTransform(u,p)):s.setAltitudeOfTransformation(M.z,p);const g=b/s.unitInMeters;return(l.TESTS_DISABLE_OPTIMIZATIONS||Math.abs(p[12]-d[0])>=g||Math.abs(p[13]-d[1])>=g||Math.abs(p[14]-d[2])>=g)&&f.setGlobalTransform(u,p),m}function I(t,e,n,o,a){const r=t.stageObject,s=r.geometries;if(0===s.length)return 0;let i=0,l=null,c=0,u=!1;for(const p of s){if(!m(p))continue;const t=p.vertexAttributes.get(f.POSITION);if(t!==l){const{update:r,averageGeometrySampledElevation:s}=A(p,e,n,o,a);c=s,l=t,u=r}u&&r.geometryVertexAttrsUpdated(p),i+=c}return i/s.length}const b=.01,T=o(),h=o(),S=o(),v=e(),E=o(),M=new s;function A(t,e,n,o,a){let s=!1;const i=t.shaderTransformation,m=e.requiresSampledElevationInfo;h[0]=i[12],h[1]=i[13],h[2]=i[14],t.invalidateBoundingInfo();const u=t.getMutableAttribute(f.POSITION),p=u.data,d=u.size,g=p.length/d,I=new c(t.mapPositions,n);let v=0,E=0;for(let c=0;c<g;c++){if(S[0]=p[v],S[1]=p[v+1],S[2]=p[v+2],o(I,M),m&&(E+=M.sampledElevation),l.TESTS_DISABLE_OPTIMIZATIONS)p[v]=I.array[I.offset],p[v+1]=I.array[I.offset+1],p[v+2]=M.z,r(p,n,v,p,a.spatialReference,v,1),p[v]-=h[0],p[v+1]-=h[1],p[v+2]-=h[2],s=!0;else{T[0]=p[v]+h[0],T[1]=p[v+1]+h[1],T[2]=p[v+2]+h[2],a.setAltitude(T,M.z),p[v]=T[0]-h[0],p[v+1]=T[1]-h[1],p[v+2]=T[2]-h[2];const t=b/a.unitInMeters;(Math.abs(S[0]-p[v])>=t||Math.abs(S[1]-p[v+1])>=t||Math.abs(S[2]-p[v+2])>=t)&&(s=!0)}v+=d,I.offset+=3}return E/=g,{update:s,averageGeometrySampledElevation:E}}export{g as perLodInstanceElevationAligner,p as perObjectElevationAligner,u as perVertexElevationAligner,I as sharedGeometryElevationAligner};
