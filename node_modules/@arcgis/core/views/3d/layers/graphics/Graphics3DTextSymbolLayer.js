/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{isPromiseLike as t}from"../../../../core/promiseUtils.js";import{pt2px as r}from"../../../../core/screenUtils.js";import{f as n,Z as s,a as i}from"../../../../chunks/vec2f64.js";import{hasCalloutSupport as o,textSymbolLayerSupportsVerticalOffset as l}from"../../../../symbols/callouts/calloutUtils.js";import{CreateLabelParameters as a}from"./CreateLabelParameters.js";import{perObjectElevationAligner as c}from"./ElevationAligners.js";import{SymbolUpdateType as m,needsElevationUpdates2D as h}from"./elevationAlignmentUtils.js";import{ElevationContext as u}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as d}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DObjectMetadata as p}from"./Graphics3DObjectMetadata.js";import{Graphics3DSymbolLayer as f}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as g}from"./graphicUtils.js";import{verticalPlacementFromAlignment as y,textRenderAlignmentFromHorizontalPlacement as x,horizontalPlacementToAnchorX as b,anchorFromPlacements as v,namedAnchorToHUDMaterialAnchorPos as P}from"./placementUtils.js";import{placePointOnGeometry as O,createStageObject as j,extendPointGraphicElevationContext as w}from"./pointUtils.js";import{createPointGeometry as S}from"../../webgl-engine/lib/GeometryUtil.js";import{TextRenderParameters as _}from"../../webgl-engine/lib/TextRenderParameters.js";import E from"../../webgl-engine/lib/TextTextureFactory.js";import{HUDMaterial as L}from"../../webgl-engine/materials/HUDMaterial.js";const z=[0,0,1];class C extends f{constructor(e,t,r,n){super(e,t,r,n),this._elevationOptions={supportsOffsetAdjustment:!0,supportsOnTheGround:!1},this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=g(this.symbolLayer.size);if(t)throw new e("graphics3dtextsymbollayer:invalid-size",t)}await this._createTextRenderParameters()}async _createTextRenderParameters(){const e=this._context.graphicsCoreOwner.view.state.rasterPixelRatio;this._textRenderParameters=await _.fromSymbol(this.symbolLayer,e)}destroy(){super.destroy()}createGraphics3DGraphic(e){const t=e.graphic,r=O(t.geometry);if(null==r)return this.logger.warn(`unsupported geometry type for text symbol: ${t.geometry.type}`),null;const n=this.symbolLayer.text;if(null==n||""===n)return null;const s=o(this.symbol)&&this.symbol.hasVisibleVerticalOffset()?this.symbol.verticalOffset:null;if(null!=s&&!l(this.symbolLayer))return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`),null;const i=new a(s,this.symbolLayer.horizontalAlignment,y(this.symbolLayer.verticalAlignment));return this._createAs3DShape(t,r,n,i)}createLabel(e,t,r,n){const s=e.graphic,i=O(s.geometry);if(null==i)return this.logger.warn(`unsupported geometry type for label: ${s.geometry.type}`),null;const o=t.text;return!o||/^\s+$/.test(o)?null:this._createAs3DShape(s,i,o,t,r,n)}setGraphicElevationContext(e,t,r=0){const n=super.setGraphicElevationContext(e,t);return n.addOffsetRenderUnits(r),n}layerOpacityChanged(){return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"),!1}layerElevationInfoChanged(e,t){return G(e,t,((e,t)=>{this.updateGraphicElevationContext(t,e)})),m.UPDATE}slicePlaneEnabledChanged(e,t){return G(e,t,(e=>{for(const t of e.stageObject.geometries)t.material.setParameters({hasSlicePlane:this._context.slicePlaneEnabled})})),!0}physicalBasedRenderingChanged(){return!0}get pixelRatioChanged(){return!1}updateGraphicElevationContext(e,t){const r=t.elevationContext;this.setGraphicElevationContext(e,r,null!=t.metadata?t.metadata.elevationOffset:0),t.needsElevationUpdates=h(r.mode)||"absolute-height"===r.mode}_defaultElevationInfoNoZ(){return U}_createAs3DShape(e,o,l,a,m,f){const g=this.setGraphicElevationContext(e,new u,a.elevationOffset),y="polyline"===e.geometry?.type,b=e.uid;let v=null,P=null;if(null==f){const e=x(a.horizontalPlacement);v=new E(l,e,this._textRenderParameters);let r=null;if(null!=this._context.sharedResources.textures){P=this._context.sharedResources.textures.fromData(v.key,(()=>v.create()),(()=>{null!=r&&r.release()}));const e=this._context.stage.renderView.textureRepository.acquire(P.texture.id);if(null==e||t(e))return P.release(),null;r=e}}const O=R(v,a),_={occlusionTest:!0,screenOffset:a.screenOffset,anchorPosition:O,polygonOffset:!0,color:[1,1,1,1],centerOffsetUnits:a.centerOffsetUnits,drawInSecondSlot:!0};if(null!=f?_.textureId=f.id:null!=P&&(_.textureId=P.texture.id),null!=a.verticalOffset){const{screenLength:e,minWorldLength:t,maxWorldLength:n}=a.verticalOffset;_.verticalOffset={screenLength:r(e),minWorldLength:t||0,maxWorldLength:null!=n?n:1/0}}if(this._context.screenSizePerspectiveEnabled){const{screenSizePerspectiveSettings:e,screenSizePerspectiveSettingsLabels:t}=this._context.sharedResources;_.screenSizePerspective=t.overridePadding(this._textRenderParameters.haloSize+this._textRenderParameters.definition.background.padding[0]),_.screenSizePerspectiveAlignment=e}let C;if(y&&(_.shaderPolygonOffset=1e-4),_.hasSlicePlane=this._context.slicePlaneEnabled,null!=m){const e=JSON.stringify(_);C=m.get(e),null==C&&(C=new L(_),m.add(e,C))}else C=new L(_);const G=a.translation,U=v?n(v.displayWidth,v.displayHeight):s,D=a.centerOffset,A=S(C,z,G,null,U,D,[0,0],null),T=j(this._context,o,A,g,b);if(null==T)return null;const W=new d(this,T.object,[A],null==m?[C]:null,P,c,g);W.alignedSampledElevation=T.sampledElevation,W.needsElevationUpdates=h(g.mode)||"absolute-height"===g.mode;const{displayWidth:I,displayHeight:k}=null!=v?v:a;W.getScreenSize=(e=i())=>(e[0]=I,e[1]=k,e);const $=new p(a.elevationOffset,l);return W.metadata=$,w(W,o,this._context.elevationProvider),W}}function G(e,t,r){e&&e.forEach((e=>{const n=t(e);null!=n&&r(n,e.graphic)}))}function R(e,t){if("baseline"===t.verticalPlacement){const r=b[t.horizontalPlacement],s=null!=e?e.baselineAnchorY:0;return n(r,s)}const r=v(t.horizontalPlacement,t.verticalPlacement);return P[r]}const U={mode:"relative-to-ground",offset:0};export{C as Graphics3DTextSymbolLayer};
