/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import e from"../../../../request.js";import{result as t}from"../../../../core/asyncUtils.js";import{estimateNestedObjectSize as r}from"../../../../core/byteSizeEstimations.js";import n from"../../../../core/Error.js";import s from"../../../../core/Logger.js";import{NestedMap as a}from"../../../../core/NestedMap.js";import{throwIfAbortError as o}from"../../../../core/promiseUtils.js";import{Version as i}from"../../../../core/Version.js";import{g as l}from"../../../../chunks/vec3f64.js";import{empty as u,expandWithVec3 as c}from"../../../../geometry/support/aaBoundingBox.js";import{requestImage as p}from"../../../../support/requestImageUtils.js";import{Attribute as m}from"../../webgl-engine/lib/Attribute.js";import{CullFaceOptions as f,AlphaDiscardMode as d}from"../../webgl-engine/lib/basicInterfaces.js";import{Geometry as g}from"../../webgl-engine/lib/Geometry.js";import{Texture as y}from"../../webgl-engine/lib/Texture.js";import{VertexAttribute as b}from"../../webgl-engine/lib/VertexAttribute.js";import{DefaultMaterial as w}from"../../webgl-engine/materials/DefaultMaterial.js";import{TextureWrapMode as x}from"../../../webgl/enums.js";const h=s.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");async function v(e,t){const n=await A(e,t),s=await T(n.textureDefinitions??{},t);let a=0;for(const r in s)if(s.hasOwnProperty(r)){const e=s[r];a+=e?.image?e.image.width*e.image.height*4:0}return{resource:n,textures:s,size:a+r(n)}}async function A(r,n){const s=null!=n&&n.streamDataRequester;if(s)return j(r,s,n);const a=await t(e(r,n));if(!0===a.ok)return a.value.data;o(a.error),M(a.error)}async function j(e,r,n){const s=await t(r.request(e,"json",n));if(!0===s.ok)return s.value;o(s.error),M(s.error.details.url)}function M(e){throw new n("",`Request for object resource failed: ${e}`)}function P(e){const t=e.params,r=t.topology;let n=!0;switch(t.vertexAttributes||(h.warn("Geometry must specify vertex attributes"),n=!1),t.topology){case"PerAttributeArray":break;case"Indexed":case null:case void 0:{const e=t.faces;if(e){if(t.vertexAttributes)for(const r in t.vertexAttributes){const t=e[r];t&&t.values?(null!=t.valueType&&"UInt32"!==t.valueType&&(h.warn(`Unsupported indexed geometry indices type '${t.valueType}', only UInt32 is currently supported`),n=!1),null!=t.valuesPerElement&&1!==t.valuesPerElement&&(h.warn(`Unsupported indexed geometry values per element '${t.valuesPerElement}', only 1 is currently supported`),n=!1)):(h.warn(`Indexed geometry does not specify face indices for '${r}' attribute`),n=!1)}}else h.warn("Indexed geometries must specify faces"),n=!1;break}default:h.warn(`Unsupported topology '${r}'`),n=!1}e.params.material||(h.warn("Geometry requires material"),n=!1);const s=e.params.vertexAttributes;for(const a in s){s[a].values||(h.warn("Geometries with externally defined attributes are not yet supported"),n=!1)}return n}function I(e,t){const r=new Array,n=new Array,s=new Array,o=new a,u=e.resource,c=i.parse(u.version||"1.0","wosr");O.validate(c);const p=u.model.name,d=u.model.geometries,x=u.materialDefinitions??{},h=e.textures;let v=0;const A=new Map;for(let a=0;a<d.length;a++){const e=d[a];if(!P(e))continue;const i=k(e),u=e.params.vertexAttributes,c=[];for(const t in u){const e=u[t],r=e.values;c.push([t,new m(r,e.valuesPerElement,!0)])}const p=[];if("PerAttributeArray"!==e.params.topology){const t=e.params.faces;for(const e in t)p.push([e,t[e].values])}const j=i.texture,M=h&&h[j];if(M&&!A.has(j)){const{image:e,parameters:t}=M,r=new y(e,t);n.push(r),A.set(j,r)}const I=A.get(j),U=I?I.id:void 0,T=i.material;let O=o.get(T,j);if(null==O){const e=x[T.substring(T.lastIndexOf("/")+1)].params;1===e.transparency&&(e.transparency=0);const r=M&&M.alphaChannelUsage,n=e.transparency>0||"transparency"===r||"maskAndTransparency"===r,s=M?E(M.alphaChannelUsage):void 0,a={ambient:l(e.diffuse),diffuse:l(e.diffuse),opacity:1-(e.transparency||0),transparent:n,textureAlphaMode:s,textureAlphaCutoff:.33,textureId:U,initTextureTransparent:!0,doubleSided:!0,cullFace:f.None,colorMixMode:e.externalColorMixMode||"tint",textureAlphaPremultiplied:M?.parameters.preMultiplyAlpha??!1};null!=t&&t.materialParamsMixin&&Object.assign(a,t.materialParamsMixin),O=new w(a),o.set(T,j,O)}s.push(O);const q=new g(O,c,p);v+=p.find((e=>e[0]===b.POSITION))?.[1].length??0,r.push(q)}return{engineResources:[{name:p,stageResources:{textures:n,materials:s,geometries:r},pivotOffset:u.model.pivotOffset,numberOfVertices:v,lodThreshold:null}],referenceBoundingBox:U(r)}}function U(e){const t=u();return e.forEach((e=>{const r=e.boundingInfo;null!=r&&(c(t,r.bbMin),c(t,r.bbMax))})),t}async function T(e,t){const r=new Array;for(const a in e){const n=e[a],s=n.images[0].data;if(!s){h.warn("Externally referenced texture data is not yet supported");continue}const o=n.encoding+";base64,"+s,i="/textureDefinitions/"+a,l="rgba"===n.channels?n.alphaChannelUsage||"transparency":"none",u={noUnpackFlip:!0,wrap:{s:x.REPEAT,t:x.REPEAT},preMultiplyAlpha:E(l)!==d.Opaque},c=null!=t&&t.disableTextures?Promise.resolve(null):p(o,t);r.push(c.then((e=>({refId:i,image:e,parameters:u,alphaChannelUsage:l}))))}const n=await Promise.all(r),s={};for(const a of n)s[a.refId]=a;return s}function E(e){switch(e){case"mask":return d.Mask;case"maskAndTransparency":return d.MaskBlend;case"none":return d.Opaque;default:return d.Blend}}function k(e){const t=e.params;return{id:1,material:t.material,texture:t.texture,region:t.texture}}const O=new i(1,2,"wosr");export{T as createTextureResources,v as load,I as processLoadResult};
