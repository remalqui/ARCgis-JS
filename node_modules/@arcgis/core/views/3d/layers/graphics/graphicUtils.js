/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{getMetersPerUnitForSR as t}from"../../../../core/unitUtils.js";import{o as e,r as n,n as r}from"../../../../chunks/mat4.js";import{c as o}from"../../../../chunks/mat4f64.js";import{g as i,O as s}from"../../../../chunks/vec3f64.js";import{s as l}from"../../../../chunks/vec4.js";import{d as u,O as a}from"../../../../chunks/vec4f64.js";import{projectPoint as m}from"../../../../geometry/projection.js";import{width as c,depth as f,height as p}from"../../../../geometry/support/aaBoundingBox.js";import{create as h}from"../../../../geometry/support/aaBoundingRect.js";import{ringsCentroid as g}from"../../../../geometry/support/centroid.js";import{getPointOnPath as y,getPathLength as d}from"../../../../geometry/support/coordsUtils.js";import{makeDehydratedPoint as x}from"../../../../layers/graphics/dehydratedFeatures.js";import{isHydratedGeometry as j,clonePoint as b}from"../../../../layers/graphics/hydratedFeatures.js";import{VertexAttribute as v}from"../../webgl-engine/lib/VertexAttribute.js";function w(t,e){if("point"===t.type)return R(t,e,!1);if(j(t))switch(t.type){case"extent":return R(t.center,e,!1);case"polygon":return R(t.centroid,e,!1);case"polyline":return R(z(t),e,!0);case"mesh":return R(t.origin,e,!1)}else switch(t.type){case"extent":return R(A(t),e,!0);case"polygon":return R(M(t),e,!0);case"polyline":return R(z(t),e,!0)}}function z(t){const e=t.paths[0];if(!e||0===e.length)return null;const n=y(e,d(e)/2);return x(n[0],n[1],n[2],t.spatialReference)}function A(t){return x(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),null!=t.zmin&&null!=t.zmax&&isFinite(t.zmin)&&isFinite(t.zmax)?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}function M(t){const e=t.rings[0];if(!e||0===e.length)return null;const n=g(t.rings,!!t.hasZ);return x(n[0],n[1],n[2],t.spatialReference)}function R(t,e,n){const r=n?t:b(t);return e&&t?m(t,r,e)?r:null:r}function F(t,e,n,r=0){if(t){e||(e=h());const o=t;let i=.5*o.width*(n-1),s=.5*o.height*(n-1);return o.width<1e-7*o.height?i+=s/20:o.height<1e-7*o.width&&(s+=i/20),l(e,o.xmin-i-r,o.ymin-s-r,o.xmax+i+r,o.ymax+s+r),e}return null}function P(t,e){for(let n=0;n<t.geometries.length;++n){const r=t.geometries[n].getMutableAttribute(v.AUXPOS1);r&&r.data[3]!==e&&(r.data[3]=e,t.geometryVertexAttrsUpdated(t.geometries[n]))}}function k(t,e,n=null){const r=u(a);return null!=t&&(r[0]=t[0],r[1]=t[1],r[2]=t[2]),null!=e?r[3]=e:null!=t&&t.length>3&&(r[3]=t[3]),n&&(r[0]*=n,r[1]*=n,r[2]*=n,r[3]*=n),r}function U(t,e,n,r,o,i=[0,0,0,0]){for(let s=0;s<3;++s)null!=t&&null!=t[s]?i[s]=t[s]:null!=n&&null!=n[s]?i[s]=n[s]:i[s]=o[s];return i[3]=null!=e?e:null!=r?r:o[3],i}function B(t=s,e,n,r=1){const o=new Array(3);if(null==e||null==n)o[0]=1,o[1]=1,o[2]=1;else{let r,i=0;for(let s=2;s>=0;s--){const l=t[s];let u;const a=null!=l,m=0===s&&!r&&!a,c=n[s];"symbol-value"===l||m?u=0!==c?e[s]/c:1:a&&"proportional"!==l&&isFinite(l)&&(u=0!==c?l/c:1),null!=u&&(o[s]=u,r=u,i=Math.max(i,Math.abs(u)))}for(let t=2;t>=0;t--)null==o[t]?o[t]=r:0===o[t]&&(o[t]=.001*i)}for(let i=2;i>=0;i--)o[i]/=r;return i(o)}function D(t){return null!=t.isPrimitive}function I(t){return O(D(t)?[t.width,t.depth,t.height]:t)?null:"Symbol sizes may not be negative values"}function O(t){const e=t=>null==t||t>=0;return Array.isArray(t)?t.every(e):e(t)}function S(t,i,s,l=o()){return t&&e(l,l,-t/180*Math.PI),i&&n(l,l,i/180*Math.PI),s&&r(l,l,s/180*Math.PI),l}function V(e,n,r){if(null!=r.minDemResolution)return r.minDemResolution;const o=t(n),i=c(e)*o,s=f(e)*o,l=p(e)*(n.isGeographic?1:o);return 0===i&&0===s&&0===l?r.minDemResolutionForPoints:.01*Math.max(i,s,l)}export{w as computeCentroid,S as computeObjectRotation,B as computeObjectScale,V as demResolutionForBoundingBox,F as enlargeExtent,O as isValidSize,k as mixinColorAndOpacity,U as overrideColor,P as updateVertexAttributeAuxpos1w,I as validateSymbolLayerSize};
