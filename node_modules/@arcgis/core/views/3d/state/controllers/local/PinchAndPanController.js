/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{createScreenPointArray as e,screenPointObjectToArray as n}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/Error.js";import{subclass as o}from"../../../../../core/accessorSupport/decorators/subclass.js";import{d as s}from"../../../../../chunks/vec2.js";import{o as r,c as a,e as m,b as h,l as c,n as l,g as p,a as _}from"../../../../../chunks/vec3.js";import{c as u,f as d}from"../../../../../chunks/vec3f64.js";import{wrapAxisAngle as C}from"../../../../../geometry/support/axisAngle.js";import{create as g,fromNormalAndOffset as M,setOffsetFromPoint as v,negate as b,normal as f}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as w,applyAll as j}from"../../../camera/constraintUtils.js";import{ConstraintTypes as E}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as P}from"../../../camera/constraintUtils/InteractionType.js";import{TiltMode as S}from"../../../camera/constraintUtils/TiltMode.js";import{ExponentialFalloff as V}from"../../../input/util.js";import{InteractiveController as z}from"../InteractiveController.js";import{PanPlanarMomentumController as H}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as O}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as y}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as T,contentIntersectorOptions as A,PAN_DISTANCE_MODIFIER as F,MIN_HEIGHT_LIMIT as L,SCREEN_PIXEL_AREA as U,centroid as x,applyZoomToPoint as R,applyPanPlanar as D,normalizeRotationDelta as N,applyRotation as k,intersectPlaneFromScreenPointAtEye as I}from"../../utils/navigationUtils.js";import{Camera as G}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as Z}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as B}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as W}from"../../../../navigation/ZoomMomentumEstimator.js";const q=d(0,0,1),J={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI};let K=class extends z{constructor(){super(...arguments),this._rotationValueSmooth=new V(.05),this._scalingValueSmooth=new V(.05),this._planeHorizontal=g(),this._planeVertical=g(),this._rotationMomentumEstimator=new B,this._panMomentumEstimator=new Z(300,12,.9),this._zoomMomentumEstimator=new W,this._beginRadius=0,this._beginCenter=u(),this._beginAngle=0,this._tmpPoints=[],this._panMode=T.Horizontal,this._beginCenterScreen=e(),this._tmpCentroid3d=u(),this._tmpCentroid2d=e(),this._tmp2d=e(),this._pointerCount=0,this._constraintOptions={selection:E.ALL,interactionType:P.NONE,interactionFactor:0,interactionStartCamera:new G,interactionDirection:null,tiltMode:S.TUMBLE}}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=e,this._rotationMomentumEstimator.enabled=e,this._panMomentumEstimator.enabled=e,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),n(t.center,this._beginCenterScreen),M(q,0,this._planeHorizontal);const o=u(),s=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,o,0===this.view.map.ground.opacity?A:{}),d=u();r(d,this.startCamera.viewForward);const C=u();a(C,q);const g=m(d,C),w=i(g<0?-g:g);this._panMode=w>=J.ANGLE_THRESHOLD?T.Horizontal:T.Vertical;const j=Math.min(F,1/Math.abs(m(C,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),L);v(this._planeHorizontal,this._planeHorizontal,o),this.startCamera.aboveGround||b(this._planeHorizontal,this._planeHorizontal);const E=u(),P=u(),S=u();h(E,o,this.currentCamera.eye);const V=c(E);if(l(E,E),this._panMode===T.Vertical){p(C,C,g),h(this._planeVertical,d,C),l(this._planeVertical,this._planeVertical),v(this._planeVertical,this._planeVertical,o);const i=this.view._stage.renderView.getMinimalDepthForArea(this.view.voxelWasm,this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,U);let e=null!=i?i:j;e=s?Math.min(e,V):e,a(S,_(P,this.currentCamera.eye,p(P,E,e))),this._planeVertical[3]=-m(this._planeVertical,S),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),x(this._tmpPoints,this._beginCenter)}else{const i=s?V:j;a(S,_(P,this.currentCamera.eye,p(P,E,i))),this._planeHorizontal[3]=-m(f(this._planeHorizontal),S),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),x(this._tmpPoints,this._beginCenter)}this._constraintOptions.interactionStartCamera?.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this._panMode===T.Horizontal?this._planeHorizontal:this._planeVertical,o=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),R(this.currentCamera,o,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=P.ZOOM,this._constraintOptions.interactionFactor=w(Math.abs(t.radius-this._beginRadius)),j(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,e,this.currentCamera,this._tmpPoints),x(this._tmpPoints,this._tmpCentroid3d),n(t.center,this._tmpCentroid2d),D(this.currentCamera,o,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=P.PAN,this._constraintOptions.interactionFactor=w(s(this._beginCenterScreen,this._tmpCentroid2d)),j(this.view,this.currentCamera,this._constraintOptions),i){const i=this._planeHorizontal,e=o,n=this._rotationValueSmooth.value,s=n+N(t.angle-n),r=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=r,this._rotationValueSmooth.update(s);const a=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(a,.001*t.timestamp),k(this.currentCamera,e,C(i,a)),this._constraintOptions.interactionType=P.TUMBLE,this._constraintOptions.interactionFactor=w(Math.abs(t.radius*a)),j(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new y({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new O({view:this.view,momentum:e,center:this._beginCenter,axis:f(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new H({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const o=this._tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=u()),I(i,e,o,n[s]),s+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};K=t([o("esri.views.3d.state.controllers.local.PinchAndPanController")],K);export{K as PinchAndPanController};
