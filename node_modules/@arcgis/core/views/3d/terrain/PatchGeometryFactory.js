/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{isPowerOfTwo as t,clamp as e}from"../../../core/mathUtils.js";import{s as n}from"../../../chunks/vec4.js";import{empty as o}from"../../../geometry/support/aaBoundingBox.js";import{fromValues as s}from"../../../geometry/support/aaBoundingRect.js";import{sampleElevation as r}from"./ElevationData.js";import{PatchType as i}from"./interfaces.js";import{NeighborIndex as a}from"./ITile.js";import{acquireTerrainAttributes as l,minMaxBoundingBox as c,encodeUVInBuffer as u,EdgeDescriptor as f}from"./PatchGeometry.js";import{PatchGeometryLUT as d}from"./PatchGeometryLUT.js";import{neighborTileIfLoadedOrSelf as m}from"./PatchRenderData.js";import{ENABLE_TERRAIN_INTERNAL_CHECKS as g,internalAssert as p,neighborEdgeIndices as h,almostEquals as M}from"./terrainUtils.js";import{isCornerNeighbor as x}from"./Tile.js";import{compareTilesByLij as y}from"./tileUtils.js";import{compressNormal as S}from"../webgl-engine/lib/Normals.js";const b=65536;function v(t,e){const n=t.tile,{extent:s,extentInRadians:r,surface:a}=n,f=t.localOrigin,d=t.geometryState,m=a.isWebMercator,h=d.numVerticesPerSide,M=h-1,x=(h-2)**2,y=m&&(e===i.HAS_SOUTH_POLE||e===i.HAS_BOTH_POLES),b=m&&(e===i.HAS_NORTH_POLE||e===i.HAS_BOTH_POLES),v=6,L=((y?1:0)+(b?1:0))*v*(M+1),R=d.neighborData,T=R.edgeResolutions.reduce(((t,e)=>t+e+1),0),D=l(x+L+T),A=t.geometry;A.numVerticesPerSide=d.numVerticesPerSide,A.vertexAttributes=D;const V=A.boundingBox;o(V);const U=E(t);X.update(M,r,U),B(t),k(t,x),O(t);const C=[];if((()=>{let t=x+T;const e=f[0],o=f[1],r=f[2],i=n.ellipsoid.radius,a=s[1],l=s[3],d=(n,s)=>{const f=s*h;c(-e,-o,n*i-r,V),C.push({connectedRowOffset:f,connectedOuterEdgeOffset:1===n?0:2,rowOffset:t,latitudeResolution:v});const d=P(-1===n?a:l,i),m=n*Math.PI/2-d,g=.99*(1===n?1:-1),p=i+0,x=D.position,y=D.uv0,{typedBuffer:b,typedBufferStride:B}=D.normalCompressed;for(let i=1;i<=v;++i){const n=d+m*(i/v),s=Math.cos(n),a=Math.sin(n);for(let i=0;i<=M;i++){const n=i/M,l=X.sinLonLUT[i],f=X.cosLonLUT[i]*s,d=l*s,m=a,h=f*p-e,v=d*p-o,L=m*p-r;c(h,v,L,V),x.setValues(t,h,v,L),u(y,t,n,g),S(b,t,f,d,m,B),++t}}};y&&d(-1,0),b&&d(1,M)})(),F(A,d.numVerticesPerSide,C,[0,h-1],[0,h-1],d.wireframe),t.intersectionData=null,g)for(let o=0;o<4;++o)p(A.outerEdges[o].count===R.edgeResolutions[o]+1)}function B(t){const e=t.tile;if(!e.intersectsClippingArea)return;const n=t.geometryState,o=n.numVerticesPerSide,s=o-2,i=o-1,a=t.geometry,l=a.vertexAttributes,f=l.position,d=l.uv0,{typedBuffer:m,typedBufferStride:g}=l.normalCompressed,p=e.extent,h=p[0],M=p[2],x=p[1],y=p[3],b=e.ellipsoid.radius,v=n.samplerData,B=t.localOrigin,L=B[0],R=B[1],O=B[2],T=f.typedBuffer,D=f.typedBufferStride,P=1/i,A=a.boundingBox;let V=0;if(1<=s){const t=P,e=x*(1-t)+y*t,n=X.sinLatLUT[1],o=X.cosLatLUT[1];for(let i=1;i<=s;i++){const s=i*P,a=h*(1-s)+M*s,l=X.sinLonLUT[i],f=X.cosLonLUT[i],m=b+r(a,e,v),g=m*f*o-L,p=m*l*o-R,x=m*n-O;c(g,p,x,A);const y=(i-1)*D;T[y]=g,T[y+1]=p,T[y+2]=x,u(d,i-1,s,t)}}for(let E=1;E<=s;E++){const t=E*P,e=x*(1-t)+y*t,n=X.sinLatLUT[E],o=X.cosLatLUT[E],a=E+1,l=a*P,f=x*(1-l)+y*l,p=X.sinLatLUT[a],B=X.cosLatLUT[a],U=X.sinLonLUT[0],C=X.cosLonLUT[0],I=b+r(h,e,v);let j=C*o*I-L,w=U*o*I-R,N=n*I-O;const H=V*D;let _=T[H],q=T[H+1],W=T[H+2];for(let y=1;y<=s;y++){const t=y*P,a=h*(1-t)+M*t,U=X.sinLonLUT[y],C=X.cosLonLUT[y];let I=0,H=0,F=0;if(y<s){const t=(V+1)*D;I=T[t],H=T[t+1],F=T[t+2]}else{const t=X.sinLonLUT[i],s=X.cosLonLUT[i],a=b+r(M,e,v);I=s*o*a-L,H=t*o*a-R,F=n*a-O}const k=j,z=w,G=N;j=_,w=q,N=W,_=I,q=H,W=F;const J=I-k,K=H-z,Q=F-G;let Y=0,Z=0,$=0;if(E>1){const t=(V-s)*D;Y=T[t],Z=T[t+1],$=T[t+2]}else{const t=X.sinLatLUT[0],e=X.cosLatLUT[0],n=b+r(a,x,v);Y=C*e*n-L,Z=U*e*n-R,$=t*n-O}const tt=b+r(a,f,v),et=C*B*tt-L,nt=U*B*tt-R,ot=p*tt-O;if(E<s){const e=V+s,n=e*D;T[n]=et,T[n+1]=nt,T[n+2]=ot,c(et,nt,ot,A),u(d,e,t,l)}const st=Y-et,rt=Z-nt,it=$-ot;let at=C*o,lt=U*o,ct=n;ct*ct<.999&&(at=Q*rt-K*it,lt=J*it-Q*st,ct=K*st-J*rt);const ut=1/Math.sqrt(at*at+lt*lt+ct*ct);S(m,V,at*ut,lt*ut,ct*ut,g),++V}}}function L(t){t.tile.intersectsClippingArea&&(O(t),K(t))}function R(t){t.tile.intersectsClippingArea&&(D(t),T(t,!0),K(t))}function O(t){t.tile.intersectsClippingArea&&(D(t),T(t))}function T(e,n=!1){const o=e.geometryState,s=e.geometry,i=o.neighborData,a=e.tile,l=a.level,f=a.extent,d=a.ellipsoid.radius,x=a.extentInRadians,S=x[0],b=x[2],v=x[1],B=x[3],L=o.samplerData,R=f[0],O=f[2],T=f[1],D=f[3],P=E(e),A=s.boundingBox,V=e.localOrigin,U=V[0],C=V[1],I=V[2],j=s.vertexAttributes,w=j.position,N=w.typedBuffer,H=w.typedBufferStride,_=j.uv0;for(let E=0;E<4;++E){const o=1===E||3===E,x=i.edgeResolutions[E];p(t(x));const V=x+1,j=m(a,i.edgePeerNeighbors[E]);if($(a,j,E)){z(e,E,j);continue}const w=null!=j;p(!w||j.level===a.level),p(!w||y(a,j)<=0);const q=j?.renderData,W=q?.geometryState;if(g){const t=a.surface;if(!j&&t&&!t.updatingRootTiles){const e=h[E],n=a.findNeighborTile(e,(t=>t.isLoaded||t.isLeaf||t.level===a.level));n?n.intersectsClippingArea&&(p(!n.isLoaded),p(!n.isLeaf),p(n.level===l)):p(null==t?.rootTiles||!a.shouldHaveNeighbor(e))}}const F=1===E?f[2]:f[0],k=j?.extent,G=k&&o?1===E?k[0]:k[2]:F,J=0===E?f[3]:f[1],K=1===E?1:0,Q=0===E?1:0,X=1===E?b:S,Y=0===E?B:v,Z=Math.sin(X),tt=Math.cos(X),et=Math.sin(Y),nt=Math.cos(Y),ot=W?.samplerData,st=w?(t,e,n)=>.5*(r(t,e,L)+r(n,e,ot)):(t,e,n)=>r(t,e,L),rt=s.outerEdges[E],it=n&&V>3?V-3:1,at=null!=L&&L.some((t=>null!=t)),lt=null!=ot&&ot.some((t=>null!=t)),ct=at||lt,ut=1/x,ft=rt.index0;p(!k||M(k[2]-k[0],f[2]-f[0]));(()=>{const t=1===E?-1:3===E?1:0,e=0===E?-1:2===E?1:0,n=(f[2]-f[0])*ut,s=t*n,i=e*n,a=o?t*((b-S)*ut):0,l=o?0:e*ut,m=Q,g=o?X+a:X,p=o?Math.sin(g):Z,h=o?Math.cos(g):tt,M=o?X-a:X,x=o?Math.sin(M):Z,y=o?Math.cos(M):tt,v=o?Y:P(m+l),B=o?et:Math.sin(v),j=o?nt:Math.cos(v),q=o?Y:P(m-l),W=o?et:Math.sin(q),k=o?nt:Math.cos(q);let z=0,$=0,at=0;{const t=0*ut,e=o?F:R*(1-t)+O*t,n=o?G:e,s=o?T*(1-t)+D*t:J,r=o?X:S*(1-t)+b*t,i=o?Z:Math.sin(r),a=o?tt:Math.cos(r),l=o?P(t):Y,c=o?Math.sin(l):et,u=o?Math.cos(l):nt,f=d+st(e,s,n);z=a*u*f,$=i*u*f,at=c*f}let lt=0,dt=0,mt=0;{const t=1*ut,e=o?F:R*(1-t)+O*t,n=o?G:e,s=o?T*(1-t)+D*t:J,r=o?X:S*(1-t)+b*t,i=o?Z:Math.sin(r),a=o?tt:Math.cos(r),l=o?P(t):Y,c=o?Math.sin(l):et,u=o?Math.cos(l):nt,f=d+st(e,s,n);lt=a*u*f,dt=i*u*f,mt=c*f}for(let f=1;f<V-1;f+=it){let t=0,e=0,n=0;{const s=(f+1)*ut,r=o?F:R*(1-s)+O*s,i=o?G:r,a=o?T*(1-s)+D*s:J,l=o?X:S*(1-s)+b*s,c=o?Z:Math.sin(l),u=o?tt:Math.cos(l),m=o?P(s):Y,g=o?Math.sin(m):et,p=o?Math.cos(m):nt,h=d+st(r,a,i);t=u*p*h,e=c*p*h,n=g*h}const a=t,l=e,m=n,g=lt,M=dt,v=mt;lt=a,dt=l,mt=m;{const t=ft+f,e=t*H,n=g-U,s=M-C,r=v-I;N[e]=n,N[e+1]=s,N[e+2]=r,c(n,s,r,A);const i=f*ut;u(_,t,o?K:i,o?i:Q)}const V=z,q=$,it=at;z=g,$=M,at=v;const gt=g,pt=M,ht=v,Mt=1/Math.sqrt(gt*gt+pt*pt+ht*ht),xt=ht*Mt;let yt=0,St=0,bt=0;if(ct&&xt*xt<.999){let t=0,e=0,n=0;{const o=0===E?-1:1;t=o*(a-V),e=o*(l-q),n=o*(m-it)}{const a=f*ut,l=o?F:R*(1-a)+O*a,c=o?G:l,u=o?T*(1-a)+D*a:J,m=o?X:S*(1-a)+b*a,g=o?Z:Math.sin(m),M=o?tt:Math.cos(m),v=o?P(a):Y,A=o?Math.sin(v):et,V=o?Math.cos(v):nt;let U=gt,C=pt,I=ht;if(w){const t=d+r(c-s,u-i,ot),e=o?V:k;U=(o?y:M)*e*t,C=(o?x:g)*e*t,I=(o?A:W)*t}{const a=d+r(l+s,u+i,L),c=o?V:j,f=(o?h:M)*c*a,m=(o?p:g)*c*a,x=(o?A:B)*a;w||(U=2*gt-f,C=2*pt-m,I=2*ht-x);const y=3===E?-1:1,S=y*(U-f),b=y*(C-m),v=y*(I-x);yt=n*b-e*v,St=t*v-n*S,bt=e*S-t*b;const R=1/Math.sqrt(yt*yt+St*St+bt*bt);yt*=R,St*=R,bt*=R}}}else yt=gt*Mt,St=pt*Mt,bt=ht*Mt;rt.setNormalFromValues(f,yt,St,bt)}})()}}function D(t){G(t)}function P(t,e){return Math.PI/2-2*Math.atan(Math.exp(-t/e))}function A(t,e,n,o){return P(t*(1-o)+e*o,n)}function V(t,e,n){return t*(1-n)+e*n}function E(t){const e=t.tile;if(e.surface.isWebMercator){const t=e.extent,n=e.ellipsoid.radius;return e=>A(t[1],t[3],n,e)}const n=e.extentInRadians;return t=>V(n[1],n[3],t)}function U(t,e){const s=t.tile.extent,r=t.geometryState,i=s[0],a=s[1],c=s[2]-i,u=s[3]-a,f=r.clippingArea,d=null!=f?Math.max(0,(f[0]-i)/c):0,m=null!=f?Math.max(0,(f[1]-a)/u):0,g=null!=f?Math.min(1,(f[2]-i)/c):1,p=null!=f?Math.min(1,(f[3]-a)/u):1,h=r.numVerticesPerSide,M=(h-2)**2,x=r.neighborData.edgeResolutions.reduce(((t,e)=>t+e+1),0),y=l(M+x),S=t.geometry,b=S.boundingBox;o(b),S.numVerticesPerSide=r.numVerticesPerSide,S.vertexAttributes=y,n(S.uvRange,d,m,g,p),C(t),k(t,M),w(t),F(S,r.numVerticesPerSide,[],[0,h-1],[0,h-1],r.wireframe),t.intersectionData=null}function C(t){const n=t.tile;if(!n.intersectsClippingArea)return;const o=n.surface,s=t.geometryState,i=s.samplerData,a=t.localOrigin,l=o.isWebMercatorOnPlateeCarree,f=s.clippingArea,d=null!=f?f:Y,m=n.extent,g=m[0],p=m[1],h=m[2],M=m[3],x=Math.max(g,d[0]),y=Math.min(h,d[2]),b=Math.max(p,d[1]),v=Math.min(M,d[3]),B=n.ellipsoid.radius,L=n.horizontalScale,R=s.numVerticesPerSide,O=R-1,T=R-2,D=t.geometry,P=D.vertexAttributes,A=P.position,V=P.uv0,{typedBuffer:E,typedBufferStride:U}=P.normalCompressed,C=D.uvRange,I=C[0],j=C[1],w=C[2],N=C[3],H=D.boundingBox,_=a[0],q=a[1],W=a[2],F=A.typedBuffer,k=A.typedBufferStride;let z=0;const G=e(p,b,v),J=l?(Math.PI/2-2*Math.atan(Math.exp(-G/B)))*B:G*L,K=1/O,Q=e(p*(1-K)+M*K,b,v);let X=J,Z=l?(Math.PI/2-2*Math.atan(Math.exp(-Q/B)))*B:Q*L;for(let Y=1;Y<=T;Y++){const t=Y/O,n=e(p*(1-t)+M*t,b,v),o=e(t,j,N),s=Z,a=(Y-1)/O,f=e(p*(1-a)+M*a,b,v),d=X,m=(Y+1)/O,R=e(p*(1-m)+M*m,b,v),D=l?(Math.PI/2-2*Math.atan(Math.exp(-R/B)))*B:R*L,P=e(m,j,N);X=Z,Z=D;const A=e(g,x,y);let C=A*L,G=r(A,n,i);const J=1/O,K=e(J,I,w),Q=e(g*(1-K)+h*K,x,y);let $=K,tt=Q,et=Q*L,nt=r(Q,n,i);if(1===Y){const t=et-_,n=X-q,s=nt-W,r=0*k;F[r]=t,F[r+1]=n,F[r+2]=s,c(t,n,s,H);const i=e(J,I,w);u(V,z,i,o)}for(let l=1;l<=T;l++){const t=et,a=nt,m=(l+1)/O,p=e(m,I,w),M=e(g*(1-m)+h*m,x,y),b=tt;tt=M;{const t=z+1,e=t*k;if(1===Y||l===T){const a=M*L,f=r(M,n,i);if(1===Y&&l<T){const n=a-_,r=s-q,i=f-W;F[e]=n,F[e+1]=r,F[e+2]=i,c(n,r,i,H),u(V,t,p,o)}et=a,nt=f}else et=F[e]+_,nt=F[e+2]+W}const v=et,B=nt,A=C,j=G;C=t,G=a;const N=(z-T)*k,J=1===Y?r(b,f,i):F[N+2]+W,K=r(b,R,i);if(Y<T){const e=z+T,n=e*k,o=t-_,s=D-q,r=K-W;F[n]=o,F[n+1]=s,F[n+2]=r,c(o,s,r,H);const i=$;$=p,u(V,e,i,P)}{const t=v-A,e=d-D,n=e*(B-j),o=t*(J-K),s=-e*t,r=n*n+o*o+s*s;if(0===r)S(E,z,0,0,1,U);else{const t=1/Math.sqrt(r);S(E,z,n*t,o*t,s*t,U)}}++z}}}function I(t,e){t.tile.intersectsClippingArea&&(H(t),N(t,!0),K(t))}function j(t,e){t.tile.intersectsClippingArea&&(w(t),K(t))}function w(t,e){t.tile.intersectsClippingArea&&(H(t),N(t,!1))}function N(n,o){const s=n.geometryState,i=s.neighborData,a=n.tile,l=a.surface,u=a.extent,f=s.clippingArea,d=null!=f?f:Y,M=u[0],x=u[2],S=u[1],b=u[3],v=[b>d[3],x>d[2],S<d[1],M<d[0]],B=n.geometry,L=a.horizontalScale,R=W(l.isWebMercatorOnPlateeCarree,a.ellipsoid.radius,L),O=B.boundingBox,T=B.uvRange[0],D=B.uvRange[1],P=B.uvRange[2],A=B.uvRange[3],V=Math.max(M,d[0]),E=Math.min(x,d[2]),U=Math.max(S,d[1]),C=Math.min(b,d[3]),I=n.localOrigin,j=I[0],w=I[1],N=I[2],H=s.samplerData;for(let _=0;_<4;++_){const s=1===_||3===_,u=i.edgeResolutions[_];p(t(u));const f=u+1,d=v[_],I=m(a,i.edgePeerNeighbors[_]);if(!d&&$(a,I,_)){z(n,_,I);continue}const q=null!=I&&!d,W=I?.renderData,F=W?.geometryState;if(g&&(p(!q||I.level===a.level),p(!q||y(a,I)<=0),a&&!I&&!l.updatingRootTiles)){const t=h[_],e=a.findNeighborTile(t,(t=>t.isLoaded||t.isLeaf||t.level===a.level));l.updatingRootTiles||(e?e.intersectsClippingArea&&(p(!e.isLoaded),p(!e.isLeaf),p(e.level===a.level)):p(null==l?.rootTiles||!a.shouldHaveNeighbor(t)))}const k=e(1===_?x:M,V,E),G=e(0===_?b:S,U,C),J=F?.samplerData,K=B.outerEdges[_],Q=o&&f>3?f-3:1,X=e(1===_?1:0,T,P),Y=e(0===_?1:0,D,A),Z=q?(t,e)=>.5*(r(t,e,J)+r(t,e,H)):(t,e)=>r(t,e,H),tt=(x-M)/u,et=s?1===_?tt:-tt:0,nt=s?0:0===_?tt:-tt,ot=-et,st=-nt;let rt=0,it=0,at=0;{const t=0/u,n=s?k:e(M*(1-t)+x*t,V,E),o=s?e(S*(1-t)+b*t,U,C):G,r=Z(n,o);rt=n*L,it=R(o),at=r}let lt=0,ct=0,ut=0;{const t=1/u,n=s?k:e(M*(1-t)+x*t,V,E),o=s?e(S*(1-t)+b*t,U,C):G,r=Z(n,o);lt=n*L,ct=R(o),ut=r}for(let t=1;t<f-1;t+=Q){const n=t/u,o=lt,i=ct,a=ut;{const r=s?X:e(n,T,P),l=s?e(n,D,A):Y,u=o-j,f=i-w,d=a-N;c(o,f,d,O),K.setVertexFromValuesRawPositionUV(t,u,f,d,r,l)}{const n=(t+1)/u,o=s?k:e(M*(1-n)+x*n,V,E),r=s?e(S*(1-n)+b*n,U,C):G,i=Z(o,r);lt=o*L,ct=R(r),ut=i}const l=lt,f=ut,d=rt,m=it,g=at;rt=o,it=i,at=a;let p=0,h=0,y=0;if(s){const t=ct-i,s=f-a,l=m-i,c=g-a,u=e(S*(1-n)+b*n,U,C),d=k+ot,M=d*L-o,x=r(d,u,H)-a,v=3===_?-1:1;if(p=v*(-l+t)*x,h=v*M*(-c+s),y=-v*M*(-l+t),q){const e=k+et,n=e*L-o;p=(-l+t)*(x-(r(e,u,J)-a)),h=(M-n)*(-c+s),y=-(M-n)*(-l+t)}}else{const t=l-o,s=f-a,c=d-o,u=g-a,m=e(M*(1-n)+x*n,V,E),S=G+st,b=r(m,S,H)-a,v=R(S)-i,B=2===_?-1:1;if(p=B*v*(-u+s),h=B*(-c+t)*b,y=-B*v*(-c+t),q){const e=m,n=G+nt,o=R(n)-i;p=(-v+o)*(-u+s),h=(-c+t)*(-b+(r(e,n,J)-a)),y=-(-v+o)*(-c+t)}}const v=1/Math.sqrt(p*p+h*h+y*y);K.setNormalFromValues(t,p*v,h*v,y*v)}}}function H(t,e){G(t)}function _(t,e){return(Math.PI/2-2*Math.atan(Math.exp(-t/e)))*e}function q(t,e){return t*e}function W(t,e,n){return t?t=>_(t,e):t=>q(t,n)}function F(t,e,n,o,s,r){const i=e-1,a=t.vertexAttributes.count,l=2*(Math.min(e-2,o[1])-Math.max(1,o[0]))*(Math.min(e-2,s[1])-Math.max(1,s[0])),c=h.map(((t,n)=>0===n&&s[1]<e-2||1===n&&o[1]<e-2||2===n&&s[0]>1||3===n&&o[0]>1)),u=t.outerEdges.reduce(((t,e,n)=>t+(c[n]?0:i-2+e.count-1)),0),f=n.reduce(((t,e)=>t+i*(2*(e.latitudeResolution-1)+1)),0),d=r?2:1,m=3*(l+u+f)*d,M=a>=b?new Uint32Array(m):new Uint16Array(m);let x=0;const y=e-2,S=i-2;p(S>=0);const v=(t,e,n,o,s,r)=>{const i=t*s,a=r[i],l=r[i+1],c=r[i+2],u=e*s,f=r[u],d=r[u+1],m=r[u+2],g=n*s,p=r[g],h=r[g+1],M=r[g+2],x=o*s,y=r[x],S=r[x+1],b=r[x+2];return(f-y)*(f-y)+(d-S)*(d-S)+(m-b)*(m-b)>(a-p)*(a-p)+(l-h)*(l-h)+(c-M)*(c-M)};if(r){const r=(t,e,n)=>{M[x++]=t,M[x++]=e,M[x++]=e,M[x++]=n,M[x++]=n,M[x++]=t,g&&(p(t<a),p(e<a),p(n<a),p(x<=m))};(()=>{for(let n=Math.max(s[0],1)-1;n<Math.min(s[1],e-2)-1;++n){const s=n*y;for(let i=Math.max(o[0],1)-1;i<Math.min(o[1],e-2)-1;++i){const e=n*y+i,o=e+1,a=o+y,l=a-1,c=s+i,u=c+1,f=u+y,d=f-1,m=t.vertexAttributes.position.typedBuffer,g=t.vertexAttributes.position.typedBufferStride;v(c,u,f,d,g,m)?(r(e,o,a),r(a,l,e)):(r(e,o,l),r(l,a,o))}}})(),p(x===3*l*d);(()=>{for(let e=0;e<4;++e){const n=x;if(c[e])continue;const o=t.outerEdges[e],s=t.innerEdges[e];let a=0,l=0;const u=o.count,f=s.count;p(f===i-1);let m=0;const h=1===e||2===e?(t,e,n)=>r(t,e,n):(t,e,n)=>r(t,n,e);for(;a<u-1||l<f-1;){const t=s.getVertexIndex(l),e=o.getVertexIndex(a),n=a<u-1,r=l<f-1;if(n&&(!r||(n?0+i*(a+.5)/(u-1):0)<=(r?1+S*(l+.5)/(f-1):0))){++a,g&&p(a<u);h(t,e,o.getVertexIndex(a)),m++}else{++l,g&&p(l<f);h(t,e,s.getVertexIndex(l)),m++}}g&&(p(a===u-1),p(l===f-1),p(m===u+f-2),p(m===i-2+o.count-1),p(x===n+3*m*d))}})(),p(x===3*(l+u)*d);const f=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),a=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<i;e++)r(s,s+1,o+e),t<n.latitudeResolution-1&&r(s+1,o+e+1,o+e),s+=a;s=o,a=1}};(()=>n.forEach(f))()}else{(()=>{const n=Math.max(s[0],1)-1,r=Math.min(s[1],e-2)-1,i=Math.max(o[0],1)-1,a=Math.min(o[1],e-2)-1;for(let e=n;e<r;++e){const n=e*y;for(let e=i;e<a;++e){const o=n+e,s=o+1,r=s+y,i=r-1,a=t.vertexAttributes.position.typedBuffer,l=t.vertexAttributes.position.typedBufferStride;v(o,s,r,i,l,a)?(M[x]=o,M[x+1]=s,M[x+2]=r,M[x+3]=r,M[x+4]=i,M[x+5]=o):(M[x]=o,M[x+1]=s,M[x+2]=i,M[x+3]=i,M[x+4]=s,M[x+5]=r),x+=6}}})(),p(x===3*l*d);(()=>{for(let e=0;e<4;++e){if(c[e])continue;const n=t.outerEdges[e],o=t.innerEdges[e];let s=0,r=0;const a=n.count,l=o.count;p(l===i-1);const u=1===e||2===e,f=u?1:2,d=u?2:1,m=n.index0,g=n.stride,h=o.index0,y=o.stride;for(;s<a-1||r<l-1;){const t=h+r*y,e=m+s*g,n=s<a-1,o=r<l-1,c=n&&(!o||(n?0+i*(s+.5)/(a-1):0)<=(o?1+S*(r+.5)/(l-1):0));c?++s:++r;const u=c?e+g:t+y;M[x]=t,M[x+f]=e,M[x+d]=u,x+=3}}})(),p(x===3*(l+u)*d);const r=n=>{const o=t.outerEdges[n.connectedOuterEdgeOffset];let s=o.getVertexIndex(0),r=o.stride;for(let t=0;t<n.latitudeResolution;++t){const o=0===t?n.rowOffset:s+e;for(let e=0;e<i;e++){const i=o+e;M[x]=s,M[x+1]=s+1,M[x+2]=i,t<n.latitudeResolution-1?(M[x+3]=s+1,M[x+4]=i+1,M[x+5]=i,x+=6):x+=3,s+=r}s=o,r=1}};(()=>n.forEach(r))()}p(x===m),t.indices=M,t.indexCount=m}function k(t,e){const n=t.localOrigin,o=t.geometry,s=t.geometryState.neighborData.edgeResolutions,r=o.numVerticesPerSide-2,i=o.vertexAttributes;let a=e;for(let l=0;l<4;++l){{const t=0===l||2===l,e=(0===l?r-1:0)*r+(1===l?r-1:0),s=(t?0:1)*r+(t?1:0);o.innerEdges[l]=new f(i,n,e,s,r)}{const t=a,e=s[l]+1;o.outerEdges[l]=new f(i,n,t,1,e),a+=e}}}function z(n,o,s){const r=(o+2)%4,i=n.geometryState,a=n.tile,l=i.neighborData,f=a.level-s.level,d=1===o||3===o,m=l.edgeResolutions[o];p(t(m));const g=m+1,h=n.geometry,M=h.boundingBox,x=h.outerEdges[o],y=h.uvRange[0],S=h.uvRange[1],b=h.uvRange[2],v=h.uvRange[3],B=e(1===o?1:0,y,b),L=e(0===o?1:0,S,v),R=s.renderData,O=R.geometryState,T=R.geometry.outerEdges[r],D=a.getNeighborEdgeStartVertexIndex(o,s)*m,P=m*2**f;p(O.neighborData.edgeResolutions[r]===P),p(T.count-1===P);const A=R.localOrigin[0]-n.localOrigin[0],V=R.localOrigin[1]-n.localOrigin[1],E=R.localOrigin[2]-n.localOrigin[2],U=x.attributes,C=x.index0,I=x.stride,j=U.position.typedBuffer,w=U.position.typedBufferStride,N=U.normalCompressed.typedBuffer,H=U.normalCompressed.typedBufferStride,_=U.uv0,q=T.attributes,W=T.index0,F=T.stride,k=q.position.typedBuffer,z=q.position.typedBufferStride,G=q.normalCompressed.typedBuffer,J=q.normalCompressed.typedBufferStride;for(let t=1;t<g-1;++t){const n=C+I*t,o=W+F*(D+t),s=n*w,r=o*z,i=k[r]+A,a=k[r+1]+V,l=k[r+2]+E;j[s]=i,j[s+1]=a,j[s+2]=l,c(i,a,l,M);const f=n*H,g=o*J;N[f]=G[g],N[f+1]=G[g+1];const p=t/m,h=d?B:e(p,y,b),x=d?e(p,S,v):L;u(_,n,h,x)}}function G(t){const n=t.geometryState,o=n.neighborData,s=t.localOrigin,i=o.cornerNeighborData,a=t.geometry,l=a.outerEdges,f=a.boundingBox,d=t.tile,m="local"===t.tile.surface.view?.viewingMode,g=d.ellipsoid.radius,h=d.extentInRadians,M=d.horizontalScale;let x=0,S=0,b=0;const v=(t,e,n)=>{const o=h[0===e?1:3],s=h[0===t?0:2],r=Math.cos(o),i=Math.sin(o),a=Math.sin(s),l=Math.cos(s),c=g+n;x=l*r*c,S=a*r*c,b=i*c},B=m?(()=>{const n=t.geometryState.clippingArea,o=d.extent,s=null!=n&&(o[3]>n[3]||o[2]>n[2]||o[1]<n[1]||o[0]<n[0]),r=W(d.surface.isWebMercatorOnPlateeCarree,d.ellipsoid.radius,M);return(t,o,i)=>{const a=0===t?j[0]:j[2],l=0===o?j[1]:j[3],c=s?e(a,n[0],n[2]):a,u=s?e(l,n[1],n[3]):l,f=i;x=c*M,S=r(u),b=f}})():v;let L=0,R=0,O=0,T=0,D=0,P=0,A=0,V=0,U=0;const C=m&&t.tile.surface.isWebMercatorOnPlateeCarree,I=(t,e,n,o,s)=>{let r=0,i=0,a=0;if(m){const t=e*M,s=C?(Math.PI/2-2*Math.atan(Math.exp(-n/g)))*g:n*M;r=t-x,i=s-S,a=o-b}else{const s=E(t),l=t.tile,c=l.extent,u=l.extentInRadians,f=(e-c[0])/(c[2]-c[0]),d=(n-c[1])/(c[3]-c[1]),m=u[0]*(1-f)+u[2]*f,p=s(d),h=Math.cos(p),M=Math.sin(p),y=Math.sin(m),v=Math.cos(m),B=g+o;r=v*h*B-x,i=y*h*B-S,a=M*B-b}switch(s){case 0:A+=r,V+=i,U+=a;break;case 1:T-=r,D-=i,P-=a;break;case 2:A-=r,V-=i,U-=a;break;case 3:T+=r,D+=i,P+=a}},j=d.extent,w=n.clippingArea,N=null!=w?w:Y,H=j[0],_=j[2],q=j[1],F=j[3],k=[F>N[3],_>N[2],q<N[1],H<N[0]],z=Math.max(H,N[0]),G=Math.min(_,N[2]),K=Math.max(q,N[1]),X=Math.min(F,N[3]),$=a.uvRange[0],tt=a.uvRange[1],et=a.uvRange[2],nt=a.uvRange[3],ot=t=>{const e=i[t].cornerTiles;L=0,R=0,O=1,T=0,D=0,P=0,A=0,V=0,U=0;let n=1/0;for(let r=0;r<4;++r)n=Math.min(n,e[r]?.level??1/0);for(let r=0;r<4;++r){const t=e[r];Z[r]=t?.level===n?t:null}let o=1,s=0;for(let r=0;r<4;++r){const t=Z[r];t&&(o=Math.max(o,t?.renderData.geometryState.numVerticesPerSide),s=t.extent[2]-t.extent[0])}const a=s,l=o;p(l>1);const c=a/l;for(let i=0;i<4;++i){const t=Z[(i+3)%4],e=Z[i%4];if(!t&&!e)continue;const n=0===i?1:1===i?2:2===i?3:0,o=0===i?2:1===i?3:2===i?0:1;if(t&&e){const s=Q[i][0]*c,a=Q[i][1]*c,l=t.extent,u=l[0===n||1===n?2:0]+s,f=l[0===n||3===n?3:1]+a,d=e.extent,m=d[0===o||1===o?2:0]+s,g=d[0===o||3===o?3:1]+a,p=t.renderData,h=e.renderData,M=r(u,f,p.geometryState.samplerData),x=r(m,g,h.geometryState.samplerData);I(p,u,f,.5*(M+x),i)}else{const s=t??e,a=t?n:o,l=s.extent,u=Q[i],f=l[0===a||1===a?2:0]+u[0]*c,d=l[0===a||3===a?3:1]+u[1]*c,m=s.renderData,g=r(f,d,m.geometryState.samplerData);I(m,f,d,g,i)}}if(!m){const t=Math.sqrt(x*x+S*S+b*b);L=x/t,R=S/t,O=b/t}if(m||O*O<.999){const t=Math.sqrt(T*T+D*D+P*P);T/=t,D/=t,P/=t;const e=Math.sqrt(A*A+V*V+U*U);A/=e,V/=e,U/=e,L=P*V-D*U,R=T*U-P*A,O=D*A-T*V;const n=1/Math.sqrt(L*L+R*R+O*O);L*=n,R*=n,O*=n}};for(let E=0;E<4;++E){const o=E,a=(E+1)%4,m=0===E||1===E?1:0,g=0===E||3===E?1:0,h=e(m,$,et),M=e(g,tt,nt),v=l[o],T=0===E||3===E?v.count-1:0,D=l[a],P=0===E||1===E?D.count-1:0,A=i[E].cornerTiles;let V=-1;for(let t=0;t<4;++t){const e=A[t];e&&(-1===V||y(A[V],e)>0)&&(V=t)}const U=V,C=A[U];if(C!==d){const e=d.level-C.level,n=2**e,o=[C.lij[0]+e,C.lij[1]*n,C.lij[2]*n],s=[o[1]+n===d.lij[1],0===E&&(1===U||0===U&&C!==A[3])||1===E&&(0===U||1===U&&C!==A[2]),o[1]===d.lij[1]+1,2===E&&(3===U||2===U&&C!==A[1])||3===E&&(2===U||3===U&&C!==A[0])],r=s.reduce(((t,e)=>t+(e?1:0)),0);p(1===r||2===r);let i=-1,a=-1;const l=C.renderData;if(1===r){const e=s.findIndex((t=>t));p(0<=e&&e<=3),i=(e+2)%4;const n=t.geometryState.neighborData.edgeResolutions[e];a=d.getNeighborEdgeStartVertexIndex(e,C)*n+n*(0===e&&0===E||1===e&&0===E||2===e&&1===E||3===e&&3===E?1:0)}else{p(s[1]||s[3]),i=s[1]?3:1;const t=l.geometryState.neighborData.edgeResolutions[i];a=0===E||3===E?0:t}const m=l.geometry.outerEdges[i];{const e=v.index0+T*v.stride,n=D.index0+P*D.stride,o=m.index0+a*m.stride;{const s=m.attributes.position,r=s.typedBuffer,i=o*s.typedBufferStride,a=t.localOrigin,l=m.localOrigin,u=r[i]+l[0]-a[0],d=r[i+1]+l[1]-a[1],g=r[i+2]+l[2]-a[2];c(u,d,g,f);{const t=v.attributes.position,n=t.typedBuffer,o=e*t.typedBufferStride;n[o]=u,n[o+1]=d,n[o+2]=g}{const t=D.attributes.position,e=t.typedBuffer,o=n*t.typedBufferStride;e[o]=u,e[o+1]=d,e[o+2]=g}}u(v.attributes.uv0,e,h,M),u(D.attributes.uv0,n,h,M);{const t=m.attributes.normalCompressed.typedBuffer,s=o*m.attributes.normalCompressed.typedBufferStride;{const n=v.attributes.normalCompressed,o=n.typedBuffer,r=e*n.typedBufferStride;o[r]=t[s],o[r+1]=t[s+1]}{const e=D.attributes.normalCompressed,o=e.typedBuffer,r=n*e.typedBufferStride;o[r]=t[s],o[r+1]=t[s+1]}}}}else{const t=k[o],i=k[a];let l;if(t||i){const t=e(H*(1-m)+_*m,z,G),o=e(q*(1-g)+F*g,K,X),s=n.samplerData;l=r(t,o,s)}else l=J(A);B(m,g,l),ot(E);const u=x-s[0],d=S-s[1],p=b-s[2];c(u,d,p,f),v.setVertexFromValuesRawPositionUVNormal(T,u,d,p,h,M,L,R,O),D.setVertexFromValuesRawPositionUVNormal(P,u,d,p,h,M,L,R,O)}}for(let e=0;e<4;++e)Z[e]=null}function J(t){const e=t.reduce(((t,e)=>Math.min(t,e?.level??1/0)),1/0);g&&(p(!t[0]||!t[2]||x(t[0],t[2],a.SOUTH_WEST)),p(!t[1]||!t[3]||x(t[1],t[3],a.NORTH_WEST)));let n=0,o=0;for(let i=0;i<4;++i){const s=t[i];if(s&&s.level===e){const t=0===i||1===i,e=0===i||3===i,a=s.extent,l=a[t?0:2],c=a[e?1:3],u=s.renderData?.geometryState?.samplerData;o+=r(l,c,u),n++}}const s=n?o/n:0;return p(null!=s),s}function K(t){const e=t.vao,n=t.geometry.vertexAttributes.position.typedBuffer;e.vertexBuffers.geometry.setSubData(n,0,0,n.length)}const Q=[[0,1],[1,0],[0,-1],[-1,0]],X=new d,Y=s(-1/0,-1/0,1/0,1/0),Z=[null,null,null,null];function $(t,e,n){if(!e)return!1;const o=y(t,e);return o>0||0===o&&n>=2}export{U as createPlanarGlobePatch,v as createSphericalGlobePatch,R as updateCornerSpherical,I as updateCornersPlanar,j as updateEdgesAndCornersPlanar,L as updateEdgesAndCornersSpherical};
