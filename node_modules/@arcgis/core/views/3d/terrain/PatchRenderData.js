/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{isPowerOfTwo as t}from"../../../core/mathUtils.js";import{i as r,j as i,u as s,b as a,n as o,e as n,w as l,F as h}from"../../../chunks/vec3.js";import{c as d,a as g}from"../../../chunks/vec3f64.js";import{empty as u}from"../../../geometry/support/aaBoundingBox.js";import{containsXY as c}from"../../../geometry/support/aaBoundingRect.js";import{earth as m}from"../../../geometry/support/Ellipsoid.js";import{glLayout as p}from"../support/buffer/glUtil.js";import{GeometryState as y}from"./GeometryState.js";import{NeighborIndex as f}from"./ITile.js";import{LayerClass as _}from"./LayerClass.js";import{PatchGeometry as x,releaseGeometry as D}from"./PatchGeometry.js";import{ENABLE_TERRAIN_INTERNAL_CHECKS as v,internalAssert as C,neighborEdgeIndices as S,oppositeEdge as $,neighborCornerIndices as E,v32s as b,lij2s as T}from"./terrainUtils.js";import{TextureFader as A,ActivationTime as V}from"./TextureFader.js";import{isEdgeNeighbor as j}from"./Tile.js";import R from"./TileOverlayData.js";import{fallsWithinLayer as w}from"./tileUtils.js";import{VertexArrayObject as L}from"../webgl-engine/lib/VertexArrayObject.js";import{terrainVertexAttributeLocations as P}from"../webgl-engine/shaders/TerrainTechnique.js";import{BufferObject as N}from"../../webgl/BufferObject.js";class G{constructor(){this.geometry=new x,this.intersectionData=null,this.geometryState=null,this._textureRef=new A((()=>this.tile.surface.textureFadeDuration)),this.overlay=new R,this._geometryStateChangedSinceLastUpdate=!0,this._hasGeometry=!1,this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._clippingAreaChanged=!1,this._wireframeChanged=!1,this._dirtyEdgeResolutions=15,this._dirtyEdges=15,this._dirtyCorners=15}get tile(){return this._tile}init(e){this.clear(),this._tile=e;const t=this.geometry;t.indices=null,t.vertexAttributes=null,u(t.boundingBox),t.indexCount=0,t.numVerticesPerSide=0,this.intersectionData=null,this.geometryState=new y,this.localOrigin=null,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear(),this._tile=null,this.intersectionData=null,this.geometryState=null}updateGeometryIfNeeded(e){if((!this._vao||this._geometryStateChangedSinceLastUpdate||this._wireframeChanged||this._clippingAreaChanged||this._samplerDataChanged||this._numVerticesPerSideChanged||this._dirtyCorners||this._dirtyEdgeResolutions||this._dirtyEdges)&&(this._updateGeometry(e),this._geometryStateChangedSinceLastUpdate=!1),v&&this.tile.intersectsClippingArea)for(let t=0;t<4;++t)C(this.geometry.outerEdges[t].count===this.geometryState.neighborData.edgeResolutions[t]+1)}_calculateEdgeResolution(e,t){const r=this.tile,i=this.geometryState.numVerticesPerSide-1;if(!r.surface.isGlobal){const t=r.surface.extent;if(null!=t&&(0===e&&r.extent[3]>t[3]||1===e&&r.extent[2]>t[2]||2===e&&r.extent[1]<t[1]||3===e&&r.extent[0]<t[0]))return i}const s=r.level,a=S[e];if(!t)return C(null==r.surface?.rootTiles||r.surface.updatingRootTiles||!r.shouldHaveNeighbor(a)),i;if(t.isLoaded){const r=t,a=r.renderData.geometryState,o=s-r.level;if(C(o>=0),0===o){const e=a.numVerticesPerSide-1;return Math.max(e,i)}const n=2**o,l=a.neighborData.edgeResolutions[(e+2)%4]/n;return Math.max(1,l)}C(!t.isLeaf);let o=i;return t.forAllSubtreeOnSide($(a),(e=>e===r||(e.isLoaded?(o=Math.max(o,2**(e.level-s)),!0):(C(!e.isLeaf),!1)))),o}updateNeighborData(){const e=this.tile;if(!e.intersectsClippingArea)return;const r=e.renderData.geometryState.neighborData,i=t=>(t.isLoaded||t.level===e.level)&&t?.intersectsClippingArea,s=r.edgePeerNeighbors,a=r.edgePeerNeighborSamplerVersions;for(let n=0;n<4;++n){const o=e.findNeighborTile(S[n],i),l=H(e,o),h=l?.renderData?.geometryState.samplerDataVersion??-1,d=s[n],g=l!==H(e,d),u=a[n]!==h;s[n]=o,(g||u)&&(a[n]=h,this._markEdgeDirty(n));const c=r.edgeResolutions[n],m=this._calculateEdgeResolution(n,o);C(t(m)),C(m>=1),r.edgeResolutions[n]=m,c!==m&&this._markEdgeResolutionDirty(n)}const o=r.cornerPeerNeighbors;for(let t=0;t<4;++t){const a=e.findNeighborTile(E[t],i);o[t]=a;const n=H(e,s[t]),l=H(e,s[(t+1)%4]),h=H(e,a);X[t]=h,X[(t+1)%4]=l,X[(t+2)%4]=e,X[(t+3)%4]=n,C(X.some((t=>t?.isLoaded||t===e)));const d=X.reduce(((e,t)=>Math.min(e,t?.level??1/0)),1/0);X.forEach(((e,t)=>{e&&e?.level>d&&(X[t]=null)})),C(X.some((t=>t?.isLoaded||t===e)));const g=r.cornerNeighborData[t].cornerTiles,u=r.cornerNeighborData[t].cornerTileSamplerVersions;for(let e=0;e<4;++e){const r=X[e],i=r?.renderData.geometryState.samplerDataVersion??-1,s=g[e]!==r,a=!s&&u[e]!==i;(s||a)&&(g[e]=r,u[e]=i,this._markCornerDirty(t))}C(g.some((t=>t?.isLoaded||t===e)))}v&&C(this.geometryState.neighborData.edgeResolutions.every((e=>e>0)));for(let t=0;t<4;++t)X[t]=null}_updateGeometry(e){if(!this.tile.intersectsClippingArea)return;v&&C(!this.tile.intersectsClippingArea||this.geometryState.neighborData.edgeResolutions.every((e=>e>0))),this.intersectionData=null;const t=this.tile,r=this._vao,i=this.geometry.vertexAttributes,s=!r||!i||this._wireframeChanged||this._numVerticesPerSideChanged||this._samplerDataChanged||this._clippingAreaChanged||this._dirtyEdgeResolutions,a=!s&&(0!==this._dirtyEdges||0!==this._dirtyEdgeResolutions),o=!a&&0!==this._dirtyCorners;s?(this.releaseGeometry(),this._createGeometry(e)):a||o?t.updateEdgeElevations():o?t.updateCornerElevations():console.warn("Update for no reason?"),this._numVerticesPerSideChanged=!1,this._samplerDataChanged=!1,this._dirtyEdgeResolutions=0,this._dirtyEdges=0,this._dirtyCorners=0,this._clippingAreaChanged=!1,this._wireframeChanged=!1}get hasGeometry(){return this._hasGeometry}releaseGeometry(){return this._hasGeometry=!1,this.intersectionData=null,!!this._vao&&(this._vao.dispose(),this._vao=null,D(this.geometry),!0)}ensureTexture(e,t){return null!=this._texture&&this._texture.descriptor.width!==e&&this.releaseTexture(),null==this._texture&&(this._texture=t(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){null!=this._texture&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_markCornerDirty(e){const t=1<<e;this._dirtyCorners|=t}_markEdgeDirty(e){const t=1<<e;this._dirtyEdges|=t,this._markCornerDirty((e+0)%4),this._markCornerDirty((e+3)%4)}_markEdgeResolutionDirty(e){const t=1<<e;this._dirtyEdgeResolutions|=t,this._markEdgeDirty(e)}_markAllEdgesAndCornersDirty(){this._dirtyCorners=15,this._dirtyEdges=15,this._dirtyEdgeResolutions=15}updateGeometryState(){const t=this._getElevationInfo(),r=this.tile,i=t.samplerData?r.getElevationVerticesPerSide(t.maxTileLevel):r.getDefaultVerticesPerSide(),s=Math.max(i,5);let a=r.clippingArea;r.intersectsClippingArea&&!r.isWithinClippingArea||(a=null);const o=this.geometryState;let n=!1;o.numVerticesPerSide!==s&&(this._numVerticesPerSideChanged=!0,o.numVerticesPerSide=s,o.samplerDataVersion++,n=!0),t.changed&&(this._samplerDataChanged=!0,o.samplerData=t.samplerData,o.samplerDataVersion++,n=!0),e(o.clippingArea,a)||(this._clippingAreaChanged=!0,o.clippingArea=a,n=!0);const l=r.surface.wireframe;return o.wireframe!==l&&(this._wireframeChanged=!0,o.wireframe=l,n=!0),this._geometryStateChangedSinceLastUpdate||=n,n&&this._markAllEdgesAndCornersDirty(),this._hasGeometry=!0,this._geometryStateChangedSinceLastUpdate}_createGeometry(e){this.tile.createGeometry();const t=this.geometry.vertexAttributes,r=this.geometry.indices,i=e.gl;this._vao=new L(e,P,{geometry:p(t.layout)},{geometry:N.createVertex(e,i.STATIC_DRAW,t.buffer)},N.createIndex(e,i.STATIC_DRAW,r)),this._hasGeometry=!0}get vao(){return this._vao}setTextureReference(e,t=V.Immediate){null!=e&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,t)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[_.ELEVATION],r=t.length,i=new Array(r);let s=0,a=0,o=!1;for(let h=0;h<r;h++){const r=t[h];if(null!=r.upsampleInfo){const t=r.upsampleInfo.tile,n=t.layerInfo[_.ELEVATION][h].data,l=n&&n.samplerData;e&&e[s]===l||(o=!0),i[s++]=l,a=Math.max(a,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(h,_.ELEVATION);if(w(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(o=!0),i[s++]=t.samplerData,a=this.tile.level}}}null!=e&&e.length!==s&&(o=!0);const n=s>0,l=n?i:null;return n&&(i.length=s),{changed:o,samplerData:l,maxTileLevel:a}}get estimatedGeometryMemoryUsage(){const e=this.intersectionData?.estimatedMemoryUsage??0;return(this.geometry.indices?.byteLength??0)+(this.geometry.vertexAttributes?.byteLength??0)+e}get texture(){return this._texture}get test(){return{hasTexture:null!=this._texture}}checkGeometryWaterproofness(){if(!v)return;const e=this.tile;if(!e.isLoaded||!e.intersectsClippingArea||0===e.level)return void C(e?.isLoaded);const u=e.surface.extent;if(null!=u&&!e.intersectsExtent(u))return;const p=S.map(((t,r)=>null!=u&&(r<2?-1:1)*(e.extent[3-r]-u[3-r])<0)),y=e.level;C(0===this._dirtyCorners),C(0===this._dirtyEdges),C(0===this._dirtyEdgeResolutions),C(!this._numVerticesPerSideChanged),C(!this._samplerDataChanged),C(!this._clippingAreaChanged),C(!this._wireframeChanged);const _=E.map((t=>e.findNeighborCornerTileExact(t,(t=>!t.intersectsClippingArea||t.isLoaded||t.level===e.level))??null)).map((e=>e?.intersectsClippingArea?e:null)),x=this.geometryState.neighborData;for(let t=0;t<4;++t){const r=x.cornerPeerNeighbors[t],i=_[t];C(i===r,`Tile[${e.lij}].corner[${t}] out of date: cur=[${r?.lij}] exp=[${i?.lij}]`)}S.forEach(((u,_)=>{if(p[_])return;const x=e.findNeighborTile(u,(e=>(e.level===y||e?.isLoaded)&&e?.intersectsClippingArea));if(!x){const t=!e.surface.updatingRootTiles&&null!=e.surface.rootTiles&&e.surface.rootTiles.length>0&&e.shouldHaveNeighbor(u);return void C(!t)}C(x.isLoaded||x.level===e.level),C(x===this.geometryState.neighborData.edgePeerNeighbors[_]);const D=y-x.level;if(!x.isLoaded)return C(!x.isLeaf),void C(0===D);const v=x.renderData;C(j(e,x,u)),C(D>=0);const S=2**D;if(D<0)return void C(!1);const $=e.renderData,E=$.geometry,A=E.outerEdges[_],V=E.numVerticesPerSide-1,R=v.geometry;if(!R)return void C(!1);const w=this.geometryState.neighborData.edgePeerNeighbors[_];if(w?.isLoaded){const e=w.renderData;C(w==w),C($.geometryState.neighborData.edgePeerNeighborSamplerVersions[_]===e.geometryState.samplerDataVersion),C(this.geometryState.neighborData.edgePeerNeighborSamplerVersions[_]===e.geometryState.samplerDataVersion)}const L=(_+2)%4,P=R.outerEdges[L],N=A.count-1,G=P.count-1;C(N*S===G,`Tile[${e.lij}]:e${_},res=${N} edgeRes mismatch with Neighbor[${x.lij}]:e${L},res=${G} (expected:${N*S})`);const X=e.extent,H=u===f.NORTH||u===f.SOUTH,W=P.count-1,q=W/2**D,z=A.count-1;if(q<1)return void C(1===z);C(q===z),C(t(q));const J=R.numVerticesPerSide-1;C(D>0||q===Math.max(J,V));const K=e.getNeighborEdgeStartVertexIndex(_,x);C(0<=K&&K<S);const Q=K*q;C(0<=Q&&Q<=W-q);let Y=0,Z=Q;A.getVertexPos(I,0),A.getVertexPos(M,A.count-1);const ee=r(I,M),te=Math.max(B,1e-4*ee);for(let t=0;t<=q;++t){A.getVertexPos(I,Y),P.getVertexPos(M,Z);const r=t/q,p=H?X[0]+r*(X[2]-X[0]):u===f.WEST?X[0]:X[2],y=H?u===f.SOUTH?X[1]:X[3]:X[1]+r*(X[3]-X[1]),D=e.surface.extent;if(null==D||c(D,p,y)){const t=i(I,M),r=s(I)-m.radius,u=s(M)-m.radius,c=t<te;if(!c){console.warn(`Tile edge vertex position mismatch: between [${e.lij}].edge${_}[${Y}/${A.count}] and [${x.lij}].edge${L}[${Z}/${P.count}]`),null!=D&&console.warn("  surface extent= ",D," x,y=",p,",",y);const i=d();a(i,$.localOrigin,v.localOrigin),s(i)>0&&console.warn(`   localOrigins: ${$.localOrigin} vs ${v.localOrigin} d=${s(i)} [${i}]`);(()=>{const t=g(I),r=g(M);e.updateEdgeElevations(),x.updateEdgeElevations(),A.getVertexPos(I,Y),P.getVertexPos(M,Z);const i=d();l(i,I,t),s(i)>0&&console.warn(`  XXX Tile[${e.lij}] edge out of date: ${t} vs ${I} d=${s(i)} [${i}]`),l(i,M,r),s(i)>0&&console.warn(`  XXX Neighbor[${x.lij}] edge out of date: ${r} vs ${M} d=${s(i)} [${i}]`)})(),C(c,`Mismatch in tile [${e.lij}].edge[${_}][${Y}/${A.count}] vs neighbor [${x.lij}].edge[${L}][${Z}/${P.count}] ${b(I)} vs ${b(M)}  dist=${t} h(t|n|d)=${r}|${u}|${u-r}`)}A.getNormal(O,Y),P.getNormal(U,Z),o(k,O),o(F,U);const f=n(k,F),S=1-f<.01||!1||e===x;if(!S){const t=d();l(t,O,U);const r=()=>`Mismatch in tile edge normal ${T(e.lij)} (${Y}/${A.count-1}) edge ${_} vs neighbor ${T(x.lij)}  (${Z}/${P.count-1}) nedge ${L} :${b(O)} vs ${b(U)}  dot = ${f} : ${b(t)}`;console.warn("Mismatch in tile edge normal: ",r());{e.updateEdgeElevations(),x.updateEdgeElevations();const t=d(),r=d();A.getNormal(t,Y),P.getNormal(r,Z),h(O,t)||console.warn("Missing update in tile normal: ",b(O)," => ",b(t)),h(U,r)||console.warn("Missing update in neighbor normal: ",b(U)," => ",b(r))}C(S,r())}}Y+=1,Z+=1}}))}}const I=d(),M=d(),O=d(),U=d(),k=d(),F=d(),B=1,X=[null,null,null,null];function H(e,t){return t?.isLoaded||t===e?t:null}export{V as ActivationTime,G as PatchRenderData,H as neighborTileIfLoadedOrSelf};
