/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,s,a as i,g as o,u as n,f as r,e as l,j as a,w as h}from"../../../chunks/vec3.js";import{c as u}from"../../../chunks/vec3f64.js";import{lonLatToSphericalPCPF as c}from"../../../geometry/projection.js";import{newDoubleArray as d}from"../../../geometry/support/DoubleArray.js";import{intersectsSphere as p,NumPlanes as f,PlaneIndex as m}from"../../../geometry/support/frustum.js";import{c as g}from"../../../chunks/sphere.js";import{PatchType as $}from"./interfaces.js";import{TileFrustumVisibility as _}from"./ITile.js";import{createSphericalGlobePatch as v,updateCornerSpherical as x,updateEdgesAndCornersSpherical as M}from"./PatchGeometryFactory.js";import{ENABLE_TERRAIN_INTERNAL_CHECKS as j,internalAssert as b,almostEquals as S}from"./terrainUtils.js";import{Tile as T,CenterPosition as E}from"./Tile.js";import{compareTilesByLij as H}from"./tileUtils.js";class D extends T{get convexHull(){return this._convexHull}constructor(t,e,s){super(),this._convexHull=new Array(24),this._boundingSphere=g(),void 0!==t&&this.init(t,e,s)}init(s,i,o){super.init(s,i,o);const n=this.ellipsoid.radius,r=this.extentInRadians[0],l=this.extentInRadians[1],a=this.extentInRadians[2],h=this.extentInRadians[3],u=s[0],d=t(l,h,.5),p=t(r,a,.5),f=0===u?0:Math.min(Math.abs(l),Math.abs(h));this._edgeLen=(a-r)*Math.cos(f)*n,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=n-Math.sqrt(n*n-this._edgeLen2/4),c(this.centerAtSeaLevel,p,d,this.ellipsoid.radius),e(this.up,this.centerAtSeaLevel),this.updateRadiusAndCenter()}updateRadiusAndCenter(){this._updateBoundingVolumes();const t=this._center;if(0===this.lij[0])s(t[E.MIDDLE],0,0,0),s(t[E.TOP],0,0,0),s(t[E.BOTTOM],0,0,0),t[E.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const e=t[E.MIDDLE],s=this.convexHull;let i=0;for(let t=0;t<8;++t)i=Math.max(i,L(e,s,3*t));t[E.MIDDLE][3]=Math.sqrt(i)}}_calculateFrustumVisibilityStatus(t){if(!p(t,this._boundingSphere))return _.OUTSIDE;if(this.lij[0]<10)return _.INTERSECTS;const e=this.convexHull,s=this.surface.view.state.camera.near;let i=!0;for(let o=0;o<f;o++){const n=o===m.NEAR,r=t[o],l=r[0],a=r[1],h=r[2],u=r[3]-(n?s:0);let c=!1;for(let t=0;t<8;++t){const s=3*t;if(l*e[s]+a*e[s+1]+h*e[s+2]+u<0){if(c=!0,!i)break}else i=!1}if(!c)return _.OUTSIDE}return i?_.INSIDE:_.INTERSECTS}computeElevationBounds(){super.computeElevationBounds(),this._updateBoundingVolumes()}createGeometry(){v(this.renderData,this._getPatchType()),this._updateBoundingVolumes(),this.setMemoryDirty()}_updateBoundingVolumes(){this._updateConvexHull(),this._updateBoundingSphere(),j&&this._checkBVs()}_updateBoundingSphere(){const t=this._boundingSphere,e=t,r=this.elevationBounds,l=this.ellipsoid.radius,a=r[1];if(0===this.level)s(e,0,0,0),t[3]=l+a;else{const s=this.extentInRadians,a=.5*(s[0]+s[2]),h=s[1],u=s[3];y(O,a,h,l),y(A,a,u,l),i(e,O,A);const c=.5*(r[0]+r[1]);o(e,e,(l+c)/n(e));const d=this.convexHull;let p=0;const f=(t,e)=>{const s=t[0]-d[3*e],i=t[1]-d[3*e+1],o=t[2]-d[3*e+2];return Math.sqrt(s*s+i*i+o*o)};for(let t=0;t<8;++t){const s=f(e,t);p=Math.max(p,s)}const m=p;t[3]=m+2}}_updateConvexHull(){const t=this.extentInRadians,s=this.ellipsoid.radius;if(0===this.level)return;const a=this.elevationBounds,c=this._getPatchType(),d=this.surface.isWebMercator,p=d&&c===$.HAS_NORTH_POLE,f=d&&c===$.HAS_SOUTH_POLE,m=f||p,g=Math.PI/2,_=t[0],v=t[2],x=f?-g:t[1],M=p?g:t[3],j=.5*(_+v),T=a[0],E=s+(m?Math.min(0,T-1):T),H=(t,e,s)=>y(t,e,s,E),D=u(),I=u(),L=u(),R=u();H(D,_,x),H(I,_,M),H(L,v,M),H(R,v,x);const O=(t,e)=>{for(let s=0;s<3;++s)this._convexHull[3*e+s]=t[s]};O(D,0),O(I,1),O(L,2),O(R,3);const A=a[1],P=s+(m?Math.max(0,A+1):A),V=u(),C=u(),N=u();y(C,j,M,E),y(N,j,x,E),i(V,C,N),e(V,V);const k=u(),U=u(),F=(t,s)=>{h(U,t,s),e(U,U);const n=-l(t,k)/l(U,k);b(n>=0),o(U,U,n),i(t,t,U)};if(2**this.lij[0]>2*this.lij[1]){const t=N,s=u();r(s,B,t),e(s,s),r(k,t,s),e(k,k),b(S(l(k,t)/n(t),0)),F(D,I),F(R,L),O(D,0),O(R,3)}else if(2**this.lij[0]!==2*this.lij[1]){const t=C,s=u();r(s,B,t),e(s,s),r(k,s,t),e(k,k),F(I,D),F(L,R),O(I,1),O(L,2)}const w=(t,e)=>{const s=P/l(e,V);for(let i=0;i<3;++i)this._convexHull[3*t+i]=e[i]*s};w(4,D),w(5,I),w(6,L),w(7,R)}_getPatchType(){const t=this.lij[1],e=0===t,s=t===(1<<this.level)-1;return e?s?$.HAS_BOTH_POLES:$.HAS_NORTH_POLE:s?$.HAS_SOUTH_POLE:$.REGULAR}intersectsRay(t,e,s,i){const o=this._boundingSphere,n=o[3]+s,r=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],l=o[0]-t[0],a=o[1]-t[1],h=o[2]-t[2],u=(l*e[0]+a*e[1]+h*e[2])/r,c=e[0]*u-l,d=e[1]*u-a,p=e[2]*u-h;return c*c+d*d+p*p<n*n}getDefaultVerticesPerSide(){return this.level<I.length?I[this.level]+1:2}updateCornerElevations(){x(this.renderData),this._updateBoundingVolumes()}updateEdgeElevations(){M(this.renderData),this._updateBoundingVolumes()}_checkBVs(){if(!j)return;if(this.level<=2)return;const t=this._boundingSphere,s=t[3],o=t,c=u(),p=this.ellipsoid.radius,f=this.elevationBounds;f[1],f[0];const m=p+f[0],g=1,$=0,_=this._center[E.MIDDLE][3],v=this.convexHull,x=(t,e)=>{for(let s=0;s<3;++s)t[s]=v[3*e+s]};{const t=u(),s=u(),i=u(),o=u(),n=u(),a=(a,u,c,d)=>{x(s,a),x(i,u),x(o,c),h(s,s,i),h(o,o,i),r(t,s,o),e(t,t);const p=l(t,i);x(n,d);const f=l(t,n),m=Math.abs(f-p);b(S(m,0),`Non coplanar ${a},${u},${c},${d} diff = ${m}`)};a(0,1,2,3),a(4,5,6,7),a(0,1,4,5),a(1,2,5,6),a(2,3,6,7),a(3,0,7,4)}const M=d(24),T=(t,e,s)=>{const i=4*t;for(let o=0;o<3;++o)M[i+o]=e[o];M[i+3]=s},D=u(),I=u(),L=u(),B=u(),O=(t,s,i,o)=>{x(D,s),x(I,i),x(L,o),h(D,D,I),e(D,D),h(L,L,I),e(L,L),r(B,D,L),e(B,B);const n=l(B,I);T(t,B,n)};O(0,0,1,2),O(1,1,0,4),O(2,1,5,2),O(3,3,2,6),O(4,4,0,3),O(5,4,6,5);const A=1,P=(t,e,s,i)=>{const o=4*t;return M[o]*e+M[o+1]*s+M[o+2]*i-M[o+3]},V=(t,e,s,i)=>P(t,e,s,i)>=-A,C=(t,e)=>V(t,e[0],e[1],e[2]),N=2**this.lij[0]>2*this.lij[1],k=(t,e,i)=>Math.sqrt(R(t,e,i,o[0],o[1],o[2]))<s,U=t=>k(t[0],t[1],t[2]),F=(t,e)=>k(t[e],t[e+1],t[e+2]),w=this.extentInRadians,q=.5*(w[0]+w[2]),G=w[1],z=w[3],W=u(),J=u();y(W,q,z,m),y(J,q,G,m);const K=N?"Upper":"Lower";let Q=!0;for(let e=0;e<6;++e){for(let t=0;t<8;++t){const s=3*t,i=V(e,v[s],v[s+1],v[s+2]);Q&&=i,b(i,`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}b(C(e,J),`Tile[${this.lij}] (${K}) bottom mid outside of plane ${e}`),b(C(e,W),`Tile[${this.lij}] (${K}) top mid outside of plane ${e}`)}b(Q,"Not all convex hull points are inside  convex hull polyhedron"),b(U(J),`Tile[${this.lij}] (${K}) bottom mid outside of bounding sphere`),b(U(W),`Tile[${this.lij}] (${K}) top mid outside of bounding sphere`);for(let e=0;e<8;++e){const t=F(v,3*e);b(t,`Tile[${this.lij}] Convex hull point ${e} outside of bounding sphere`)}for(let e=0;e<6;++e)for(let t=0;t<8;++t){const s=3*t;V(e,v[s],v[s+1],v[s+2])||console.error(`Tile[${this.lij}] Convex hull point ${t} outside of plane ${e}`)}const X=this.extentInRadians,Y=Math.max(X[2]-X[0],X[3]-X[1]),Z=Math.round(Y*p),tt=this.renderData;if(!tt)return;const{geometry:et,localOrigin:st}=tt,it=et.vertexAttributes?.position;if(!it)return;const ot=it.count,nt=u(),rt=et.numVerticesPerSide-2,lt=rt*rt,at=tt.geometryState.neighborData,ht=at.edgeResolutions.reduce(((t,e)=>t+e+1),0);for(let e=0;e<ot;++e){const t=e<lt,r=!t&&e<lt+ht;let l=!1,h=-1;if(r){let t=lt;for(let s=0;s<4;++s){const i=at.edgeResolutions[s];if(e===t||e===t+i-1){l=!0;break}if(t+=i,e<t){h=s;break}}}const u=r?at.edgePeerNeighbors[h]:null,d=r&&u&&H(this,u)>0;it.getVec(e,c),i(nt,c,st);const m=n(nt)-p;let v=0,x=!1;const M=f[0]-m,j=m-f[1],b=M>g,S=j>g,T=b||S,E=()=>{const s=t?"internal":r&&!l?"edge":l?"corner":"pole";return`Tile[${this.lij}].vertex[${e}]:${s}`+(b?"(below)":S?"(above)":"")+(d?"(Neighbor)":"")},D=a(nt,o);if(D>=s+$){const t=D-s;T||(console.error(`${E()} is out of the bounding sphere by ${t.toFixed(0)} / ${s.toFixed(0)}[tol=${$}] h=${m.toFixed(0)} / [${f[0].toFixed(0)}..${f[1].toFixed(0)}] (${(t/s).toFixed(0)})`),x=!0)}for(let i=0;i<6;++i)if(!V(i,nt[0],nt[1],nt[2])){const t=P(i,nt[0],nt[1],nt[2]),o=e%rt,n=(e-o)/rt;0===i&&M||5===i&&j||(console.error(`${E()} (${o},${n})|${rt}] is out of the bounding trapezoid plane ${i} h=${Math.round(m)} / [${Math.round(f[0])}..${Math.round(f[1])}] dist=${Math.round(t)} radii = ${Math.round(s)}/${Math.round(_)}} : maxL = ${Z}`),++v)}if(x||v>0)break}}}const I=[128,64,64,32,16,8,8,4];function L(t,e,s){return R(t[0],t[1],t[2],e[s],e[s+1],e[s+2])}function R(t,e,s,i,o,n){const r=i-t,l=o-e,a=n-s;return r*r+l*l+a*a}const y=(t,e,s,i)=>{const o=Math.cos(e),n=Math.sin(e),r=Math.cos(s),l=Math.sin(s);t[0]=i*r*o,t[1]=i*r*n,t[2]=i*l},B=[0,0,1],O=u(),A=u();export{D as SphericalPatch};
