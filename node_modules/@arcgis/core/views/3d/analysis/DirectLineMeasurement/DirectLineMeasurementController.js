/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import i from"../../../../core/Handles.js";import s from"../../../../core/Logger.js";import{destroyMaybe as o}from"../../../../core/maybe.js";import{createQuantity as r}from"../../../../core/quantityUtils.js";import{watch as n,syncAndInitial as a}from"../../../../core/reactiveUtils.js";import{property as c}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/accessorSupport/ensureType.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import{subclass as l}from"../../../../core/accessorSupport/decorators/subclass.js";import{i as m}from"../../../../chunks/vec3.js";import{c as p}from"../../../../chunks/vec3f64.js";import{geodesicLength as d}from"../../../../geometry/geometryEngine.js";import u from"../../../../geometry/Polyline.js";import{canProjectWithoutEngine as h,projectPointToVector as v,projectPointToWGS84ComparableLonLat as f}from"../../../../geometry/projection.js";import{getSphericalPCPF as _,SphericalECEFSpatialReference as j,WGS84ECEFSpatialReference as g}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{isSupported as P,geodesicLengths as y,InverseGeodeticSolverResult as D,inverseGeodeticSolver as w}from"../../../../geometry/support/geodesicUtils.js";import{MeasurementMode as z}from"../interfaces.js";import{applyProjectionAndElevationAlignment as A,logFailedGeometryProjectionError as R}from"../support/projectionUtils.js";import{UnitNormalizer as E}from"../support/UnitNormalizer.js";const b="esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController",S=s.getLogger(b),U=1e5;let k=class extends t{constructor(e){super(e),this._unitNormalizer=new E,this._handles=new i,this._tempStartPosition=p(),this._tempEndPosition=p(),this._tempCornerPosition=p()}initialize(){const e=this.view.spatialReference,t=_(e),i=t===j?g:t;this._sphericalPCPF=i;const s=h(e,i);this._unitNormalizer.spatialReference=s?i:e,this._handles.add([n((()=>({viewData:this.viewData,startPoint:this.analysis.startPoint})),(({viewData:e,startPoint:t})=>{e.elevationAlignedStartPoint=this._applyProjectionAndElevationAlignment(t)}),a),n((()=>({viewData:this.viewData,endPoint:this.analysis.endPoint})),(({viewData:e,endPoint:t})=>{e.elevationAlignedEndPoint=this._applyProjectionAndElevationAlignment(t)}),a),n((()=>({result:this._computedResult,viewData:this.viewData})),(({result:e,viewData:t})=>{t.result=e}),a)])}destroy(){this._handles=o(this._handles)}_applyProjectionAndElevationAlignment(e){if(null==e)return e;const{spatialReference:t,elevationProvider:i}=this.view,s=A(e,t,i);return s??(R(this.analysis,e.spatialReference,S),null)}get _computedResult(){const{elevationAlignedStartPoint:e,elevationAlignedEndPoint:t,measurementMode:i}=this.viewData;if(null==e||null==t)return null;const s=this._euclideanDistances(e,t),o=this._geodesicDistance(e,t,s.horizontal.value),r=i===z.Geodesic||i===z.Auto&&s.horizontal.value>U?"geodesic":"euclidean";return{mode:r,distance:"euclidean"===r?s.direct:o,directDistance:s.direct,horizontalDistance:s.horizontal,verticalDistance:s.vertical,geodesicDistance:o}}_euclideanDistances(e,t){const i=e.clone();i.z=t.z;const s=this._tempStartPosition,o=this._tempEndPosition,n=this._tempCornerPosition,a=this.view.spatialReference,c=this._sphericalPCPF,l=h(a,c)?c:a;v(e,s,l),v(t,o,l),v(i,n,l);const p=m(s,o),d=m(n,o),u=Math.abs(t.z-e.z),f=e=>this._unitNormalizer.normalizeDistance(e),_=f(p),j=f(d),g=f(u);return{direct:r(_,"meters"),horizontal:r(j,"meters"),vertical:r(g,"meters")}}_geodesicDistance(e,t,i){const s=e.spatialReference,o=new u({spatialReference:s});o.addPath([e,t]);const n=s.isGeographic&&P(s)?y([o],"meters")[0]:s.isWebMercator?d(o,"meters"):null,a=null!=n?n:this._fallbackGeodesicDistance(e,t,i);return r(a,"meters")}_fallbackGeodesicDistance(e,t,i){if(f(e,C)&&f(t,M)){const e=new D;return w(e,C,M),e.distance}return i}};e([c()],k.prototype,"view",void 0),e([c()],k.prototype,"analysis",void 0),e([c()],k.prototype,"viewData",void 0),e([c()],k.prototype,"_computedResult",null),k=e([l(b)],k);const C=p(),M=p();export{k as DirectLineMeasurementController};
