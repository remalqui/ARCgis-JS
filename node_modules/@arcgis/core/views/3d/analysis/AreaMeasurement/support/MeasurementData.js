/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{deg2rad as e}from"../../../../../core/mathUtils.js";import{createLength as t,createArea as s}from"../../../../../core/quantityUtils.js";import{s as i,d as o}from"../../../../../chunks/vec2.js";import{a as r}from"../../../../../chunks/vec2f64.js";import{n,i as h,c as a,f as d,o as l,b as g,e as p,g as c,a as m}from"../../../../../chunks/vec3.js";import{c as u}from"../../../../../chunks/vec3f64.js";import{c as _}from"../../../../../chunks/vec4f64.js";import{getReferenceEllipsoid as f}from"../../../../../geometry/ellipsoidUtils.js";import{canProjectWithoutEngine as C,canProjectToWGS84ComparableLonLat as S,projectPointToVector as L,projectPointToWGS84ComparableLonLat as P,projectDirection as R,projectVectorToVector as j}from"../../../../../geometry/projection.js";import M from"../../../../../geometry/SpatialReference.js";import{getSphericalPCPF as A}from"../../../../../geometry/spatialReferenceEllipsoidUtils.js";import{Axis as v}from"../../../../../geometry/support/Axis.js";import{compactIndices as W}from"../../../../../geometry/support/Indices.js";import{segmentIntersects as I}from"../../../../../geometry/support/intersectsBase.js";import{areaPoints2d as w}from"../../../../../geometry/support/triangle.js";import{MeasurementMode as z}from"../../interfaces.js";import{segmentLengthGeodesicVector as U,bestFitPlane as G,fitHemisphere as V,triangleAreaGeodesic as y,planePointDistance as T,boundingSphere as F,segmentLengthGeodesic as E,segmentLengthEuclidean as N}from"../../support/measurementUtils.js";import{midpoint as x}from"../../support/viewUtils.js";import{getElevationAtPoint as k}from"../../../support/ElevationProvider.js";import{makeOrthonormal as b,tangentFrame as q}from"../../../support/mathUtils.js";import{triangulate as D}from"../../../../support/euclideanAreaMeasurementUtils.js";class B{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.areaCentroidWorldCoords=u(),this.areaCentroidRenderCoords=u(),this.geodesicAreaCentroidRenderCoords=u(),this.area=null,this.geodesicArea=null,this.pathLength=null,this.geodesicPathLength=null,this.perimeterLength=null,this._length=0,this._centroidRenderCoords=u(),this._planeWorldCoords=_(),this._worldUp=u(),this._worldTangent=u(),this._frame=[u(),u(),u()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=u(),this._tempV=u(),this._tempVec3=u(),this._tempSphere={center:u(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,s,i,o,r,h,a){const d=this.unitNormalizer,l=this._sceneView.renderSpatialReference,g=this.unitNormalizer.spatialReference,p=null!=s;if(this._pathVersion===e.version&&this._validMeasurement===o&&!a&&this._hasCursorPoint===p&&this._mode===h){return!e.isValidPolygon&&(this._updateCursorSegmentLength(e,s),!0)}this._pathVersion=e.version,this._validMeasurement=o,this._hasCursorPoint=p;const c=e.numVertices;this._resize(c);const m=A(i.spatialReference),u=C(i.spatialReference,m)&&S(i.spatialReference),{positionsGeographic:_,positionsWorldCoords:f,positionsRenderCoords:R,positionsSpherical:j}=this;e.forEachVertexPosition(((e,t)=>{H(i.elevationProvider,e),L(e,f[t],g),L(e,R[t],l),u&&(P(e,_[t]),L(e,j[t],m),n(j[t],j[t]))}));const M=this._updatePathLengths(o);if(this.pathLength=this._length>1?t(d.normalizeDistance(M),"meters"):null,u){const e=this._updateGeodesicPathLengths(o,g);this.geodesicPathLength=this._length>1?t(e,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,s),this._updateMode(e,h),o?(this._updateArea(i,d,l,g,r),u&&this._updateGeodesicArea(i),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(u()),this.positionsRenderCoords.push(u()),this.positionsProjectedWorldCoords.push(r()),this.positionsFittedRenderCoords.push(u()),this.positionsGeographic.push(u()),this.positionsSpherical.push(u()),this.positionsStereographic.push(r()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const r=s[o]=h(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=r)}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=U(s[r],s[(r+1)%this._length],t??void 0);(r<this._length-1||e)&&(o+=n)}return o}_updateArea(e,o,r,n,h){const u=e.renderCoordsHelper,_=this.positionsWorldCoords,f=this.positionsRenderCoords,C=this.positionsProjectedWorldCoords,S=this.positionsFittedRenderCoords,L=this._planeWorldCoords,P=this._centroidRenderCoords;x(f,P),u.worldUpAtPosition(P,this._worldUp),u.worldBasisAtPosition(P,v.X,this._worldTangent),R(P,this._worldUp,r,this._worldUp,n),R(P,this._worldTangent,r,this._worldTangent,n),_.length>2&&G(_,L),this.fittingMode=this._selectFittingMode(L,_,this._worldUp,h);let M=0;if("horizontal"===this.fittingMode){let e=-1/0;f.forEach(((t,s)=>{const i=u.getAltitude(f[s]);i>e&&(e=i,M=s)}))}const A=_[M];let W=L,I=this._worldTangent;"horizontal"===this.fittingMode?W=this._worldUp:"vertical"===this.fittingMode&&(W=this._tempVec3,I=this._worldUp,b(L,this._worldUp,W)),a(this._frame[2],W),b(I,W,this._frame[0]),d(this._frame[1],this._frame[0],this._frame[2]),l(this._frame[1],this._frame[1]);const w=this._tempVec3,z=this._tempU,U=this._tempV;for(let t=0;t<this._length;++t){const e=C[t],s=S[t];g(w,_[t],A),i(e,p(this._frame[0],w),p(this._frame[1],w)),c(z,this._frame[0],e[0]),c(U,this._frame[1],e[1]),m(w,z,U),m(w,w,A),j(w,n,s,r)}this.perimeterLength=this._length>0?t(o.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,x(S,this.areaCentroidRenderCoords),j(this.areaCentroidRenderCoords,r,this.areaCentroidWorldCoords,n),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?s(o.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const{renderCoordsHelper:t,spatialReference:o}=e,{positionsSpherical:r,positionsStereographic:n}=this,h=this._tempVec3,a=V(r,h);if(!a)return void(this.geodesicArea=null);const d=this._tempU,l=this._tempV;q(h,d,l);for(let s=0;s<this._length;++s){const e=p(r[s],d),t=p(r[s],l),o=p(r[s],h);i(n[s],e/o,t/o)}c(h,h,f(o).radius),t.toRenderCoords(h,A(o),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=a&&0===this.geodesicIntersectingSegments.size?s(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=o(e[i],e[(i+1)%this._length])}return s}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];I(o,r,n,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=this.triangleIndices=W(D(e));let s=0;for(let i=0;i<t.length;i+=3)s+=w(e[t[i]],e[t[i+1]],e[t[i+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];I(o,r,n,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=this.positionsStereographic,s=this.geodesicTriangleIndices=W(D(t));let i=0;for(let o=0;o<s.length;o+=3)i+=y(e[s[o]],e[s[o+1]],e[s[o+2]],M.WGS84);return i}_selectFittingMode(t,s,i,o){const r=s.map((e=>Math.abs(T(t,e)))).reduce(((e,t)=>Math.max(e,t)),0);F(s,this._tempSphere);const n=r/(2*this._tempSphere.radius),h=n<o.maxRelativeErrorCoplanar,a=n<o.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(h)d="oblique";else if(a){d=Math.abs(p(i,t))>Math.cos(e(o.verticalAngleThreshold))?"horizontal":"vertical"}return d}_updateCursorSegmentLength(e,s){const i=e.lastPoint;e.isValidPolygon||null==i||null==s?(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null):(this.geodesicCursorSegmentLength=t(E(i,s),"meters"),this.cursorSegmentLength=t(this.unitNormalizer.normalizeDistance(N(i,s,this.unitNormalizer.spatialReference)),"meters"))}_updateMode(e,t){if(t===z.Auto){this.actualMeasurementMode="euclidean";let t=0;null!=this.geodesicPathLength&&(t+=this.geodesicPathLength.value),e.isValidPolygon||null==this.geodesicCursorSegmentLength||(t+=this.geodesicCursorSegmentLength.value),t>X&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=t===z.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=t}}function H(e,t){t.hasZ||(t.z=k(e,t,"ground")??0)}const X=1e5;export{B as MeasurementDataManager};
