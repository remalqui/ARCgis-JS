/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{ObservableBase as t}from"./ObservableBase.js";import{OriginId as e}from"./PropertyOrigin.js";import{trackAccess as s,runTracked as i,trackExplicitDependencies as r,runUntracked as o}from"./tracking.js";import{Flags as n}from"./tracking/Flags.js";class a{constructor(t,e){this.propertyName=t,this.metadata=e,this.observerObject=new l,this._accessed=null,this._handles=null,this.observerObject.flags=n.Dirty|(e.nonNullable?n.NonNullable:0)|(e.hasOwnProperty("value")?n.HasDefaultValue:0)|(void 0===e.get?n.DepTrackingInitialized:0)|(void 0===e.dependsOn?n.AutoTracked:0)}destroy(){this.observerObject.destroy(),this._accessed=null,this._clearObservationHandles()}getComputed(t){const a=this.observerObject;s(a);const l=t.store,c=this.propertyName,h=a.flags,d=l.get(c);if(h&n.Computing)return d;if(~h&n.Dirty&&l.has(c))return d;a.flags|=n.Computing;const g=t.host;let f;h&n.AutoTracked?f=i(this,this.metadata.get,g):(r(g,this),f=this.metadata.get.call(g)),l.set(c,f,e.COMPUTED);const m=l.get(c);return m===d?a.flags&=~n.Dirty:o(this.commit,this),a.flags&=~n.Computing,m}onObservableAccessed(t){if(t===this.observerObject)return;let e=this._accessed;if(null==e)e=[],this._accessed=e;else if(e.includes(t))return;e.push(t)}onTrackingEnd(){this._clearObservationHandles();const t=this.observerObject;t.flags|=n.DepTrackingInitialized;const e=this._accessed;if(null==e||0===e.length)return;let s=this._handles;null==s&&(s=[],this._handles=s);for(let i=0;i<e.length;++i)s.push(e[i].observe(t));e.length=0}notifyChange(){const t=this.observerObject;t.onInvalidated(),t.onCommitted()}invalidate(){this.observerObject.onInvalidated()}commit(){const t=this.observerObject;t.flags&=~n.Dirty,t.onCommitted()}_clearObservationHandles(){const t=this._handles;if(null!==t){for(let e=0;e<t.length;++e)t[e].remove();t.length=0}}}class l extends t{constructor(){super(...arguments),this.flags=0}onInvalidated(){~this.flags&n.Overriden&&(this.flags|=n.Dirty);const t=this._observers;if(t&&t.length>0)for(const e of t)e.onInvalidated()}onCommitted(){const t=this._observers;if(t&&t.length>0){const e=t.slice();for(const t of e)t.onCommitted()}}destroy(){this.flags&n.Dirty&&this.onCommitted(),super.destroy()}}export{a as Property};
