/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{splitIntoChunks as e}from"../../../core/arrayUtils.js";import{lerp as t}from"../../../core/mathUtils.js";import{forEachSome as r}from"../../../core/maybe.js";import{throwIfAborted as o,after as s,isAbortError as n,throwIfNotAbortError as i}from"../../../core/promiseUtils.js";import l from"../../../geometry/Multipoint.js";import{unnormalizedCoordinate as a}from"../../../geometry/support/coordsUtils.js";import{getInfo as c}from"../../../geometry/support/spatialReferenceUtils.js";import{QueueProcessor as p}from"../../../views/support/QueueProcessor.js";import{TaskPriority as u}from"../../../views/support/Scheduler.js";import{getConfig as m,ERROR_RESULT as f}from"./constants.js";import{isValidInputPath as d,countPoints as h,densifyPath as y}from"./geometryUtils.js";import{ProfileGenerationError as w,ProfileGenerationErrorCause as g}from"./ProfileGenerationError.js";import{getStatistics as v}from"./statisticsUtils.js";import{breadthFirstBinaryPartitioning as j}from"../../support/traversalUtils.js";async function*P(e,t){const{view:n,geometry:i,elevationInfo:l,providers:a,options:c}=e,p=n.spatialReference;if(!p||null==i||!d(i))throw new w(g.InvalidGeometry);const u=a.length;if(0===u)return null;const f=Math.round(c.maxTotalSamples/u);if(h(i)>f)throw new w(g.TooComplex);const v=await y(i,l,n,p,c,f,t);let j=0;const P=new Array(u),Z=new Array(u);for(let r=0;r<u;r++){const o=S(v);P[r]=o,j+=o.samples.length;const s={...e,provider:a[r],result:o,densificationResult:v};Z[r]=R(s,t)[Symbol.iterator]()}if(j>c.maxTotalSamples)throw new w(g.TooComplex);const x=await Promise.all(Z.map((e=>{const t=e.next();return!0===t.done?Promise.resolve(null):t.value})));o(t);for(let r=0;r<u;r++)P[r]=x[r];yield P,await s(e.delayAfterPreview??m().delayAfterPreviewMillis,null,t.signal);const E=[];try{let e;do{e=!1;for(let t=0;t<u;t++){const r=Z[t].next();!1===r.done&&(E.push({resultPromise:r.value,index:t}),e=!0)}}while(e)}finally{Z.forEach((e=>e.return?.()))}for(const{resultPromise:r,index:s}of E)P[s]=await r,o(t),yield P;r(P,(e=>{e.progress=1})),yield P}function*R(t,r){const{densificationResult:o}=t,s={...t,abortOptions:r,densificationResult:o},n=j(0,s.result.samples.length),i=n.slice(0,s.provider.numSamplesForPreview);yield Z(s,i,!0);const l=e(n,s.provider.numSamplesPerChunk);for(const e of l)yield Z(s,e,!1)}async function Z({densificationResult:e,result:t,provider:r,queue:o,abortOptions:s,cache:i},a,c){const{densifiedPath:p,pathLength:u}=e,d=t.spatialReference,{samples:h}=t,y=[];for(let n=0;n<a.length;n++){const e=h[a[n]];y[n]=e.coordinate}try{return await o.push({geometry:new l({spatialReference:d,points:y,hasZ:p.hasZ}),provider:r,indices:a,preview:c,result:t,queryOptions:{...m().defaultQueryOptions(),minDemResolution:c?Math.round(u/r.numSamplesForPreview):Math.round(u/h.length),cache:i}},s),{...t}}catch(w){return n(w)?null:f}}function x(e){return new p({priority:u.ELEVATION_PROFILE,concurrency:1,scheduler:e,process:async e=>{o(e.queryOptions);try{await E(e)}catch(t){i(t)}}})}async function E({geometry:e,provider:t,indices:r,preview:o,result:s,queryOptions:n}){if(0===r.length)return;const i=(await T(t,e,n)).geometry,{hasZ:l,points:a}=i,c=n.noDataValue,{samples:p}=s;for(let u=0;u<r.length;u++){const e=p[r[u]];if(e.isHole)continue;const t=l?a[u][2]:null;null===t||t===c?e.sampledZ=null:(s.hasZ=!0,e.sampledZ=t),e.sampled=!0}O(p),s.progress=o?0:s.progress+r.length/p.length,s.statistics=v(s.samples,s.spatialReference)}function O(e){const t=e.length-1;let r=0;for(let o=1;o<=t;o++){(e[o].sampled||o===t)&&(U(e,r,o),r=o)}}function U(e,r,o){if(o-r==1)return;const s=e[r],n=s.sampledZ,i=e[o],l=i.sampledZ;if(null==n||null==l){for(let t=r+1;t<o;t++)e[t].sampledZ=null;return}const a=s.distance,c=i.distance-a;for(let p=r+1;p<o;p++){const r=e[p],o=(r.distance-a)/c;r.sampledZ=t(n,l,o)}}function S({densifiedPath:e,distances:t}){const r=e.spatialReference,o=c(r),s=e.paths,n=s.length,i=[];let l=null,p=0;for(let c=0;c<n;c++){const e=s[c],r=e.length,n=t[c];for(let t=0;t<r;t++){const r=e[t],s=n[t];o&&(r[0]=a(r[0],o.valid[0],o.valid[1])),l&&0===t&&q(i,l,r,p,s),i.push(A(r,s)),l=r,p=s}}return{progress:0,samples:i,hasZ:!1,statistics:null,spatialReference:r}}function q(e,t,r,o,s){e.push(M(t,o)),e.push(M(r,s))}function A(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!1,isHole:!1}}function M(e,t){return{coordinate:e,distance:t,sampledZ:null,sampled:!0,isHole:!0}}async function T(e,t,r){try{return await e.queryElevation(t,r)}catch(o){throw new w(g.ElevationQueryError)}}export{x as createProfileQueue,R as generateProfile,P as generateProfiles,O as interpolateElevations};
