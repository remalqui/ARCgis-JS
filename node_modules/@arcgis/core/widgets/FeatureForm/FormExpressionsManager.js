/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../core/Accessor.js";import{getOrCreateMapValue as s}from"../../core/MapUtils.js";import{isAbortError as r,createResolver as o}from"../../core/promiseUtils.js";import{property as a}from"../../core/accessorSupport/decorators/property.js";import"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{subclass as n}from"../../core/accessorSupport/decorators/subclass.js";const i="#JSAPI_FORM_EXPRESSIONS_MANAGER_GEOMETRY",l="esri.widgets.FeatureForm.FormExpressionsManager";let c=class extends t{constructor(e){super(e),this._fieldReferencesLookup=new Map,this._fieldsAffectedLookup=new Map,this._latestFieldValues={...e.feature.attributes}}initialize(){this._dependencyGraph=this._buildDependencyGraph()}get _baseContext(){const{editType:e,layer:t,map:s,originalFeature:r,spatialReference:o}=this.arcadeContextInfo,a="feature"===t?.type?t:"scene"===t?.type&&null!=t.associatedLayer?t.associatedLayer:void 0;return[{$originalfeature:r,$editcontext:{editType:e},$layer:a,$featureset:a,$datastore:t?.url,$map:s},{spatialReference:o??void 0}]}set feature(e){this._latestFieldValues={...e?.attributes},this._set("feature",e)}evaluateAll(){return this._evaluate(this.executors)}evaluateExpressions(e){return this._evaluate(e)}evaluateInvalidated(e){const{_fieldReferencesLookup:t,_latestFieldValues:s,feature:r}=this,o=new Set;for(const a of e)if(s[a]=r.getAttribute(a),t.has(a))for(const e of t.get(a))o.add(e);return this._evaluate([...o])}async evaluateInvalidatedByGeometry(){if(this._fieldReferencesLookup.has(i))return this._evaluate([...this._fieldReferencesLookup.get(i)])}resetExecutors(){for(const e of this.executors)e.reset()}_buildDependencyGraph(){const{_fieldReferencesLookup:e,_fieldsAffectedLookup:t,executors:r}=this,o=new Map(this.fieldInputs.map((e=>[e.name,e]))),a=new Map(r.map((e=>[e,new Array])));for(const n of r){for(const r of n.fieldsUsed){s(e,r,(()=>new Set)).add(n);const i=o.get(r),l=i?.valueExpressionExecutor,c=i?.editableExpressionExecutor;if(null!=l&&l!==n){a.get(l).push(n);s(t,l,(()=>new Set)).add(i)}if(null!=c&&c!==n){a.get(c).push(n);s(t,c,(()=>new Set)).add(i)}}if(n.geometryUsed){s(e,i,(()=>new Set)).add(n)}}return a}async _evaluate(e){const t=new Map,{_dependencyGraph:s,_fieldsAffectedLookup:o,_latestFieldValues:a}=this;for(const r of e)u(r,t,s);for(const[i,{resolver:l,dependencyPromises:c}]of t){Promise.all(c).then((async()=>{const[e,t]=this._makeContext(a);return i.executeAsync(e,t)})).then((()=>{if(o.has(i))for(const e of o.get(i))this._latestFieldValues[e.name]=e.value;l.resolve()}),(e=>{!e||r(e)||p(e)||i.markStale(),l.reject(e)}))}const n=(await Promise.allSettled(Array.from(t.values(),(({resolver:e})=>e.promise)))).filter((e=>"rejected"===e.status&&!(r(e.reason)||p(e.reason))));if(n.length>0)throw new AggregateError(n,"One or more expression executions failed")}_makeContext(e){const[t,s]=this._baseContext,r=this.feature.clone();return r.attributes=e,[{...t,$feature:r},s]}};e([a()],c.prototype,"_baseContext",null),e([a()],c.prototype,"feature",null),e([a()],c.prototype,"executors",void 0),e([a()],c.prototype,"fieldInputs",void 0),e([a()],c.prototype,"arcadeContextInfo",void 0),c=e([n(l)],c);const u=(e,t,s)=>{if(t.has(e))return;const r=o();t.set(e,{resolver:r,dependencyPromises:[]}),e.abort();const a=s.get(e);for(const o of a)u(o,t,s),t.get(o).dependencyPromises.push(r.promise)},p=e=>e&&"object"==typeof e&&"message"in e&&"Cancelled"===e.message;export{c as FormExpressionsManager};
