/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import"../../geometry.js";import t from"../../Graphic.js";import r from"../../core/Collection.js";import i from"../../core/Evented.js";import o from"../../core/Logger.js";import{destroyMaybe as s}from"../../core/maybe.js";import{once as a,on as n,watch as l,when as g,syncAndInitial as h}from"../../core/reactiveUtils.js";import{createScreenPoint as c}from"../../core/screenUtils.js";import{property as u}from"../../core/accessorSupport/decorators/property.js";import{ensureType as m}from"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{subclass as d}from"../../core/accessorSupport/decorators/subclass.js";import p from"../../geometry/Extent.js";import y from"../../layers/GraphicsLayer.js";import _ from"../../layers/ImageryTileLayer.js";import{searchImages as v}from"../../layers/orientedImagery/queries.js";import{calculateSuitabilities as f}from"../../layers/orientedImagery/core/bestImageUtils.js";import{createCoveragePolygon as C,computePolygonForInspection as w,resizePolygon as P,checkIfPolygonContainsSelectedPoint as I}from"../../layers/orientedImagery/core/coverageUtils.js";import{updateElevation as b,transformPoints as F}from"../../layers/orientedImagery/transformations/groundToImageUtils.js";import{transformPoints as V}from"../../layers/orientedImagery/transformations/imageToGroundUtils.js";import S from"../../views/MapView.js";import{getResolutionToScaleFactor as x}from"../../views/2d/viewpointUtils.js";import{projectWithEngineOrService as O}from"../../views/support/projectionUtils.js";import{activePolygonSymbol as G,polygonSymbol as M,activeSourcePointSymbol as j,sourcePointSymbol as R,crossSymbol as L,diamondSymbol as D}from"./symbols.js";import A from"../../geometry/Polygon.js";import E from"../../geometry/SpatialReference.js";import U from"../../geometry/Point.js";const J={click:"view-click",view:"view",viewLayers:"view-layers",mapLayers:"map-layers",layerViews:"layer-views",layerListMode:"layer-list-mode",children:"children",registerLayerSelection:"register-layer-selection",plotPointOnGround:"plot-point-on-ground"};function N(e){return"3d"===e?.type}function T(e){return"esri.Graphic"===e?.declaredClass}let k=class extends i.EventedAccessor{constructor(e){super(e),this.activeLayer=null,this.shouldShowSelectedImage=!1,this.coverageFrustums=null,this.coveragePolygons=null,this.displayMessage=null,this.pointSources=null,this.selectedFeature=null,this.selectedPoint=null,this.features=null,this._additionalCoveragePolygons=null,this._additionalFeatureGraphics=null,this._currentCoveragePolygon=null,this._currentImage=null,this._fetchFeaturesController=null,this._imageViewer=null,this._initialCurrentCoveragePolygon=null,this._initialCurrentCoverageUpdate=!0,this._overlays=null,this._referencePointOnGround=null,this._referencePointOnImage=null,this._crossSymbol=null,this._panConstraint=null,this._scaleConstraint=null,this._transformController=new AbortController,this._updateCoverageController=null,this.loadViewer=this.loadViewer.bind(this),this.searchBestImage=this.searchBestImage.bind(this)}initialize(){a((()=>this.view?.ready)).then((()=>{this._overlays=new y({listMode:"hide"}),this.view.map.layers.add(this._overlays)})),this.addHandles(n((()=>this.view),"click",(e=>{this.view.ready&&this.active&&(e.stopPropagation(),e.preventDefault(),"mouse"===e.pointerType&&0!==e.button||(e.native.altKey?(this.plotReferencePoint(e),this.plotImagePointOnGround({feature:this.selectedFeature,selectedLocation:e.mapPoint,options:{signal:this._transformController?.signal}})):(this.displayMessage=null,this.selectedPoint=e.mapPoint,this.features=null,this.selectedFeature=null,this._overlays?.removeAll(),this._overlays?.add(new t({geometry:e.mapPoint.clone(),symbol:L})),this._fetchFeaturesWithController(e))))})),J.view)}destroy(){this._cancelCurrentCoverageUpdate(),this._cancelFetchingFeatures(),this.coverageFrustums=null,this.coveragePolygons=null,this.pointSources=null,this._additionalCoveragePolygons=null,this._additionalFeatureGraphics=null,this._currentImage=s(this._currentImage),this._imageViewer=s(this._imageViewer),this._initialCurrentCoveragePolygon=s(this._initialCurrentCoveragePolygon),this._currentCoveragePolygon=s(this._currentCoveragePolygon),this._crossSymbol=s(this._crossSymbol),this._referencePointOnGround=s(this._referencePointOnGround),this._referencePointOnImage=s(this._referencePointOnImage),this._overlays=s(this._overlays)}get active(){return!0===this.view?.map?.allLayers.some((e=>"oriented-imagery"===e.type&&e.loaded))}get currentImageView(){return this._imageViewer?.allLayerViews.find((e=>e.layer===this._currentImage))}get featureCount(){return this.features?.length??0}get hasImageLoaded(){return!!this._currentImage}get isAdditionalCoverageDisabled(){return!this._additionalCoveragePolygons?.length}get isAdditionalCoverageVisible(){return this._additionalCoveragePolygons?.getItemAt(0)?.visible??!1}get isAdditionalPointSourcesDisabled(){return!this._additionalFeatureGraphics?.length}get isAdditionalPointSourcesVisible(){return this._additionalFeatureGraphics?.getItemAt(0)?.visible??!1}get isCurrentCoverageDisabled(){return!this._currentCoveragePolygon}get isCurrentCoverageVisible(){return!!this._currentCoveragePolygon?.visible}get updating(){return!(this._imageViewer?.stationary??1)||(this.currentImageView?.updating??!1)||"loading"===this._currentImage?.loadStatus||!!this._fetchFeaturesController}get state(){const{active:e,hasImageLoaded:t,updating:r}=this;return r?"loading":t?"image-loaded":e?"ready":"disabled"}set view(e){this._set("view",e)}getCurrentCoveragePolygon(){return this._currentCoveragePolygon}getSelectedFeature(){return this.selectedFeature}getSelectedFeaturePolygon(){return this._initialCurrentCoveragePolygon}loadViewer(e){const t=new Map,r={wkid:0};this._imageViewer=new S({container:e,map:t,spatialReferance:r,constraints:{snapToZoom:!1,rotationEnabled:!1},ui:{components:["zoom"]}}),a((()=>this._imageViewer?.stationary)).then((()=>{this.setMessage("onLoadMessage","info")})),this._imageViewer.addHandles([this._imageViewer.on("click",(async e=>{if(0===e.button&&this._currentImage&&this._currentImage&&this._currentImage.fullExtent){const{xmin:t,xmax:r,ymin:i,ymax:o}=this._currentImage.fullExtent,{x:s,y:a}=e.mapPoint;if(t>s||r<s||o<a||i>a)return;this.plotReferencePointOnImage(e.mapPoint);const n=this.getSelectedFeature();if(n){const t=(await V([e.mapPoint.toJSON()],{feature:n,currentCoveragePolygon:this.getSelectedFeaturePolygon(),imageProperties:this._currentImage.rasterInfo,options:{signal:this._transformController?.signal}}))[0];t&&this.plotReferencePointOnGround(t)}}})),l((()=>[this._imageViewer?.viewpoint,this._initialCurrentCoveragePolygon]),(()=>{this._imageViewer?.viewpoint&&this._initialCurrentCoveragePolygon&&(this._cancelCurrentCoverageUpdate(),this.updateCoverage())})),l((()=>this.selectedFeature),(async()=>{const{_fetchFeaturesController:e,selectedFeature:t,selectedPoint:r}=this;!t&&this._currentImage&&(this._imageViewer?.map.layers.remove(this._currentImage),this._currentImage=s(this._currentImage)),t&&r&&(await this.loadImage(t,{signal:e?.signal}),this.transformAndPlotSelectedLocation({signal:this._fetchFeaturesController?.signal}))}))])}async searchBestImage(e,t){try{const r=await v(e,t);r&&await this._processFeatureResponse(r,{signal:t?.signal})}catch(r){const e=o.getLogger(this);this.setMessage("imageLoadError","error"),e.error("error occured while finding best image",r)}}toggleAdditionalCameraLocations(){this._additionalFeatureGraphics?.forEach((e=>{e.visible=!e.visible}))}toggleAdditionalCoverage(){this._additionalCoveragePolygons?.forEach((e=>{e.visible=!e.visible}))}toggleCurrentCoverage(){this._currentCoveragePolygon&&(this._currentCoveragePolygon.visible=!this._currentCoveragePolygon.visible,this._selectedFeatureGraphic.visible=!this._selectedFeatureGraphic)}_cancelFetchingFeatures(){const e=this._fetchFeaturesController;e&&e.abort(),this._fetchFeaturesController=null}_cancelCurrentCoverageUpdate(){const e=this._updateCoverageController;e&&e.abort("Multiple Coverage Updates: Aborting Current Coverage Update to sync image and coverage"),this._updateCoverageController=null}async _fetchFeatures(e,t){const{screenPoint:r}=e,i=this.activeLayer;if(i){const e={include:i},o=await this.view.hitTest(r,e);this._processHitTestResults(i,o,t)}}async _fetchFeaturesWithController(e){this._cancelFetchingFeatures();const t=new AbortController,{signal:r}=t;this._fetchFeaturesController=t;try{this._fetchFeatures(e,{signal:r})}catch(i){const e=o.getLogger(this);this.setMessage("imageLoadError","error"),e.error("error occured while fetching features",i)}this._fetchFeaturesController=null}async _processFeatureResponse(e,i){const{selectedPoint:o}=this;if(!o)return;if(!e)return;const s=await e;if(this._fetchFeaturesController=null,!s)return;const{features:a}=s;if(!a.length)return this.setMessage("noImageError","error"),void(this.selectedFeature=null);const n=new Array;this.coveragePolygons=new r,this.coverageFrustums=new r,this.pointSources=new r,a.forEach((e=>{let t;const{polygon:r,frustum:i}=C(e);if(t=r,e.attributes.isInspection&&(t=w(e.attributes)),e.layer.coveragePercent&&(t=P(t,e.layer.coveragePercent)),I(t,o)){n.push(e);const r=t.toJSON(),o=i?.toJSON(),{attributes:s}=e,{cameraHeight:a,cameraHeading:l,location:g,objectId:h}=s,c="toJSON"in g?g.toJSON():g;r.imageID=c.imageID=h,o&&(o.imageID=h),c.z=a,this.pointSources?.push(c),this.coveragePolygons?.push(l>0?r:void 0),this.coverageFrustums?.push(l>0?o:void 0)}}));const l=this.coveragePolygons?.getItemAt(0);if(!n.length)return void this.setMessage("noImageError","error");if(n[0].attributes.elevationSource&&!o.z&&l){const e=await b([o],{feature:n[0],currentCoveragePolygon:new A(l),options:i});if(e[0]){const t=e[0];o.elevation=t.z}}const g=f({features:n,selectedPoint:o,camera:N(this.view)?this.view.camera:null,currentImage:this.selectedFeature});g?.sort(((e,t)=>e.suitability-t.suitability));const h=g?.map((e=>e.feature)),c=h[0];this._updateFeatures(h),this._additionalCoveragePolygons=new r,this._additionalFeatureGraphics=new r,this._currentCoveragePolygon&&(this._currentCoveragePolygon.destroy(),this._currentCoveragePolygon=null,this._initialCurrentCoveragePolygon=null);for(const r of this.coveragePolygons)r?.imageID===c?.attributes.objectId?this._initialCurrentCoveragePolygon=new t({attributes:{imageID:r?.imageID},geometry:{type:"polygon",...r},symbol:G,visible:!1}):this._additionalCoveragePolygons.push(new t({attributes:{imageID:r?.imageID},geometry:{type:"polygon",...r},symbol:M,visible:!1}));for(const r of this.pointSources)r.imageID===c?.attributes.objectId?this._selectedFeatureGraphic=new t({attributes:{imageID:r.imageID},geometry:{type:"point",...r},symbol:j,visible:!1}):this._additionalFeatureGraphics?.push(new t({attributes:{imageID:r.imageID},geometry:{type:"point",...r},symbol:R,visible:!1}));this.selectedFeature=c,this._initialCurrentCoverageUpdate=!0}async _processHitTestResults(e,t,r){const{screenPoint:i,results:o}=t,s=this.view.toMap(i),a=o[0],n={layerInstanceOrURL:e,point:s,queryParams:{maximumDistance:e.maximumDistance,objectIds:this.shouldShowSelectedImage?[a.graphic.attributes.id]:void 0,outSpatialReference:s.spatialReference},queryFeatures:null};await this.searchBestImage(n,r)}async _updateFeatures(e){e.length&&(this.features=new r(e),this.notifyChange("features"))}plotReferencePoint(e){"mapPoint"in e?this.plotReferencePointOnGround(e.mapPoint):this.plotReferencePointOnGround(e)}updateCurrentCoveragePolygon(e){if(this._initialCurrentCoverageUpdate)if(this._initialCurrentCoverageUpdate=!1,e&&(this._currentCoveragePolygon&&(this._overlays?.remove(this._currentCoveragePolygon),this._currentCoveragePolygon.destroy()),e.visible=this.isCurrentCoverageVisible,this._currentCoveragePolygon=e),this.view)this._overlays?.graphics.addMany([...this._additionalCoveragePolygons??[],...this._additionalFeatureGraphics??[],this._currentCoveragePolygon,this._selectedFeatureGraphic].filter(T));else{const e={points:this.pointSources?.filter((e=>e?.imageID!==this.selectedFeature?.attributes.objectId)),frustums:this.coverageFrustums?.filter((e=>e?.imageID!==this.selectedFeature?.attributes.objectId)),polygons:this._additionalCoveragePolygons?.map((e=>e.geometry?.toJSON())),currentPoint:this.selectedFeature?.geometry,currentPolygon:this._currentCoveragePolygon,currentFrustum:this.coverageFrustums?.find((e=>e?.imageID===this.selectedFeature?.attributes.objectId))};this.emit("plot-polygons",{data:e})}else if(this.view){const t=this._currentCoveragePolygon&&this._overlays?this._overlays.graphics.indexOf(this._currentCoveragePolygon):-1;e&&(this._currentCoveragePolygon&&(this._overlays?.remove(this._currentCoveragePolygon),this._currentCoveragePolygon.destroy()),e.visible=this.isCurrentCoverageVisible,this._currentCoveragePolygon=e,this._overlays?.graphics.add(this._currentCoveragePolygon,t>=0?t:void 0))}else e&&this.emit("update-current-coverage",{graphic:e.toJSON()})}async loadImage(e,t){if(!this._imageViewer)return;if(this._imageViewer.graphics.removeAll(),this._currentImage&&this._imageViewer?.map.layers.includes(this._currentImage)&&(this._currentImage?.removeHandles("image-handles"),this._imageViewer?.map.layers.remove(this._currentImage),this._currentImage?.destroy(),this._currentImage=null),!e)return void this.setMessage("noImageError","error");const r=e.attributes.image;this._referencePointOnGround&&(this._imageViewer?.graphics.remove(this._referencePointOnGround),this._referencePointOnGround.destroy());const i={skipExtensions:["aux.xml","jgw"]};this._currentImage=new _({ioConfig:i,url:r,options:t}),this._imageViewer.map.layers.add(this._currentImage);try{const t=await this._currentImage.when();this._imageViewer.extent=t.fullExtent,t.raster.rasterInfo.isPseudoSpatialReference&&(this._imageViewer.constraints.rotationEnabled=!0,this._imageViewer.rotation=(e.attributes.cameraRoll??0)+(e.attributes.imageRotation??0),this._imageViewer.constraints.rotationEnabled=!1),this._panConstraint&&this._imageViewer?.constraints.customConstraints.remove(this._panConstraint),this._panConstraint={constrain:(e,t)=>{if(!this._currentImage||!this._imageViewer||!e.targetGeometry)return e;const{xmin:r,xmax:i,ymin:o,ymax:s}=this._currentImage.fullExtent,{width:a,height:n}=this._imageViewer.extent,l=this._imageViewer?.rotation*Math.PI/180,g=Math.abs(Math.cos(l)*a+Math.sin(l)*n),h=Math.abs(Math.cos(l)*n+Math.sin(l)*a),{width:c,height:u}=this._currentImage.rasterInfo;return e.targetGeometry.x=Math.min(Math.max(r+(c>g?g:c)/2,e.targetGeometry.x),i-(c>g?g:c)/2),e.targetGeometry.y=Math.min(Math.max(o+(u>h?h:u)/2,e.targetGeometry.y),s-(u>h?h:u)/2),e}},this._scaleConstraint&&this._imageViewer?.constraints.customConstraints.remove(this._scaleConstraint),this._scaleConstraint={constrain:(e,t)=>{if(this._imageViewer&&this._currentImage){const{width:t,height:r}=this._currentImage.rasterInfo,{width:i,height:o}=this._imageViewer;e.scale=Math.min(e.scale,x(this._imageViewer.spatialReference)*Math.max(t/i,r/o))}return e}},this._imageViewer?.constraints.customConstraints.add(this._panConstraint),this._imageViewer?.constraints.customConstraints.add(this._scaleConstraint),t.addHandles([g((()=>this._imageViewer?.stationary),(e=>{e&&this._imageViewer?.viewpoint&&this._panConstraint?.constrain(this._imageViewer?.viewpoint)}),h)])}catch(s){o.getLogger(this.declaredClass).error("oriented-imagery-viewer:load-image",s)}}async transformAndPlotSelectedLocation(e){const{_currentImage:r,selectedFeature:i,selectedPoint:o}=this;if(!o||!i||!r)return;const{pixelSize:s}=r.rasterInfo,a=await F([o],{feature:i,imageProperties:r.rasterInfo,currentCoveragePolygon:this.getSelectedFeaturePolygon(),options:e});if(!a.length)return;const n=a[0];if(!n)return;const l=m(p,await O(r.fullExtent,m(E,this._imageViewer?.spatialReference),null,e?.signal));n.x=n.x*s.x+l.xmin,n.y=l.ymax-n.y*s.y,n.spatialReference=l.spatialReference,this._crossSymbol&&(this._imageViewer?.graphics.remove(this._crossSymbol),this._crossSymbol.destroy()),this._crossSymbol=new t({geometry:U.fromJSON(n),symbol:L}),this._imageViewer?.graphics.add(this._crossSymbol)}async plotImagePointOnGround(e){if(!this._imageViewer)return;const t=this._currentImage;if(!t)return;const{feature:r,selectedLocation:i,options:o}=e,{pixelSize:s,isPseudoSpatialReference:a,transform:n}=t.rasterInfo,l=await F([i],{feature:r,imageProperties:t.rasterInfo,currentCoveragePolygon:this.getSelectedFeaturePolygon(),options:o});if(!l.length)return;let g=l[0];const h=await O(t.fullExtent,this._imageViewer.spatialReference,null,o?.signal);a?(g.x=g.x*s.x+h.xmin,g.y=h.ymax-g.y*s.y,g.spatialReference=h.spatialReference):g=n.forwardTransform(new U(g)),this.plotReferencePointOnImage(g)}plotReferencePointOnGround(e){this._referencePointOnGround&&(this._overlays?.remove(this._referencePointOnGround),this._referencePointOnGround.destroy()),this._referencePointOnGround=new t({geometry:{type:"point",...e.toJSON()},symbol:D}),this._overlays?.add(this._referencePointOnGround)}plotReferencePointOnImage(e){this._imageViewer&&(this._referencePointOnImage&&(this._imageViewer.graphics.remove(this._referencePointOnImage),this._referencePointOnImage.destroy()),this._referencePointOnImage=new t({geometry:{type:"point",..."toJSON"in e?e.toJSON():e},symbol:D}),this._imageViewer.graphics.add(this._referencePointOnImage))}setMessage(e,t,r){this.displayMessage={key:e,type:t,data:r}}async updateCoverage(){const e=new AbortController,{signal:r}=e;this._updateCoverageController=e;const{_imageViewer:i}=this;if(this._currentImage?.loaded&&i){const{width:e,height:o}=this._currentImage.rasterInfo,{xmin:s,xmax:a,ymin:n,ymax:l}=this._currentImage.fullExtent,g=[[0,0],[Math.min(i.width,e),0],[Math.min(i.width,e),Math.min(i.height,o)],[0,Math.min(i.height,o)]].map((e=>i.toMap(c(e[0],e[1]))));g.forEach((e=>{e.x=s<=e.x&&e.x<=a?e.x:Math.abs(s-e.x)>Math.abs(a-e.x)?a:s,e.y=n<=e.y&&e.y<=l?e.y:Math.abs(n-e.y)>Math.abs(l-e.y)?l:n}));const h=await V(g,{feature:this.getSelectedFeature(),currentCoveragePolygon:this.getSelectedFeaturePolygon(),imageProperties:this._currentImage.rasterInfo,options:{signal:r}});if(h&&!r.aborted){const e=[h.map((e=>[e.x,e.y,1]))];e[0].push(e[0][0]);const r=new A({hasZ:!0,rings:e,spatialReference:h[0].spatialReference});this.updateCurrentCoveragePolygon(new t({geometry:r,symbol:G,visible:this.isCurrentCoverageVisible}))}}}};e([u()],k.prototype,"active",null),e([u()],k.prototype,"activeLayer",void 0),e([u()],k.prototype,"shouldShowSelectedImage",void 0),e([u()],k.prototype,"coverageFrustums",void 0),e([u()],k.prototype,"coveragePolygons",void 0),e([u()],k.prototype,"currentImageView",null),e([u()],k.prototype,"displayMessage",void 0),e([u()],k.prototype,"pointSources",void 0),e([u()],k.prototype,"selectedFeature",void 0),e([u()],k.prototype,"selectedPoint",void 0),e([u({readOnly:!0})],k.prototype,"featureCount",null),e([u()],k.prototype,"features",void 0),e([u()],k.prototype,"hasImageLoaded",null),e([u()],k.prototype,"isAdditionalCoverageDisabled",null),e([u()],k.prototype,"isAdditionalCoverageVisible",null),e([u()],k.prototype,"isAdditionalPointSourcesDisabled",null),e([u()],k.prototype,"isAdditionalPointSourcesVisible",null),e([u()],k.prototype,"isCurrentCoverageDisabled",null),e([u()],k.prototype,"isCurrentCoverageVisible",null),e([u()],k.prototype,"updating",null),e([u()],k.prototype,"state",null),e([u()],k.prototype,"view",null),e([u()],k.prototype,"_additionalCoveragePolygons",void 0),e([u()],k.prototype,"_additionalFeatureGraphics",void 0),e([u()],k.prototype,"_currentCoveragePolygon",void 0),e([u()],k.prototype,"_currentImage",void 0),e([u()],k.prototype,"_fetchFeaturesController",void 0),e([u()],k.prototype,"_imageViewer",void 0),e([u()],k.prototype,"_initialCurrentCoveragePolygon",void 0),e([u()],k.prototype,"_initialCurrentCoverageUpdate",void 0),e([u()],k.prototype,"_overlays",void 0),e([u()],k.prototype,"_referencePointOnGround",void 0),e([u()],k.prototype,"_referencePointOnImage",void 0),e([u()],k.prototype,"_selectedFeatureGraphic",void 0),k=e([d("esri.widgets.OrientedImageryViewer.OrientedImageryViewerViewModel")],k);const H=k;export{H as default};
