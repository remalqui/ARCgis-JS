/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.27/esri/copyright.txt for details.
*/
import{_ as e}from"../../chunks/tslib.es6.js";import t from"../../Graphic.js";import a from"../../core/Error.js";import{makeHandle as o}from"../../core/handleUtils.js";import i from"../../core/Logger.js";import{abortMaybe as r}from"../../core/maybe.js";import{onAbort as s,createAbortError as n,throwIfAborted as l,debounce as d}from"../../core/promiseUtils.js";import c from"../../core/Queue.js";import{whenOnce as p,watch as u,sync as h}from"../../core/reactiveUtils.js";import{property as w}from"../../core/accessorSupport/decorators/property.js";import"../../core/accessorSupport/ensureType.js";import"../../core/arrayUtils.js";import"../../core/has.js";import{subclass as f}from"../../core/accessorSupport/decorators/subclass.js";import{isEditableLayer as m}from"../../layers/support/editableLayers.js";import{isTable as g}from"../../layers/support/layerUtils.js";import{highlightsSupported as k}from"../../views/support/layerViewUtils.js";import y from"./CreateFeaturesWorkflow.js";import{UpdateFeatureWorkflow as v}from"./UpdateFeatureWorkflow.js";import{UpdateRecordWorkflow as b}from"./UpdateRecordWorkflow.js";import W from"./UpdateWorkflowData.js";import _ from"./Workflow.js";import{createWorkflowSteps as C,fetchCandidates as S}from"./workflowUtils.js";import{isGraphicForRelatableFeatureSupportedLayer as F}from"../Feature/support/featureUtils.js";var U;const j="candidate-highlight",A="esri.widgets.Editor.UpdateWorkflow",I=i.getLogger(A);let M=U=class extends _{constructor(e){super(e),this._workflowStack=new c((e=>{let t;for(t of e);return t})),this.type="update"}get activeEditableItem(){const{activeWorkflow:e}=this;return R(e)?e.data.editableItem:void 0}get activeWorkflow(){return this._workflowStack.last()}get nestedWorkflowCount(){return this._workflowStack.length}get shouldShowAttachments(){return!!this.activeEditableItem?.attachmentsOnUpdateEnabled}get shouldAllowAttachmentEditing(){return!!this.activeEditableItem?.supports.includes("update")}get hasPendingEdits(){return Array.from(this._workflowStack).some((e=>e.hasPendingEdits))}get helpMessage(){return"awaiting-feature-to-update"===this.stepId?"select":void 0}get reliesOnOwnerAdminPrivileges(){return this.activeWorkflow?.reliesOnOwnerAdminPrivileges??!1}get hasInvalidFormTemplate(){return!!this.activeEditableItem?.hasInvalidFormTemplate}get hasUnsupportedFields(){return!!this.activeEditableItem?.hasUnsupportedFields}get updating(){return this.updatingHandles.updating}async back(e=(()=>Promise.resolve(!0))){const{featureFormViewModel:t}=this.data.viewModel;if(null==t.relationshipId)if(this.activeWorkflow){if(this.activeWorkflow.hasPendingEdits){if(!await e())return}this.activeWorkflow.hasPreviousStep?await this.activeWorkflow.previous({cancelCurrentStep:!0}):await this.cancelActiveWorkflow({force:!0})}else this.hasPreviousStep?await this.previous({cancelCurrentStep:!0}):await this.cancel({force:!0});else t.relationshipId=null}async cancelActiveWorkflow(e){await(this.activeWorkflow?.cancel(e)),await this._popWorkflow()}async commit(){await this._drainWorkflowStack((e=>e.commit())),await super.commit()}static create(e,t,a){const o=new U({data:new W({applyEditsCallback:a,viewModel:e}),onCommit:async()=>{}});return o._set("steps",this._createWorkflowSteps(o,t)),o}async save(){this.nestedWorkflowCount>1?(await(this.activeWorkflow?.commit()),await this._popWorkflow()):await this.commit()}async startCreatingRelatedRecord(e){try{const t=await this._createNestedCreateFeaturesWorkflow(e);await this._pushWorkflow(t)}catch(t){throw new a("editor:unable-to-start-creating","Could not begin updating the provided feature or table record.",{error:t})}}async startUpdating(e){try{const t=await this._createNestedUpdateWorkflow(e);await this._pushWorkflow(t)}catch(t){throw new a("editor:unable-to-start-updating","Could not begin updating the provided feature or table record.",{error:t})}}async deleteActiveFeature(){const{activeWorkflow:e}=this;if(!e)throw new a("editor:nothing-to-delete","There is no feature to delete");R(e)?await e.deleteAndCommit():await e.cancel(),1===this.nestedWorkflowCount?await this.reset():await this._popWorkflow()}async cancelAll(){await this._drainWorkflowStack((e=>e.cancel({force:!0})))}async _createNestedCreateFeaturesWorkflow(e){const{relatedLayer:o}=e,{addAttachmentsCallback:i,applyEditsCallback:r,viewModel:s}=this.data;if(!m(o))throw new a("editor:unsupported-layer","Editing is not supported on the provided layer");const n=new t({sourceLayer:o,attributes:this._makeRelatedRecordAttributes(e)});return y.create({addAttachmentsCallback:i,applyEditsCallback:r,creationInfo:{layer:o,initialFeature:n,maxFeatures:1},startAt:"creating-features",viewModel:s})}async _createNestedUpdateWorkflow(e){const t=g(e.sourceLayer)?b:v,{applyEditsCallback:a,viewModel:o}=this.data,i=await t.create({feature:e,viewModel:o,applyEdits:a});return await p((()=>!i.updating)),i}async _drainWorkflowStack(e){const t=this._workflowStack,a=[];for(;t.length>0;){const o=t.pop(),i=e(o).then((()=>o.destroy()));this.updatingHandles.addPromise(i),a.push(i)}await Promise.all(a)}_highlight(e){this._removeHighlight();const t=this.data.viewModel.view;if(!t||!e)return;const a=e&&t.allLayerViews.items.find((({layer:t})=>t===e.layer||"subtype-sublayer"===e.layer?.type&&e.layer?.parent===t));k(a)&&this.handles.add(a.highlight(e),j)}_makeRelatedRecordAttributes(e){const{parentFeature:t,relatedLayer:a,relationshipId:o}=e;if(!F(t))return;const i=a.relationships?.find((e=>e.id===o));if(!i)return void E("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the destination layer.");if("origin"===i.role)return void E("unsupported-role","Creating new related records in the 'origin' table of a relationship is not yet supported");const r=t.sourceLayer;i.relatedTableId!==r.layerId&&E("invalid-argument-combination","The given parent feature does not belong to the relationship designated by the given relationship ID.");const s=r.relationships?.find((e=>e.id===o));if(!s)return void E("relationship-not-found","Could not begin creating a related record because the relationship specified could not be found on the origin layer.");const n=t.getAttribute(s.keyField);return n||E("no-key-on-origin-feature","The given parent feature does not have a value for the relationship's origin primary key field."),{[i.keyField]:n}}async _popWorkflow(){this._workflowStack.pop()?.destroy();const e=await this._reconcileWorkflowStack();if(e.failureCount>0)throw new a("editor:next-workflow-failed","Popped the top workflow, but the next workflow in the stack failed to activate",e)}async _pushWorkflow(e){const t=this._workflowRequiresSketchViewModel(e);this.activeWorkflow?.exit({removeSketchHandles:t}),await e.start(),this._workflowStack.push(e);const o=await this._reconcileWorkflowStack();if(o.failureCount>0)throw new a("editor:failed-to-start-updating-feature","Failed to enter the provided workflow.",o)}async _reconcileWorkflowStack(){const e=this._workflowStack;try{const t=e.peek();return await(t?.enter()),{activeWorkflow:t,failureCount:0}}catch(t){e.pop().destroy();const{activeWorkflow:a,failureCount:o}=await this._reconcileWorkflowStack();return{activeWorkflow:a,failureCount:o+1}}}_removeHighlight(){this.handles.remove(j)}_workflowRequiresSketchViewModel(e){const{type:t}=e;return"update-features"===t||"create-features"===t&&!g(e.data.creationInfo?.layer)}static _createWorkflowSteps(e,t="awaiting-feature-to-update"){const{data:i,handles:c}=e;return C(["awaiting-feature-to-update","awaiting-update-feature-candidate","editing-existing-feature","adding-attachment","editing-attachment"],t,{"awaiting-feature-to-update":()=>({id:"awaiting-feature-to-update",async setUp(){const{spinnerViewModel:t}=i.viewModel,a=i.viewModel.view;let d=null;c.add(o((()=>{d=r(d)})),this.id),i.rootFeature=null,i.candidates=[];const p=a.on("immediate-click",(async o=>{t.location=o.mapPoint,t.visible=!0,d?.abort();const{editableItems:r}=i.viewModel;d=new AbortController;const c=await new Promise(((e,t)=>{s(d?.signal,(()=>t(n()))),e(S(r,a,o,d?.signal))}));l(d),i.candidates=c.reduce(((e,t)=>t.error?e:[...e,...t.value]),[]),t.visible=1===i.candidates.length,0!==i.candidates.length&&(1===i.candidates.length?(i.rootFeature=i.candidates[0],e.go("editing-existing-feature").catch((()=>{})).then((()=>t.visible=!1))):e.next())}));a.focus(),c.add(p,this.id)},async tearDown(){c.remove(this.id)}}),"awaiting-update-feature-candidate":()=>({id:"awaiting-update-feature-candidate",async setUp(){i.rootFeature=null,c.add([u((()=>i.rootFeature),(t=>e._highlight(t)),h),o((()=>e._removeHighlight()))],this.id)},async tearDown(){c.remove(this.id)}}),"editing-existing-feature":()=>({id:"editing-existing-feature",async setUp(){const{rootFeature:t,viewModel:r}=e.data;if(!t)throw new a("editor:no-feature-specified","Cannot setup the 'updating-existing-feature' step until the root feature is defined");await e.startUpdating(t),r.spinnerViewModel.visible=!1;const s=d((async()=>{await p((()=>!e.updating)),e.previous()})),{featureFormViewModel:n}=i.viewModel,l=n.relatedRecordCallbacks;n.relatedRecordCallbacks={addRelatedRecord:async t=>{await e.startCreatingRelatedRecord(t),n.relationshipId=null},editRelatedRecord:async({relatedFeature:t})=>{await e.startUpdating(t),n.relationshipId=null},showAllRelatedRecords:e=>n.relationshipId=e.relationshipId},c.add([o((()=>n.relatedRecordCallbacks=l)),u((()=>e.nestedWorkflowCount),((e,t)=>{0===e&&0!==t&&s()}),h)],this.id)},async tearDown(){await e.cancelAll(),c.remove(this.id)}}),"adding-attachment":()=>({id:"adding-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){i.viewModel.attachmentsViewModel.mode="view"}}),"editing-attachment":()=>({id:"editing-attachment",parent:"editing-existing-feature",async setUp(){},async tearDown(){i.viewModel.attachmentsViewModel.mode="view"}})})}};e([w()],M.prototype,"activeEditableItem",null),e([w()],M.prototype,"activeWorkflow",null),e([w()],M.prototype,"nestedWorkflowCount",null),e([w()],M.prototype,"shouldShowAttachments",null),e([w()],M.prototype,"shouldAllowAttachmentEditing",null),e([w()],M.prototype,"hasPendingEdits",null),e([w()],M.prototype,"helpMessage",null),e([w()],M.prototype,"reliesOnOwnerAdminPrivileges",null),e([w()],M.prototype,"hasInvalidFormTemplate",null),e([w()],M.prototype,"hasUnsupportedFields",null),e([w()],M.prototype,"updating",null),M=U=e([f(A)],M);const E=(e,t)=>I.warn(`editor:${e}`,t,"The create operation will be allowed to proceed, but the resulting feature may not be related to the given parent feature."),R=e=>!!e&&/update-/.test(e.type),P=M;export{P as default};
