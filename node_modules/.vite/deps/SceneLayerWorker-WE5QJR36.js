import "./chunk-TTCCMCQH.js";
import {
  m as m2,
  p,
  y
} from "./chunk-SUQV3FHQ.js";
import "./chunk-AEPMR2T7.js";
import "./chunk-EF6YPOUN.js";
import {
  m
} from "./chunk-T5KDTHII.js";
import {
  n,
  s
} from "./chunk-GXWNOUDM.js";
import "./chunk-AYMF6OMA.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-AHAGGZUI.js";
import "./chunk-VZAEQ6CY.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-4H5JODOT.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import {
  a
} from "./chunk-LQVUN6IS.js";
import {
  f
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n2;
var e;
!function(n5) {
  n5[n5.None = 0] = "None", n5[n5.Int16 = 1] = "Int16", n5[n5.Int32 = 2] = "Int32";
}(n2 || (n2 = {})), function(n5) {
  n5[n5.Replace = 0] = "Replace", n5[n5.Outside = 1] = "Outside", n5[n5.Inside = 2] = "Inside", n5[n5.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n3 || (n3 = new Promise((t) => import("./i3s-4KUXZJKS.js").then((t2) => t2.i).then(({ default: e3 }) => {
    const n5 = e3({ locateFile: i, onRuntimeInitialized: () => t(n5) });
    delete n5.then;
  })).catch((t) => {
    throw t;
  })), n3;
}
function i(e3) {
  return a(`esri/libs/i3s/${e3}`);
}
var n3;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var n4;
var o;
var s2;
var a2;
var c;
!function(e3) {
  e3[e3.Unmodified = 0] = "Unmodified", e3[e3.Culled = 1] = "Culled", e3[e3.NotChecked = 2] = "NotChecked";
}(n4 || (n4 = {})), function(e3) {
  e3[e3.Unmodified = 0] = "Unmodified", e3[e3.PotentiallyModified = 1] = "PotentiallyModified", e3[e3.Culled = 2] = "Culled", e3[e3.Unknown = 3] = "Unknown", e3[e3.NotChecked = 4] = "NotChecked";
}(o || (o = {}));
!function(e3) {
  e3[e3.Unknown = 0] = "Unknown", e3[e3.Uncached = 1] = "Uncached", e3[e3.Cached = 2] = "Cached";
}(s2 || (s2 = {})), function(e3) {
  e3[e3.None = 0] = "None", e3[e3.MaxScreenThreshold = 1] = "MaxScreenThreshold", e3[e3.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e3[e3.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e3[e3.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(a2 || (a2 = {})), function(e3) {
  e3[e3.Hole = 0] = "Hole", e3[e3.Leaf = 1] = "Leaf";
}(c || (c = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function c2(e3) {
  await j();
  const r = [e3.geometryBuffer];
  return { result: A(e3, r), transferList: r };
}
async function u(e3) {
  var _a;
  await j();
  const r = [e3.geometryBuffer], { geometryBuffer: t } = e3, o2 = t.byteLength, n5 = E2._malloc(o2), s3 = new Uint8Array(E2.HEAPU8.buffer, n5, o2);
  s3.set(new Uint8Array(t));
  const i2 = E2.dracoDecompressPointCloudData(n5, s3.byteLength);
  if (E2._free(n5), i2.error.length > 0)
    throw new Error(`i3s.wasm: ${i2.error}`);
  const a3 = ((_a = i2.featureIds) == null ? void 0 : _a.length) > 0 ? i2.featureIds.slice() : null, f2 = i2.positions.slice();
  return a3 && r.push(a3.buffer), r.push(f2.buffer), { result: { positions: f2, featureIds: a3 }, transferList: r };
}
async function m3(e3) {
  await j(), S(e3);
  const r = { buffer: e3.buffer };
  return { result: r, transferList: [r.buffer] };
}
async function y2(e3) {
  await j(), w(e3);
}
async function p2(e3) {
  await j(), E2.setLegacySchema(e3.context, e3.jsonSchema);
}
async function d(s3) {
  const { localMatrix: i2, origin: a3, positions: f2, vertexSpace: l, local: c3 } = s3, u2 = f.fromJSON(s3.inSpatialReference), m4 = f.fromJSON(s3.outSpatialReference), y3 = { georeferenced: p, georeferencedRelative: m, local: m2 }[l.type].fromJSON(l);
  let p3;
  if ("georeferenced" === y3.type) {
    const { projectBuffer: e3, initializeProjection: r } = await import("./projection-KMVIENPO.js");
    await r(u2, m4), p3 = new Float64Array(f2.length), e3(f2, u2, 0, p3, m4, 0, p3.length / 3);
  } else {
    const { project: e3 } = await import("./georeference-FBIRGNIP.js");
    p3 = y(e3({ positions: f2, transform: i2 ? { localMatrix: i2 } : void 0, vertexSpace: y3, inSpatialReference: u2, outSpatialReference: m4, local: c3 }));
  }
  const d2 = p3.length, [b2, h2, g2] = a3;
  for (let e3 = 0; e3 < d2; e3 += 3)
    p3[e3] -= b2, p3[e3 + 1] -= h2, p3[e3 + 2] -= g2;
  return { result: { projected: p3, original: f2 }, transferList: [p3.buffer, f2.buffer] };
}
async function b({ normalMatrix: e3, normals: r }) {
  const t = new Float32Array(r.length);
  return n(t, r, e3), s(t, t), { result: { transformed: t, original: r }, transferList: [t.buffer, r.buffer] };
}
function h(e3) {
  _(e3);
}
var g;
var E2;
function w(e3) {
  const r = e3.modifications, t = E2._malloc(8 * r.length), o2 = new Float64Array(E2.HEAPU8.buffer, t, r.length);
  for (let n5 = 0; n5 < r.length; ++n5)
    o2[n5] = r[n5];
  E2.setModifications(e3.context, t, r.length, e3.isGeodetic), E2._free(t);
}
function A(e3, r) {
  if (!E2)
    return null;
  const { context: t, localOrigin: o2, globalTrafo: n5, mbs: s3, obb: i2, elevationOffset: f2, geometryBuffer: l, geometryDescriptor: c3, indexToVertexProjector: u2, vertexToRenderProjector: m4 } = e3, y3 = E2._malloc(l.byteLength), p3 = 33, d2 = E2._malloc(p3 * Float64Array.BYTES_PER_ELEMENT), b2 = new Uint8Array(E2.HEAPU8.buffer, y3, l.byteLength);
  b2.set(new Uint8Array(l));
  const h2 = new Float64Array(E2.HEAPU8.buffer, d2, p3);
  I(h2, o2);
  let g2 = h2.byteOffset + 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2);
  I(w2, n5), g2 += 16 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), I(w2, s3), g2 += 4 * h2.BYTES_PER_ELEMENT, null != i2 && (w2 = new Float64Array(h2.buffer, g2), I(w2, i2.center), g2 += 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), I(w2, i2.halfSize), g2 += 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), I(w2, i2.quaternion));
  const A2 = c3, L2 = { isDraco: false, isLegacy: false, color: e3.layouts.some((e4) => e4.some((e5) => "color" === e5.name)), normal: e3.needNormals && e3.layouts.some((e4) => e4.some((e5) => "normalCompressed" === e5.name)), uv0: e3.layouts.some((e4) => e4.some((e5) => "uv0" === e5.name)), uvRegion: e3.layouts.some((e4) => e4.some((e5) => "uvRegion" === e5.name)), featureIndex: A2.featureIndex }, S2 = E2.process(t, !!e3.obb, y3, b2.byteLength, A2, L2, d2, f2, u2, m4, e3.normalReferenceFrame);
  if (E2._free(d2), E2._free(y3), S2.error.length > 0)
    throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded)
    return null;
  const _2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, j2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, x2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, T = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, M = S2.interleavedVertedData.slice().buffer, P = S2.indicesType === n2.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), R = S2.positions.slice(), U = S2.positionIndicesType === n2.Int16 ? new Uint16Array(S2.positionIndices.buffer, S2.positionIndices.byteOffset, S2.positionIndices.byteLength / 2).slice() : new Uint32Array(S2.positionIndices.buffer, S2.positionIndices.byteOffset, S2.positionIndices.byteLength / 4).slice(), v = { layout: e3.layouts[0], interleavedVertexData: M, indices: P, hasColors: S2.hasColors, hasModifications: S2.hasModifications, positionData: { data: R, indices: U } };
  return j2 && r.push(j2.buffer), _2 && r.push(_2.buffer), r.push(M), r.push(P.buffer), r.push(R.buffer), r.push(U.buffer), { componentOffsets: _2, featureIds: j2, anchorIds: x2, anchors: T, transformedGeometry: v, obb: S2.obb };
}
function L(e3) {
  return 0 === e3 ? o.Unmodified : 1 === e3 ? o.PotentiallyModified : 2 === e3 ? o.Culled : o.Unknown;
}
function S(e3) {
  const { context: r, buffer: t } = e3, o2 = E2._malloc(t.byteLength), n5 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s3 = new Float64Array(E2.HEAPU8.buffer, o2, n5), i2 = new Float64Array(t);
  s3.set(i2), E2.filterOBBs(r, o2, n5), i2.set(s3), E2._free(o2);
}
function _(e3) {
  E2 && (E2.destroy(e3), E2 = null);
}
function I(e3, r) {
  for (let t = 0; t < r.length; ++t)
    e3[t] = r[t];
}
function j() {
  return E2 ? Promise.resolve() : (g || (g = e2().then((e3) => {
    E2 = e3, g = null;
  })), g);
}
var x = { transform: A, destroy: _ };
export {
  h as destroyContext,
  u as dracoDecompressPointCloudData,
  m3 as filterObbsForModifications,
  S as filterObbsForModificationsSync,
  j as initialize,
  L as interpretObbModificationResults,
  c2 as process,
  d as project,
  p2 as setLegacySchema,
  y2 as setModifications,
  w as setModificationsSync,
  x as test,
  b as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-WE5QJR36.js.map
