import {
  r as r2
} from "./chunk-6ETVGJDF.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import {
  e
} from "./chunk-LREUW66K.js";
import {
  d as d2
} from "./chunk-HB3KZNZ3.js";
import {
  i,
  l
} from "./chunk-7KM4XBUC.js";
import {
  h
} from "./chunk-KKGH4SRQ.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  d
} from "./chunk-HNHXEGH2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  c
} from "./chunk-I5JT24BO.js";

// node_modules/@arcgis/core/renderers/support/DictionaryLoader.js
var h2 = "esri.renderers.support.DictionaryLoader";
var u = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
var y = class {
  constructor(e2, t, s3) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = /* @__PURE__ */ new Map(), this._symbolCache = new e(100), this._dictionaryVersion = null, this._fieldIndex = null, this._dictionaryPromise = null, this.url = e2, this.config = t, this.fieldMap = s3;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t, s3) {
    let i2;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(s3));
    try {
      i2 = await this._dictionaryPromise;
    } catch (d4) {
      if (d(d4))
        return this._dictionaryPromise = null, null;
    }
    const o = this._dictionaryVersion && this._dictionaryVersion.since(4, 0), l2 = {};
    if (this.fieldMap)
      for (const e2 of this._symbolFields) {
        const s4 = this._getFieldName(this.fieldMap[e2]);
        l2[e2] = s4 ? o ? t.attributes[s4] : "" + t.attributes[s4] : "";
      }
    let a = null;
    try {
      a = i2 == null ? void 0 : i2(l2, s3);
    } catch (g) {
      return null;
    }
    if (!a || "string" != typeof a)
      return null;
    const c2 = c(a).toString(), m = this._symbolCache.get(c2);
    if (m)
      return m.catch(() => {
        this._symbolCache.pop(c2);
      }), m;
    const f = a.split(";"), h3 = [], u2 = [];
    for (const r3 of f)
      if (r3)
        if (r3.includes("po:")) {
          const t2 = r3.substr(3).split("|");
          if (3 === t2.length) {
            const s4 = t2[0], i3 = t2[1];
            let o2 = t2[2];
            if ("DashTemplate" === i3)
              o2 = o2.split(" ").map((e2) => Number(e2));
            else if ("Color" === i3) {
              const t3 = new h(o2).toRgba();
              o2 = [t3[0], t3[1], t3[2], 255 * t3[3]];
            } else
              o2 = Number(o2);
            u2.push({ primitiveName: s4, propertyName: i3, value: o2 });
          }
        } else if (r3.includes("|")) {
          for (const e2 of r3.split("|"))
            if (this._itemNames.has(e2)) {
              h3.push(e2);
              break;
            }
        } else
          this._itemNames.has(r3) && h3.push(r3);
    const y2 = null == t.geometry || !t.geometry.hasZ && "point" === t.geometry.type, p2 = this._cimPartsToCIMSymbol(h3, u2, y2, s3);
    return this._symbolCache.put(c2, p2, 1), p2;
  }
  async fetchResources(e2) {
    if (this._dictionaryPromise)
      return this._dictionaryPromise;
    if (!this.url)
      return void s.getLogger(h2).error("no valid URL!");
    const o = j(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, signal: null != e2 ? e2.signal : null }), [{ data: r3 }] = await Promise.all([o, i()]);
    if (!r3)
      throw this._dictionaryPromise = null, new s2("esri.renderers.DictionaryRenderer", "Bad dictionary data!");
    const { authoringInfo: n, dictionary_version: f, expression: u2, itemsNames: y2 } = r3, p2 = u2;
    let d4 = false;
    f && (this._dictionaryVersion = r2.parse(f), d4 = this._dictionaryVersion.since(4, 0)), this._refSymbolUrlTemplate = this.url + "/" + r3.cimRefTemplateUrl, this._itemNames = new Set(y2), this._symbolFields = n.symbol;
    const g = {};
    if (this.config) {
      const e3 = this.config;
      for (const t in e3)
        g[t] = e3[t];
    }
    if (n.configuration)
      for (const t of n.configuration)
        g.hasOwnProperty(t.name) || (g[t.name] = t.value);
    const b = [];
    if (null != e2 && e2.fields && this.fieldMap)
      for (const t of this._symbolFields) {
        const s3 = this.fieldMap[t], i2 = e2.fields.filter((e3) => e3.name.toLowerCase() === (s3 == null ? void 0 : s3.toLowerCase()));
        i2.length > 0 && b.push({ ...i2[0], type: d4 ? i2[0].type : "esriFieldTypeString" });
      }
    b.length > 0 && (this._fieldIndex = new r(b));
    const _ = l(p2, null != e2 ? e2.spatialReference : null, b, g).then((e3) => {
      const t = { scale: 0 };
      return (s3, i2) => {
        if (null == e3)
          return null;
        const o2 = e3.repurposeFeature({ geometry: null, attributes: s3 });
        return t.scale = null != i2 ? i2.scale ?? void 0 : void 0, e3.evaluate({ $feature: o2, $view: t }, e3.services);
      };
    }).catch((e3) => (s.getLogger(h2).error("Creating dictinoary expression failed:", e3), null));
    return this._dictionaryPromise = _, _;
  }
  async _cimPartsToCIMSymbol(e2, t, s3, i2) {
    const o = new Array(e2.length);
    for (let l2 = 0; l2 < e2.length; l2++)
      o[l2] = this._getSymbolPart(e2[l2], i2);
    const r3 = await Promise.all(o), n = this.fieldMap;
    if (n)
      for (const l2 of r3)
        p(l2, n);
    return new d2({ data: this._combineSymbolParts(r3, t, s3) });
  }
  async _getSymbolPart(e2, s3) {
    if (this._ongoingRequests.has(e2))
      return this._ongoingRequests.get(e2).then((e3) => e3.data);
    const i2 = this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi, e2), o = j(i2, { responseType: "json", query: { f: "json" }, ...s3 });
    this._ongoingRequests.set(e2, o);
    try {
      return (await o).data;
    } catch (r3) {
      throw this._ongoingRequests.delete(e2), r3;
    }
  }
  _combineSymbolParts(e2, t, s3) {
    if (!e2 || 0 === e2.length)
      return null;
    const i2 = { ...e2[0] };
    if (e2.length > 1) {
      i2.symbolLayers = [];
      for (const t2 of e2) {
        const e3 = t2;
        i2.symbolLayers.unshift(...e3.symbolLayers);
      }
    }
    return s3 && (i2.callout = u), { type: "CIMSymbolReference", symbol: i2, primitiveOverrides: t };
  }
  _getFieldName(e2) {
    if (null !== this._fieldIndex) {
      const t = this._fieldIndex.get(e2);
      return t ? t.name : e2;
    }
    return e2;
  }
};
function p(e2, t) {
  if (!e2)
    return;
  const s3 = e2.symbolLayers;
  if (!s3)
    return;
  let i2 = s3.length;
  for (; i2--; ) {
    const e3 = s3[i2];
    if (e3 && false !== e3.enable && "CIMVectorMarker" === e3.type)
      d3(e3, t);
  }
}
function d3(e2, t) {
  const s3 = e2.markerGraphics;
  if (s3)
    for (const i2 of s3) {
      if (!i2)
        continue;
      const e3 = i2.symbol;
      if (e3)
        switch (e3.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            p(e3, t);
            break;
          case "CIMTextSymbol":
            e3.fieldMap = t;
        }
    }
}

export {
  y
};
//# sourceMappingURL=chunk-4NWXO2LT.js.map
