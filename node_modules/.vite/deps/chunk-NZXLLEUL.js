import {
  T
} from "./chunk-C3ULZZZU.js";
import {
  st
} from "./chunk-KKGVORR5.js";
import {
  A,
  m
} from "./chunk-CIYZZPIM.js";
import {
  B,
  J,
  L,
  Re,
  Y,
  se,
  t as t2,
  w
} from "./chunk-RFI4CCAC.js";
import {
  c
} from "./chunk-YAWND7HF.js";
import {
  e,
  t
} from "./chunk-FJYIB7HF.js";
import {
  p as p2
} from "./chunk-T4XWQYGC.js";
import {
  p2 as p,
  x2 as x
} from "./chunk-SFV6XLDZ.js";

// node_modules/@arcgis/core/arcade/Feature.js
var b = class _b {
  constructor() {
    this.arcadeDeclaredClass = "esri.arcade.Feature", this._optimizedGeomDefinition = null, this._geometry = null, this.attributes = null, this._layer = null, this._datesfixed = true, this.dateTimeReferenceFieldIndex = null, this.contextTimeReference = null, this.immutable = true, this._datefields = null, this.immutable = true;
  }
  static createFromGraphic(e2, t3) {
    const i = new _b();
    return i.contextTimeReference = t3 ?? null, i._geometry = null != e2.geometry ? e2.geometry : null, void 0 === e2.attributes || null === e2.attributes ? i.attributes = {} : i.attributes = e2.attributes, e2._sourceLayer ? (i._layer = e2._sourceLayer, i._datesfixed = false) : e2._layer ? (i._layer = e2._layer, i._datesfixed = false) : e2.layer && "fields" in e2.layer ? (i._layer = e2.layer, i._datesfixed = false) : e2.sourceLayer && "fields" in e2.sourceLayer && (i._layer = e2.sourceLayer, i._datesfixed = false), i._layer && false === i._datesfixed && (void 0 !== i._layer.dateTimeReferenceFieldIndex ? i.dateTimeReferenceFieldIndex = i._layer.dateTimeReferenceFieldIndex : i.dateTimeReferenceFieldIndex = T.createFromLayer(i._layer)), i;
  }
  static createFromArcadeFeature(e2) {
    if (e2 instanceof _b) {
      const t4 = new _b();
      return t4._datesfixed = e2._datesfixed, t4.attributes = e2.attributes, t4._geometry = e2._geometry, t4._optimizedGeomDefinition = e2._optimizedGeomDefinition, e2._layer && (t4._layer = e2._layer), t4.dateTimeReferenceFieldIndex = e2.dateTimeReferenceFieldIndex, t4.contextTimeReference = e2.contextTimeReference, t4;
    }
    const t3 = {};
    for (const i of e2.keys())
      t3[i] = e2.field(i);
    return _b.createFromGraphicLikeObject(e2.geometry(), t3, e2.fullSchema(), e2.contextTimeReference);
  }
  static createFromOptimisedFeature(e2, t3, i) {
    const r = new _b();
    return r._geometry = e2.geometry ? { geometry: e2.geometry } : null, r._optimizedGeomDefinition = i, r.attributes = e2.attributes || {}, r._layer = t3, r._datesfixed = false, r;
  }
  static createFromArcadeDictionary(t3) {
    const i = new _b();
    return i.attributes = t3.field("attributes"), null !== i.attributes && i.attributes instanceof A ? (i.attributes = i.attributes.attributes, null === i.attributes && (i.attributes = {})) : i.attributes = {}, i._geometry = t3.field("geometry"), null !== i._geometry && (i._geometry instanceof A ? i._geometry = _b.parseGeometryFromDictionary(i._geometry) : i._geometry instanceof p || (i._geometry = null)), i;
  }
  static createFromGraphicLikeObject(e2, t3, i = null, r) {
    const s = new _b();
    return s.contextTimeReference = r ?? null, null === t3 && (t3 = {}), s.attributes = t3, s._geometry = null != e2 ? e2 : null, s._layer = i, s._layer && (s._datesfixed = false, void 0 !== s._layer.dateTimeReferenceFieldIndex ? s.dateTimeReferenceFieldIndex = s._layer.dateTimeReferenceFieldIndex : s.dateTimeReferenceFieldIndex = T.createFromLayer(s._layer)), s;
  }
  repurposeFromGraphicLikeObject(e2, t3, i = null) {
    null === t3 && (t3 = {}), this.attributes = t3, this._geometry = e2 ?? null, this._layer = i, this._layer ? this._datesfixed = false : this._datesfixed = true;
  }
  get layerPreferredTimeZone() {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.layerPreferredTimeZone) ?? "";
  }
  fieldSourceTimeZone(e2) {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e2)) ?? "";
  }
  castToText(e2 = false) {
    let a = "";
    false === this._datesfixed && this._fixDates();
    for (const o in this.attributes) {
      "" !== a && (a += ",");
      const l = this.attributes[o];
      null == l ? a += JSON.stringify(o) + ":null" : Y(l) || J(l) || L(l) ? a += JSON.stringify(o) + ":" + JSON.stringify(l) : l instanceof p ? a += JSON.stringify(o) + ":" + se(l) : l instanceof t2 || l instanceof Array ? a += JSON.stringify(o) + ":" + se(l, null, e2) : l instanceof c ? a += e2 ? JSON.stringify(o) + ":" + JSON.stringify(l.getTime()) : JSON.stringify(o) + ":" + l.stringify() : null !== l && "object" == typeof l && void 0 !== l.castToText && (a += JSON.stringify(o) + ":" + l.castToText(e2));
    }
    return '{"geometry":' + (null === this.geometry() ? "null" : se(this.geometry())) + ',"attributes":{' + a + "}}";
  }
  _fixDates() {
    if (null !== this._datefields)
      return this._datefields.length > 0 && this._fixDateFields(this._datefields), void (this._datesfixed = true);
    const e2 = [], t3 = this._layer.fields;
    for (let i = 0; i < t3.length; i++) {
      const r = t3[i], s = r.type;
      "date" !== s && "esriFieldTypeDate" !== s || e2.push(r.name);
    }
    this._datefields = e2, e2.length > 0 && this._fixDateFields(e2), this._datesfixed = true;
  }
  isUnknownDateTimeField(e2) {
    var _a;
    return "unknown" === ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e2));
  }
  _fixDateFields(e2) {
    var _a;
    this.attributes = { ...this.attributes };
    const t3 = ((_a = this.contextTimeReference) == null ? void 0 : _a.timeZone) ?? "system";
    for (let i = 0; i < e2.length; i++) {
      let r = this.attributes[e2[i]];
      if (null === r)
        ;
      else if (void 0 === r) {
        for (const s in this.attributes)
          if (s.toLowerCase() === e2[i].toLowerCase()) {
            if (r = this.attributes[s], null !== r) {
              const e3 = this.isUnknownDateTimeField(s);
              B(r) ? this.attributes[s] = r : r instanceof Date ? this.attributes[s] = e3 ? c.unknownDateJSToArcadeDate(r) : c.dateJSAndZoneToArcadeDate(r, t3) : this.attributes[s] = e3 ? c.unknownEpochToArcadeDate(r) : c.epochToArcadeDate(r, t3);
            }
            break;
          }
      } else {
        const s = this.isUnknownDateTimeField(e2[i]);
        B(r) ? this.attributes[e2[i]] = r : r instanceof Date ? this.attributes[e2[i]] = s ? c.unknownDateJSToArcadeDate(r) : c.dateJSAndZoneToArcadeDate(r, t3) : this.attributes[e2[i]] = s ? c.unknownEpochToArcadeDate(r) : c.epochToArcadeDate(r, t3);
      }
    }
  }
  geometry() {
    return null === this._geometry || this._geometry instanceof p || (this._optimizedGeomDefinition ? (this._geometry = p2(st(this._geometry, this._optimizedGeomDefinition.geometryType, this._optimizedGeomDefinition.hasZ, this._optimizedGeomDefinition.hasM)), this._geometry.spatialReference = this._optimizedGeomDefinition.spatialReference) : this._geometry = p2(this._geometry)), this._geometry;
  }
  field(e2) {
    false === this._datesfixed && this._fixDates();
    const t3 = this.attributes[e2];
    if (void 0 !== t3)
      return t3;
    const i = e2.toLowerCase();
    for (const r in this.attributes)
      if (r.toLowerCase() === i)
        return this.attributes[r];
    if (this._hasFieldDefinition(i))
      return null;
    throw new t(null, e.FieldNotFound, null, { key: e2 });
  }
  _hasFieldDefinition(e2) {
    if (null === this._layer)
      return false;
    for (let t3 = 0; t3 < this._layer.fields.length; t3++) {
      if (this._layer.fields[t3].name.toLowerCase() === e2)
        return true;
    }
    return false;
  }
  setField(e2, t3) {
    if (this.immutable)
      throw new t(null, e.Immutable, null);
    if (t3 instanceof Date && (t3 = this.isUnknownDateTimeField(e2) ? c.unknownDateJSToArcadeDate(t3) : c.dateJSToArcadeDate(t3)), false === w(t3))
      throw new t(null, e.TypeNotAllowedInFeature, null);
    const i = e2.toLowerCase();
    if (void 0 === this.attributes[e2]) {
      for (const e3 in this.attributes)
        if (e3.toLowerCase() === i)
          return void (this.attributes[e3] = t3);
      this.attributes[e2] = t3;
    } else
      this.attributes[e2] = t3;
  }
  hasField(e2) {
    const t3 = e2.toLowerCase();
    if (void 0 !== this.attributes[e2])
      return true;
    for (const i in this.attributes)
      if (i.toLowerCase() === t3)
        return true;
    return !!this._hasFieldDefinition(t3);
  }
  keys() {
    let e2 = [];
    const t3 = {};
    for (const i in this.attributes)
      e2.push(i), t3[i.toLowerCase()] = 1;
    if (null !== this._layer)
      for (let i = 0; i < this._layer.fields.length; i++) {
        const r = this._layer.fields[i];
        1 !== t3[r.name.toLowerCase()] && e2.push(r.name);
      }
    return e2 = e2.sort(), e2;
  }
  static parseGeometryFromDictionary(e2) {
    const t3 = _b._convertDictionaryToJson(e2, true);
    return void 0 !== t3.hasm && (t3.hasM = t3.hasm, delete t3.hasm), void 0 !== t3.hasz && (t3.hasZ = t3.hasz, delete t3.hasz), void 0 !== t3.spatialreference && (t3.spatialReference = t3.spatialreference, delete t3.spatialreference), void 0 !== t3.rings && (t3.rings = this._fixPathArrays(t3.rings, true === t3.hasZ, true === t3.hasZ)), void 0 !== t3.paths && (t3.paths = this._fixPathArrays(t3.paths, true === t3.hasZ, true === t3.hasM)), void 0 !== t3.points && (t3.points = this._fixPointArrays(t3.points, true === t3.hasZ, true === t3.hasM)), p2(t3);
  }
  static _fixPathArrays(e2, i, r) {
    const s = [];
    if (e2 instanceof Array)
      for (let t3 = 0; t3 < e2.length; t3++)
        s.push(this._fixPointArrays(e2[t3], i, r));
    else if (e2 instanceof t2)
      for (let t3 = 0; t3 < e2.length(); t3++)
        s.push(this._fixPointArrays(e2.get(t3), i, r));
    return s;
  }
  static _fixPointArrays(e2, i, r) {
    const s = [];
    if (e2 instanceof Array)
      for (let n = 0; n < e2.length; n++) {
        const a = e2[n];
        a instanceof x ? i && r ? s.push([a.x, a.y, a.z, a.m]) : i ? s.push([a.x, a.y, a.z]) : r ? s.push([a.x, a.y, a.m]) : s.push([a.x, a.y]) : a instanceof t2 ? s.push(a.toArray()) : s.push(a);
      }
    else if (e2 instanceof t2)
      for (let n = 0; n < e2.length(); n++) {
        const a = e2.get(n);
        a instanceof x ? i && r ? s.push([a.x, a.y, a.z, a.m]) : i ? s.push([a.x, a.y, a.z]) : r ? s.push([a.x, a.y, a.m]) : s.push([a.x, a.y]) : a instanceof t2 ? s.push(a.toArray()) : s.push(a);
      }
    return s;
  }
  static _convertDictionaryToJson(t3, i = false) {
    const r = {};
    for (const s in t3.attributes) {
      let n = t3.attributes[s];
      n instanceof A && (n = _b._convertDictionaryToJson(n)), i ? r[s.toLowerCase()] = n : r[s] = n;
    }
    return r;
  }
  static parseAttributesFromDictionary(e2) {
    const t3 = {};
    for (const i in e2.attributes) {
      const r = e2.attributes[i];
      if (!w(r))
        throw new t(null, e.InvalidParameter, null);
      t3[i] = r;
    }
    return t3;
  }
  static fromJson(e2, t3) {
    let n = null;
    null !== e2.geometry && void 0 !== e2.geometry && (n = p2(e2.geometry));
    const o = {};
    if (null !== e2.attributes && void 0 !== e2.attributes)
      for (const l in e2.attributes) {
        const t4 = e2.attributes[l];
        if (null === t4)
          o[l] = t4;
        else {
          if (!(L(t4) || J(t4) || Y(t4) || B(t4)))
            throw new t(null, e.InvalidParameter, null);
          o[l] = t4;
        }
      }
    return _b.createFromGraphicLikeObject(n, o, null, t3 ?? null);
  }
  fullSchema() {
    return this._layer;
  }
  gdbVersion() {
    if (null === this._layer)
      return "";
    const e2 = this._layer.gdbVersion;
    return void 0 === e2 ? "" : "" === e2 && this._layer.capabilities && this._layer.capabilities.isVersioned ? "SDE.DEFAULT" : e2;
  }
  castAsJson(e2) {
    var _a;
    const t3 = { attributes: {}, geometry: true === (e2 == null ? void 0 : e2.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
    for (const i in this.attributes) {
      const r = this.attributes[i];
      void 0 !== r && (t3.attributes[i] = Re(r, e2));
    }
    return t3;
  }
  async castAsJsonAsync(e2 = null, t3) {
    return this.castAsJson(t3);
  }
};
m(b);

export {
  b
};
//# sourceMappingURL=chunk-NZXLLEUL.js.map
