import {
  i
} from "./chunk-T3UXUOZW.js";
import {
  f as f2,
  v as v2
} from "./chunk-HZHMZHPT.js";
import {
  v
} from "./chunk-5WXPQVZD.js";
import {
  S,
  g,
  h,
  m as m2,
  p
} from "./chunk-G5WJIWPP.js";
import {
  _
} from "./chunk-UKJF25H6.js";
import {
  x
} from "./chunk-D5MIJ6WT.js";
import {
  j as j3
} from "./chunk-7KX64CAH.js";
import {
  n
} from "./chunk-5EXFDBQJ.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  f,
  o2 as o,
  r
} from "./chunk-SFV6XLDZ.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  m
} from "./chunk-DEI4XQQ6.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import {
  L
} from "./chunk-O3CHVGVF.js";
import {
  j,
  k,
  s as s3
} from "./chunk-HNHXEGH2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/support/I3SIndexInfo.js
async function r2(r3, n4, t, s4, a3, i2) {
  let l = null;
  if (null != t) {
    const o2 = `${r3}/nodepages/`, n5 = o2 + Math.floor(t.rootIndex / t.nodesPerPage);
    try {
      return { type: "page", rootPage: (await j2(n5, { query: { f: "json", token: s4 }, responseType: "json", signal: i2 })).data, rootIndex: t.rootIndex, pageSize: t.nodesPerPage, lodMetric: t.lodSelectionMetricType, urlPrefix: o2 };
    } catch (c) {
      null != a3 && a3.warn("#fetchIndexInfo()", "Failed to load root node page. Falling back to node documents.", n5, c), l = c;
    }
  }
  if (!n4)
    return null;
  const d = `${r3}/nodes/`, p3 = d + (n4 && n4.split("/").pop());
  try {
    return { type: "node", rootNode: (await j2(p3, { query: { f: "json", token: s4 }, responseType: "json", signal: i2 })).data, urlPrefix: d };
  } catch (c) {
    throw new s2("sceneservice:root-node-missing", "Root node missing.", { pageError: l, nodeError: c, url: p3 });
  }
}

// node_modules/@arcgis/core/layers/support/schemaValidatorLoader.js
var n2 = null;
function u() {
  return n2;
}

// node_modules/@arcgis/core/webdoc/support/saveUtils.js
async function p2(r3, p3, u2) {
  if (!p3 || !p3.resources)
    return;
  const h2 = p3.portalItem === r3.portalItem ? new Set(r3.paths) : /* @__PURE__ */ new Set();
  r3.paths.length = 0, r3.portalItem = p3.portalItem;
  const i2 = new Set(p3.resources.toKeep.map((r4) => r4.resource.path)), m3 = /* @__PURE__ */ new Set(), f3 = [];
  i2.forEach((e2) => {
    h2.delete(e2), r3.paths.push(e2);
  });
  for (const e2 of p3.resources.toUpdate)
    if (h2.delete(e2.resource.path), i2.has(e2.resource.path) || m3.has(e2.resource.path)) {
      const { resource: o2, content: t, finish: p4, error: n4 } = e2, h3 = m(o2, n());
      r3.paths.push(h3.path), f3.push(a2({ resource: h3, content: t, compress: e2.compress, finish: p4, error: n4 }, u2));
    } else
      r3.paths.push(e2.resource.path), f3.push(n3(e2, u2)), m3.add(e2.resource.path);
  for (const e2 of p3.resources.toAdd)
    f3.push(a2(e2, u2)), r3.paths.push(e2.resource.path);
  if (h2.forEach((r4) => {
    if (p3.portalItem) {
      const e2 = p3.portalItem.resourceFromPath(r4);
      f3.push(e2.portalItem.removeResource(e2).catch(() => {
      }));
    }
  }), 0 === f3.length)
    return;
  const l = await j(f3);
  s3(u2);
  const d = l.filter((r4) => "error" in r4).map((r4) => r4.error);
  if (d.length > 0)
    throw new s2("save:resources", "Failed to save one or more resources", { errors: d });
}
async function a2(e2, o2) {
  var _a, _b;
  const t = { ...null != o2 ? o2 : {}, compress: e2.compress }, s4 = await _(e2.resource.portalItem.addResource(e2.resource, e2.content, t));
  if (true !== s4.ok)
    throw (_a = e2.error) == null ? void 0 : _a.call(e2, s4.error), s4.error;
  (_b = e2.finish) == null ? void 0 : _b.call(e2, e2.resource);
}
async function n3(e2, o2) {
  var _a, _b;
  const t = await _(e2.resource.update(e2.content, o2));
  if (true !== t.ok)
    throw (_a = e2.error) == null ? void 0 : _a.call(e2, t.error), t.error;
  (_b = e2.finish) == null ? void 0 : _b.call(e2, e2.resource);
}

// node_modules/@arcgis/core/layers/mixins/SceneService.js
var R = "esri.layers.mixins.SceneService";
var A = s.getLogger(R);
var N = (o2) => {
  let N2 = class extends o2 {
    constructor() {
      super(...arguments), this.spatialReference = null, this.fullExtent = null, this.heightModelInfo = null, this.minScale = 0, this.maxScale = 0, this.version = { major: Number.NaN, minor: Number.NaN, versionString: "" }, this.copyright = null, this.sublayerTitleMode = "item-title", this.title = null, this.layerId = null, this.indexInfo = null, this._debouncedSaveOperations = k(async (e2, t, r3) => {
        switch (e2) {
          case K.SAVE:
            return this._save(t);
          case K.SAVE_AS:
            return this._saveAs(r3, t);
        }
      });
    }
    readSpatialReference(e2, t) {
      return this._readSpatialReference(t);
    }
    _readSpatialReference(e2) {
      if (null != e2.spatialReference)
        return f.fromJSON(e2.spatialReference);
      {
        const t = e2.store, r3 = t.indexCRS || t.geographicCRS, o3 = r3 && parseInt(r3.substring(r3.lastIndexOf("/") + 1, r3.length), 10);
        return null != o3 ? new f(o3) : null;
      }
    }
    readFullExtent(e2, t, r3) {
      if (null != e2 && "object" == typeof e2) {
        const o4 = null == e2.spatialReference ? { ...e2, spatialReference: this._readSpatialReference(t) } : e2;
        return M.fromJSON(o4, r3);
      }
      const o3 = t.store, i2 = this._readSpatialReference(t);
      return null == i2 || null == o3 || null == o3.extent || !Array.isArray(o3.extent) || o3.extent.some((e3) => e3 < E) ? null : new M({ xmin: o3.extent[0], ymin: o3.extent[1], xmax: o3.extent[2], ymax: o3.extent[3], spatialReference: i2 });
    }
    parseVersionString(e2) {
      const t = { major: Number.NaN, minor: Number.NaN, versionString: e2 }, r3 = e2.split(".");
      return r3.length >= 2 && (t.major = parseInt(r3[0], 10), t.minor = parseInt(r3[1], 10)), t;
    }
    readVersion(e2, t) {
      const r3 = t.store, o3 = null != r3.version ? r3.version.toString() : "";
      return this.parseVersionString(o3);
    }
    readTitlePortalItem(e2) {
      return "item-title" !== this.sublayerTitleMode ? void 0 : e2;
    }
    readTitleService(e2, t) {
      const r3 = this.portalItem && this.portalItem.title;
      if ("item-title" === this.sublayerTitleMode)
        return h(this.url, t.name);
      let o3 = t.name;
      if (!o3 && this.url) {
        const e3 = p(this.url);
        null != e3 && (o3 = e3.title);
      }
      return "item-title-and-service-name" === this.sublayerTitleMode && r3 && (o3 = r3 + " - " + o3), m2(o3);
    }
    set url(e2) {
      const t = g({ layer: this, url: e2, nonStandardUrlAllowed: false, logger: A });
      this._set("url", t.url), null != t.layerId && this._set("layerId", t.layerId);
    }
    writeUrl(e2, t, r3, o3) {
      S(this, e2, "layers", t, o3);
    }
    get parsedUrl() {
      const e2 = this._get("url"), t = L(e2);
      return null != this.layerId && (t.path = `${t.path}/layers/${this.layerId}`), t;
    }
    async _fetchIndexAndUpdateExtent(e2, t) {
      this.indexInfo = r2(this.parsedUrl.path, this.rootNode, e2, this.apiKey, A, t), null == this.fullExtent || this.fullExtent.hasZ || this._updateExtent(await this.indexInfo);
    }
    _updateExtent(e2) {
      var _a, _b, _c;
      if ("page" === (e2 == null ? void 0 : e2.type)) {
        const t = e2.rootIndex % e2.pageSize, o3 = (_b = (_a = e2.rootPage) == null ? void 0 : _a.nodes) == null ? void 0 : _b[t];
        if (null == o3 || null == o3.obb || null == o3.obb.center || null == o3.obb.halfSize)
          throw new s2("sceneservice:invalid-node-page", "Invalid node page.");
        if (o3.obb.center[0] < E || null == this.fullExtent || this.fullExtent.hasZ)
          return;
        const i2 = o3.obb.halfSize, s4 = o3.obb.center[2], a3 = Math.sqrt(i2[0] * i2[0] + i2[1] * i2[1] + i2[2] * i2[2]);
        this.fullExtent.zmin = s4 - a3, this.fullExtent.zmax = s4 + a3;
      } else if ("node" === (e2 == null ? void 0 : e2.type)) {
        const t = (_c = e2.rootNode) == null ? void 0 : _c.mbs;
        if (!Array.isArray(t) || 4 !== t.length || t[0] < E)
          return;
        const r3 = t[2], o3 = t[3], { fullExtent: i2 } = this;
        i2 && (i2.zmin = r3 - o3, i2.zmax = r3 + o3);
      }
    }
    async _fetchService(e2) {
      if (null == this.url)
        throw new s2("sceneservice:url-not-set", "Scene service can not be loaded without valid portal item or url");
      if (null == this.layerId && /SceneServer\/*$/i.test(this.url)) {
        const t = await this._fetchFirstLayerId(e2);
        null != t && (this.layerId = t);
      }
      return this._fetchServiceLayer(e2);
    }
    async _fetchFirstLayerId(e2) {
      const r3 = await j2(this.url, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: e2 });
      if (r3.data && Array.isArray(r3.data.layers) && r3.data.layers.length > 0)
        return r3.data.layers[0].id;
    }
    async _fetchServiceLayer(e2) {
      var _a;
      const r3 = await j2(((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "", { query: { f: "json", token: this.apiKey }, responseType: "json", signal: e2 });
      r3.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
      let o3 = false;
      if (r3.data.layerType && "Voxel" === r3.data.layerType && (o3 = true), o3)
        return this._fetchVoxelServiceLayer();
      const i2 = r3.data;
      this.read(i2, this._getServiceContext()), this.validateLayer(i2);
    }
    async _fetchVoxelServiceLayer(e2) {
      var _a;
      const r3 = (await j2(((_a = this.parsedUrl) == null ? void 0 : _a.path) + "/layer", { query: { f: "json", token: this.apiKey }, responseType: "json", signal: e2 })).data;
      this.read(r3, this._getServiceContext()), this.validateLayer(r3);
    }
    _getServiceContext() {
      var _a;
      return { origin: "service", portalItem: this.portalItem, portal: (_a = this.portalItem) == null ? void 0 : _a.portal, url: this.parsedUrl };
    }
    async _ensureLoadBeforeSave() {
      await this.load(), "beforeSave" in this && "function" == typeof this.beforeSave && await this.beforeSave();
    }
    validateLayer(e2) {
    }
    _updateTypeKeywords(e2, t, r3) {
      e2.typeKeywords || (e2.typeKeywords = []);
      const o3 = t.getTypeKeywords();
      for (const i2 of o3)
        e2.typeKeywords.push(i2);
      e2.typeKeywords && (e2.typeKeywords = e2.typeKeywords.filter((e3, t2, r4) => r4.indexOf(e3) === t2), r3 === U.newItem && (e2.typeKeywords = e2.typeKeywords.filter((e3) => "Hosted Service" !== e3)));
    }
    async _saveAs(e2, t) {
      var _a;
      const o3 = { ...O, ...t };
      let i2 = x.from(e2);
      i2 || (A.error("_saveAs(): requires a portal item parameter"), await Promise.reject(new s2("sceneservice:portal-item-required", "_saveAs() requires a portal item to save to"))), i2.id && (i2 = i2.clone(), i2.id = null);
      const s4 = i2.portal || j3.getDefault();
      await this._ensureLoadBeforeSave(), i2.type = T, i2.portal = s4;
      const a3 = { origin: "portal-item", url: null, messages: [], portal: s4, portalItem: i2, writtenProperties: [], blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, n4 = { layers: [this.write({}, a3)] };
      return await Promise.all(a3.resources.pendingOperations ?? []), await this._validateAgainstJSONSchema(n4, a3, o3), i2.url = this.url, i2.title || (i2.title = this.title), this._updateTypeKeywords(i2, o3, U.newItem), await s4.signIn(), await ((_a = s4.user) == null ? void 0 : _a.addItem({ item: i2, folder: o3 && o3.folder, data: n4 })), await p2(this.resourceReferences, a3, null), this.portalItem = i2, i(a3), a3.portalItem = i2, i2;
    }
    async _save(e2) {
      const t = { ...O, ...e2 };
      if (!this.portalItem)
        throw A.error("_save(): requires the .portalItem property to be set"), new s2("sceneservice:portal-item-not-set", "Portal item to save to has not been set on this SceneService");
      if (this.portalItem.type !== T)
        throw A.error("_save(): Non-matching portal item type. Got " + this.portalItem.type + ", expected " + T), new s2("sceneservice:portal-item-wrong-type", `Portal item needs to have type "${T}"`);
      await this._ensureLoadBeforeSave();
      const o3 = { origin: "portal-item", url: this.portalItem.itemUrl && L(this.portalItem.itemUrl), messages: [], portal: this.portalItem.portal || j3.getDefault(), portalItem: this.portalItem, writtenProperties: [], blockedRelativeUrls: [], resources: { toAdd: [], toUpdate: [], toKeep: [], pendingOperations: [] } }, i2 = { layers: [this.write({}, o3)] };
      return await Promise.all(o3.resources.pendingOperations ?? []), await this._validateAgainstJSONSchema(i2, o3, t), this.portalItem.url = this.url, this.portalItem.title || (this.portalItem.title = this.title), this._updateTypeKeywords(this.portalItem, t, U.existingItem), await this.portalItem.update({ data: i2 }), await p2(this.resourceReferences, o3, null), i(o3), this.portalItem;
    }
    async _validateAgainstJSONSchema(e2, t, o3) {
      var _a, _b;
      let i2 = ((_a = t.messages) == null ? void 0 : _a.filter((e3) => "error" === e3.type).map((e3) => new s2(e3.name, e3.message, e3.details))) ?? [];
      ((_b = o3 == null ? void 0 : o3.validationOptions) == null ? void 0 : _b.ignoreUnsupported) && (i2 = i2.filter((e3) => "layer:unsupported" !== e3.name && "symbol:unsupported" !== e3.name && "symbol-layer:unsupported" !== e3.name && "property:unsupported" !== e3.name && "url:unsupported" !== e3.name && "scenemodification:unsupported" !== e3.name));
      const s4 = o3 == null ? void 0 : o3.validationOptions, a3 = s4 == null ? void 0 : s4.enabled, n4 = u();
      if (a3 && n4) {
        const t2 = (await n4()).validate(e2, o3.portalItemLayerType);
        if (t2.length > 0) {
          const e3 = `Layer item did not validate:
${t2.join("\n")}`;
          if (A.error(`_validateAgainstJSONSchema(): ${e3}`), "throw" === s4.failPolicy) {
            const e4 = t2.map((e5) => new s2("sceneservice:schema-validation", e5)).concat(i2);
            throw new s2("sceneservice-validate:error", "Failed to save layer item due to schema validation, see `details.errors`.", { combined: e4 });
          }
        }
      }
      if (i2.length > 0)
        throw new s2("sceneservice:save", "Failed to save SceneService due to unsupported or invalid content. See 'details.errors' for more detailed information", { errors: i2 });
    }
  };
  return e([y(v2)], N2.prototype, "id", void 0), e([y({ type: f })], N2.prototype, "spatialReference", void 0), e([o("spatialReference", ["spatialReference", "store.indexCRS", "store.geographicCRS"])], N2.prototype, "readSpatialReference", null), e([y({ type: M })], N2.prototype, "fullExtent", void 0), e([o("fullExtent", ["fullExtent", "store.extent", "spatialReference", "store.indexCRS", "store.geographicCRS"])], N2.prototype, "readFullExtent", null), e([y({ readOnly: true, type: v })], N2.prototype, "heightModelInfo", void 0), e([y({ type: Number, json: { name: "layerDefinition.minScale", write: true, origins: { service: { read: { source: "minScale" }, write: false } } } })], N2.prototype, "minScale", void 0), e([y({ type: Number, json: { name: "layerDefinition.maxScale", write: true, origins: { service: { read: { source: "maxScale" }, write: false } } } })], N2.prototype, "maxScale", void 0), e([y({ readOnly: true })], N2.prototype, "version", void 0), e([o("version", ["store.version"])], N2.prototype, "readVersion", null), e([y({ type: String, json: { read: { source: "copyrightText" } } })], N2.prototype, "copyright", void 0), e([y({ type: String, json: { read: false } })], N2.prototype, "sublayerTitleMode", void 0), e([y({ type: String })], N2.prototype, "title", void 0), e([o("portal-item", "title")], N2.prototype, "readTitlePortalItem", null), e([o("service", "title", ["name"])], N2.prototype, "readTitleService", null), e([y({ type: Number, json: { origins: { service: { read: { source: "id" } }, "portal-item": { write: { target: "id", isRequired: true, ignoreOrigin: true }, read: false } } } })], N2.prototype, "layerId", void 0), e([y(f2)], N2.prototype, "url", null), e([r("url")], N2.prototype, "writeUrl", null), e([y()], N2.prototype, "parsedUrl", null), e([y({ readOnly: true })], N2.prototype, "store", void 0), e([y({ type: String, readOnly: true, json: { read: { source: "store.rootNode" } } })], N2.prototype, "rootNode", void 0), N2 = e([a(R)], N2), N2;
};
var E = -1e38;
var U;
!function(e2) {
  e2[e2.existingItem = 0] = "existingItem", e2[e2.newItem = 1] = "newItem";
}(U || (U = {}));
var T = "Scene Service";
var O = { getTypeKeywords: () => [], portalItemLayerType: "unknown", validationOptions: { enabled: true, ignoreUnsupported: false, failPolicy: "throw" } };
var K;
!function(e2) {
  e2[e2.SAVE = 0] = "SAVE", e2[e2.SAVE_AS = 1] = "SAVE_AS";
}(K || (K = {}));

export {
  r2 as r,
  N,
  K
};
//# sourceMappingURL=chunk-YPIJJVCA.js.map
