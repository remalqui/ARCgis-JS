import {
  t
} from "./chunk-TDPKDZC3.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import {
  se,
  u2 as u
} from "./chunk-7KM4XBUC.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/geojson.js
var i = { LineString: "esriGeometryPolyline", MultiLineString: "esriGeometryPolyline", MultiPoint: "esriGeometryMultipoint", Point: "esriGeometryPoint", Polygon: "esriGeometryPolygon", MultiPolygon: "esriGeometryPolygon" };
function s2(e) {
  return i[e];
}
function* c(e) {
  switch (e.type) {
    case "Feature":
      yield e;
      break;
    case "FeatureCollection":
      for (const t3 of e.features)
        t3 && (yield t3);
  }
}
function* u2(e) {
  if (e)
    switch (e.type) {
      case "Point":
        yield e.coordinates;
        break;
      case "LineString":
      case "MultiPoint":
        yield* e.coordinates;
        break;
      case "MultiLineString":
      case "Polygon":
        for (const t3 of e.coordinates)
          yield* t3;
        break;
      case "MultiPolygon":
        for (const t3 of e.coordinates)
          for (const e2 of t3)
            yield* e2;
    }
}
function* l(e, o = {}) {
  const { geometryType: r, objectIdField: i2 } = o;
  for (const c2 of e) {
    const { geometry: e2, properties: u3, id: l2 } = c2;
    if (e2 && s2(e2.type) !== r)
      continue;
    const f2 = u3 || {};
    let a2;
    i2 && (a2 = f2[i2], null == l2 || a2 || (f2[i2] = a2 = l2));
    const y2 = new t(e2 ? g(new t2(), e2, o) : null, f2, null, a2 ?? void 0);
    yield y2;
  }
}
function f(e) {
  for (const t3 of e)
    if (t3.length > 2)
      return true;
  return false;
}
function a(e) {
  return !p(e);
}
function y(e) {
  return p(e);
}
function p(e) {
  let t3 = 0;
  for (let n = 0; n < e.length; n++) {
    const o = e[n], r = e[(n + 1) % e.length];
    t3 += o[0] * r[1] - r[0] * o[1];
  }
  return t3 <= 0;
}
function d(e) {
  const t3 = e[0], n = e[e.length - 1];
  return t3[0] === n[0] && t3[1] === n[1] && t3[2] === n[2] || e.push(t3), e;
}
function g(e, t3, n) {
  switch (t3.type) {
    case "LineString":
      return m(e, t3, n);
    case "MultiLineString":
      return h(e, t3, n);
    case "MultiPoint":
      return w(e, t3, n);
    case "MultiPolygon":
      return P(e, t3, n);
    case "Point":
      return b(e, t3, n);
    case "Polygon":
      return j(e, t3, n);
  }
}
function m(e, t3, n) {
  return G(e, t3.coordinates, n), e;
}
function h(e, t3, n) {
  for (const o of t3.coordinates)
    G(e, o, n);
  return e;
}
function w(e, t3, n) {
  return G(e, t3.coordinates, n), e;
}
function P(e, t3, n) {
  for (const o of t3.coordinates) {
    S(e, o[0], n);
    for (let t4 = 1; t4 < o.length; t4++)
      F(e, o[t4], n);
  }
  return e;
}
function b(e, t3, n) {
  return k(e, t3.coordinates, n), e;
}
function j(e, t3, n) {
  const o = t3.coordinates;
  S(e, o[0], n);
  for (let r = 1; r < o.length; r++)
    F(e, o[r], n);
  return e;
}
function S(e, t3, n) {
  const o = d(t3);
  a(o) ? M(e, o, n) : G(e, o, n);
}
function F(e, t3, n) {
  const o = d(t3);
  y(o) ? M(e, o, n) : G(e, o, n);
}
function G(e, t3, n) {
  for (const o of t3)
    k(e, o, n);
  e.lengths.push(t3.length);
}
function M(e, t3, n) {
  for (let o = t3.length - 1; o >= 0; o--)
    k(e, t3[o], n);
  e.lengths.push(t3.length);
}
function k(e, t3, n) {
  const [o, r, i2] = t3;
  e.coords.push(o, r), n.hasZ && e.coords.push(i2 || 0);
}
function O(e) {
  switch (typeof e) {
    case "string":
      return "esriFieldTypeString";
    case "number":
      return "esriFieldTypeDouble";
    default:
      return "unknown";
  }
}
function T(t3) {
  if (!t3)
    throw new s("geojson-layer:empty", "GeoJSON data is empty");
  if ("Feature" !== t3.type && "FeatureCollection" !== t3.type)
    throw new s("geojson-layer:unsupported-geojson-object", "missing or not supported GeoJSON object type", { data: t3 });
  const { crs: n } = t3;
  if (!n)
    return;
  const o = "string" == typeof n ? n : "name" === n.type ? n.properties.name : "EPSG" === n.type ? n.properties.code : null, r = new RegExp(".*(CRS84H?|4326)$", "i");
  if (!o || !r.test(o))
    throw new s("geojson-layer:unsupported-crs", "unsupported GeoJSON 'crs' member", { crs: n });
}
function L(e, t3 = {}) {
  const n = [], i2 = /* @__PURE__ */ new Set(), l2 = /* @__PURE__ */ new Set();
  let a2, y2 = false, p2 = null, d2 = false, { geometryType: g2 = null } = t3, m2 = false;
  for (const r of c(e)) {
    const { geometry: e2, properties: t4, id: c2 } = r;
    if (!e2 || (g2 || (g2 = s2(e2.type)), s2(e2.type) === g2)) {
      if (!y2) {
        y2 = f(u2(e2));
      }
      if (d2 || (d2 = null != c2, d2 && (a2 = typeof c2, t4 && (p2 = Object.keys(t4).filter((e3) => t4[e3] === c2)))), t4 && p2 && d2 && null != c2 && (p2.length > 1 ? p2 = p2.filter((e3) => t4[e3] === c2) : 1 === p2.length && (p2 = t4[p2[0]] === c2 ? p2 : [])), !m2 && t4) {
        let e3 = true;
        for (const r2 in t4) {
          if (i2.has(r2))
            continue;
          const s3 = t4[r2];
          if (null == s3) {
            e3 = false, l2.add(r2);
            continue;
          }
          const c3 = O(s3);
          if ("unknown" === c3) {
            l2.add(r2);
            continue;
          }
          l2.delete(r2), i2.add(r2);
          const u3 = u(r2);
          u3 && n.push({ name: u3, alias: r2, type: c3 });
        }
        m2 = e3;
      }
    }
  }
  const h2 = u(1 === (p2 == null ? void 0 : p2.length) && p2[0] || null) ?? void 0;
  if (h2) {
    for (const o of n)
      if (o.name === h2 && se(o)) {
        o.type = "esriFieldTypeOID";
        break;
      }
  }
  return { fields: n, geometryType: g2, hasZ: y2, objectIdFieldName: h2, objectIdFieldType: a2, unknownFields: Array.from(l2) };
}
function I(e, t3) {
  return Array.from(l(c(e), t3));
}

export {
  s2 as s,
  T,
  L,
  I
};
//# sourceMappingURL=chunk-CKK5HS7D.js.map
