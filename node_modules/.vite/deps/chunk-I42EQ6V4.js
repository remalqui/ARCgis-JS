import {
  E
} from "./chunk-WWUAHPIM.js";
import {
  e as e3
} from "./chunk-LREUW66K.js";
import {
  t
} from "./chunk-Y2ZDD3I4.js";
import {
  h,
  l as l2
} from "./chunk-XN5VV437.js";
import {
  m as m2,
  y,
  y3 as y2
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a3,
  e as e2,
  l
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  v
} from "./chunk-O3CHVGVF.js";
import {
  a as a2,
  c,
  d,
  w
} from "./chunk-HNHXEGH2.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  A,
  M,
  m
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/geometry/support/UintArray.js
function t2(n2, t3 = false) {
  return n2 <= A ? t3 ? new Array(n2).fill(0) : new Array(n2) : new Uint32Array(n2);
}

// node_modules/@arcgis/core/layers/support/Tilemap.js
var r = class _r {
  constructor(t3) {
    this._validateJSON(t3);
    const { location: i, data: e4 } = t3;
    this.location = Object.freeze(a(i));
    const r2 = this.location.width, n2 = this.location.height;
    let s4 = true, h2 = true;
    const c2 = Math.ceil(r2 * n2 / 32), m3 = t2(c2);
    let f = 0;
    for (let a4 = 0; a4 < e4.length; a4++) {
      const t4 = a4 % 32;
      e4[a4] ? (h2 = false, m3[f] |= 1 << t4) : s4 = false, 31 === t4 && ++f;
    }
    h2 ? (this._availability = "unavailable", this.byteSize = 40) : s4 ? (this._availability = "available", this.byteSize = 40) : (this._availability = m3, this.byteSize = 40 + m(m3));
  }
  getAvailability(t3, i) {
    if ("unavailable" === this._availability || "available" === this._availability)
      return this._availability;
    const e4 = (t3 - this.location.top) * this.location.width + (i - this.location.left), a4 = e4 % 32, o = e4 >> 5, l3 = this._availability;
    return o < 0 || o > l3.length ? "unknown" : l3[o] & 1 << a4 ? "available" : "unavailable";
  }
  static fromDefinition(a4, o) {
    const l3 = a4.service.request || j, { row: n2, col: h2, width: c2, height: m3 } = a4, f = { query: { f: "json" } };
    return o = o ? { ...f, ...o } : f, l3(s3(a4), o).then((t3) => t3.data).catch((t3) => {
      if (t3 && t3.details && 422 === t3.details.httpStatus)
        return { location: { top: n2, left: h2, width: c2, height: m3 }, valid: true, data: M(c2 * m3, 0) };
      throw t3;
    }).then((t3) => {
      if (t3.location && (t3.location.top !== n2 || t3.location.left !== h2 || t3.location.width !== c2 || t3.location.height !== m3))
        throw new s("tilemap:location-mismatch", "Tilemap response for different location than requested", { response: t3, definition: { top: n2, left: h2, width: c2, height: m3 } });
      return _r.fromJSON(t3);
    });
  }
  static fromJSON(t3) {
    return Object.freeze(new _r(t3));
  }
  _validateJSON(t3) {
    if (!t3 || !t3.location)
      throw new s("tilemap:missing-location", "Location missing from tilemap response");
    if (false === t3.valid)
      throw new s("tilemap:invalid", "Tilemap response was marked as invalid");
    if (!t3.data)
      throw new s("tilemap:missing-data", "Data missing from tilemap response");
    if (!Array.isArray(t3.data))
      throw new s("tilemap:data-mismatch", "Data must be an array of numbers");
    if (t3.data.length !== t3.location.width * t3.location.height)
      throw new s("tilemap:data-mismatch", "Number of data items does not match width/height of tilemap");
  }
};
function n(t3) {
  return `${t3.level}/${t3.row}/${t3.col}/${t3.width}/${t3.height}`;
}
function s3(t3) {
  var _a;
  let i;
  if ((_a = t3.service.tileServers) == null ? void 0 : _a.length) {
    const e5 = t3.service.tileServers;
    i = `${e5 && e5.length ? e5[t3.row % e5.length] : t3.service.url}/tilemap/${t3.level}/${t3.row}/${t3.col}/${t3.width}/${t3.height}`;
  } else
    i = `${t3.service.url}/tilemap/${t3.level}/${t3.row}/${t3.col}/${t3.width}/${t3.height}`;
  const e4 = t3.service.query;
  return e4 && (i = `${i}?${e4}`), i;
}

// node_modules/@arcgis/core/layers/support/TilemapCache.js
var w2;
var T = w2 = class extends m2 {
  constructor(e4) {
    super(e4), this._pendingTilemapRequests = {}, this.request = j, this.size = 32, this._prefetchingEnabled = true;
  }
  initialize() {
    this._tilemapCache = new e3(2 * E.MEGABYTES), this.addHandles([l2(() => {
      const { layer: e4 } = this;
      return [e4 == null ? void 0 : e4.parsedUrl, e4 == null ? void 0 : e4.tileServers, e4 == null ? void 0 : e4.apiKey, e4 == null ? void 0 : e4.customParameters];
    }, () => this._initializeTilemapDefinition(), h)]);
  }
  get effectiveMinLOD() {
    return this.minLOD ?? this.layer.tileInfo.lods[0].level;
  }
  get effectiveMaxLOD() {
    return this.maxLOD ?? this.layer.tileInfo.lods[this.layer.tileInfo.lods.length - 1].level;
  }
  fetchTilemap(e4, t3, i, r2) {
    if (!this.layer.tileInfo.lodAt(e4) || e4 < this.effectiveMinLOD || e4 > this.effectiveMaxLOD)
      return Promise.reject(new s("tilemap-cache:level-unavailable", `Level ${e4} is unavailable in the service`));
    const l3 = this._tmpTilemapDefinition, o = this._tilemapFromCache(e4, t3, i, l3);
    if (o)
      return Promise.resolve(o);
    const a4 = r2 && r2.signal;
    return r2 = { ...r2, signal: null }, new Promise((e5, t4) => {
      w(a4, () => t4(c()));
      const i2 = n(l3);
      let s4 = this._pendingTilemapRequests[i2];
      if (!s4) {
        s4 = r.fromDefinition(l3, r2).then((e7) => (this._tilemapCache.put(i2, e7, e7.byteSize), e7));
        const e6 = () => delete this._pendingTilemapRequests[i2];
        this._pendingTilemapRequests[i2] = s4, s4.then(e6, e6);
      }
      s4.then(e5, t4);
    });
  }
  getAvailability(e4, t3, i) {
    if (!this.layer.tileInfo.lodAt(e4) || e4 < this.effectiveMinLOD || e4 > this.effectiveMaxLOD)
      return "unavailable";
    const r2 = this._tilemapFromCache(e4, t3, i, this._tmpTilemapDefinition);
    return r2 ? r2.getAvailability(t3, i) : "unknown";
  }
  fetchAvailability(e4, t3, i, r2) {
    return !this.layer.tileInfo.lodAt(e4) || e4 < this.effectiveMinLOD || e4 > this.effectiveMaxLOD ? Promise.reject(new s("tile-map:tile-unavailable", "Tile is not available", { level: e4, row: t3, col: i })) : this.fetchTilemap(e4, t3, i, r2).catch((e5) => e5).then((r3) => {
      if (r3 instanceof r) {
        const l3 = r3.getAvailability(t3, i);
        if ("unavailable" === l3)
          throw new s("tile-map:tile-unavailable", "Tile is not available", { level: e4, row: t3, col: i });
        return l3;
      }
      if (d(r3))
        throw r3;
      return "unknown";
    });
  }
  fetchAvailabilityUpsample(e4, t3, i, r2, s4) {
    r2.level = e4, r2.row = t3, r2.col = i;
    const l3 = this.layer.tileInfo;
    l3.updateTileInfo(r2);
    const o = this.fetchAvailability(e4, t3, i, s4).catch((e5) => {
      if (d(e5))
        throw e5;
      if (l3.upsampleTile(r2))
        return this.fetchAvailabilityUpsample(r2.level, r2.row, r2.col, r2, s4);
      throw e5;
    });
    return this._fetchAvailabilityUpsamplePrefetch(r2.id, e4, t3, i, s4, o), o;
  }
  async _fetchAvailabilityUpsamplePrefetch(e4, t3, i, r2, s4, o) {
    if (!this._prefetchingEnabled || null == e4)
      return;
    const a4 = `prefetch-${e4}`;
    if (this.hasHandles(a4))
      return;
    const n2 = new AbortController();
    o.then(() => n2.abort(), () => n2.abort());
    let c2 = false;
    const h2 = e2(() => {
      c2 || (c2 = true, n2.abort());
    });
    if (this.addHandles(h2, a4), await y(10, n2.signal).catch(() => {
    }), c2 || (c2 = true, this.removeHandles(a4)), a2(n2))
      return;
    const m3 = new t(e4, t3, i, r2), f = { ...s4, signal: n2.signal }, v2 = this.layer.tileInfo;
    for (let l3 = 0; w2._prefetches.length < w2._maxPrefetch && v2.upsampleTile(m3); ++l3) {
      const e5 = this.fetchAvailability(m3.level, m3.row, m3.col, f);
      w2._prefetches.push(e5);
      const t4 = () => {
        w2._prefetches.removeUnordered(e5);
      };
      e5.then(t4, t4);
    }
  }
  _initializeTilemapDefinition() {
    var _a;
    if (!this.layer.parsedUrl)
      return;
    const { parsedUrl: e4, apiKey: t3, customParameters: i } = this.layer;
    this._tilemapCache.clear(), this._tmpTilemapDefinition = { service: { url: e4.path, query: v({ ...e4.query, ...i, token: t3 ?? ((_a = e4.query) == null ? void 0 : _a.token) }), tileServers: this.layer.tileServers, request: this.request }, width: this.size, height: this.size, level: 0, row: 0, col: 0 };
  }
  _tilemapFromCache(e4, t3, i, r2) {
    r2.level = e4, r2.row = t3 - t3 % this.size, r2.col = i - i % this.size;
    const s4 = n(r2);
    return this._tilemapCache.get(s4);
  }
  get test() {
    const e4 = this;
    return { get prefetchingEnabled() {
      return e4._prefetchingEnabled;
    }, set prefetchingEnabled(t3) {
      e4._prefetchingEnabled = t3;
    }, hasTilemap: (t3, i, r2) => !!e4._tilemapFromCache(t3, i, r2, e4._tmpTilemapDefinition) };
  }
};
T._maxPrefetch = 4, T._prefetches = new l({ initialSize: w2._maxPrefetch }), e([y2({ constructOnly: true })], T.prototype, "layer", void 0), e([y2({ constructOnly: true })], T.prototype, "minLOD", void 0), e([y2({ constructOnly: true })], T.prototype, "maxLOD", void 0), e([y2({ constructOnly: true })], T.prototype, "request", void 0), e([y2({ constructOnly: true })], T.prototype, "size", void 0), T = w2 = e([a3("esri.layers.support.TilemapCache")], T);

export {
  T
};
//# sourceMappingURL=chunk-I42EQ6V4.js.map
