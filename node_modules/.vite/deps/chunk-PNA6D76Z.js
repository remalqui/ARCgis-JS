import {
  i
} from "./chunk-QXPTMFGZ.js";
import {
  v
} from "./chunk-OYBXMT5R.js";
import {
  C,
  T,
  c,
  h,
  w
} from "./chunk-HNHXEGH2.js";
import {
  o
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/views/support/QueueProcessor.js
var n = class {
  constructor(e, s) {
    this.item = e, this.controller = s, this.promise = null;
  }
};
var u = class {
  constructor(e) {
    this._deferreds = /* @__PURE__ */ new Map(), this._controllers = /* @__PURE__ */ new Map(), this._processingItems = /* @__PURE__ */ new Map(), this._isPaused = false, this._schedule = null, this._task = null, this.concurrency = 1, e.concurrency && (this.concurrency = e.concurrency), this._queue = new i(e.peeker), this.process = e.process;
    const s = e.scheduler;
    e.priority && s && (this._task = s.registerTask(e.priority, this));
  }
  destroy() {
    this.clear(), this._schedule = o(this._schedule), this._task = o(this._task);
  }
  get length() {
    return this._processingItems.size + this._queue.length;
  }
  abort(e) {
    const s = this._controllers.get(e);
    s && s.abort();
  }
  clear() {
    this._queue.clear();
    const e = [];
    this._controllers.forEach((s) => e.push(s)), this._controllers.clear(), e.forEach((e2) => e2.abort()), this._processingItems.clear(), this._cancelNext();
  }
  forEach(e) {
    this._deferreds.forEach((s, t) => e(t));
  }
  get(e) {
    const s = this._deferreds.get(e);
    return s ? s.promise : void 0;
  }
  isOngoing(e) {
    return this._processingItems.has(e);
  }
  has(e) {
    return this._deferreds.has(e);
  }
  pause() {
    this._isPaused || (this._isPaused = true, this._cancelNext());
  }
  push(e, i2) {
    const o2 = this.get(e);
    if (o2)
      return o2;
    const c2 = new AbortController();
    let n2 = null;
    i2 && (n2 = w(i2, () => c2.abort()));
    const u2 = () => {
      const s = this._processingItems.get(e);
      s && s.controller.abort(), l(), p.reject(c());
    }, l = () => {
      _.remove(), null != n2 && n2.remove(), this._deferreds.delete(e), this._controllers.delete(e), this._queue.remove(e), this._processingItems.delete(e), this._scheduleNext();
    }, _ = h(c2.signal, u2), p = C();
    return this._deferreds.set(e, p), this._controllers.set(e, c2), p.promise.then(l, l), this._queue.push(e), this._scheduleNext(), p.promise;
  }
  last() {
    return this._queue.last();
  }
  peek() {
    return this._queue.peek();
  }
  popLast() {
    return this._queue.popLast();
  }
  reset() {
    const e = [];
    this._processingItems.forEach((s) => e.push(s)), this._processingItems.clear();
    for (const s of e)
      this._queue.push(s.item), s.controller.abort();
    this._scheduleNext();
  }
  resume() {
    this._isPaused && (this._isPaused = false, this._scheduleNext());
  }
  takeAll() {
    const e = [];
    for (; this._queue.length; )
      e.push(this._queue.pop());
    return this.clear(), e;
  }
  get running() {
    return !this._isPaused && this._queue.length > 0 && this._processingItems.size < this.concurrency;
  }
  runTask(e) {
    for (; !e.done && this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop()), e.madeProgress();
  }
  _scheduleNext() {
    this._task || this._isPaused || this._schedule || (this._schedule = v(() => {
      this._schedule = null, this._next();
    }));
  }
  _next() {
    for (; this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop());
  }
  _cancelNext() {
    this._schedule && (this._schedule.remove(), this._schedule = null);
  }
  _processResult(e, s) {
    this._canProcessFulfillment(e) && (this._scheduleNext(), this._deferreds.get(e.item).resolve(s));
  }
  _processError(e, s) {
    this._canProcessFulfillment(e) && (this._scheduleNext(), this._deferreds.get(e.item).reject(s));
  }
  _canProcessFulfillment(e) {
    return !!this._deferreds.get(e.item) && this._processingItems.get(e.item) === e;
  }
  _process(e) {
    if (null == e)
      return;
    let s;
    const t = new AbortController(), r = new n(e, t);
    this._processingItems.set(e, r);
    try {
      s = this.process(e, t.signal);
    } catch (h2) {
      this._processError(r, h2);
    }
    T(s) ? (r.promise = s, s.then((e2) => this._processResult(r, e2), (e2) => this._processError(r, e2))) : this._processResult(r, s);
  }
  get test() {
    return { update: (e) => this.runTask(e) };
  }
};

export {
  u
};
//# sourceMappingURL=chunk-PNA6D76Z.js.map
