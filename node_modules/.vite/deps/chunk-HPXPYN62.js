import {
  $,
  r
} from "./chunk-3VTULECI.js";
import {
  L
} from "./chunk-TBHRKIAA.js";
import {
  t
} from "./chunk-JSMUQBPG.js";
import {
  o,
  u
} from "./chunk-EIE3W25Z.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/util/debug.js
var n = (n2, l4) => n2 && ((...n3) => l4.warn("DEBUG:", ...n3)) || (() => null);
var l = false;

// node_modules/@arcgis/core/views/2d/engine/webgl/visualVariablesUtils.js
function l2(l4) {
  return $(l4.minDataValue) && $(l4.maxDataValue) && null != l4.minSize && null != l4.maxSize ? L.SIZE_MINMAX_VALUE : (l4.expression && "view.scale" === l4.expression || l4.valueExpression && "$view.scale" === l4.valueExpression) && Array.isArray(l4.stops) ? L.SIZE_SCALE_STOPS : (null != l4.field || l4.expression && "view.scale" !== l4.expression || l4.valueExpression && "$view.scale" !== l4.valueExpression) && (Array.isArray(l4.stops) || "levels" in l4 && l4.levels) ? L.SIZE_FIELD_STOPS : (null != l4.field || l4.expression && "view.scale" !== l4.expression || l4.valueExpression && "$view.scale" !== l4.valueExpression) && null != l4.valueUnit ? L.SIZE_UNIT_VALUE : (s.getLogger("esri.views.2d.engine.webgl").error(new s2("mapview-bad-type", "Found invalid size VisualVariable", l4)), L.NONE);
}

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/visualVariablesUtils.js
function l3(e, t2) {
  if (!e || !t2)
    return e;
  switch (t2) {
    case "radius":
    case "distance":
      return 2 * e;
    case "diameter":
    case "width":
      return e;
    case "area":
      return Math.sqrt(e);
  }
  return e;
}
function r2(t2) {
  return { value: t2.value, size: o(t2.size) };
}
function a(e) {
  return (e ?? []).map((e2) => r2(e2));
}
function u2(t2) {
  if ("string" == typeof t2 || "number" == typeof t2)
    return o(t2);
  const s3 = t2;
  return { type: "size", expression: s3.expression, stops: a(s3.stops) };
}
var p = (e) => {
  const s3 = [], o2 = [], i = a(e), l4 = i.length;
  for (let r3 = 0; r3 < 6; r3++) {
    const e2 = i[Math.min(r3, l4 - 1)];
    s3.push(e2.value), o2.push(null == e2.size ? t : u(e2.size));
  }
  return { values: new Float32Array(s3), sizes: new Float32Array(o2) };
};
function c(e) {
  const t2 = e && e.length > 0 ? {} : null, s3 = t2 ? {} : null;
  if (!t2 || !s3)
    return { vvFields: t2, vvRanges: s3 };
  for (const n2 of e)
    if (n2.field && (t2[n2.type] = n2.field), "size" === n2.type) {
      s3.size || (s3.size = {});
      const e2 = n2;
      switch (l2(e2)) {
        case L.SIZE_MINMAX_VALUE:
          s3.size.minMaxValue = { minDataValue: e2.minDataValue, maxDataValue: e2.maxDataValue, minSize: u2(e2.minSize), maxSize: u2(e2.maxSize) };
          break;
        case L.SIZE_SCALE_STOPS:
          s3.size.scaleStops = { stops: a(e2.stops) };
          break;
        case L.SIZE_FIELD_STOPS:
          if (e2.levels) {
            const t3 = {};
            for (const s4 in e2.levels)
              t3[s4] = p(e2.levels[s4]);
            s3.size.fieldStops = { type: "level-dependent", levels: t3 };
          } else
            s3.size.fieldStops = { type: "static", ...p(e2.stops) };
          break;
        case L.SIZE_UNIT_VALUE:
          s3.size.unitValue = { unit: e2.valueUnit, valueRepresentation: e2.valueRepresentation ?? void 0 };
      }
    } else if ("color" === n2.type)
      s3.color = m(n2);
    else if ("opacity" === n2.type)
      s3.opacity = f(n2);
    else if ("rotation" === n2.type) {
      const e2 = n2;
      s3.rotation = { type: e2.rotationType };
    }
  return { vvFields: t2, vvRanges: s3 };
}
function f(e) {
  const t2 = { values: [0, 0, 0, 0, 0, 0, 0, 0], opacities: [0, 0, 0, 0, 0, 0, 0, 0] };
  if ("string" == typeof e.field) {
    if (!e.stops)
      return null;
    {
      if (e.stops.length > 8)
        return null;
      const s3 = e.stops;
      for (let e2 = 0; e2 < 8; ++e2) {
        const n2 = s3[Math.min(e2, s3.length - 1)];
        t2.values[e2] = n2.value, t2.opacities[e2] = n2.opacity;
      }
    }
  } else {
    if (!(e.stops && e.stops.length >= 0))
      return null;
    {
      const s3 = e.stops && e.stops.length >= 0 ? e.stops[0].opacity : 0;
      for (let e2 = 0; e2 < 8; e2++)
        t2.values[e2] = 1 / 0, t2.opacities[e2] = s3;
    }
  }
  return t2;
}
function v(e, t2, s3) {
  e[4 * t2] = s3.r / 255, e[4 * t2 + 1] = s3.g / 255, e[4 * t2 + 2] = s3.b / 255, e[4 * t2 + 3] = s3.a;
}
function m(e) {
  if (null == e)
    return null;
  if (e.normalizationField)
    return null;
  const t2 = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
  if ("string" == typeof e.field) {
    if (!e.stops)
      return null;
    {
      if (e.stops.length > 8)
        return null;
      t2.field = e.field;
      const s3 = e.stops;
      for (let e2 = 0; e2 < 8; ++e2) {
        const n2 = s3[Math.min(e2, s3.length - 1)];
        t2.values[e2] = n2.value, v(t2.colors, e2, n2.color);
      }
    }
  } else {
    if (!(e.stops && e.stops.length >= 0))
      return null;
    {
      const s3 = e.stops && e.stops.length >= 0 && e.stops[0].color;
      for (let e2 = 0; e2 < 8; e2++)
        t2.values[e2] = 1 / 0, v(t2.colors, e2, s3);
    }
  }
  for (let n2 = 0; n2 < 32; n2 += 4)
    r(t2.colors, n2, true);
  return t2;
}

export {
  n,
  l,
  l2,
  l3,
  c
};
//# sourceMappingURL=chunk-HPXPYN62.js.map
