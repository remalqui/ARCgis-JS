import {
  h as h2
} from "./chunk-KUTIL64W.js";
import {
  c as c2
} from "./chunk-AHVENFMO.js";
import "./chunk-JUYJSPTR.js";
import {
  l
} from "./chunk-ROAORTI3.js";
import {
  t as t2
} from "./chunk-NGH54QS3.js";
import {
  m
} from "./chunk-ZEKM2THG.js";
import "./chunk-2735WBYK.js";
import "./chunk-4NLQ63FV.js";
import "./chunk-Y7HVH6RU.js";
import "./chunk-QVFTB6AS.js";
import {
  G,
  Q,
  V,
  et,
  ie,
  ne,
  r
} from "./chunk-GTENSI4J.js";
import "./chunk-CN3PB7HS.js";
import "./chunk-NLX3GR5V.js";
import {
  O,
  c,
  r as r2,
  t
} from "./chunk-ZL3HOHNK.js";
import "./chunk-PX3Q44FM.js";
import "./chunk-XYJMHUDA.js";
import "./chunk-CSLWFQJE.js";
import "./chunk-A4HFWKMU.js";
import "./chunk-TDXHXKUI.js";
import "./chunk-IVABPLLZ.js";
import "./chunk-JSMUQBPG.js";
import "./chunk-LREUW66K.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-TQGXXOXA.js";
import "./chunk-QNFDBY7V.js";
import "./chunk-EL72ISXP.js";
import "./chunk-5KLICR5E.js";
import {
  p2 as p
} from "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-X4Y5OF5X.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-KTSEQWMB.js";
import {
  e,
  u as u2
} from "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import {
  h
} from "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-4RFFPIT2.js";
import "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-KUQPXYNJ.js";
import "./chunk-XN5VV437.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import "./chunk-3GSONYPC.js";
import "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import {
  s
} from "./chunk-HNHXEGH2.js";
import {
  u
} from "./chunk-DWOEYHKS.js";
import "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/symbols/cim/CIMSymbolRasterizer.js
var M;
!function(e2) {
  e2.Legend = "legend", e2.Preview = "preview";
}(M || (M = {}));
var _ = (e2) => e2 && e2.scaleFactor ? e2.scaleFactor : 1;
var b = 96 / 72;
var z = class {
  constructor(e2, t3) {
    this._spatialReference = e2, this._avoidSDF = t3, this._resourceCache = /* @__PURE__ */ new Map(), this._imageDataCanvas = null, this._pictureMarkerCache = /* @__PURE__ */ new Map(), this._textRasterizer = new r(), this._cimResourceManager = new h2(), this._rasterizer = new c2(this._cimResourceManager);
  }
  get resourceManager() {
    return this._cimResourceManager;
  }
  async rasterizeCIMSymbolAsync(e2, t3, a, i, r3, o, s2, n) {
    if (!e2)
      return null;
    const { data: g } = e2;
    if (!g || "CIMSymbolReference" !== g.type || !g.symbol)
      return null;
    const { symbol: u4 } = g;
    o || (o = O(u4));
    const d2 = await ne.resolveSymbolOverrides(g, t3, this._spatialReference, r3, o, s2, n);
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const y2 = this._imageDataCanvas, p2 = this._cimResourceManager, w = [];
    ie.fetchResources(d2, p2, w), ie.fetchFonts(d2, p2, w), w.length > 0 && await Promise.all(w);
    const { width: C, height: M2 } = a, _2 = v(o, C, M2, i), z2 = ie.getEnvelope(d2, _2, p2);
    if (!z2)
      return null;
    const I2 = (window.devicePixelRatio || 1) * b;
    let x = 1, R = 0, P = 0;
    switch (u4.type) {
      case "CIMPointSymbol":
      case "CIMTextSymbol":
        {
          let e3 = 1;
          z2.width > C && (e3 = C / z2.width);
          let t4 = 1;
          z2.height > M2 && (t4 = M2 / z2.height), "preview" === i && (z2.width < C && (e3 = C / z2.width), z2.height < M2 && (t4 = M2 / z2.height)), x = Math.min(e3, t4), R = z2.x + z2.width / 2, P = z2.y + z2.height / 2;
        }
        break;
      case "CIMLineSymbol":
        {
          let e3 = 1;
          z2.height > M2 && (e3 = M2 / z2.height), x = e3, P = z2.y + z2.height / 2;
          const t4 = z2.x * x + C / 2, a2 = (z2.x + z2.width) * x + C / 2;
          if (t4 < 0) {
            const { paths: e4 } = _2;
            e4[0][0][0] -= t4;
          }
          if (a2 > C) {
            const { paths: e4 } = _2;
            e4[0][2][0] -= a2 - C;
          }
        }
        break;
      case "CIMPolygonSymbol": {
        R = z2.x + z2.width / 2, P = z2.y + z2.height / 2;
        const e3 = z2.x * x + C / 2, t4 = (z2.x + z2.width) * x + C / 2, a2 = z2.y * x + M2 / 2, i2 = (z2.y + z2.height) * x + M2 / 2, { rings: r4 } = _2;
        e3 < 0 && (r4[0][0][0] -= e3, r4[0][3][0] -= e3, r4[0][4][0] -= e3), a2 < 0 && (r4[0][0][1] += a2, r4[0][1][1] += a2, r4[0][4][1] += a2), t4 > C && (r4[0][1][0] -= t4 - C, r4[0][2][0] -= t4 - C), i2 > M2 && (r4[0][2][1] += i2 - M2, r4[0][3][1] += i2 - M2);
      }
    }
    y2.width = C * I2, y2.height = M2 * I2;
    const D = 1;
    y2.width += 2 * D, y2.height += 2 * D;
    const S = y2.getContext("2d"), k = Q.createIdentity();
    k.translate(-R, -P), k.scale(x * I2, -x * I2), k.translate(C * I2 / 2 + D, M2 * I2 / 2 + D), S.clearRect(0, 0, y2.width, y2.height);
    return new et(S, p2, k, true).drawSymbol(d2, _2), S.getImageData(0, 0, y2.width, y2.height);
  }
  async analyzeCIMSymbol3D(e2, t3, a, r3, s2) {
    const n = [], c4 = t3 ? { geometryType: r3, spatialReference: this._spatialReference, fields: t3 } : null, l2 = [];
    ie.fetchFonts(e2.data.symbol, this._cimResourceManager, l2), await Promise.all(l2);
    const h4 = new G(this._cimResourceManager, c4);
    let g;
    await h4.analyzeSymbolReference(e2.data, this._avoidSDF, n), s(s2);
    for (const i of n)
      "CIMPictureMarker" !== i.cim.type && "CIMPictureFill" !== i.cim.type && "CIMPictureStroke" !== i.cim.type || (g || (g = []), g.push(this._fetchPictureMarkerResource(i, s2))), a && "text" === i.type && "string" == typeof i.text && i.text.includes("[") && (i.text = c(a, i.text, i.cim.textCase));
    return g && await Promise.all(g), n;
  }
  rasterizeCIMSymbol3D(e2, t3, a, i, r3, o) {
    const s2 = [];
    for (const n of e2) {
      i && "function" == typeof i.scaleFactor && (i.scaleFactor = i.scaleFactor(t3, r3, o));
      const e3 = this._getRasterizedResource(n, t3, a, i, r3, o);
      if (!e3)
        continue;
      let c4 = 0, l2 = e3.anchorX || 0, h4 = e3.anchorY || 0, m3 = false, g = 0, u4 = 0;
      if ("esriGeometryPoint" === a) {
        const e4 = _(i);
        if (g = t(n.offsetX, t3, r3, o) * e4 || 0, u4 = t(n.offsetY, t3, r3, o) * e4 || 0, "marker" === n.type)
          c4 = t(n.rotation, t3, r3, o) || 0, m3 = n.rotateClockwise ?? false;
        else if ("text" === n.type) {
          if (c4 = t(n.angle, t3, r3, o) || 0, void 0 !== n.horizontalAlignment)
            switch (n.horizontalAlignment) {
              case "left":
                l2 = -0.5;
                break;
              case "right":
                l2 = 0.5;
                break;
              default:
                l2 = 0;
            }
          if (void 0 !== n.verticalAlignment)
            switch (n.verticalAlignment) {
              case "top":
                h4 = 0.5;
                break;
              case "bottom":
                h4 = -0.5;
                break;
              case "baseline":
                h4 = -0.25;
                break;
              default:
                h4 = 0;
            }
        }
      }
      null != e3 && s2.push({ angle: c4, rotateClockWise: m3, anchorX: l2, anchorY: h4, offsetX: g, offsetY: u4, rasterizedResource: e3 });
    }
    return this.getSymbolImage(s2);
  }
  getSymbolImage(e2) {
    const t3 = document.createElement("canvas"), i = u(t3.getContext("2d"));
    let o = 0, s2 = 0, n = 0, c4 = 0;
    const l2 = [];
    for (let a = 0; a < e2.length; a++) {
      const t4 = e2[a], h5 = t4.rasterizedResource;
      if (!h5)
        continue;
      const m4 = h5.size, g2 = t4.offsetX, u4 = t4.offsetY, f2 = t4.anchorX, d2 = t4.anchorY, y2 = t4.rotateClockWise || false;
      let p2 = t4.angle, w = u2(g2) - m4[0] * (0.5 + f2), C = u2(u4) - m4[1] * (0.5 + d2), M2 = w + m4[0], _2 = C + m4[1];
      if (p2) {
        y2 && (p2 = -p2);
        const e3 = Math.sin(p2 * Math.PI / 180), t5 = Math.cos(p2 * Math.PI / 180), a2 = w * t5 - C * e3, i2 = w * e3 + C * t5, r3 = w * t5 - _2 * e3, o2 = w * e3 + _2 * t5, s3 = M2 * t5 - _2 * e3, n2 = M2 * e3 + _2 * t5, c5 = M2 * t5 - C * e3, l3 = M2 * e3 + C * t5;
        w = Math.min(a2, r3, s3, c5), C = Math.min(i2, o2, n2, l3), M2 = Math.max(a2, r3, s3, c5), _2 = Math.max(i2, o2, n2, l3);
      }
      o = w < o ? w : o, s2 = C < s2 ? C : s2, n = M2 > n ? M2 : n, c4 = _2 > c4 ? _2 : c4;
      const b2 = i.createImageData(h5.size[0], h5.size[1]);
      b2.data.set(new Uint8ClampedArray(h5.image.buffer));
      const z2 = { offsetX: g2, offsetY: u4, rotateClockwise: y2, angle: p2, rasterizedImage: b2, anchorX: f2, anchorY: d2 };
      l2.push(z2);
    }
    t3.width = n - o, t3.height = c4 - s2;
    const h4 = -o, m3 = c4;
    for (let a = 0; a < l2.length; a++) {
      const e3 = l2[a], t4 = this._imageDataToCanvas(e3.rasterizedImage), o2 = e3.rasterizedImage.width, s3 = e3.rasterizedImage.height, n2 = h4 - o2 * (0.5 + e3.anchorX), c5 = m3 - s3 * (0.5 - e3.anchorY);
      if (e3.angle) {
        const a2 = (360 - e3.angle) * Math.PI / 180;
        i.save(), i.translate(u2(e3.offsetX), -u2(e3.offsetY)), i.translate(h4, m3), i.rotate(a2), i.translate(-h4, -m3), i.drawImage(t4, n2, c5), i.restore();
      } else
        i.drawImage(t4, n2 + u2(e3.offsetX), c5 - u2(e3.offsetY));
    }
    const g = new p({ x: h4 / t3.width - 0.5, y: m3 / t3.height - 0.5 });
    return { imageData: 0 !== t3.width && 0 !== t3.height ? i.getImageData(0, 0, t3.width, t3.height) : i.createImageData(1, 1), anchorPosition: g };
  }
  async _fetchPictureMarkerResource(e2, a) {
    const i = e2.materialHash;
    if (!this._pictureMarkerCache.get(i)) {
      const r3 = (await j(e2.cim.url, { responseType: "image", signal: a && a.signal })).data;
      this._pictureMarkerCache.set(i, r3);
    }
  }
  _imageDataToCanvas(e2) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const t3 = this._imageDataCanvas, i = u(t3.getContext("2d"));
    return t3.width = e2.width, t3.height = e2.height, i.putImageData(e2, 0, 0), t3;
  }
  _imageTo32Array(t3, i, r3, o) {
    this._imageDataCanvas || (this._imageDataCanvas = document.createElement("canvas"));
    const s2 = this._imageDataCanvas, n = u(s2.getContext("2d"));
    if (s2.width = i, s2.height = r3, n.drawImage(t3, 0, 0, i, r3), o) {
      n.save();
      const a = new h(o);
      n.fillStyle = a.toHex(), n.globalCompositeOperation = "multiply", n.fillRect(0, 0, i, r3), n.globalCompositeOperation = "destination-atop", n.drawImage(t3, 0, 0, i, r3), n.restore();
    }
    return new Uint32Array(n.getImageData(0, 0, i, r3).data.buffer);
  }
  _getRasterizedResource(e2, t3, i, r3, o, s2) {
    let n, c4, l2;
    const h4 = null, m3 = null;
    if ("text" === e2.type)
      return this._rasterizeTextResource(e2, t3, r3, o, s2);
    ({ analyzedCIM: n, hash: c4 } = I(e2, t3, o, s2));
    const g = _(r3);
    if ("CIMPictureMarker" === e2.cim.type) {
      const i2 = t(e2.size, t3, o, s2) * g, { image: r4, width: n2, height: c5 } = u(this._getPictureResource(e2, i2, t(e2.color, t3, o, s2)));
      return l2 = { image: r4, size: [n2, c5], sdf: false, simplePattern: false, anchorX: e2.anchorPoint ? e2.anchorPoint.x : 0, anchorY: e2.anchorPoint ? e2.anchorPoint.y : 0 }, l2;
    }
    m(n, g, { preserveOutlineWidth: false });
    const u4 = n;
    c4 += i, r3 && (c4 += JSON.stringify(r3));
    const f2 = this._resourceCache;
    return f2.has(c4) ? f2.get(c4) : (l2 = this._rasterizer.rasterizeJSONResource({ cim: u4, type: e2.type, url: e2.url, mosaicHash: c4, size: h4, path: m3 }, window.devicePixelRatio || 1, this._avoidSDF), f2.set(c4, l2), l2);
  }
  _rasterizeTextResource(e2, t3, a, i, r3) {
    var _a, _b, _c;
    const o = _(a), s2 = t(e2.text, t3, i, r3);
    if (!s2 || 0 === s2.length)
      return null;
    const n = e2.cim, c4 = t((n == null ? void 0 : n.fontFamilyName) || e2.fontName, t3, i, r3), l2 = t(((_a = n == null ? void 0 : n.font) == null ? void 0 : _a.style) || e2.style, t3, i, r3), h4 = t(((_b = n == null ? void 0 : n.font) == null ? void 0 : _b.weight) || e2.weight, t3, i, r3), m3 = t(((_c = n == null ? void 0 : n.font) == null ? void 0 : _c.decoration) || e2.decoration, t3, i, r3), g = t(e2.size, t3, i, r3) * o, u4 = t(e2.horizontalAlignment, t3, i, r3), f2 = t(e2.verticalAlignment, t3, i, r3), d2 = r2(t(e2.color, t3, i, r3)), w = r2(t(e2.outlineColor, t3, i, r3)), C = t(e2.outlineSize, t3, i, r3), M2 = null != e2.backgroundColor ? r2(e2.backgroundColor) : null, b2 = null != e2.borderLineColor ? r2(e2.borderLineColor) : null, z2 = null != e2.borderLineWidth ? e2.borderLineWidth : null, v2 = { color: d2, size: g, horizontalAlignment: u4, verticalAlignment: f2, font: { family: c4, style: l2, weight: h4, decoration: m3 }, halo: { size: C || 0, color: w, style: l2 }, backgroundColor: M2, borderLine: null != b2 && null != z2 ? { color: b2, size: z2 } : null, pixelRatio: 1, premultiplyColors: !this._avoidSDF };
    return this._textRasterizer.rasterizeText(s2, v2);
  }
  _getPictureResource(e2, t3, a) {
    const i = this._pictureMarkerCache.get(e2.materialHash);
    if (!i)
      return null;
    const o = i.height / i.width, s2 = t3 ? o > 1 ? u2(t3) : u2(t3) / o : i.width, n = t3 ? o > 1 ? u2(t3) * o : u2(t3) : i.height;
    return { image: this._imageTo32Array(i, s2, n, a), width: s2, height: n };
  }
};
function v(e2, t3, a, i) {
  const r3 = 1, o = -t3 / 2 + r3, s2 = t3 / 2 - r3, n = a / 2 - r3, c4 = -a / 2 + r3;
  switch (e2) {
    case "esriGeometryPoint":
      return { x: 0, y: 0 };
    case "esriGeometryPolyline":
      return { paths: [[[o, 0], [0, 0], [s2, 0]]] };
    default:
      return "legend" === i ? { rings: [[[o, n], [s2, 0], [s2, c4], [o, c4], [o, n]]] } : { rings: [[[o, n], [s2, n], [s2, c4], [o, c4], [o, n]]] };
  }
}
function I(e2, t3, a, i) {
  let r3, o;
  if ("function" == typeof e2.materialHash) {
    r3 = (0, e2.materialHash)(t3, a, i), o = V(e2.cim, e2.materialOverrides);
  } else
    r3 = e2.materialHash, o = e2.cim;
  return { analyzedCIM: o, hash: r3 };
}

// node_modules/@arcgis/core/symbols/support/previewCIMSymbol.js
var c3 = new z(null, true);
var h3 = e(t2.size);
var m2 = e(t2.maxSize);
var u3 = e(t2.lineWidth);
var f = 1;
function y(e2) {
  const t3 = e2 == null ? void 0 : e2.size;
  if ("number" == typeof t3)
    return { width: t3, height: t3 };
  return { width: null != t3 && "object" == typeof t3 && "width" in t3 ? t3.width : null, height: null != t3 && "object" == typeof t3 && "height" in t3 ? t3.height : null };
}
async function d(e2, r3 = {}) {
  var _a;
  const { node: a, opacity: d2, symbolConfig: g } = r3, p2 = null != g && "object" == typeof g && "isSquareFill" in g && g.isSquareFill, w = r3.cimOptions || r3, b2 = w.geometryType || O((_a = e2 == null ? void 0 : e2.data) == null ? void 0 : _a.symbol), M2 = y(r3), { feature: j2, fieldMap: v2 } = w;
  if (null == M2.width || null == M2.height) {
    const t3 = await ne.resolveSymbolOverrides(e2.data, j2, null, v2, b2);
    if (!t3)
      return null;
    (e2 = e2.clone()).data = { type: "CIMSymbolReference", symbol: t3 }, e2.data.primitiveOverrides = void 0;
    const r4 = [];
    ie.fetchResources(t3, c3.resourceManager, r4), ie.fetchFonts(t3, c3.resourceManager, r4), r4.length > 0 && await Promise.all(r4);
    const n = ie.getEnvelope(t3, null, c3.resourceManager), o = n == null ? void 0 : n.width, a2 = n == null ? void 0 : n.height;
    M2.width = "esriGeometryPolygon" === b2 ? h3 : "esriGeometryPolyline" === b2 ? u3 : null != o && isFinite(o) ? Math.min(o, m2) : h3, M2.height = "esriGeometryPolygon" === b2 ? h3 : null != a2 && isFinite(a2) ? Math.max(Math.min(a2, m2), f) : h3;
  }
  const S = await c3.rasterizeCIMSymbolAsync(e2, j2, M2, p2 || "esriGeometryPolygon" !== b2 ? M.Preview : M.Legend, v2, b2);
  if (!S)
    return null;
  const { width: C, height: L } = S, I2 = document.createElement("canvas");
  I2.width = C, I2.height = L;
  I2.getContext("2d").putImageData(S, 0, 0);
  const P = u2(M2.width), x = u2(M2.height), z2 = new Image(P, x);
  z2.src = I2.toDataURL(), z2.ariaLabel = r3.ariaLabel ?? null, z2.alt = r3.ariaLabel ?? "", null != d2 && (z2.style.opacity = `${d2}`);
  let F = z2;
  if (null != r3.effectView) {
    const e3 = { shape: { type: "image", x: 0, y: 0, width: P, height: x, src: z2.src }, fill: null, stroke: null, offset: [0, 0] };
    F = l([[e3]], [P, x], { effectView: r3.effectView, ariaLabel: r3.ariaLabel });
  }
  return a && F && a.appendChild(F), F;
}
export {
  d as previewCIMSymbol
};
//# sourceMappingURL=previewCIMSymbol-QJYJNDPU.js.map
