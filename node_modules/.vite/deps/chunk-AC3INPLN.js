import {
  T
} from "./chunk-C3ULZZZU.js";
import {
  t as t2
} from "./chunk-D5EV57FM.js";
import {
  st
} from "./chunk-KKGVORR5.js";
import {
  t
} from "./chunk-M5UHI5WR.js";
import {
  c
} from "./chunk-YAWND7HF.js";
import {
  p
} from "./chunk-T4XWQYGC.js";
import {
  u
} from "./chunk-DWOEYHKS.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t3 = class _t {
  static fromBuffer(e, s) {
    return new _t(e, s);
  }
  static create(e, s = 4294967295) {
    const r = new Uint32Array(Math.ceil(e / 32));
    return new _t(r, s);
  }
  constructor(t4, e) {
    this._mask = 0, this._buf = t4, this._mask = e;
  }
  _getIndex(t4) {
    return Math.floor(t4 / 32);
  }
  has(t4) {
    const e = this._mask & t4;
    return !!(this._buf[this._getIndex(e)] & 1 << e % 32);
  }
  hasRange(t4, e) {
    let s = t4, r = e;
    for (; s % 32 && s !== r; ) {
      if (this.has(s))
        return true;
      s++;
    }
    for (; r % 32 && s !== r; ) {
      if (this.has(s))
        return true;
      r--;
    }
    if (s === r)
      return false;
    for (let h2 = s / 32; h2 !== r / 32; h2++) {
      if (this._buf[h2])
        return true;
    }
    return false;
  }
  set(t4) {
    const e = this._mask & t4, s = this._getIndex(e), r = 1 << e % 32;
    this._buf[s] |= r;
  }
  setRange(t4, e) {
    let s = t4, r = e;
    for (; s % 32 && s !== r; )
      this.set(s++);
    for (; r % 32 && s !== r; )
      this.set(r--);
    if (s !== r)
      for (let h2 = s / 32; h2 !== r / 32; h2++)
        this._buf[h2] = 4294967295;
  }
  unset(t4) {
    const e = this._mask & t4, s = this._getIndex(e), r = 1 << e % 32;
    this._buf[s] &= 4294967295 ^ r;
  }
  resize(t4) {
    const e = this._buf, s = new Uint32Array(Math.ceil(t4 / 32));
    s.set(e), this._buf = s;
  }
  or(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] |= t4._buf[e];
    return this;
  }
  and(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] &= t4._buf[e];
    return this;
  }
  xor(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] ^= t4._buf[e];
    return this;
  }
  ior(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] |= ~t4._buf[e];
    return this;
  }
  iand(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] &= ~t4._buf[e];
    return this;
  }
  ixor(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] ^= ~t4._buf[e];
    return this;
  }
  any() {
    for (let t4 = 0; t4 < this._buf.length; t4++)
      if (this._buf[t4])
        return true;
    return false;
  }
  copy(t4) {
    for (let e = 0; e < this._buf.length; e++)
      this._buf[e] = t4._buf[e];
    return this;
  }
  clone() {
    return new _t(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t4 = 0; t4 < this._buf.length; t4++)
      this._buf[t4] = 0;
  }
  forEachSet(t4) {
    for (let e = 0; e < this._buf.length; e++) {
      let s = this._buf[e], r = 32 * e;
      if (s)
        for (; s; ) {
          1 & s && t4(r), s >>>= 1, r++;
        }
    }
  }
  countSet() {
    let t4 = 0;
    return this.forEachSet((e) => {
      t4++;
    }), t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var d = 0;
var h = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var u2 = h[0];
var l = h[1];
var c2 = h[2];
var m = h[3];
var f = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var g = f[0];
var y = f[1];
var _ = f[2];
var p2 = has("featurelayer-simplify-mobile-factor") ?? 2;
var x = has("esri-mobile");
var I = class {
  constructor(e, t4) {
    this.type = "FeatureSetReader", this.arcadeDeclaredClass = "esri.arcade.Feature", this.seen = false, this.instance = 0, this._tx = 0, this._ty = 0, this._sx = 1, this._sy = 1, this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._level = 0, this._datetimeMetadata = null, this.contextTimeReference = null, this.instance = e, this._layerSchema = t4;
  }
  static createInstance() {
    return d++, d = d > 65535 ? 0 : d, d;
  }
  get isEmpty() {
    return null != this._deleted && this._deleted.countSet() === this.getSize();
  }
  set level(e) {
    this._level = e;
  }
  getAreaSimplificationThreshold(e, t4) {
    let r = 1;
    const s = x ? p2 : 1;
    t4 > 4e6 ? r = _ * s : t4 > 1e6 ? r = y * s : t4 > 5e5 ? r = g * s : t4 > 1e5 && (r = s);
    let i = 0;
    e > 4e3 ? i = m * r : e > 2e3 ? i = c2 * r : e > 100 ? i = l : e > 15 && (i = u2);
    let n = 8;
    return this._level < 4 ? n = 1 : this._level < 5 ? n = 2 : this._level < 6 && (n = 4), i * n;
  }
  createQuantizedExtrudedQuad(e, t4) {
    return new t([5], [e - 1, t4, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  parseTimestampOffset(e) {
    return e;
  }
  setArcadeSpatialReference(e) {
    this._arcadeSpatialReference = e;
  }
  attachStorage(e) {
    this._storage = e;
  }
  getQuantizationTransform() {
    throw new Error("Unable to find transform for featureSet");
  }
  getStorage() {
    return this._storage;
  }
  getComputedNumeric(e) {
    return this.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e, t4) {
    return this.setComputedNumericAtIndex(t4, 0);
  }
  getComputedString(e) {
    return this.getComputedStringAtIndex(0);
  }
  setComputedString(e, t4) {
    return this.setComputedStringAtIndex(0, t4);
  }
  getComputedNumericAtIndex(e) {
    return this._storage.getComputedNumericAtIndex(this.getDisplayId(), e);
  }
  setComputedNumericAtIndex(e, t4) {
    this._storage.setComputedNumericAtIndex(this.getDisplayId(), e, t4);
  }
  getComputedStringAtIndex(e) {
    return this._storage.getComputedStringAtIndex(this.getDisplayId(), e);
  }
  setComputedStringAtIndex(e, t4) {
    return this._storage.setComputedStringAtIndex(this.getDisplayId(), e, t4);
  }
  transform(e, t4, r, s) {
    const i = this.copy();
    return i._tx += e, i._ty += t4, i._sx *= r, i._sy *= s, i;
  }
  readAttribute(e, t4 = false) {
    const r = this._readAttribute(e, t4);
    if (void 0 !== r)
      return r;
    for (const s of this._joined) {
      s.setIndex(this.getIndex());
      const r2 = s._readAttribute(e, t4);
      if (void 0 !== r2)
        return r2;
    }
  }
  readAttributes() {
    const e = this._readAttributes();
    for (const t4 of this._joined) {
      t4.setIndex(this.getIndex());
      const r = t4._readAttributes();
      for (const t5 of Object.keys(r))
        e[t5] = r[t5];
    }
    return e;
  }
  joinAttributes(e) {
    this._joined.push(e);
  }
  readArcadeFeature() {
    return this;
  }
  hasField(e) {
    return this.fields.has(e);
  }
  geometry() {
    const e = this.readHydratedGeometry(), t4 = st(e, this.geometryType, this.hasZ, this.hasM), r = p(t4);
    return r && (r.spatialReference = this._arcadeSpatialReference), r;
  }
  get dateTimeReferenceFieldIndex() {
    return this._datetimeMetadata || (this._datetimeMetadata = T.create(this._layerSchema.fields, this._layerSchema)), this._datetimeMetadata;
  }
  autocastArcadeDate(t4, r) {
    var _a;
    return r && r instanceof Date ? this.isUnknownDateTimeField(t4) ? c.unknownDateJSToArcadeDate(r) : c.dateJSAndZoneToArcadeDate(r, ((_a = this.contextTimeReference) == null ? void 0 : _a.timeZone) ?? "system") : r;
  }
  isUnknownDateTimeField(e) {
    var _a;
    return "unknown" === ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e));
  }
  fieldSourceTimeZone(e) {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.fieldTimeZone(e)) ?? "";
  }
  get layerPreferredTimeZone() {
    var _a;
    return ((_a = this.dateTimeReferenceFieldIndex) == null ? void 0 : _a.layerPreferredTimeZone) ?? "";
  }
  field(e) {
    if (this.hasField(e))
      return this.autocastArcadeDate(e, this.readAttribute(e, true));
    for (const t4 of this._joined)
      if (t4.setIndex(this.getIndex()), t4.hasField(e)) {
        const r = t4._readAttribute(e, true);
        return this.autocastArcadeDate(e, r);
      }
    throw new Error(`Field ${e} does not exist`);
  }
  setField(e, t4) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.fields.fields.map((e) => e.name);
  }
  castToText(e = false) {
    if (!e)
      return JSON.stringify(this.readLegacyFeature());
    const t4 = this.readLegacyFeature();
    if (!t4)
      return JSON.stringify(null);
    const r = { geometry: t4.geometry, attributes: { ...t4.attributes ?? {} } };
    for (const s in r.attributes) {
      const e2 = r.attributes[s];
      e2 instanceof Date && (r.attributes[s] = e2.getTime());
    }
    return JSON.stringify(r);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this._layerSchema;
  }
  castAsJson(e = null) {
    var _a;
    return { attributes: this._readAttributes(), geometry: true === (e == null ? void 0 : e.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
  }
  castAsJsonAsync(e = null, t4 = null) {
    return Promise.resolve(this.castAsJson(t4));
  }
  removeIds(e) {
    if (null == this._objectIdToIndex) {
      const e2 = /* @__PURE__ */ new Map(), t5 = this.getCursor();
      for (; t5.next(); ) {
        const s = u(t5.getObjectId());
        e2.set(s, t5.getIndex());
      }
      this._objectIdToIndex = e2;
    }
    const t4 = this._objectIdToIndex;
    for (const r of e)
      t4.has(r) && this.removeAtIndex(t4.get(r));
  }
  removeAtIndex(e) {
    null == this._deleted && (this._deleted = t3.create(this.getSize())), this._deleted.set(e);
  }
  readGeometryForDisplay() {
    return this.readUnquantizedGeometry(true);
  }
  readLegacyGeometryForDisplay() {
    return this.readLegacyGeometry(true);
  }
  *features() {
    const e = this.getCursor();
    for (; e.next(); )
      yield e.readOptimizedFeature();
  }
  _getExists() {
    return null == this._deleted || !this._deleted.has(this.getIndex());
  }
  _computeCentroid() {
    if ("esriGeometryPolygon" !== this.geometryType)
      return null;
    const e = this.readUnquantizedGeometry();
    if (!e || e.hasIndeterminateRingOrder)
      return null;
    const t4 = this.getQuantizationTransform() ?? null;
    return t2(new t(), e, this.hasM, this.hasZ, t4);
  }
  copyInto(e) {
    e.seen = this.seen, e._storage = this._storage, e._arcadeSpatialReference = this._arcadeSpatialReference, e._joined = this._joined, e._tx = this._tx, e._ty = this._ty, e._sx = this._sx, e._sy = this._sy, e._deleted = this._deleted, e._objectIdToIndex = this._objectIdToIndex;
  }
};

export {
  t3 as t,
  I
};
//# sourceMappingURL=chunk-AC3INPLN.js.map
