import {
  n,
  t
} from "./chunk-MIHFHM6P.js";
import {
  c,
  d,
  h,
  u,
  y
} from "./chunk-TG63P74N.js";
import {
  a,
  i as i2,
  o
} from "./chunk-P34MS5MD.js";
import "./chunk-FHYNSVC4.js";
import {
  m
} from "./chunk-M72PBKGH.js";
import "./chunk-APDPMAO5.js";
import {
  ee
} from "./chunk-R6YQG4NY.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-BKDPNGLX.js";
import {
  f,
  g
} from "./chunk-D5EV57FM.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-YBMFRTPB.js";
import {
  et,
  nt,
  tt
} from "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-Z36PKTLY.js";
import "./chunk-S2P7FTAG.js";
import {
  i
} from "./chunk-WZAASLQW.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-PRUCXFZ4.js";
import "./chunk-KLV5OJVG.js";
import "./chunk-TQGXXOXA.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-ITRH3PGV.js";
import "./chunk-BRDC7DKL.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import {
  B
} from "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import {
  l,
  v
} from "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-3GSONYPC.js";
import {
  p
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var x = p;
var T = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: p };
var R = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
function q(e) {
  return l(e) ? null != e.z : !!e.hasZ;
}
function w(e) {
  return l(e) ? null != e.m : !!e.hasM;
}
var D = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    this._queryEngine && this._queryEngine && this._queryEngine.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(t2) {
    const i3 = [], { features: s2 } = t2, n2 = this._inferLayerProperties(s2, t2.fields), r2 = t2.fields || [], a2 = null != t2.hasM ? t2.hasM : !!n2.hasM, p2 = null != t2.hasZ ? t2.hasZ : !!n2.hasZ, h2 = !t2.spatialReference && !n2.spatialReference, g2 = h2 ? x : t2.spatialReference || n2.spatialReference, I = h2 ? T : null, b = t2.geometryType || n2.geometryType, F = !b;
    let q2 = t2.objectIdField || n2.objectIdField, w2 = t2.timeInfo;
    if (!F && (h2 && i3.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !b))
      throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!q2)
      throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (n2.objectIdField && q2 !== n2.objectIdField && (i3.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${q2}" doesn't match the field name "${n2.objectIdField}", found in the provided fields` }), q2 = n2.objectIdField), q2 && !n2.objectIdField) {
      let e = null;
      r2.some((t3) => t3.name === q2 && (e = t3, true)) ? (e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : r2.unshift({ alias: q2, name: q2, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const l2 of r2) {
      if (null == l2.name && (l2.name = l2.alias), null == l2.alias && (l2.alias = l2.name), !l2.name)
        throw new s("feature-layer:invalid-field-name", "field name is missing", { field: l2 });
      if (l2.name === q2 && (l2.type = "esriFieldTypeOID"), !i.jsonValues.includes(l2.type))
        throw new s("feature-layer:invalid-field-type", `invalid type for field "${l2.name}"`, { field: l2 });
    }
    const D2 = {};
    for (const e of r2)
      if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
        const t3 = B(e);
        void 0 !== t3 && (D2[e.name] = t3);
      }
    if (this._fieldsIndex = new r(r2), this._createDefaultAttributes = i2(D2, q2), w2) {
      if (w2.startTimeField) {
        const e = this._fieldsIndex.get(w2.startTimeField);
        e ? (w2.startTimeField = e.name, e.type = "esriFieldTypeDate") : w2.startTimeField = null;
      }
      if (w2.endTimeField) {
        const e = this._fieldsIndex.get(w2.endTimeField);
        e ? (w2.endTimeField = e.name, e.type = "esriFieldTypeDate") : w2.endTimeField = null;
      }
      if (w2.trackIdField) {
        const e = this._fieldsIndex.get(w2.trackIdField);
        e ? w2.trackIdField = e.name : (w2.trackIdField = null, i3.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: w2 } }));
      }
      w2.startTimeField || w2.endTimeField || (i3.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: w2 } }), w2 = null);
    }
    const O = { warnings: i3, featureErrors: [], layerDefinition: { ...R, drawingInfo: o(b), templates: a(D2), extent: I, geometryType: b, objectIdField: q2, fields: r2, hasZ: p2, hasM: a2, timeInfo: w2 }, assignedObjectIds: {} };
    if (this._queryEngine = new ee({ fields: r2, geometryType: b, hasM: a2, hasZ: p2, objectIdField: q2, spatialReference: g2, featureStore: new m({ geometryType: b, hasM: a2, hasZ: p2 }), timeInfo: w2, cacheSpatialQueries: true }), !s2 || !s2.length)
      return this._nextObjectId = t, O;
    const S = n(q2, s2);
    return this._nextObjectId = S + 1, await f(s2, g2), this._loadInitialFeatures(O, s2);
  }
  async applyEdits(e) {
    const { spatialReference: t2, geometryType: i3 } = this._queryEngine;
    return await Promise.all([y(t2, i3), f(e.adds, t2), f(e.updates, t2)]), this._applyEdits(e);
  }
  queryFeatures(e, t2 = {}) {
    return this._queryEngine.executeQuery(e, t2.signal);
  }
  queryFeatureCount(e, t2 = {}) {
    return this._queryEngine.executeQueryForCount(e, t2.signal);
  }
  queryObjectIds(e, t2 = {}) {
    return this._queryEngine.executeQueryForIds(e, t2.signal);
  }
  queryExtent(e, t2 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t2.signal);
  }
  querySnapping(e, t2 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t2.signal);
  }
  _inferLayerProperties(e, i3) {
    let s2, n2, r2 = null, a2 = null, l2 = null;
    for (const o2 of e) {
      const e2 = o2.geometry;
      if (null != e2 && (r2 || (r2 = v(e2)), a2 || (a2 = e2.spatialReference), null == s2 && (s2 = q(e2)), null == n2 && (n2 = w(e2)), r2 && a2 && null != s2 && null != n2))
        break;
    }
    if (i3 && i3.length) {
      let e2 = null;
      i3.some((t2) => {
        const i4 = "esriFieldTypeOID" === t2.type, s3 = !t2.type && t2.name && "objectid" === t2.name.toLowerCase();
        return e2 = t2, i4 || s3;
      }) && (l2 = e2.name);
    }
    return { geometryType: r2, spatialReference: a2, objectIdField: l2, hasM: n2, hasZ: s2 };
  }
  async _loadInitialFeatures(e, i3) {
    const { geometryType: s2, hasM: r2, hasZ: a2, objectIdField: l2, spatialReference: o2, featureStore: u2 } = this._queryEngine, d2 = [];
    for (const n2 of i3) {
      if (null != n2.uid && (e.assignedObjectIds[n2.uid] = -1), n2.geometry && s2 !== v(n2.geometry)) {
        e.featureErrors.push(u("Incorrect geometry type."));
        continue;
      }
      const i4 = this._createDefaultAttributes(), r3 = d(this._fieldsIndex, i4, n2.attributes, true, e.warnings);
      r3 ? e.featureErrors.push(r3) : (this._assignObjectId(i4, n2.attributes, true), n2.attributes = i4, null != n2.uid && (e.assignedObjectIds[n2.uid] = n2.attributes[l2]), null != n2.geometry && (n2.geometry = g(n2.geometry, n2.geometry.spatialReference, o2)), d2.push(n2));
    }
    u2.addMany(et([], d2, s2, a2, r2, l2));
    const { fullExtent: f2, timeExtent: c2 } = await this._queryEngine.fetchRecomputedExtents();
    if (e.layerDefinition.extent = f2, c2) {
      const { start: t2, end: i4 } = c2;
      e.layerDefinition.timeInfo.timeExtent = [t2, i4];
    }
    return e;
  }
  async _applyEdits(e) {
    const { adds: t2, updates: i3, deletes: s2 } = e, n2 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t2 && t2.length && this._applyAddEdits(n2, t2), i3 && i3.length && this._applyUpdateEdits(n2, i3), s2 && s2.length) {
      for (const e2 of s2)
        n2.deleteResults.push(c(e2));
      this._queryEngine.featureStore.removeManyById(s2);
    }
    const { fullExtent: r2, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: r2, timeExtent: a2, featureEditResults: n2 };
  }
  _applyAddEdits(e, i3) {
    const { addResults: s2 } = e, { geometryType: r2, hasM: a2, hasZ: l2, objectIdField: o2, spatialReference: u2, featureStore: d2 } = this._queryEngine, f2 = [];
    for (const n2 of i3) {
      if (n2.geometry && r2 !== v(n2.geometry)) {
        s2.push(u("Incorrect geometry type."));
        continue;
      }
      const i4 = this._createDefaultAttributes(), a3 = d(this._fieldsIndex, i4, n2.attributes);
      if (a3)
        s2.push(a3);
      else {
        if (this._assignObjectId(i4, n2.attributes), n2.attributes = i4, null != n2.uid) {
          const t2 = n2.attributes[o2];
          e.uidToObjectId[n2.uid] = t2;
        }
        if (null != n2.geometry) {
          const e2 = n2.geometry.spatialReference ?? u2;
          n2.geometry = g(h(n2.geometry, e2), e2, u2);
        }
        f2.push(n2), s2.push(c(n2.attributes[o2]));
      }
    }
    d2.addMany(et([], f2, r2, l2, a2, o2));
  }
  _applyUpdateEdits({ updateResults: e }, i3) {
    const { geometryType: s2, hasM: n2, hasZ: l2, objectIdField: o2, spatialReference: u2, featureStore: d2 } = this._queryEngine;
    for (const f2 of i3) {
      const { attributes: i4, geometry: c2 } = f2, y2 = i4 && i4[o2];
      if (null == y2) {
        e.push(u(`Identifier field ${o2} missing`));
        continue;
      }
      if (!d2.has(y2)) {
        e.push(u(`Feature with object id ${y2} missing`));
        continue;
      }
      const m2 = nt(d2.getFeature(y2), s2, l2, n2);
      if (null != c2) {
        if (s2 !== v(c2)) {
          e.push(u("Incorrect geometry type."));
          continue;
        }
        const i5 = c2.spatialReference ?? u2;
        m2.geometry = g(h(c2, i5), i5, u2);
      }
      if (i4) {
        const t2 = d(this._fieldsIndex, m2.attributes, i4);
        if (t2) {
          e.push(t2);
          continue;
        }
      }
      d2.add(tt(m2, s2, l2, n2, o2)), e.push(c(y2));
    }
  }
  _assignObjectId(e, t2, i3 = false) {
    const s2 = this._queryEngine.objectIdField;
    i3 && t2 && isFinite(t2[s2]) ? e[s2] = t2[s2] : e[s2] = this._nextObjectId++;
  }
};
export {
  D as default
};
//# sourceMappingURL=MemorySourceWorker-JSF74MMG.js.map
