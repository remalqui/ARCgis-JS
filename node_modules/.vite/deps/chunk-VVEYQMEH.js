import {
  T,
  e2 as e
} from "./chunk-NE5U5H4D.js";
import {
  D,
  G,
  L,
  P,
  U,
  c
} from "./chunk-BCDDCNQ2.js";
import {
  n
} from "./chunk-OMDLZQUU.js";
import {
  f
} from "./chunk-VZAEQ6CY.js";

// node_modules/@arcgis/core/views/webgl/rasterUtils.js
function c2(e2, s, c3 = "nearest", m2 = false) {
  var _a;
  const l2 = !(m2 && "u8" === s.pixelType), _2 = l2 ? U.FLOAT : U.UNSIGNED_BYTE, p2 = null == s.pixels || 0 === s.pixels.length ? null : l2 ? s.getAsRGBAFloat() : s.getAsRGBA(), g2 = (_a = e2.capabilities.textureFloat) == null ? void 0 : _a.textureFloatLinear, A2 = new e();
  return A2.width = s.width, A2.height = s.height, A2.internalFormat = e2.type === n.WEBGL2 && l2 ? P.RGBA32F : G.RGBA, A2.samplingMode = !g2 || "bilinear" !== c3 && "cubic" !== c3 ? L.NEAREST : L.LINEAR, A2.dataType = _2, A2.wrapMode = D.CLAMP_TO_EDGE, new T(e2, A2, p2);
}
function m(e2, s) {
  const { spacing: c3, offsets: m2, coefficients: l2, size: [_2, p2] } = s, g2 = c3[0] > 1, A2 = new e();
  A2.width = g2 ? 4 * _2 : _2, A2.height = p2, A2.internalFormat = e2.type === n.WEBGL2 ? P.RGBA32F : G.RGBA, A2.dataType = U.FLOAT, A2.samplingMode = L.NEAREST, A2.wrapMode = D.CLAMP_TO_EDGE;
  const T3 = new Float32Array(g2 ? _2 * p2 * 16 : 2 * m2.length);
  if (g2 && null != l2)
    for (let t = 0, n2 = 0; t < l2.length; t++)
      T3[n2++] = l2[t], t % 3 == 2 && (T3[n2++] = 1);
  else
    for (let t = 0; t < p2; t++)
      for (let e3 = 0; e3 < _2; e3++) {
        const n2 = 4 * (t * _2 + e3), r = 2 * (e3 * p2 + t);
        T3[n2] = m2[r], T3[n2 + 1] = m2[r + 1], T3[n2 + 3] = -1 === m2[r] ? 0 : 1;
      }
  return new T(e2, A2, T3);
}
function l(e2, t) {
  const n2 = new e();
  return n2.internalFormat = G.RGBA, n2.width = t.length / 4, n2.height = 1, n2.samplingMode = L.NEAREST, n2.wrapMode = D.CLAMP_TO_EDGE, new T(e2, n2, t);
}
function _(t, n2, r, a = 1, i = true) {
  return { u_flipY: i, u_applyTransform: !!t, u_opacity: a, u_transformSpacing: t ? t.spacing : f, u_transformGridSize: t ? t.size : f, u_targetImageSize: n2, u_srcImageSize: r };
}
function p(e2, t) {
  return { u_colormapOffset: t || 0, u_colormapMaxIndex: e2 ? e2.length / 4 - 1 : 0 };
}
function g(e2, t) {
  return { u_scale: e2, u_offset: t };
}
function A(e2) {
  return { u_bandCount: e2.bandCount, u_minOutput: e2.outMin, u_maxOutput: e2.outMax, u_minCutOff: e2.minCutOff, u_maxCutOff: e2.maxCutOff, u_factor: e2.factor, u_useGamma: e2.useGamma, u_gamma: e2.gamma, u_gammaCorrection: e2.gammaCorrection };
}
function T2(e2) {
  return { u_hillshadeType: e2.hillshadeType, u_sinZcosAs: e2.sinZcosAs, u_sinZsinAs: e2.sinZsinAs, u_cosZs: e2.cosZs, u_weights: e2.weights, u_factor: e2.factor, u_minValue: e2.minValue, u_maxValue: e2.maxValue };
}
function h(e2, t) {
  const n2 = e2.gl, r = t.glName, a = /* @__PURE__ */ new Map();
  if (null == r)
    return a;
  const i = n2.getProgramParameter(r, n2.ACTIVE_UNIFORMS);
  let o;
  for (let s = 0; s < i; s++)
    o = n2.getActiveUniform(r, s), o && a.set(o.name, { location: n2.getUniformLocation(r, o.name), info: o });
  return a;
}
function E(e2, t, n2) {
  Object.keys(n2).forEach((r) => {
    const a = t.get(r) || t.get(r + "[0]");
    a && x(e2, r, n2[r], a);
  });
}
function O(e2, t, n2, r) {
  n2.length === r.length && (r.some((e3) => null == e3) || n2.some((e3) => null == e3) || n2.forEach((n3, a) => {
    t.setUniform1i(n3, a), e2.bindTexture(r[a], a);
  }));
}
function x(e2, t, n2, r) {
  if (null === r || null == n2)
    return false;
  const { info: a } = r;
  switch (a.type) {
    case c.FLOAT:
      a.size > 1 ? e2.setUniform1fv(t, n2) : e2.setUniform1f(t, n2);
      break;
    case c.FLOAT_VEC2:
      e2.setUniform2fv(t, n2);
      break;
    case c.FLOAT_VEC3:
      e2.setUniform3fv(t, n2);
      break;
    case c.FLOAT_VEC4:
      e2.setUniform4fv(t, n2);
      break;
    case c.FLOAT_MAT3:
      e2.setUniformMatrix3fv(t, n2);
      break;
    case c.FLOAT_MAT4:
      e2.setUniformMatrix4fv(t, n2);
      break;
    case c.INT:
      a.size > 1 ? e2.setUniform1iv(t, n2) : e2.setUniform1i(t, n2);
      break;
    case c.BOOL:
      e2.setUniform1i(t, n2 ? 1 : 0);
      break;
    case c.INT_VEC2:
    case c.BOOL_VEC2:
      e2.setUniform2iv(t, n2);
      break;
    case c.INT_VEC3:
    case c.BOOL_VEC3:
      e2.setUniform3iv(t, n2);
      break;
    case c.INT_VEC4:
    case c.BOOL_VEC4:
      e2.setUniform4iv(t, n2);
      break;
    default:
      return false;
  }
  return true;
}

export {
  c2 as c,
  m,
  l,
  _,
  p,
  g,
  A,
  T2 as T,
  h,
  E,
  O
};
//# sourceMappingURL=chunk-VVEYQMEH.js.map
