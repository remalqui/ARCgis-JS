import {
  c
} from "./chunk-HTY52TPQ.js";
import {
  b
} from "./chunk-YC4PIRSZ.js";
import {
  f
} from "./chunk-YBMFRTPB.js";
import {
  It,
  st
} from "./chunk-KKGVORR5.js";
import {
  t
} from "./chunk-QXGO5RRL.js";
import {
  r,
  u
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/rest/query/operations/pbfJSONFeatureSet.js
function i(e, t2) {
  return t2;
}
function n(e, t2, r2, s) {
  switch (r2) {
    case 0:
      return d(e, t2 + s, 0);
    case 1:
      return "lowerLeft" === e.originPosition ? d(e, t2 + s, 1) : l(e, t2 + s, 1);
  }
}
function a(e, t2, r2, s) {
  return 2 === r2 ? d(e, t2, 2) : n(e, t2, r2, s);
}
function h(e, t2, r2, s) {
  return 2 === r2 ? d(e, t2, 3) : n(e, t2, r2, s);
}
function u2(e, t2, r2, s) {
  return 3 === r2 ? d(e, t2, 3) : a(e, t2, r2, s);
}
function d({ translate: e, scale: t2 }, r2, s) {
  return e[s] + r2 * t2[s];
}
function l({ translate: e, scale: t2 }, r2, s) {
  return e[s] - r2 * t2[s];
}
var c2 = class {
  constructor(e) {
    this._options = e, this.geometryTypes = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"], this._previousCoordinate = [0, 0], this._transform = null, this._applyTransform = i, this._lengths = [], this._currentLengthIndex = 0, this._toAddInCurrentPath = 0, this._vertexDimension = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, this._attributesConstructor = class {
    };
  }
  createFeatureResult() {
    return { fields: [], features: [] };
  }
  finishFeatureResult(e) {
    if (this._options.applyTransform && (e.transform = null), this._attributesConstructor = class {
    }, this._coordinateBuffer = null, this._lengths.length = 0, !e.hasZ)
      return;
    const t2 = t(e.geometryType, this._options.sourceSpatialReference, e.spatialReference);
    if (null != t2)
      for (const r2 of e.features)
        t2(r2.geometry);
  }
  createSpatialReference() {
    return {};
  }
  addField(t2, r2) {
    const s = t2.fields;
    r(s), s.push(r2);
    const o = s.map((e) => e.name);
    this._attributesConstructor = function() {
      for (const e of o)
        this[e] = null;
    };
  }
  addFeature(e, t2) {
    e.features.push(t2);
  }
  prepareFeatures(e) {
    switch (this._transform = e.transform, this._options.applyTransform && e.transform && (this._applyTransform = this._deriveApplyTransform(e)), this._vertexDimension = 2, e.hasZ && this._vertexDimension++, e.hasM && this._vertexDimension++, e.geometryType) {
      case "esriGeometryPoint":
        this.addCoordinate = (e2, t2, r2) => this.addCoordinatePoint(e2, t2, r2), this.createGeometry = (e2) => this.createPointGeometry(e2);
        break;
      case "esriGeometryPolygon":
        this.addCoordinate = (e2, t2, r2) => this._addCoordinatePolygon(e2, t2, r2), this.createGeometry = (e2) => this._createPolygonGeometry(e2);
        break;
      case "esriGeometryPolyline":
        this.addCoordinate = (e2, t2, r2) => this._addCoordinatePolyline(e2, t2, r2), this.createGeometry = (e2) => this._createPolylineGeometry(e2);
        break;
      case "esriGeometryMultipoint":
        this.addCoordinate = (e2, t2, r2) => this._addCoordinateMultipoint(e2, t2, r2), this.createGeometry = (e2) => this._createMultipointGeometry(e2);
    }
  }
  createFeature() {
    return this._lengths.length = 0, this._currentLengthIndex = 0, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, { attributes: new this._attributesConstructor() };
  }
  allocateCoordinates() {
  }
  addLength(e, t2, r2) {
    0 === this._lengths.length && (this._toAddInCurrentPath = t2), this._lengths.push(t2);
  }
  addQueryGeometry(e, t2) {
    const { queryGeometry: r2, queryGeometryType: i2 } = t2, n3 = It(r2.clone(), r2, false, false, this._transform), a2 = st(n3, i2, false, false);
    e.queryGeometryType = i2, e.queryGeometry = { ...a2 };
  }
  createPointGeometry(e) {
    const t2 = { x: 0, y: 0, spatialReference: e.spatialReference };
    return e.hasZ && (t2.z = 0), e.hasM && (t2.m = 0), t2;
  }
  addCoordinatePoint(e, r2, s) {
    const o = u(this._transform, "transform");
    switch (r2 = this._applyTransform(o, r2, s, 0), s) {
      case 0:
        e.x = r2;
        break;
      case 1:
        e.y = r2;
        break;
      case 2:
        "z" in e ? e.z = r2 : e.m = r2;
        break;
      case 3:
        e.m = r2;
    }
  }
  _transformPathLikeValue(e, r2) {
    let s = 0;
    r2 <= 1 && (s = this._previousCoordinate[r2], this._previousCoordinate[r2] += e);
    const o = u(this._transform, "transform");
    return this._applyTransform(o, e, r2, s);
  }
  _addCoordinatePolyline(e, t2, r2) {
    this._dehydratedAddPointsCoordinate(e.paths, t2, r2);
  }
  _addCoordinatePolygon(e, t2, r2) {
    this._dehydratedAddPointsCoordinate(e.rings, t2, r2);
  }
  _addCoordinateMultipoint(e, t2, r2) {
    0 === r2 && e.points.push([]);
    const s = this._transformPathLikeValue(t2, r2);
    e.points[e.points.length - 1].push(s);
  }
  _createPolygonGeometry(e) {
    return { rings: [[]], spatialReference: e.spatialReference, hasZ: !!e.hasZ, hasM: !!e.hasM };
  }
  _createPolylineGeometry(e) {
    return { paths: [[]], spatialReference: e.spatialReference, hasZ: !!e.hasZ, hasM: !!e.hasM };
  }
  _createMultipointGeometry(e) {
    return { points: [], spatialReference: e.spatialReference, hasZ: !!e.hasZ, hasM: !!e.hasM };
  }
  _dehydratedAddPointsCoordinate(e, t2, r2) {
    0 === r2 && 0 == this._toAddInCurrentPath-- && (e.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
    const s = this._transformPathLikeValue(t2, r2), o = e[e.length - 1];
    0 === r2 && (this._coordinateBufferPtr = 0, this._coordinateBuffer = new Array(this._vertexDimension), o.push(this._coordinateBuffer)), this._coordinateBuffer[this._coordinateBufferPtr++] = s;
  }
  _deriveApplyTransform(e) {
    const { hasZ: t2, hasM: r2 } = e;
    return t2 && r2 ? u2 : t2 ? a : r2 ? h : n;
  }
};

// node_modules/@arcgis/core/rest/query/executeQueryPBF.js
async function n2(o, s, n3) {
  const p = f(o), i2 = { ...n3 }, u3 = b.from(s), m = !u3.quantizationParameters, { data: f2 } = await c(p, u3, new c2({ sourceSpatialReference: u3.sourceSpatialReference, applyTransform: m }), i2);
  return f2;
}

export {
  n2 as n
};
//# sourceMappingURL=chunk-BDD7KT6D.js.map
