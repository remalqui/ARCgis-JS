import {
  n
} from "./chunk-MH2LNFJK.js";
import {
  D,
  F,
  H,
  I,
  J,
  K,
  L,
  M,
  P,
  R,
  St,
  X,
  Z,
  kt,
  t,
  tt,
  v,
  yt
} from "./chunk-O3CHVGVF.js";
import {
  a as a2,
  c,
  d,
  w
} from "./chunk-HNHXEGH2.js";
import {
  s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/support/apiKeyUtils.js
var t2 = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function r(c3) {
  const r2 = X(c3, true);
  return !!r2 && (r2.endsWith(".arcgis.com") && !t2.includes(r2) && !c3.endsWith("/sharing/rest/generateToken"));
}

// node_modules/@arcgis/core/support/requestUtils.js
function i(e, o, t3 = false, n2) {
  return new Promise((s3, i2) => {
    if (a2(n2))
      return void i2(c2());
    let a4 = () => {
      l2(), i2(new Error(`Unable to load ${o}`));
    }, u2 = () => {
      const r2 = e;
      l2(), s3(r2);
    }, m = () => {
      if (!e)
        return;
      const r2 = e;
      l2(), r2.src = "", i2(c2());
    };
    const l2 = () => {
      has("esri-image-decode") || (e.removeEventListener("error", a4), e.removeEventListener("load", u2)), a4 = null, u2 = null, e = null, null != n2 && n2.removeEventListener("abort", m), m = null, t3 && URL.revokeObjectURL(o);
    };
    null != n2 && n2.addEventListener("abort", m), has("esri-image-decode") ? e.decode().then(u2, a4) : (e.addEventListener("error", a4), e.addEventListener("load", u2));
  });
}
function c2() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const e = new Error();
    return e.name = "AbortError", e;
  }
}
var a3 = "Timeout exceeded";
function u() {
  return new Error(a3);
}
function l(r2) {
  s.request.crossOriginNoCorsDomains || (s.request.crossOriginNoCorsDomains = {});
  const t3 = s.request.crossOriginNoCorsDomains;
  for (let e of r2)
    e = e.toLowerCase(), /^https?:\/\//.test(e) ? t3[X(e) ?? ""] = 0 : (t3[X("http://" + e) ?? ""] = 0, t3[X("https://" + e) ?? ""] = 0);
}
function d2(r2) {
  const s3 = s.request.crossOriginNoCorsDomains;
  if (s3) {
    let e = X(r2);
    if (e)
      return e = e.toLowerCase(), !F(e, R()) && s3[e] < Date.now() - 36e5;
  }
  return false;
}
async function f(r2) {
  var _a;
  const t3 = s.request.crossOriginNoCorsDomains, n2 = X(r2);
  t3 && n2 && (t3[n2.toLowerCase()] = Date.now());
  const i2 = L(r2);
  r2 = i2.path, "json" === ((_a = i2.query) == null ? void 0 : _a.f) && (r2 += "?f=json");
  try {
    await fetch(r2, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}

// node_modules/@arcgis/core/request.js
async function j(e, t3) {
  var _a;
  e instanceof URL && (e = e.toString()), (t3 == null ? void 0 : t3.query) instanceof URLSearchParams && (t3.query = I(t3.query.toString().replaceAll("+", " ")));
  const r2 = tt(e), s3 = Z(e);
  s3 || r2 || (e = K(e));
  const a4 = { url: e, requestOptions: { ...t3 } };
  let n2 = D(e);
  if (n2) {
    const e2 = await J2(n2, a4);
    if (null != e2)
      return { data: e2, getHeader: R2, httpStatus: 200, requestOptions: a4.requestOptions, url: a4.url };
    n2.after || n2.error || (n2 = null);
  }
  if (e = a4.url, "image" === (t3 = a4.requestOptions).responseType && (has("host-webworker") || has("host-node")))
    throw B("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), a4);
  if ("head" === t3.method) {
    if (t3.body)
      throw B("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), a4);
    if (r2 || s3)
      throw B("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), a4);
  }
  if (await $(), P2)
    return P2.execute(e, t3);
  const i2 = new AbortController();
  w(t3, () => i2.abort());
  const h = { controller: i2, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: false, interceptor: n2, params: a4, redoRequest: false, useIdentity: D2.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, m = await V(h);
  return (_a = n2 == null ? void 0 : n2.after) == null ? void 0 : _a.call(n2, m), m;
}
var P2;
var D2 = s.request;
var _ = "FormData" in globalThis;
var A = [499, 498, 403, 401];
var F2 = ["COM_0056", "COM_0057", "SB_0008"];
var I2 = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i];
var R2 = () => null;
var M2 = Symbol();
function H2(e) {
  const t3 = X(e);
  t3 && !j._corsServers.includes(t3) && j._corsServers.push(t3);
}
function N(e) {
  const t3 = X(e);
  return !t3 || t3.endsWith(".arcgis.com") || j._corsServers.includes(t3) || M(t3);
}
function B(e, t3, o, i2) {
  let l2 = "Error";
  const u2 = { url: o.url, requestOptions: o.requestOptions, getHeader: R2, ssl: false };
  if (t3 instanceof s2)
    return t3.details ? (t3.details = a(t3.details), t3.details.url = o.url, t3.details.requestOptions = o.requestOptions) : t3.details = u2, t3;
  if (t3) {
    const e2 = i2 && ((e3) => i2.headers.get(e3)), r2 = i2 == null ? void 0 : i2.status, s3 = t3.message;
    s3 && (l2 = s3), e2 && (u2.getHeader = e2), u2.httpStatus = (null != t3.httpCode ? t3.httpCode : t3.code) || r2 || 0, u2.subCode = t3.subcode, u2.messageCode = t3.messageCode, "string" == typeof t3.details ? u2.messages = [t3.details] : u2.messages = t3.details, u2.raw = M2 in t3 ? t3[M2] : t3;
  }
  return d(t3) ? c() : new s2(e, l2, u2);
}
async function $() {
  has("host-webworker") ? P2 || (P2 = await import("./request-N3RRVFOF.js")) : j._abortableFetch || (j._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function z() {
  n || await import("./IdentityManager-4YWYF3WG.js");
}
async function K2(r2) {
  var _a;
  const s3 = r2.params.url, o = r2.params.requestOptions, a4 = r2.controller.signal, n2 = o.body;
  let l2 = null, u2 = null;
  if (_ && "HTMLFormElement" in globalThis && (n2 instanceof FormData ? l2 = n2 : n2 instanceof HTMLFormElement && (l2 = new FormData(n2))), "string" == typeof n2 && (u2 = n2), r2.fetchOptions = { cache: o.cacheBust && !("polyfill" in j._abortableFetch) ? "no-cache" : "default", credentials: "same-origin", headers: o.headers || {}, method: "head" === o.method ? "HEAD" : "GET", mode: "cors", priority: D2.priority, redirect: "follow", signal: a4 }, (l2 || u2) && (r2.fetchOptions.body = l2 || u2), "anonymous" === o.authMode && (r2.useIdentity = false), r2.hasToken = !!(/token=/i.test(s3) || ((_a = o.query) == null ? void 0 : _a.token) || (l2 == null ? void 0 : l2.get("token"))), !r2.hasToken && s.apiKey && r(s3) && (o.query || (o.query = {}), o.query.token = s.apiKey, r2.hasToken = true), r2.useIdentity && !r2.hasToken && !r2.credentialToken && !W(s3) && !a2(a4)) {
    let e;
    "immediate" === o.authMode ? (await z(), e = await n.getCredential(s3, { signal: a4 }), r2.credential = e) : "no-prompt" === o.authMode ? (await z(), e = await n.getCredential(s3, { prompt: false, signal: a4 }).catch(() => {
    }), r2.credential = e) : n && (e = n.findCredential(s3)), e && (r2.credentialToken = e.token, r2.useSSL = !!e.ssl);
  }
}
function W(e) {
  return I2.some((t3) => t3.test(e));
}
async function G(e) {
  let r2 = e.params.url;
  const s3 = e.params.requestOptions, o = e.fetchOptions ?? {}, a4 = Z(r2) || tt(r2), i2 = s3.responseType || "json", l2 = a4 ? 0 : null != s3.timeout ? s3.timeout : D2.timeout;
  let d3 = false;
  if (!a4) {
    e.useSSL && (r2 = yt(r2)), s3.cacheBust && "default" === o.cache && (r2 = St(r2, "request.preventCache", Date.now()));
    let a5 = { ...s3.query };
    e.credentialToken && (a5.token = e.credentialToken);
    let n2 = v(a5);
    has("esri-url-encodes-apostrophe") && (n2 = n2.replaceAll("'", "%27"));
    const i3 = r2.length + 1 + n2.length;
    let l3;
    d3 = "delete" === s3.method || "post" === s3.method || "put" === s3.method || !!s3.body || i3 > D2.maxUrlLength;
    const u2 = s3.useProxy || !!J(r2);
    if (u2) {
      const e2 = P(r2);
      l3 = e2.path, !d3 && l3.length + 1 + i3 > D2.maxUrlLength && (d3 = true), e2.query && (a5 = { ...e2.query, ...a5 });
    }
    if ("HEAD" === o.method && (d3 || u2)) {
      if (d3) {
        if (i3 > D2.maxUrlLength)
          throw B("request:invalid-parameters", new Error("URL exceeds maximum length"), e.params);
        throw B("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e.params);
      }
      if (u2)
        throw B("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e.params);
    }
    if (d3 ? (o.method = "delete" === s3.method ? "DELETE" : "put" === s3.method ? "PUT" : "POST", s3.body ? r2 = kt(r2, a5) : (o.body = v(a5), o.headers || (o.headers = {}), o.headers["Content-Type"] = "application/x-www-form-urlencoded")) : r2 = kt(r2, a5), u2 && (e.useProxy = true, r2 = `${l3}?${r2}`), a5.token && _ && o.body instanceof FormData && !t(r2) && o.body.set("token", a5.token), s3.hasOwnProperty("withCredentials"))
      e.withCredentials = s3.withCredentials;
    else if (!F(r2, R())) {
      if (M(r2))
        e.withCredentials = true;
      else if (n) {
        const s4 = n.findServerInfo(r2);
        (s4 == null ? void 0 : s4.webTierAuth) && (e.withCredentials = true);
      }
    }
    e.withCredentials && (o.credentials = "include", d2(r2) && await f(d3 ? kt(r2, a5) : r2));
  }
  let p, C, v2 = 0, U = false;
  l2 > 0 && (v2 = setTimeout(() => {
    U = true, e.controller.abort();
  }, l2));
  try {
    if ("native-request-init" === s3.responseType)
      C = o, C.url = r2;
    else if ("image" !== s3.responseType || "default" !== o.cache || "GET" !== o.method || d3 || X2(s3.headers) || !a4 && !e.useProxy && D2.proxyUrl && !N(r2)) {
      if (p = await j._abortableFetch(r2, o), e.useProxy || H2(r2), "native" === s3.responseType)
        C = p;
      else if ("HEAD" !== o.method)
        if (p.ok) {
          switch (i2) {
            case "array-buffer":
              C = await p.arrayBuffer();
              break;
            case "blob":
            case "image":
              C = await p.blob();
              break;
            default:
              C = await p.text();
          }
          if (v2 && (clearTimeout(v2), v2 = 0), "json" === i2 || "xml" === i2 || "document" === i2)
            if (C)
              switch (i2) {
                case "json":
                  C = JSON.parse(C);
                  break;
                case "xml":
                  C = Q(C, "application/xml");
                  break;
                case "document":
                  C = Q(C, "text/html");
              }
            else
              C = null;
          if (C) {
            if ("array-buffer" === i2 || "blob" === i2) {
              const e2 = p.headers.get("Content-Type");
              if (e2 && /application\/json|text\/plain/i.test(e2) && C["blob" === i2 ? "size" : "byteLength"] <= 750)
                try {
                  const e3 = await new Response(C).json();
                  e3.error && (C = e3);
                } catch {
                }
            }
            "image" === i2 && C instanceof Blob && (C = await Z2(URL.createObjectURL(C), e, true));
          }
        } else {
          C = await p.text();
          try {
            C = JSON.parse(C);
          } catch {
          }
        }
    } else
      C = await Z2(r2, e);
  } catch (P3) {
    if ("AbortError" === P3.name) {
      if (U)
        throw u();
      throw c("Request canceled");
    }
    if (!(!p && P3 instanceof TypeError && D2.proxyUrl) || s3.body || "delete" === s3.method || "head" === s3.method || "post" === s3.method || "put" === s3.method || e.useProxy || N(r2))
      throw P3;
    e.redoRequest = true, H({ proxyUrl: D2.proxyUrl, urlPrefix: X(r2) ?? "" });
  } finally {
    v2 && clearTimeout(v2);
  }
  return [p, C];
}
async function J2(e, t3) {
  if (null != e.responseData)
    return e.responseData;
  if (e.headers && (t3.requestOptions.headers = { ...t3.requestOptions.headers, ...e.headers }), e.query && (t3.requestOptions.query = { ...t3.requestOptions.query, ...e.query }), e.before) {
    let o, a4;
    try {
      a4 = await e.before(t3);
    } catch (s3) {
      o = B("request:interceptor", s3, t3);
    }
    if ((a4 instanceof Error || a4 instanceof s2) && (o = B("request:interceptor", a4, t3)), o)
      throw e.error && e.error(o), o;
    return a4;
  }
}
function X2(e) {
  if (e) {
    for (const t3 of Object.getOwnPropertyNames(e))
      if (e[t3])
        return true;
  }
  return false;
}
function Q(e, t3) {
  let r2;
  try {
    r2 = new DOMParser().parseFromString(e, t3);
  } catch {
  }
  if (!r2 || r2.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return r2;
}
async function V(e) {
  var _a, _b;
  let r2, s3;
  await K2(e);
  try {
    do {
      [r2, s3] = await G(e);
    } while (!await Y(e, r2, s3));
  } catch (n2) {
    const t3 = B("request:server", n2, e.params, r2);
    throw t3.details.ssl = e.useSSL, ((_a = e.interceptor) == null ? void 0 : _a.error) && e.interceptor.error(t3), t3;
  }
  const o = e.params.url;
  if (s3 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o)) {
    if (!e.hasToken && !e.credentialToken && ((_b = s3.user) == null ? void 0 : _b.username) && !M(o)) {
      const e2 = X(o, true);
      e2 && D2.trustedServers.push(e2);
    }
    Array.isArray(s3.authorizedCrossOriginNoCorsDomains) && l(s3.authorizedCrossOriginNoCorsDomains);
  }
  const a4 = e.credential;
  if (a4 && n) {
    const e2 = n.findServerInfo(a4.server);
    let r3 = e2 == null ? void 0 : e2.owningSystemUrl;
    if (r3) {
      r3 = r3.replace(/\/?$/, "/sharing");
      const e3 = n.findCredential(r3, a4.userId);
      e3 && -1 === n._getIdenticalSvcIdx(r3, e3) && e3.resources.unshift(r3);
    }
  }
  return { data: s3, getHeader: r2 ? (e2) => r2 == null ? void 0 : r2.headers.get(e2) : R2, httpStatus: (r2 == null ? void 0 : r2.status) ?? 200, requestOptions: e.params.requestOptions, ssl: e.useSSL, url: e.params.url };
}
async function Y(e, r2, s3) {
  var _a;
  if (e.redoRequest)
    return e.redoRequest = false, false;
  const o = e.params.requestOptions;
  if (!r2 || "native" === o.responseType || "native-request-init" === o.responseType)
    return true;
  let a4, n2;
  if (s3 && (s3.error ? a4 = s3.error : "error" === s3.status && Array.isArray(s3.messages) && (a4 = { ...s3 }, a4[M2] = s3, a4.details = s3.messages)), !a4 && !r2.ok)
    throw a4 = new Error(`Unable to load ${r2.url} status: ${r2.status}`), a4[M2] = s3, a4;
  let i2, l2 = null;
  a4 && (n2 = Number(a4.code), l2 = a4.hasOwnProperty("subcode") ? Number(a4.subcode) : null, i2 = a4.messageCode, i2 = i2 == null ? void 0 : i2.toUpperCase());
  const u2 = o.authMode;
  if (403 === n2 && (4 === l2 || ((_a = a4.message) == null ? void 0 : _a.toLowerCase().includes("ssl")) && !a4.message.toLowerCase().includes("permission"))) {
    if (!e.useSSL)
      return e.useSSL = true, false;
  } else if (!e.hasToken && e.useIdentity && ("no-prompt" !== u2 || 498 === n2) && void 0 !== n2 && A.includes(n2) && !W(e.params.url) && (403 !== n2 || i2 && !F2.includes(i2) && (null == l2 || 2 === l2 && e.credentialToken))) {
    await z();
    try {
      const r3 = await n.getCredential(e.params.url, { error: B("request:server", a4, e.params), prompt: "no-prompt" !== u2, signal: e.controller.signal, token: e.credentialToken });
      return e.credential = r3, e.credentialToken = r3.token, e.useSSL = e.useSSL || r3.ssl, false;
    } catch (c3) {
      if ("no-prompt" === u2)
        return e.credential = void 0, e.credentialToken = void 0, false;
      a4 = c3;
    }
  }
  if (a4)
    throw a4;
  return true;
}
function Z2(e, t3, r2 = false) {
  const s3 = t3.controller.signal, o = new Image();
  return t3.withCredentials ? o.crossOrigin = "use-credentials" : o.crossOrigin = "anonymous", o.alt = "", o.fetchPriority = D2.priority, o.src = e, i(o, e, r2, s3);
}
j._abortableFetch = null, j._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];

export {
  r,
  i,
  j
};
//# sourceMappingURL=chunk-HKVL2MJK.js.map
