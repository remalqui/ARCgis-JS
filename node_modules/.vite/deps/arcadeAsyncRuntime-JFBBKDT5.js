import {
  G,
  N,
  T as T2,
  W,
  Z,
  f as f2,
  o,
  p2,
  s as s3
} from "./chunk-FRJUHTCO.js";
import {
  Pn
} from "./chunk-MPUQPE5T.js";
import {
  b
} from "./chunk-NZXLLEUL.js";
import "./chunk-KXXE4EG4.js";
import "./chunk-P6EIQMMQ.js";
import "./chunk-OVCZ34SK.js";
import "./chunk-TQF2QRC7.js";
import "./chunk-BDKC62LO.js";
import "./chunk-C3ULZZZU.js";
import "./chunk-EISDT6B4.js";
import "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-CEAO27ON.js";
import {
  A
} from "./chunk-CIYZZPIM.js";
import "./chunk-SXL2EDR4.js";
import {
  C,
  Ce,
  D,
  E,
  F2 as F,
  J,
  L,
  O,
  Q,
  R,
  T2 as T,
  V,
  Y,
  ae,
  e as e2,
  fe,
  ie,
  n,
  oe,
  q,
  r,
  s,
  s2,
  ye,
  z
} from "./chunk-RFI4CCAC.js";
import "./chunk-YAWND7HF.js";
import "./chunk-5CIVT7RW.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import {
  e,
  t,
  u
} from "./chunk-FJYIB7HF.js";
import "./chunk-AF36K5Y6.js";
import "./chunk-5K6FTFN4.js";
import "./chunk-CNCZBOLJ.js";
import "./chunk-QXPTMFGZ.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-4NOOGA4U.js";
import "./chunk-CWQ6Q3PH.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-74O2T7JC.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import "./chunk-3GSONYPC.js";
import {
  f,
  p2 as p
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
function q2(e3) {
  return e3 && "function" == typeof e3.then;
}
var W2 = 100;
async function V2(e3, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.arguments.length; r2++)
    n2.push(await J2(e3, t2.arguments[r2]));
  return n2;
}
async function _(e3, t2, n2) {
  if (true === t2.preparsed)
    return n2(e3, null, t2.arguments);
  return n2(e3, t2, await V2(e3, t2));
}
var z2 = class extends r {
  constructor(e3, t2) {
    super(), this.definition = null, this.context = null, this.definition = e3, this.context = t2;
  }
  createFunction(e3) {
    return (...t2) => {
      const n2 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, timeReference: this.context.timeReference ?? null, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, localScope: {}, depthCounter: { depth: e3.depthCounter + 1 }, globalScope: this.context.globalScope };
      if (n2.depthCounter.depth > 64)
        throw new t(e3, e.MaximumCallDepth, null);
      return Pe(this.definition, n2, t2, null);
    };
  }
  call(e3, t2) {
    return H(e3, t2, (n2, a, i) => {
      const l = { spatialReference: e3.spatialReference, services: e3.services, console: e3.console, libraryResolver: e3.libraryResolver, exports: e3.exports, lrucache: e3.lrucache, timeReference: e3.timeReference ?? null, interceptor: e3.interceptor, localScope: {}, abortSignal: e3.abortSignal, globalScope: e3.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 } };
      if (l.depthCounter.depth > 64)
        throw new t(e3, e.MaximumCallDepth, t2);
      return Pe(this.definition, l, i, t2);
    });
  }
  marshalledCall(e3, t2, n2, r2) {
    return r2(e3, t2, async (o2, a, i) => {
      const l = { spatialReference: e3.spatialReference, globalScope: n2.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 }, libraryResolver: e3.libraryResolver, exports: e3.exports, console: e3.console, abortSignal: e3.abortSignal, lrucache: e3.lrucache, timeReference: e3.timeReference ?? null, interceptor: e3.interceptor, localScope: {} };
      return i = i.map((t3) => !O(t3) || t3 instanceof s2 ? t3 : n(t3, e3, r2)), n(await Pe(this.definition, l, i, t2), n2, r2);
    });
  }
};
var Y2 = class extends s {
  constructor(e3) {
    super(e3);
  }
  async global(e3) {
    const t2 = this.executingContext.globalScope[e3.toLowerCase()];
    if (t2.valueset || (t2.value = await J2(this.executingContext, t2.node), t2.valueset = true), O(t2.value) && !(t2.value instanceof s2)) {
      const e4 = new s2();
      e4.fn = t2.value, e4.parameterEvaluator = H, e4.context = this.executingContext, t2.value = e4;
    }
    return t2.value;
  }
  setGlobal(e3, t2) {
    if (O(t2))
      throw new t(null, e.AssignModuleFunction, null);
    this.executingContext.globalScope[e3.toLowerCase()] = { value: t2, valueset: true, node: null };
  }
  hasGlobal(e3) {
    return void 0 === this.executingContext.exports[e3] && (e3 = e3.toLowerCase()), void 0 !== this.executingContext.exports[e3];
  }
  async loadModule(e3) {
    let n2 = e3.spatialReference;
    null == n2 && (n2 = new f({ wkid: 102100 })), this.moduleScope = Ge({}, e3.customfunctions, e3.timeReference), this.executingContext = { spatialReference: n2, services: e3.services, libraryResolver: new s3(e3.libraryResolver._moduleSingletons, this.source.syntax.loadedModules), exports: {}, abortSignal: void 0 === e3.abortSignal || null === e3.abortSignal ? { aborted: false } : e3.abortSignal, globalScope: this.moduleScope, console: e3.console ?? Ue, lrucache: e3.lrucache, timeReference: e3.timeReference ?? null, interceptor: e3.interceptor, localScope: null, depthCounter: { depth: 1 } }, await J2(this.executingContext, this.source.syntax);
  }
};
async function H(e3, t2, n2) {
  if (true === t2.preparsed) {
    const r3 = n2(e3, null, t2.arguments);
    return q2(r3), r3;
  }
  const r2 = n2(e3, t2, await V2(e3, t2));
  return q2(r2), r2;
}
async function J2(e3, t2, n2) {
  if (t2.breakpoint && true !== n2) {
    const n3 = t2.breakpoint();
    return await n3, J2(e3, t2, true);
  }
  try {
    switch (t2 == null ? void 0 : t2.type) {
      case "VariableDeclarator":
        return await xe(e3, t2);
      case "ImportDeclaration":
        return await ve(e3, t2);
      case "ExportNamedDeclaration":
        return await be(e3, t2);
      case "VariableDeclaration":
        return await Se(e3, t2, 0);
      case "BlockStatement":
      case "Program":
        return await he(e3, t2);
      case "FunctionDeclaration":
        return await ye2(e3, t2);
      case "ReturnStatement":
        return await ge(e3, t2);
      case "IfStatement":
        return await de(e3, t2);
      case "ExpressionStatement":
        return await we(e3, t2);
      case "UpdateExpression":
        return await ue(e3, t2);
      case "AssignmentExpression":
        return await pe(e3, t2);
      case "ForStatement":
        return await ne(e3, t2);
      case "WhileStatement":
        return await Z2(e3, t2);
      case "ForInStatement":
        return await ce(e3, t2);
      case "BreakStatement":
        return C;
      case "EmptyStatement":
        return F;
      case "ContinueStatement":
        return R;
      case "TemplateElement":
        return await Le(e3, t2);
      case "TemplateLiteral":
        return await Ne(e3, t2);
      case "Identifier":
        return await Me(e3, t2);
      case "MemberExpression":
        return await Ie(e3, t2);
      case "Literal":
        return t2.value;
      case "CallExpression":
        return await je(e3, t2);
      case "UnaryExpression":
        return await Re(e3, t2);
      case "BinaryExpression":
        return await Ce2(e3, t2);
      case "LogicalExpression":
        return await Ae(e3, t2);
      case "ArrayExpression":
        return await Fe(e3, t2);
      case "ObjectExpression":
        return await Q2(e3, t2);
      case "Property":
        return await X(e3, t2);
      default:
        throw new t(e3, e.Unrecognised, t2);
    }
  } catch (i) {
    throw u(e3, t2, i);
  }
}
async function Q2(e3, t2) {
  const a = [];
  for (let n2 = 0; n2 < t2.properties.length; n2++)
    a[n2] = await J2(e3, t2.properties[n2]);
  const i = {}, l = /* @__PURE__ */ new Map();
  for (let n2 = 0; n2 < a.length; n2++) {
    const s5 = a[n2];
    if (O(s5.value))
      throw new t(e3, e.NoFunctionInDictionary, t2);
    if (false === L(s5.key))
      throw new t(e3, e.KeyMustBeString, t2);
    let c = s5.key.toString();
    const u2 = c.toLowerCase();
    l.has(u2) ? c = l.get(u2) : l.set(u2, c), s5.value === F ? i[c] = null : i[c] = s5.value;
  }
  const s4 = new A(i);
  return s4.immutable = false, s4;
}
async function X(e3, t2) {
  const n2 = await J2(e3, t2.value);
  if ("Identifier" === t2.key.type)
    return { key: t2.key.name, value: n2 };
  return { key: await J2(e3, t2.key), value: n2 };
}
async function Z2(e3, t2) {
  const n2 = { testResult: true, lastAction: F };
  if (n2.testResult = await J2(e3, t2.test), false === n2.testResult)
    return F;
  if (true !== n2.testResult)
    throw new t(e3, e.BooleanConditionRequired, t2);
  for (; true === n2.testResult && (n2.lastAction = await J2(e3, t2.body), n2.lastAction !== C) && !(n2.lastAction instanceof D); )
    if (n2.testResult = await J2(e3, t2.test), true !== n2.testResult && false !== n2.testResult)
      throw new t(e3, e.BooleanConditionRequired, t2);
  return n2.lastAction instanceof D ? n2.lastAction : F;
}
async function $(e3, t2, n2) {
  const r2 = await J2(e3, t2.body);
  return n2.lastAction = r2, n2.lastAction === C || n2.lastAction instanceof D ? (n2.testResult = false, n2) : null !== t2.update ? (await J2(e3, t2.update), n2) : n2;
}
async function ee(e3, t2, n2) {
  var _a;
  if (null !== t2.test) {
    const a = await J2(e3, t2.test);
    if (true === ((_a = e3.abortSignal) == null ? void 0 : _a.aborted))
      throw new t(e3, e.Cancelled, t2);
    if (n2.testResult = a, false === n2.testResult)
      return n2;
    if (true !== n2.testResult)
      throw new t(e3, e.BooleanConditionRequired, t2);
    return $(e3, t2, n2);
  }
  return $(e3, t2, n2);
}
function te(e3, t2, n2, r2, o2, a) {
  try {
    ee(e3, t2, n2).then(() => {
      try {
        true === n2.testResult ? ++a > W2 ? (a = 0, setTimeout(() => {
          te(e3, t2, n2, r2, o2, a);
        }, 0)) : te(e3, t2, n2, r2, o2, a) : n2.lastAction instanceof D ? r2(n2.lastAction) : r2(F);
      } catch (i) {
        o2(i);
      }
    }, (e4) => {
      o2(e4);
    });
  } catch (i) {
    o2(i);
  }
}
function ne(e3, t2) {
  try {
    return null !== t2.init ? J2(e3, t2.init).then(() => new Promise((n2, r2) => {
      te(e3, t2, { testResult: true, lastAction: F }, (e4) => {
        n2(e4);
      }, (e4) => {
        r2(e4);
      }, 0);
    })) : new Promise((n2, r2) => {
      te(e3, t2, { testResult: true, lastAction: F }, (e4) => {
        n2(e4);
      }, (e4) => {
        r2(e4);
      }, 0);
    });
  } catch (n2) {
    return Promise.reject(n2);
  }
}
function re(e3, t2, n2, r2, o2, a, i, l, s4, c) {
  try {
    if (r2 <= a)
      return void l(F);
    o2.value = "k" === i ? n2[a] : a, J2(e3, t2.body).then((u2) => {
      try {
        u2 instanceof D ? l(u2) : u2 === C ? l(F) : ++c > W2 ? (c = 0, setTimeout(() => {
          re(e3, t2, n2, r2, o2, a + 1, i, l, s4, c);
        }, 0)) : re(e3, t2, n2, r2, o2, a + 1, i, l, s4, c);
      } catch (f3) {
        s4(f3);
      }
    }, (e4) => {
      s4(e4);
    });
  } catch (u2) {
    s4(u2);
  }
}
function oe2(e3, t2, n2, r2, o2, a, i, l, s4) {
  try {
    if (n2.length() <= o2)
      return void i(F);
    r2.value = "k" === a ? n2.get(o2) : o2, J2(e3, t2.body).then((c) => {
      c instanceof D ? i(c) : c === C ? i(F) : ++s4 > W2 ? (s4 = 0, setTimeout(() => {
        oe2(e3, t2, n2, r2, o2 + 1, a, i, l, s4);
      }, 0)) : oe2(e3, t2, n2, r2, o2 + 1, a, i, l, s4);
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
function ae2(e3, t2, n2, r2, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === n2.length)
      return void r2.resolve(F);
    re(e3, t2, n2, n2.length, o2, 0, a, (e4) => {
      r2.resolve(e4);
    }, (e4) => {
      r2.reject(e4);
    }, 0);
  } catch (i) {
    r2.reject(i);
  }
}
function ie2(e3, t2, n2, r2, o2, a) {
  try {
    if (void 0 === a && (a = "i"), 0 === n2.length)
      return void r2.resolve(F);
    oe2(e3, t2, n2, o2, 0, a, (e4) => {
      r2.resolve(e4);
    }, (e4) => {
      r2.reject(e4);
    }, 0);
  } catch (i) {
    r2.reject(i);
  }
}
function le(e3, t2, n2, r2, o2) {
  try {
    ae2(e3, t2, n2.keys(), r2, o2, "k");
  } catch (a) {
    r2.reject(a);
  }
}
function se(e3, t2, n2, r2, o2, a, l, s4) {
  try {
    e3.next().then((c) => {
      try {
        if (null === c)
          a(F);
        else {
          const u2 = b.createFromGraphicLikeObject(c.geometry, c.attributes, r2, t2.timeReference);
          u2._underlyingGraphic = c, o2.value = u2;
          J2(t2, n2.body).then((i) => {
            try {
              i === C ? a(F) : i instanceof D ? a(i) : ++s4 > W2 ? (s4 = 0, setTimeout(() => {
                se(e3, t2, n2, r2, o2, a, l, s4);
              }, 0)) : se(e3, t2, n2, r2, o2, a, l, s4);
            } catch (c2) {
              l(c2);
            }
          }, (e4) => {
            l(e4);
          });
        }
      } catch (u2) {
        l(u2);
      }
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
async function ce(e3, t2) {
  return new Promise((a, i) => {
    J2(e3, t2.right).then((l) => {
      try {
        let s4 = null;
        s4 = "VariableDeclaration" === t2.left.type ? J2(e3, t2.left) : Promise.resolve(), s4.then(() => {
          try {
            let s5 = "";
            if ("VariableDeclaration" === t2.left.type) {
              const e4 = t2.left.declarations[0].id;
              "Identifier" === e4.type && (s5 = e4.name);
            } else
              "Identifier" === t2.left.type && (s5 = t2.left.name);
            if (!s5)
              throw new t(e3, e.InvalidIdentifier, t2);
            s5 = s5.toLowerCase();
            let c = null;
            if (null != e3.localScope && void 0 !== e3.localScope[s5] && (c = e3.localScope[s5]), null === c && void 0 !== e3.globalScope[s5] && (c = e3.globalScope[s5]), null === c)
              return void i(new t(e3, e.InvalidIdentifier, t2));
            z(l) || L(l) ? ae2(e3, t2, l, { reject: i, resolve: a }, c) : q(l) ? ie2(e3, t2, l, { reject: i, resolve: a }, c) : l instanceof A || E(l) ? le(e3, t2, l, { reject: i, resolve: a }, c) : V(l) ? se(l.iterator(e3.abortSignal), e3, t2, l, c, (e4) => {
              a(e4);
            }, (e4) => {
              i(e4);
            }, 0) : ae2(e3, t2, [], { reject: i, resolve: a }, c);
          } catch (s5) {
            i(s5);
          }
        }, i);
      } catch (s4) {
        i(s4);
      }
    }, i);
  });
}
async function ue(e3, t2) {
  const a = t2.argument;
  if ("MemberExpression" === a.type) {
    const i2 = { t: null }, l2 = await J2(e3, a.object);
    let s4 = null;
    i2.t = l2, true === a.computed ? s4 = await J2(e3, a.property) : "Identifier" === a.property.type && (s4 = a.property.name);
    const c = i2.t;
    let u2;
    if (z(c)) {
      if (!J(s4))
        throw new t(e3, e.ArrayAccessorMustBeNumber, t2);
      if (s4 < 0 && (s4 = c.length + s4), s4 < 0 || s4 >= c.length)
        throw new t(e3, e.OutOfBounds, t2);
      u2 = fe(c[s4]), c[s4] = "++" === t2.operator ? u2 + 1 : u2 - 1;
    } else if (c instanceof A) {
      if (false === L(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== c.hasField(s4))
        throw new t(e3, e.FieldNotFound, t2, { key: s4 });
      u2 = fe(c.field(s4)), c.setField(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    } else if (c instanceof Y2) {
      if (false === L(s4))
        throw new t(e3, e.ModuleAccessorMustBeString, t2);
      if (true !== c.hasGlobal(s4))
        throw new t(e3, e.ModuleExportNotFound, t2);
      u2 = fe(await c.global(s4)), c.setGlobal(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    } else {
      if (!E(c))
        throw q(c) ? new t(e3, e.Immutable, t2) : new t(e3, e.InvalidParameter, t2);
      if (false === L(s4))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== c.hasField(s4))
        throw new t(e3, e.FieldNotFound, t2, { key: s4 });
      u2 = fe(c.field(s4)), c.setField(s4, "++" === t2.operator ? u2 + 1 : u2 - 1);
    }
    return false === t2.prefix ? u2 : "++" === t2.operator ? u2 + 1 : u2 - 1;
  }
  const i = "Identifier" === t2.argument.type ? t2.argument.name.toLowerCase() : "";
  if (!i)
    throw new t(e3, e.InvalidIdentifier, t2);
  let l;
  if (null != e3.localScope && void 0 !== e3.localScope[i])
    return l = fe(e3.localScope[i].value), e3.localScope[i] = { value: "++" === t2.operator ? l + 1 : l - 1, valueset: true, node: t2 }, false === t2.prefix ? l : "++" === t2.operator ? l + 1 : l - 1;
  if (void 0 !== e3.globalScope[i])
    return l = fe(e3.globalScope[i].value), e3.globalScope[i] = { value: "++" === t2.operator ? l + 1 : l - 1, valueset: true, node: t2 }, false === t2.prefix ? l : "++" === t2.operator ? l + 1 : l - 1;
  throw new t(e3, e.InvalidIdentifier, t2);
}
function fe2(e3, t2, n2, a, i) {
  switch (t2) {
    case "=":
      return e3 === F ? null : e3;
    case "/=":
      return fe(n2) / fe(e3);
    case "*=":
      return fe(n2) * fe(e3);
    case "-=":
      return fe(n2) - fe(e3);
    case "+=":
      return L(n2) || L(e3) ? oe(n2) + oe(e3) : fe(n2) + fe(e3);
    case "%=":
      return fe(n2) % fe(e3);
    default:
      throw new t(i, e.UnsupportedOperator, a);
  }
}
async function pe(e3, t2) {
  const a = t2.left;
  if ("MemberExpression" === a.type) {
    const i2 = await J2(e3, a.object);
    let l = null;
    if (true === a.computed)
      l = await J2(e3, a.property);
    else {
      if ("Identifier" !== a.property.type)
        throw new t(e3, e.InvalidIdentifier, t2);
      l = a.property.name;
    }
    const s4 = await J2(e3, t2.right);
    if (z(i2)) {
      if (!J(l))
        throw new t(e3, e.ArrayAccessorMustBeNumber, t2);
      if (l < 0 && (l = i2.length + l), l < 0 || l > i2.length)
        throw new t(e3, e.OutOfBounds, t2);
      if (l === i2.length) {
        if ("=" !== t2.operator)
          throw new t(e3, e.OutOfBounds, t2);
        i2[l] = fe2(s4, t2.operator, i2[l], t2, e3);
      } else
        i2[l] = fe2(s4, t2.operator, i2[l], t2, e3);
    } else if (i2 instanceof A) {
      if (false === L(l))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true === i2.hasField(l))
        i2.setField(l, fe2(s4, t2.operator, i2.field(l), t2, e3));
      else {
        if ("=" !== t2.operator)
          throw new t(e3, e.FieldNotFound, t2, { key: l });
        i2.setField(l, fe2(s4, t2.operator, null, t2, e3));
      }
    } else if (i2 instanceof Y2) {
      if (false === L(l))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true !== i2.hasGlobal(l))
        throw new t(e3, e.ModuleExportNotFound, t2);
      i2.setGlobal(l, fe2(s4, t2.operator, await i2.global(l), t2, e3));
    } else {
      if (!E(i2))
        throw q(i2) ? new t(e3, e.Immutable, t2) : new t(e3, e.InvalidParameter, t2);
      if (false === L(l))
        throw new t(e3, e.KeyAccessorMustBeString, t2);
      if (true === i2.hasField(l))
        i2.setField(l, fe2(s4, t2.operator, i2.field(l), t2, e3));
      else {
        if ("=" !== t2.operator)
          throw new t(e3, e.FieldNotFound, t2, { key: l });
        i2.setField(l, fe2(s4, t2.operator, null, t2, e3));
      }
    }
    return F;
  }
  const i = a.name.toLowerCase();
  if (null != e3.localScope && void 0 !== e3.localScope[i]) {
    const n2 = await J2(e3, t2.right);
    return e3.localScope[i] = { value: fe2(n2, t2.operator, e3.localScope[i].value, t2, e3), valueset: true, node: t2.right }, F;
  }
  if (void 0 !== e3.globalScope[i]) {
    const n2 = await J2(e3, t2.right);
    return e3.globalScope[i] = { value: fe2(n2, t2.operator, e3.globalScope[i].value, t2, e3), valueset: true, node: t2.right }, F;
  }
  throw new t(e3, e.InvalidIdentifier, t2);
}
async function we(e3, t2) {
  if ("AssignmentExpression" === t2.expression.type)
    return J2(e3, t2.expression);
  if ("CallExpression" === t2.expression.type) {
    const n3 = await J2(e3, t2.expression);
    return n3 === F ? F : new T(n3);
  }
  const n2 = await J2(e3, t2.expression);
  return n2 === F ? F : new T(n2);
}
async function de(e3, t2) {
  const n2 = await J2(e3, t2.test);
  if (true === n2)
    return J2(e3, t2.consequent);
  if (false === n2)
    return null !== t2.alternate ? J2(e3, t2.alternate) : F;
  throw new t(e3, e.BooleanConditionRequired, t2);
}
async function he(e3, t2) {
  return me(e3, t2, 0);
}
async function me(e3, t2, n2) {
  if (n2 >= t2.body.length)
    return F;
  const r2 = await J2(e3, t2.body[n2]);
  return r2 instanceof D || r2 === C || r2 === R || n2 === t2.body.length - 1 ? r2 : me(e3, t2, n2 + 1);
}
async function ge(e3, t2) {
  if (null === t2.argument)
    return new D(F);
  const n2 = await J2(e3, t2.argument);
  return new D(n2);
}
async function ye2(e3, t2) {
  const n2 = t2.id.name.toLowerCase();
  return e3.globalScope[n2] = { valueset: true, node: null, value: new z2(t2, e3) }, F;
}
async function ve(e3, t2) {
  var _a, _b;
  const n2 = t2.specifiers[0].local.name.toLowerCase(), r2 = e3.libraryResolver.loadLibrary(n2);
  let o2 = null;
  return ((_a = e3.libraryResolver._moduleSingletons) == null ? void 0 : _a.has(r2.uri)) ? o2 = e3.libraryResolver._moduleSingletons.get(r2.uri) : (o2 = new Y2(r2), await o2.loadModule(e3), (_b = e3.libraryResolver._moduleSingletons) == null ? void 0 : _b.set(r2.uri, o2)), e3.globalScope[n2] = { value: o2, valueset: true, node: t2 }, F;
}
async function be(e3, t2) {
  if (await J2(e3, t2.declaration), "FunctionDeclaration" === t2.declaration.type)
    e3.exports[t2.declaration.id.name.toLowerCase()] = "function";
  else if ("VariableDeclaration" === t2.declaration.type)
    for (const n2 of t2.declaration.declarations)
      e3.exports[n2.id.name.toLowerCase()] = "variable";
  return F;
}
async function Se(e3, t2, n2) {
  return n2 >= t2.declarations.length ? F : (await J2(e3, t2.declarations[n2]), n2 === t2.declarations.length - 1 || await Se(e3, t2, n2 + 1), F);
}
async function xe(e3, t2) {
  let n2 = null;
  if (n2 = null === t2.init ? null : await J2(e3, t2.init), null !== e3.localScope) {
    if (n2 === F && (n2 = null), "Identifier" !== t2.id.type)
      throw new t(e3, e.InvalidIdentifier, t2);
    const a2 = t2.id.name.toLowerCase();
    return null != e3.localScope && (e3.localScope[a2] = { value: n2, valueset: true, node: t2.init }), F;
  }
  if ("Identifier" !== t2.id.type)
    throw new t(e3, e.InvalidIdentifier, t2);
  const a = t2.id.name.toLowerCase();
  return n2 === F && (n2 = null), e3.globalScope[a] = { value: n2, valueset: true, node: t2.init }, F;
}
async function Ie(e3, t2) {
  const a = await J2(e3, t2.object);
  if (null === a)
    throw new t(e3, e.MemberOfNull, t2);
  if (false === t2.computed) {
    if ("Identifier" === t2.property.type) {
      if (a instanceof A || E(a))
        return a.field(t2.property.name);
      if (a instanceof p)
        return W(a, t2.property.name, e3, t2);
      if (a instanceof Y2) {
        if (!a.hasGlobal(t2.property.name))
          throw new t(e3, e.InvalidIdentifier, t2);
        return a.global(t2.property.name);
      }
      throw new t(e3, e.InvalidMemberAccessKey, t2);
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  let i = await J2(e3, t2.property);
  if (a instanceof A || E(a)) {
    if (L(i))
      return a.field(i);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (a instanceof Y2) {
    if (L(i))
      return a.global(i);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (a instanceof p) {
    if (L(i))
      return W(a, i, e3, t2);
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (z(a)) {
    if (J(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length + i), i >= a.length || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a[i];
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (q(a)) {
    if (J(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length() + i), i >= a.length() || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a.get(i);
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  if (L(a)) {
    if (J(i) && isFinite(i) && Math.floor(i) === i) {
      if (i < 0 && (i = a.length + i), i >= a.length || i < 0)
        throw new t(e3, e.OutOfBounds, t2);
      return a[i];
    }
    throw new t(e3, e.InvalidMemberAccessKey, t2);
  }
  throw new t(e3, e.InvalidMemberAccessKey, t2);
}
async function Re(e3, t2) {
  const n2 = await J2(e3, t2.argument);
  if (Y(n2)) {
    if ("!" === t2.operator)
      return !n2;
    if ("-" === t2.operator)
      return -1 * fe(n2);
    if ("+" === t2.operator)
      return 1 * fe(n2);
    if ("~" === t2.operator)
      return ~fe(n2);
    throw new t(e3, e.UnsupportedUnaryOperator, t2);
  }
  if ("-" === t2.operator)
    return -1 * fe(n2);
  if ("+" === t2.operator)
    return 1 * fe(n2);
  if ("~" === t2.operator)
    return ~fe(n2);
  throw new t(e3, e.UnsupportedUnaryOperator, t2);
}
async function Fe(e3, t2) {
  const n2 = [];
  for (let r2 = 0; r2 < t2.elements.length; r2++)
    n2.push(await J2(e3, t2.elements[r2]));
  for (let a = 0; a < n2.length; a++) {
    if (O(n2[a]))
      throw new t(e3, e.NoFunctionInArray, t2);
    n2[a] === F && (n2[a] = null);
  }
  return n2;
}
async function Ce2(e3, t2) {
  const n2 = [];
  n2[0] = await J2(e3, t2.left), n2[1] = await J2(e3, t2.right);
  const a = n2[0], i = n2[1];
  switch (t2.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ce(fe(a), fe(i), t2.operator);
    case "==":
      return ie(a, i);
    case "!=":
      return !ie(a, i);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return ae(a, i, t2.operator);
    case "+":
      return L(a) || L(i) ? oe(a) + oe(i) : fe(a) + fe(i);
    case "-":
      return fe(a) - fe(i);
    case "*":
      return fe(a) * fe(i);
    case "/":
      return fe(a) / fe(i);
    case "%":
      return fe(a) % fe(i);
    default:
      throw new t(e3, e.UnsupportedOperator, t2);
  }
}
async function Ae(e3, t2) {
  const n2 = await J2(e3, t2.left);
  let a = null;
  if (!Y(n2))
    throw new t(e3, e.LogicalExpressionOnlyBoolean, t2);
  switch (t2.operator) {
    case "||":
      if (true === n2)
        return n2;
      if (a = await J2(e3, t2.right), Y(a))
        return a;
      throw new t(e3, e.LogicExpressionOrAnd, t2);
    case "&&":
      if (false === n2)
        return n2;
      if (a = await J2(e3, t2.right), Y(a))
        return a;
      throw new t(e3, e.LogicExpressionOrAnd, t2);
    default:
      throw new t(e3, e.LogicExpressionOrAnd, t2);
  }
}
async function Me(e3, t2) {
  const n2 = t2.name.toLowerCase();
  if (null != e3.localScope && void 0 !== e3.localScope[n2]) {
    const t3 = e3.localScope[n2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = J2(e3, t3.node);
    const r2 = await t3.d;
    return t3.value = r2, t3.valueset = true, r2;
  }
  if (void 0 !== e3.globalScope[n2]) {
    const t3 = e3.globalScope[n2];
    if (true === t3.valueset)
      return t3.value;
    if (null !== t3.d)
      return t3.d;
    t3.d = J2(e3, t3.node);
    const r2 = await t3.d;
    return t3.value = r2, t3.valueset = true, r2;
  }
  throw new t(e3, e.InvalidIdentifier, t2);
}
async function je(e3, t2) {
  if ("MemberExpression" === t2.callee.type) {
    const n2 = await J2(e3, t2.callee.object);
    if (!(n2 instanceof Y2))
      throw new t(e3, e.FunctionNotFound, t2);
    const a = false === t2.callee.computed ? t2.callee.property.name : await J2(e3, t2.callee.property);
    if (!n2.hasGlobal(a))
      throw new t(e3, e.FunctionNotFound, t2);
    const i = await n2.global(a);
    if (!O(i))
      throw new t(e3, e.CallNonFunction, t2);
    return i.call(e3, t2);
  }
  if ("Identifier" !== t2.callee.type)
    throw new t(e3, e.FunctionNotFound, t2);
  if (null != e3.localScope && void 0 !== e3.localScope[t2.callee.name.toLowerCase()]) {
    const n2 = e3.localScope[t2.callee.name.toLowerCase()];
    if (O(n2.value))
      return n2.value.call(e3, t2);
    throw new t(e3, e.CallNonFunction, t2);
  }
  if (void 0 !== e3.globalScope[t2.callee.name.toLowerCase()]) {
    const n2 = e3.globalScope[t2.callee.name.toLowerCase()];
    if (O(n2.value))
      return n2.value.call(e3, t2);
    throw new t(e3, e.CallNonFunction, t2);
  }
  throw new t(e3, e.FunctionNotFound, t2);
}
async function Le(e3, t2) {
  return t2.value ? t2.value.cooked : "";
}
function ke(e3, t2, n2) {
  if (O(e3))
    throw new t(t2, e.NoFunctionInTemplateLiteral, n2);
  return e3;
}
async function Ne(e3, t2) {
  const n2 = [];
  for (let a = 0; a < t2.expressions.length; a++) {
    const r3 = await J2(e3, t2.expressions[a]);
    n2[a] = oe(r3);
  }
  let r2 = "", o2 = 0;
  for (const a of t2.quasis)
    if (r2 += a.value ? a.value.cooked : "", false === a.tail) {
      r2 += n2[o2] ? ke(n2[o2], e3, t2) : "", o2++;
    }
  return r2;
}
var Oe = {};
async function Ee(e3, t2, n2, r2) {
  const o2 = await J2(e3, t2.arguments[n2]);
  if (ie(o2, r2))
    return J2(e3, t2.arguments[n2 + 1]);
  const a = t2.arguments.length - n2;
  return 1 === a ? J2(e3, t2.arguments[n2]) : 2 === a ? null : 3 === a ? J2(e3, t2.arguments[n2 + 2]) : Ee(e3, t2, n2 + 2, r2);
}
async function Be(e3, t2, n2, a) {
  if (true === a)
    return J2(e3, t2.arguments[n2 + 1]);
  if (3 === t2.arguments.length - n2)
    return J2(e3, t2.arguments[n2 + 2]);
  const i = await J2(e3, t2.arguments[n2 + 2]);
  if (false === Y(i))
    throw new t(e3, e.ModuleExportNotFound, t2.arguments[n2 + 2]);
  return Be(e3, t2, n2 + 2, i);
}
async function Pe(e3, t2, n2, a) {
  const i = e3.body;
  if (n2.length !== e3.params.length)
    throw new t(t2, e.WrongNumberOfParameters, null);
  for (let r2 = 0; r2 < n2.length; r2++) {
    const o2 = e3.params[r2];
    "Identifier" === o2.type && null != t2.localScope && (t2.localScope[o2.name.toLowerCase()] = { d: null, value: n2[r2], valueset: true, node: null });
  }
  const l = await J2(t2, i);
  if (l instanceof D)
    return l.value;
  if (l === C)
    throw new t(t2, e.UnexpectedToken, a);
  if (l === R)
    throw new t(t2, e.UnexpectedToken, a);
  return l instanceof T ? l.value : l;
}
T2(Oe, _), G(Oe, _), N(Oe, _), Z(Oe, _), f2(Oe, _), Pn({ functions: Oe, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: _, standardFunctionAsync: H }), Oe.iif = async function(e3, t2) {
  Q(null === t2.arguments ? [] : t2.arguments, 3, 3, e3, t2);
  const n2 = await J2(e3, t2.arguments[0]);
  if (false === Y(n2))
    throw new t(e3, e.BooleanConditionRequired, t2);
  return J2(e3, n2 ? t2.arguments[1] : t2.arguments[2]);
}, Oe.decode = async function(e3, t2) {
  if (t2.arguments.length < 2)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  if (2 === t2.arguments.length)
    return J2(e3, t2.arguments[1]);
  if ((t2.arguments.length - 1) % 2 == 0)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  return Ee(e3, t2, 1, await J2(e3, t2.arguments[0]));
}, Oe.when = async function(e3, t2) {
  if (t2.arguments.length < 3)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  if (t2.arguments.length % 2 == 0)
    throw new t(e3, e.WrongNumberOfParameters, t2);
  const n2 = await J2(e3, t2.arguments[0]);
  if (false === Y(n2))
    throw new t(e3, e.BooleanConditionRequired, t2.arguments[0]);
  return Be(e3, t2, 0, n2);
};
var Ke = { fixSpatialReference: ye, parseArguments: V2, standardFunction: _, standardFunctionAsync: H, evaluateIdentifier: Me };
for (const Ve in Oe)
  Oe[Ve] = { value: new e2(Oe[Ve]), valueset: true, node: null };
var De = function() {
};
function Ge(e3, t2, r2) {
  const o2 = new De();
  null == e3 && (e3 = {}), null == t2 && (t2 = {});
  const a = new A({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  a.immutable = false, o2.textformatting = { value: a, valueset: true, node: null };
  for (const n2 in t2)
    o2[n2] = { value: new e2(t2[n2]), native: true, valueset: true, node: null };
  for (const n2 in e3)
    e3[n2] && "esri.Graphic" === e3[n2].declaredClass ? o2[n2] = { value: b.createFromGraphic(e3[n2], r2), valueset: true, node: null } : o2[n2] = { value: e3[n2], valueset: true, node: null };
  return o2;
}
function Ue(e3) {
  console.log(e3);
}
De.prototype = Oe, De.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, De.prototype.pi = { value: Math.PI, valueset: true, node: null };
var Te = Ke;
function qe(e3) {
  const t2 = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: _, standardFunctionAsync: H, evaluateIdentifier: Me };
  for (let n2 = 0; n2 < e3.length; n2++)
    e3[n2].registerFunctions(t2);
  for (const n2 in t2.functions)
    Oe[n2] = { value: new e2(t2.functions[n2]), valueset: true, node: null }, De.prototype[n2] = Oe[n2];
  for (let n2 = 0; n2 < t2.signatures.length; n2++)
    o(t2.signatures[n2], "async");
}
async function We(e3, n2) {
  let a = n2.spatialReference;
  null == a && (a = new f({ wkid: 102100 }));
  let i = null;
  e3.usesModules && (i = new s3(/* @__PURE__ */ new Map(), e3.loadedModules));
  const l = Ge(n2.vars, n2.customfunctions, n2.timeReference), s4 = { spatialReference: a, services: n2.services, exports: {}, libraryResolver: i, abortSignal: void 0 === n2.abortSignal || null === n2.abortSignal ? { aborted: false } : n2.abortSignal, globalScope: l, console: n2.console ?? Ue, timeReference: n2.timeReference ?? null, lrucache: n2.lrucache, interceptor: n2.interceptor, localScope: null, depthCounter: { depth: 1 } };
  let c = await J2(s4, e3);
  if (c instanceof D && (c = c.value), c instanceof T && (c = c.value), c === F && (c = null), c === C)
    throw new t(s4, e.IllegalResult, null);
  if (c === R)
    throw new t(s4, e.IllegalResult, null);
  if (O(c))
    throw new t(s4, e.IllegalResult, null);
  return c;
}
qe([p2]);
export {
  We as executeScript,
  qe as extend,
  Te as functionHelper
};
//# sourceMappingURL=arcadeAsyncRuntime-JFBBKDT5.js.map
