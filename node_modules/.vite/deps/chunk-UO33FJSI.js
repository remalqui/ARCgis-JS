import {
  l,
  n
} from "./chunk-MLNTHYHD.js";
import {
  b
} from "./chunk-PM3CFO6N.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import {
  o,
  u
} from "./chunk-XR4HIGQP.js";
import {
  E,
  S
} from "./chunk-7E3Q7HTF.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import {
  ot
} from "./chunk-O3CHVGVF.js";
import {
  C
} from "./chunk-HNHXEGH2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";

// node_modules/@arcgis/core/layers/graphics/editingSupport.js
function m(e) {
  return e && null != e.applyEdits;
}
function y(e) {
  return "object" == typeof e && null != e && "objectId" in e && !!e.objectId;
}
function f(e) {
  return e.every(y);
}
function g(e) {
  return "object" == typeof e && null != e && "globalId" in e && !!e.globalId;
}
function b2(e) {
  return e.every(g);
}
async function F(e, t, a2, s3 = {}) {
  var _a;
  let i;
  if (n(e) && e.url)
    i = l(e.url, e.layerId, "original-and-current-features" === s3.returnServiceEditsOption);
  else {
    i = C(), i.promise.then((t3) => {
      (t3.addedFeatures.length || t3.updatedFeatures.length || t3.deletedFeatures.length || t3.addedAttachments.length || t3.updatedAttachments.length || t3.deletedAttachments.length) && e.emit("edits", t3);
    });
    const t2 = { result: i.promise };
    e.emit("apply-edits", t2);
  }
  try {
    const { results: o2, edits: n2 } = await w(e, t, a2, s3), d = (e2) => e2.filter((e3) => !e3.error).map(a), l2 = { edits: n2, addedFeatures: d(o2.addFeatureResults), updatedFeatures: d(o2.updateFeatureResults), deletedFeatures: d(o2.deleteFeatureResults), addedAttachments: d(o2.addAttachmentResults), updatedAttachments: d(o2.updateAttachmentResults), deletedAttachments: d(o2.deleteAttachmentResults), exceededTransferLimit: false };
    return ((_a = o2.editedFeatureResults) == null ? void 0 : _a.length) && (l2.editedFeatures = o2.editedFeatureResults), i.resolve(l2), o2;
  } catch (n2) {
    throw i.reject(n2), n2;
  }
}
async function w(e, t, r, s3) {
  var _a, _b, _c, _d, _e, _f;
  if (await e.load(), !m(t))
    throw new s2(`${e.type}-layer:no-editing-support`, "Layer source does not support applyEdits capability", { layer: e });
  if (!S(e))
    throw new s2(`${e.type}-layer:editing-disabled`, "Editing is disabled for layer", { layer: e });
  const { edits: o2, options: i } = await A(e, r, s3);
  return ((_a = o2.addFeatures) == null ? void 0 : _a.length) || ((_b = o2.updateFeatures) == null ? void 0 : _b.length) || ((_c = o2.deleteFeatures) == null ? void 0 : _c.length) || ((_d = o2.addAttachments) == null ? void 0 : _d.length) || ((_e = o2.updateAttachments) == null ? void 0 : _e.length) || ((_f = o2.deleteAttachments) == null ? void 0 : _f.length) ? { edits: o2, results: await t.applyEdits(o2, i) } : { edits: o2, results: { addFeatureResults: [], updateFeatureResults: [], deleteFeatureResults: [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] } };
}
async function A(e, r, o2) {
  const i = r && (r.addFeatures || r.updateFeatures || r.deleteFeatures), n2 = r && (r.addAttachments || r.updateAttachments || r.deleteAttachments), d = null != e.infoFor3D;
  if (!r || !i && !n2)
    throw new s2(`${e.type}-layer:missing-parameters`, "'addFeatures', 'updateFeatures', 'deleteFeatures', 'addAttachments', 'updateAttachments' or 'deleteAttachments' parameter is required");
  const l2 = E(e);
  if (!l2.data.isVersioned && (o2 == null ? void 0 : o2.gdbVersion))
    throw new s2(`${e.type}-layer:invalid-parameter`, "'gdbVersion' is applicable only if the layer supports versioned data. See: 'capabilities.data.isVersioned'");
  if (!l2.editing.supportsRollbackOnFailure && (o2 == null ? void 0 : o2.rollbackOnFailureEnabled))
    throw new s2(`${e.type}-layer:invalid-parameter`, "This layer does not support 'rollbackOnFailureEnabled' parameter. See: 'capabilities.editing.supportsRollbackOnFailure'");
  if (!l2.editing.supportsGlobalId && (o2 == null ? void 0 : o2.globalIdUsed))
    throw new s2(`${e.type}-layer:invalid-parameter`, "This layer does not support 'globalIdUsed' parameter. See: 'capabilities.editing.supportsGlobalId'");
  if (!l2.editing.supportsGlobalId && n2)
    throw new s2(`${e.type}-layer:invalid-parameter`, "'addAttachments', 'updateAttachments' and 'deleteAttachments' are applicable only if the layer supports global ids. See: 'capabilities.editing.supportsGlobalId'");
  if (!(o2 == null ? void 0 : o2.globalIdUsed) && n2)
    throw new s2(`${e.type}-layer:invalid-parameter`, "When 'addAttachments', 'updateAttachments' or 'deleteAttachments' is specified, globalIdUsed should be set to true");
  const u2 = { ...o2 };
  if (null != u2.rollbackOnFailureEnabled || l2.editing.supportsRollbackOnFailure || (u2.rollbackOnFailureEnabled = true), u2.rollbackOnFailureEnabled || "original-and-current-features" !== u2.returnServiceEditsOption || (false === u2.rollbackOnFailureEnabled && s.getLogger("esri.layers.graphics.editingSupport").warn(`${e.type}-layer:invalid-parameter`, "'original-and-current-features' is valid for 'returnServiceEditsOption' only when 'rollBackOnFailure' is true, but 'rollBackOnFailure' was set to false. 'rollBackOnFailure' has been overwrritten and set to true."), u2.rollbackOnFailureEnabled = true), !l2.editing.supportsReturnServiceEditsInSourceSpatialReference && u2.returnServiceEditsInSourceSR)
    throw new s2(`${e.type}-layer:invalid-parameter`, "This layer does not support 'returnServiceEditsInSourceSR' parameter. See: 'capabilities.editing.supportsReturnServiceEditsInSourceSpatialReference'");
  if (u2.returnServiceEditsInSourceSR && "original-and-current-features" !== u2.returnServiceEditsOption)
    throw new s2(`${e.type}-layer:invalid-parameter`, "'returnServiceEditsInSourceSR' is valid only when 'returnServiceEditsOption' is set to 'original-and-current-features'");
  const p = { ...r };
  if (p.addFeatures = r && V.isCollection(r.addFeatures) ? r.addFeatures.toArray() : p.addFeatures || [], p.updateFeatures = r && V.isCollection(r.updateFeatures) ? r.updateFeatures.toArray() : p.updateFeatures || [], p.deleteFeatures = r && V.isCollection(r.deleteFeatures) ? r.deleteFeatures.toArray() : p.deleteFeatures || [], p.addFeatures.length && !l2.operations.supportsAdd)
    throw new s2(`${e.type}-layer:unsupported-operation`, "Layer does not support adding features.");
  if (p.updateFeatures.length && !l2.operations.supportsUpdate)
    throw new s2(`${e.type}-layer:unsupported-operation`, "Layer does not support updating features.");
  if (p.deleteFeatures.length && !l2.operations.supportsDelete)
    throw new s2(`${e.type}-layer:unsupported-operation`, "Layer does not support deleting features.");
  p.addAttachments = p.addAttachments || [], p.updateAttachments = p.updateAttachments || [], p.deleteAttachments = p.deleteAttachments || [], p.addFeatures = p.addFeatures.map(j), p.updateFeatures = p.updateFeatures.map(j), p.addAssetFeatures = [];
  const c = (o2 == null ? void 0 : o2.globalIdUsed) || d;
  p.addFeatures.forEach((t) => E2(t, e, c)), p.updateFeatures.forEach((t) => $(t, e, c)), p.deleteFeatures.forEach((t) => S2(t, e, c)), p.addAttachments.forEach((t) => R(t, e)), p.updateAttachments.forEach((t) => R(t, e)), d && await U(p, e);
  return { edits: await O(p), options: u2 };
}
function v(e, t, r) {
  var _a, _b;
  if (r) {
    if ("attributes" in e && !e.attributes[t.globalIdField])
      throw new s2(`${t.type}-layer:invalid-parameter`, "Feature should have 'globalId' when 'globalIdUsed' is true");
    if (!("attributes" in e) && !e.globalId)
      throw new s2(`${t.type}-layer:invalid-parameter`, "'globalId' of the feature should be passed when 'globalIdUsed' is true");
  }
  if ("geometry" in e && null != e.geometry) {
    if (e.geometry.hasZ && false === ((_a = t.capabilities) == null ? void 0 : _a.data.supportsZ))
      throw new s2(`${t.type}-layer:z-unsupported`, "Layer does not support z values while feature has z values.");
    if (e.geometry.hasM && false === ((_b = t.capabilities) == null ? void 0 : _b.data.supportsM))
      throw new s2(`${t.type}-layer:m-unsupported`, "Layer does not support m values while feature has m values.");
  }
}
function I(e, t) {
  var _a;
  if ("geometry" in e && "mesh" === ((_a = e.geometry) == null ? void 0 : _a.type)) {
    const { geometry: r } = e;
    if (r.vertexSpace.isGeoreferenced)
      throw new s2(`${t.type}-layer:georeferenced-mesh-unsupported`, "Uploading georeferenced meshes to a layer is not supported.");
  }
}
function E2(e, t, a2) {
  v(e, t, a2), I(e, t);
}
function S2(e, t, a2) {
  v(e, t, a2);
}
function $(e, t, r) {
  v(e, t, r), I(e, t);
  const s3 = E(t);
  if ("geometry" in e && null != e.geometry && !(s3 == null ? void 0 : s3.editing.supportsGeometryUpdate))
    throw new s2(`${t.type}-layer:unsupported-operation`, "Layer does not support geometry updates.");
}
function R(e, t) {
  var _a;
  const { feature: r, attachment: s3 } = e;
  if (!r || "attributes" in r && !r.attributes[t.globalIdField])
    throw new s2(`${t.type}-layer:invalid-parameter`, "Attachment should have reference to a feature with 'globalId'");
  if (!("attributes" in r) && !r.globalId)
    throw new s2(`${t.type}-layer:invalid-parameter`, "Attachment should have reference to 'globalId' of the parent feature");
  if (!s3.globalId)
    throw new s2(`${t.type}-layer:invalid-parameter`, "Attachment should have 'globalId'");
  if (!s3.data && !s3.uploadId)
    throw new s2(`${t.type}-layer:invalid-parameter`, "Attachment should have 'data' or 'uploadId'");
  if (!(s3.data instanceof File && !!s3.data.name) && !s3.name)
    throw new s2(`${t.type}-layer:invalid-parameter`, "'name' is required when attachment is specified as Base64 encoded string using 'data'");
  if (!((_a = t.capabilities) == null ? void 0 : _a.editing.supportsUploadWithItemId) && s3.uploadId)
    throw new s2(`${t.type}-layer:invalid-parameter`, "This layer does not support 'uploadId' parameter. See: 'capabilities.editing.supportsUploadWithItemId'");
  if ("string" == typeof s3.data) {
    const e2 = ot(s3.data);
    if (e2 && !e2.isBase64)
      throw new s2(`${t.type}-layer:invalid-parameter`, "Attachment 'data' should be a Blob, File or Base64 encoded string");
  }
}
async function O(e) {
  const t = e.addFeatures ?? [], a2 = e.updateFeatures ?? [], r = t.concat(a2).map((e2) => e2.geometry), s3 = await b(r), o2 = t.length, i = a2.length;
  return s3.slice(0, o2).forEach((e2, a3) => t[a3].geometry = e2), s3.slice(o2, o2 + i).forEach((e2, t2) => a2[t2].geometry = e2), e;
}
function j(t) {
  const a2 = new h();
  return t.attributes || (t.attributes = {}), a2.geometry = t.geometry, a2.attributes = t.attributes, a2;
}
async function U(e, t) {
  if (null == t.infoFor3D)
    return;
  const { infoFor3D: r } = t, s3 = o("model/gltf-binary", r.supportedFormats) ?? u("glb", r.supportedFormats);
  if (!(!!s3 && r.editFormats.includes(s3)))
    throw new s2(`${t.type}-layer:binary-gltf-asset-not-supported`, "3DObjectFeatureLayer requires binary glTF (.glb) support for updating mesh geometry.");
  e.addAssetFeatures ?? (e.addAssetFeatures = []);
  const { addAssetFeatures: o2 } = e;
  for (const a2 of e.addFeatures ?? [])
    L(a2) && o2.push(a2);
  for (const a2 of e.updateFeatures ?? [])
    L(a2) && o2.push(a2);
}
function L(e) {
  var _a;
  return "mesh" === ((_a = e == null ? void 0 : e.geometry) == null ? void 0 : _a.type);
}
function k(e, t, r, s3) {
  if (!m(t))
    throw new s2(`${e.type}-layer:no-editing-support`, "Layer source does not support applyEdits capability", { layer: e });
  if (!t.uploadAssets)
    throw new s2(`${e.type}-layer:no-asset-upload-support`, "Layer source does not support uploadAssets capability", { layer: e });
  return t.uploadAssets(r, s3);
}

export {
  y,
  f,
  g,
  b2 as b,
  F,
  k
};
//# sourceMappingURL=chunk-UO33FJSI.js.map
