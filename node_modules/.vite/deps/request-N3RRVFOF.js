import {
  s3 as s
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/core/workers/request.js
var t;
function s2(s3, a) {
  let r = a.responseType;
  r ? "array-buffer" !== r && "blob" !== r && "json" !== r && "native" !== r && "native-request-init" !== r && "text" !== r && (r = "text") : r = "json", a.responseType = r;
  const n = a.signal;
  return delete a.signal, globalThis.invokeStaticMessage("request", { url: s3, options: a }, { signal: n }).then(async (o) => {
    let i, l, u, c, p;
    if (o.data)
      if (o.data instanceof ArrayBuffer) {
        if (!("json" !== r && "text" !== r && "blob" !== r || (i = new Blob([o.data]), "json" !== r && "text" !== r || (t || (t = new FileReaderSync()), c = t.readAsText(i), "json" !== r)))) {
          try {
            l = JSON.parse(c || null);
          } catch (b) {
            const t2 = { ...b, url: s3, requestOptions: a };
            throw new s("request:server", b.message, t2);
          }
          if (l.error) {
            const t2 = { ...l.error, url: s3, requestOptions: a };
            throw new s("request:server", l.error.message, t2);
          }
        }
      } else
        "native" === r && (o.data.signal = n, u = await fetch(o.data.url, o.data), o.httpStatus = u.status);
    switch (r) {
      case "blob":
        p = i;
        break;
      case "json":
        p = l;
        break;
      case "native":
        p = u;
        break;
      case "text":
        p = c;
        break;
      default:
        p = o.data;
    }
    return { data: p, httpStatus: o.httpStatus, requestOptions: a, ssl: o.ssl, url: s3 };
  });
}
export {
  s2 as execute
};
//# sourceMappingURL=request-N3RRVFOF.js.map
