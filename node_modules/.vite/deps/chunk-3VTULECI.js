import {
  x
} from "./chunk-A4HFWKMU.js";
import {
  e,
  n
} from "./chunk-TDXHXKUI.js";
import {
  E,
  I,
  S
} from "./chunk-TBHRKIAA.js";
import {
  t
} from "./chunk-FF5LS3YE.js";
import {
  C,
  F,
  U
} from "./chunk-BCDDCNQ2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/Utils.js
var m = s.getLogger("esri.views.2d.engine.webgl.Utils");
var f = "geometry";
var d = [{ name: f, strideInBytes: 12 }];
var p = [{ name: f, strideInBytes: 36 }];
var y = [{ name: f, strideInBytes: 24 }];
var I2 = [{ name: f, strideInBytes: 12 }];
var g = [{ name: f, strideInBytes: 40 }];
var S2 = [{ name: f, strideInBytes: 36 }];
var T = [{ name: f, strideInBytes: 36 }];
function w(e2) {
  const t3 = {};
  for (const n2 of e2)
    t3[n2.name] = n2.strideInBytes;
  return t3;
}
var E2 = w([{ name: f, strideInBytes: 36 }]);
var h = w(d);
var L = w(p);
var N = w(y);
var D = w(I2);
var A = w(g);
var M = w(S2);
var U2 = w(T);
function R(e2, t3) {
  switch (e2) {
    case E.MARKER:
      return t3 === S.HEATMAP ? h : E2;
    case E.FILL:
      switch (t3) {
        case S.DOT_DENSITY:
          return D;
        case S.SIMPLE:
        case S.OUTLINE_FILL_SIMPLE:
          return N;
        default:
          return L;
      }
    case E.LINE:
      return A;
    case E.TEXT:
      return M;
    case E.LABEL:
      return U2;
  }
}
var _ = [f];
var v = [f];
var B = [f];
var O = [f];
var C2 = [f];
function b(e2) {
  switch (e2) {
    case E.MARKER:
      return _;
    case E.FILL:
      return v;
    case E.LINE:
      return B;
    case E.TEXT:
      return O;
    case E.LABEL:
      return C2;
  }
}
function F2(e2) {
  switch (e2 % 4) {
    case 0:
    case 2:
      return 4;
    case 1:
    case 3:
      return 1;
  }
}
function x2(e2, t3) {
  switch (t3 % 4) {
    case 0:
    case 2:
      return new Uint32Array(Math.floor(e2 * t3 / 4));
    case 1:
    case 3:
      return new Uint8Array(e2 * t3);
  }
}
function P(e2, t3) {
  switch (t3 % 4) {
    case 0:
    case 2:
      return new Uint32Array(e2);
    case 1:
    case 3:
      return new Uint8Array(e2);
  }
}
function z(e2) {
  return null != e2;
}
function $(e2) {
  return "number" == typeof e2;
}
function k(t3) {
  switch (t3) {
    case "butt":
      return e.BUTT;
    case "round":
      return e.ROUND;
    case "square":
      return e.SQUARE;
    default:
      return m.error(new s2("mapview-invalid-type", `Cap type ${t3} is not a valid option. Defaulting to round`)), e.ROUND;
  }
}
function G(t3) {
  switch (t3) {
    case "miter":
      return n.MITER;
    case "bevel":
      return n.BEVEL;
    case "round":
      return n.ROUND;
    default:
      return m.error(new s2("mapview-invalid-type", `Join type ${t3} is not a valid option. Defaulting to round`)), n.ROUND;
  }
}
function V(e2) {
  switch (e2) {
    case "opacity":
      return I.OPACITY;
    case "color":
      return I.COLOR;
    case "rotation":
      return I.ROTATION;
    case "size":
      return I.SIZE;
    default:
      return m.error(`Cannot interpret unknown vv: ${e2}`), null;
  }
}
function j(e2, t3, n2, r2, s3, a, i) {
  for (const c in a) {
    const t4 = a[c].stride, r3 = F2(t4), i2 = a[c].data, o2 = n2[c].data;
    if (null == i2 || null == o2)
      continue;
    const u2 = t4 * s3.vertexCount / r3, l = t4 * e2 / r3, m2 = t4 * s3.vertexFrom / r3;
    for (let e3 = 0; e3 < u2; ++e3)
      o2[e3 + l] = i2[e3 + m2];
  }
  if (null != i && null != r2) {
    const n3 = s3.indexCount;
    for (let a2 = 0; a2 < n3; ++a2)
      r2[a2 + t3] = i[a2 + s3.indexFrom] - s3.vertexFrom + e2;
  }
}
var Y = { [f]: F.STATIC_DRAW };
function H(e2, t3) {
  const n2 = [];
  for (let r2 = 0; r2 < 5; ++r2) {
    const s3 = b(r2), a = {};
    for (const e3 of s3)
      a[e3] = { data: t3(r2, e3) };
    n2.push({ data: e2(r2), buffers: a });
  }
  return n2;
}
function q(e2) {
  switch (e2) {
    case C.BYTE:
    case C.UNSIGNED_BYTE:
      return 1;
    case C.SHORT:
    case C.UNSIGNED_SHORT:
      return 2;
    case C.FLOAT:
    case C.INT:
    case C.UNSIGNED_INT:
      return 4;
  }
}
function K(t3) {
  switch (t3) {
    case U.UNSIGNED_BYTE:
      return 1;
    case U.UNSIGNED_SHORT_4_4_4_4:
      return 2;
    case U.FLOAT:
      return 4;
    default:
      return void m.error(new s2("webgl-utils", `Unable to handle type ${t3}`));
  }
}
function W(t3) {
  switch (t3) {
    case U.UNSIGNED_BYTE:
      return Uint8Array;
    case U.UNSIGNED_SHORT_4_4_4_4:
      return Uint16Array;
    case U.FLOAT:
      return Float32Array;
    default:
      return void m.error(new s2("webgl-utils", `Unable to handle type ${t3}`));
  }
}
function X(e2) {
  var _a;
  const t3 = {};
  for (const n2 in e2) {
    const r2 = e2[n2];
    let s3 = 0;
    t3[n2] = r2.map((e3) => {
      const t4 = new t(e3.name, e3.count, e3.type, s3, 0, e3.normalized || false);
      return s3 += e3.count * q(e3.type), t4;
    }), (_a = t3[n2]) == null ? void 0 : _a.forEach((e3) => e3.stride = s3);
  }
  return t3;
}
var J = (e2) => {
  const t3 = /* @__PURE__ */ new Map();
  for (const n2 in e2)
    for (const r2 of e2[n2])
      t3.set(r2.name, r2.location);
  return t3;
};
var Q = (e2) => {
  const t3 = {};
  for (const n2 in e2) {
    const r2 = e2[n2];
    t3[n2] = (r2 == null ? void 0 : r2.length) ? r2[0].stride : 0;
  }
  return t3;
};
var Z = /* @__PURE__ */ new Map();
var ee = (e2, t3) => {
  if (!Z.has(e2)) {
    const n2 = X(t3), r2 = { strides: Q(n2), bufferLayouts: n2, attributes: J(t3) };
    Z.set(e2, r2);
  }
  return Z.get(e2);
};
function te(e2) {
  e2(E.FILL), e2(E.LINE), e2(E.MARKER), e2(E.TEXT), e2(E.LABEL);
}
var ne = (e2) => "path" in e2 && ye(e2.path);
var re = (e2) => "url" in e2 && e2.url || "imageData" in e2 && e2.imageData;
var se = (e2) => "imageData" in e2 && e2.imageData && "contentType" in e2 && e2.contentType ? `data:${e2.contentType};base64,${e2.imageData}` : "url" in e2 ? e2.url : null;
var ae = (e2) => null != e2 && e2.startsWith("data:image/gif");
var ie = (e2) => "url" in e2 && e2.url && (e2.url.includes(".gif") || ae(e2.url)) || "contentType" in e2 && "image/gif" === e2.contentType || "imageData" in e2 && ae(e2.imageData);
var ce = (e2) => null != e2 && e2.startsWith("data:image/png");
var oe = (e2) => "url" in e2 && e2.url && (e2.url.includes(".png") || ce(e2.url)) || "contentType" in e2 && "image/png" === e2.contentType || "imageData" in e2 && ce(e2.imageData);
var ue = (e2) => e2.type && e2.type.toLowerCase().includes("3d");
function le(e2) {
  switch (e2.type) {
    case "line": {
      const t3 = e2;
      return "CIMSolidStroke" === t3.cim.type && !t3.dashTemplate;
    }
    case "fill":
      return "CIMSolidFill" === e2.cim.type;
    case "esriSFS":
      return "esriSFSSolid" === e2.style || "esriSFSNull" === e2.style;
    case "esriSLS":
      return "esriSLSSolid" === e2.style || "esriSLSNull" === e2.style;
    default:
      return false;
  }
}
var me = (e2) => e2.includes("data:image/svg+xml");
function fe(e2) {
  switch ("cim" in e2 ? e2.cim.type : e2.type) {
    case "esriSMS":
    case "esriPMS":
    case "CIMPointSymbol":
      return false;
    case "CIMVectorMarker":
    case "CIMCharacterMarker":
    case "CIMPictureMarker":
      return Ie(e2);
    default:
      return true;
  }
}
function de(e2) {
  const t3 = "maxVVSize" in e2 && e2.maxVVSize, n2 = "width" in e2 && e2.width || "size" in e2 && e2.size || 0;
  return t3 || n2;
}
function pe(e2) {
  const t3 = [];
  for (let n2 = 0; n2 < e2.length; n2++)
    t3.push(e2.charCodeAt(n2));
  return t3;
}
var ye = (e2) => !!e2 && (e2 = e2.trim(), !!(/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(e2) && /[\dz]$/i.test(e2) && e2.length > 4));
var Ie = (e2) => {
  var _a, _b;
  return "fill" === e2.type && "CIMMarkerPlacementInsidePolygon" === ((_b = (_a = e2 == null ? void 0 : e2.cim) == null ? void 0 : _a.markerPlacement) == null ? void 0 : _b.type);
};

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function r(n2, r2 = 0, t3 = false) {
  const o2 = n2[r2 + 3];
  return n2[r2] *= o2, n2[r2 + 1] *= o2, n2[r2 + 2] *= o2, t3 || (n2[r2 + 3] *= 255), n2;
}
function t2(r2) {
  if (!r2)
    return 0;
  const { r: t3, g: o2, b: u2, a: i } = r2;
  return x(t3 * i, o2 * i, u2 * i, 255 * i);
}
function o(r2) {
  if (!r2)
    return 0;
  const [t3, o2, u2, i] = r2;
  return x(t3 * (i / 255), o2 * (i / 255), u2 * (i / 255), i);
}
function u(n2, r2, t3 = 0) {
  if (null == r2)
    return n2[t3] = 0, n2[t3 + 1] = 0, n2[t3 + 2] = 0, void (n2[t3 + 3] = 0);
  const { r: o2, g: u2, b: i, a: c } = r2;
  n2[t3] = o2 * c / 255, n2[t3 + 1] = u2 * c / 255, n2[t3 + 2] = i * c / 255, n2[t3 + 3] = c;
}

export {
  R,
  F2 as F,
  x2 as x,
  P,
  z,
  $,
  k,
  G,
  V,
  j,
  Y,
  H,
  K,
  W,
  ee,
  te,
  ne,
  re,
  se,
  ie,
  oe,
  ue,
  le,
  me,
  fe,
  de,
  pe,
  Ie,
  r,
  t2 as t,
  o,
  u
};
//# sourceMappingURL=chunk-3VTULECI.js.map
