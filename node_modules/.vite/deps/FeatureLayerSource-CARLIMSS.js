import {
  x
} from "./chunk-7NKY3QXH.js";
import "./chunk-BDD7KT6D.js";
import "./chunk-4QESYAV3.js";
import {
  s as s4
} from "./chunk-P2MEGQP6.js";
import {
  i
} from "./chunk-7MFOV26D.js";
import {
  A
} from "./chunk-5U4S3W7H.js";
import "./chunk-RNXN3MSP.js";
import {
  b as b2,
  f as f3
} from "./chunk-UO33FJSI.js";
import "./chunk-MLNTHYHD.js";
import {
  o as o2
} from "./chunk-P34MS5MD.js";
import "./chunk-FHYNSVC4.js";
import {
  m
} from "./chunk-T5KDTHII.js";
import {
  r as r2
} from "./chunk-GXWNOUDM.js";
import {
  e as e2
} from "./chunk-AYMF6OMA.js";
import "./chunk-HTY52TPQ.js";
import {
  b
} from "./chunk-YC4PIRSZ.js";
import "./chunk-MSLDEOHR.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-YIJWIXDP.js";
import "./chunk-6DURKJBD.js";
import "./chunk-FN5LEP6H.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-YBMFRTPB.js";
import "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import "./chunk-QA4FMJA6.js";
import "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-MUO4EIZP.js";
import {
  c
} from "./chunk-42RWGG3D.js";
import {
  w
} from "./chunk-G5WJIWPP.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-KTEJJM3A.js";
import {
  Rn,
  nn
} from "./chunk-SO6DBMQG.js";
import {
  q
} from "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import {
  m as m2
} from "./chunk-XR4HIGQP.js";
import "./chunk-KIEN3CY2.js";
import "./chunk-7E3Q7HTF.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-4RFFPIT2.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-7KX64CAH.js";
import {
  _
} from "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import {
  p
} from "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import {
  r
} from "./chunk-5EXFDBQJ.js";
import "./chunk-CWQ6Q3PH.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  W,
  f as f2
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import {
  s as s3
} from "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  n
} from "./chunk-MH2LNFJK.js";
import {
  Jt,
  V
} from "./chunk-O3CHVGVF.js";
import {
  f,
  g,
  k
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  o
} from "./chunk-I5JT24BO.js";
import {
  R,
  has
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/meshVertexSpaceUtils.js
function n2(t) {
  const { vertexSpace: n3 } = t;
  if (n3.isRelative)
    return t.clone();
  const { anchor: i2 } = t, c2 = i2.clone(), a2 = q(s5, [-c2.x, -c2.y, -c2.z]), m3 = new m({ origin: [c2.x, c2.y, c2.z] }), p2 = t.cloneWithVertexSpace(m3), { position: f4 } = p2.vertexAttributes;
  return p2.vertexAttributes.position = r2(new Float64Array(f4.length), f4, a2), p2.vertexAttributesChanged(), p2;
}
var s5 = e2();

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var U = new s3({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
var k2 = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table"]);
var Q = new s3({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var C = class extends _ {
  constructor() {
    super(...arguments), this.type = "feature-layer", this.refresh = k(async () => {
      var _a, _b;
      await this.load();
      const e3 = (_a = this.sourceJSON.editingInfo) == null ? void 0 : _a.lastEditDate;
      if (null == e3)
        return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t = e3 !== ((_b = this.sourceJSON.editingInfo) == null ? void 0 : _b.lastEditDate);
      return { dataChanged: t, updates: t ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    }), this._ongoingAssetUploads = /* @__PURE__ */ new Map();
  }
  load(e3) {
    const t = null != e3 ? e3.signal : null, s6 = this.layer.sourceJSON;
    return this.addResolvingPromise(this._fetchService(s6, t)), Promise.resolve(this);
  }
  get queryTask() {
    var _a;
    const { capabilities: e3, parsedUrl: t, dynamicDataSource: s6, infoFor3D: r3, gdbVersion: a2, spatialReference: i2, fieldsIndex: o3 } = this.layer, n3 = has("featurelayer-pbf") && (e3 == null ? void 0 : e3.query.supportsFormatPBF) && null == r3, u = ((_a = e3 == null ? void 0 : e3.operations) == null ? void 0 : _a.supportsQueryAttachments) ?? false;
    return new x({ url: t.path, pbfSupported: n3, fieldsIndex: o3, infoFor3D: r3, dynamicDataSource: s6, gdbVersion: a2, sourceSpatialReference: i2, queryAttachmentsSupported: u });
  }
  async addAttachment(e3, t) {
    await this.load();
    const s6 = e3.attributes[this.layer.objectIdField], a2 = this.layer.parsedUrl.path + "/" + s6 + "/addAttachment", i2 = this._getLayerRequestOptions(), o3 = this._getFormDataForAttachment(t, i2.query);
    try {
      const e4 = await j(a2, { body: o3 });
      return this._createFeatureEditResult(e4.data.addAttachmentResult);
    } catch (n3) {
      throw this._createAttachmentErrorResult(s6, n3);
    }
  }
  async updateAttachment(e3, t, s6) {
    await this.load();
    const a2 = e3.attributes[this.layer.objectIdField], i2 = this.layer.parsedUrl.path + "/" + a2 + "/updateAttachment", o3 = this._getLayerRequestOptions({ query: { attachmentId: t } }), n3 = this._getFormDataForAttachment(s6, o3.query);
    try {
      const e4 = await j(i2, { body: n3 });
      return this._createFeatureEditResult(e4.data.updateAttachmentResult);
    } catch (u) {
      throw this._createAttachmentErrorResult(a2, u);
    }
  }
  async applyEdits(e3, t) {
    var _a, _b, _c, _d, _e, _f;
    await this.load();
    const { layer: a2 } = this, o3 = a2.infoFor3D, n3 = null != o3, u = n3 || ((t == null ? void 0 : t.globalIdUsed) ?? false), l = n3 ? await this._uploadMeshesAndGetAssetMapEditsJSON(e3) : null, d = ((_a = e3.addFeatures) == null ? void 0 : _a.map((e4) => this._getFeatureJSON(e4, o3))) ?? [], c2 = (await Promise.all(d)).filter(R), p2 = ((_b = e3.updateFeatures) == null ? void 0 : _b.map((e4) => this._getFeatureJSON(e4, o3))) ?? [], h2 = (await Promise.all(p2)).filter(R), y2 = this._getFeatureIds(e3.deleteFeatures, u);
    i(c2, h2, a2.spatialReference);
    const m3 = await this._getAttachmentEditsJSON(e3), f4 = a2.capabilities.editing.supportsAsyncApplyEdits && n3, g2 = { gdbVersion: (t == null ? void 0 : t.gdbVersion) || a2.gdbVersion, rollbackOnFailure: t == null ? void 0 : t.rollbackOnFailureEnabled, useGlobalIds: u, returnEditMoment: t == null ? void 0 : t.returnEditMoment, usePreviousEditMoment: t == null ? void 0 : t.usePreviousEditMoment, sessionId: t == null ? void 0 : t.sessionId, async: f4 };
    (t == null ? void 0 : t.returnServiceEditsOption) ? (g2.edits = JSON.stringify([{ id: a2.layerId, adds: c2, updates: h2, deletes: y2, attachments: m3, assetMaps: l }]), g2.returnServiceEditsOption = U.toJSON(t == null ? void 0 : t.returnServiceEditsOption), g2.returnServiceEditsInSourceSR = t == null ? void 0 : t.returnServiceEditsInSourceSR) : (g2.adds = c2.length ? JSON.stringify(c2) : null, g2.updates = h2.length ? JSON.stringify(h2) : null, g2.deletes = y2.length ? u ? JSON.stringify(y2) : y2.join(",") : null, g2.attachments = m3 && JSON.stringify(m3), g2.assetMaps = null != l ? JSON.stringify(l) : void 0);
    const R2 = this._getLayerRequestOptions({ method: "post", query: g2 }), S = (t == null ? void 0 : t.returnServiceEditsOption) ? a2.url : a2.parsedUrl.path, b3 = f4 ? await this._asyncApplyEdits(S + "/applyEdits", R2) : await j(S + "/applyEdits", R2);
    if (!((_c = a2.capabilities.operations) == null ? void 0 : _c.supportsEditing) && ((_e = (_d = a2.effectiveCapabilities) == null ? void 0 : _d.operations) == null ? void 0 : _e.supportsEditing)) {
      const e4 = (_f = n) == null ? void 0 : _f.findCredential(a2.url);
      await (e4 == null ? void 0 : e4.refreshToken());
    }
    return this._createEditsResult(b3);
  }
  async deleteAttachments(e3, t) {
    await this.load();
    const s6 = e3.attributes[this.layer.objectIdField], a2 = this.layer.parsedUrl.path + "/" + s6 + "/deleteAttachments";
    try {
      return (await j(a2, this._getLayerRequestOptions({ query: { attachmentIds: t.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(this._createFeatureEditResult);
    } catch (i2) {
      throw this._createAttachmentErrorResult(s6, i2);
    }
  }
  fetchRecomputedExtents(e3 = {}) {
    const t = e3.signal;
    return this.load({ signal: t }).then(async () => {
      const t2 = this._getLayerRequestOptions({ ...e3, query: { returnUpdates: true } }), { layerId: s6, url: i2 } = this.layer, { data: o3 } = await j(`${i2}/${s6}`, t2), { id: n3, extent: u, fullExtent: l, timeExtent: d } = o3, c2 = u || l;
      return { id: n3, fullExtent: c2 && M.fromJSON(c2), timeExtent: d && c.fromJSON({ start: d[0], end: d[1] }) };
    });
  }
  async queryAttachments(e3, t = {}) {
    await this.load();
    const s6 = this._getLayerRequestOptions(t);
    return this.queryTask.executeAttachmentQuery(e3, s6);
  }
  async queryFeatures(e3, t) {
    return await this.load(), this.queryTask.execute(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryFeaturesJSON(e3, t) {
    return await this.load(), this.queryTask.executeJSON(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryObjectIds(e3, t) {
    return await this.load(), this.queryTask.executeForIds(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryFeatureCount(e3, t) {
    return await this.load(), this.queryTask.executeForCount(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryExtent(e3, t) {
    return await this.load(), this.queryTask.executeForExtent(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryRelatedFeatures(e3, t) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryRelatedFeaturesCount(e3, t) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryTopFeatures(e3, t) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryTopObjectIds(e3, t) {
    return await this.load(), this.queryTask.executeForTopIds(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryTopExtents(e3, t) {
    return await this.load(), this.queryTask.executeForTopExtents(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async queryTopCount(e3, t) {
    return await this.load(), this.queryTask.executeForTopCount(e3, { ...t, query: this._createRequestQueryOptions(t) });
  }
  async fetchPublishingStatus() {
    if (!w(this.layer.url))
      return "unavailable";
    const e3 = V(this.layer.url, "status"), t = await j(e3, { query: { f: "json" } });
    return Q.fromJSON(t.data.status);
  }
  async uploadAssets(e3, t) {
    const { uploadAssets: s6 } = await import("./uploadAssets-UEWRUOOS.js");
    return s6(e3, { layer: this.layer, ongoingUploads: this._ongoingAssetUploads }, t);
  }
  async _asyncApplyEdits(e3, t) {
    const s6 = (await j(e3, t)).data.statusUrl;
    for (; ; ) {
      const e4 = (await j(s6, { query: { f: "json" }, responseType: "json" })).data;
      switch (e4.status) {
        case "Completed":
          return j(e4.resultUrl, { query: { f: "json" }, responseType: "json" });
        case "CompletedWithErrors":
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed.");
        case "Failed ImportChanges":
        case "InProgress":
        case "Pending":
        case "ExportAttachments":
        case "ExportChanges":
        case "ExportingData":
        case "ExportingSnapshot":
        case "ImportAttachments":
        case "ProvisioningReplica":
        case "UnRegisteringReplica":
          break;
        default:
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed (undefined response status)");
      }
      await g(D);
    }
  }
  _createRequestQueryOptions(e3) {
    const t = { ...this.layer.customParameters, token: this.layer.apiKey, ...e3 == null ? void 0 : e3.query };
    return this.layer.datesInUnknownTimezone && (t.timeReferenceUnknownClient = true), t;
  }
  async _fetchService(e3, t) {
    if (!e3) {
      const { data: s7 } = await j(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: has("featurelayer-advanced-symbols") ? { returnAdvancedSymbols: true } : {}, signal: t }));
      e3 = s7;
    }
    this.sourceJSON = await this._patchServiceJSON(e3, t);
    const s6 = e3.type;
    if (!k2.has(s6))
      throw new s2("feature-layer-source:unsupported-type", `Source type "${s6}" is not supported`);
  }
  async _patchServiceJSON(e3, t) {
    var _a;
    if ("Table" !== e3.type && e3.geometryType && !((_a = e3 == null ? void 0 : e3.drawingInfo) == null ? void 0 : _a.renderer) && !e3.defaultSymbol) {
      const t2 = o2(e3.geometryType).renderer;
      o("drawingInfo.renderer", t2, e3);
    }
    if ("esriGeometryMultiPatch" === e3.geometryType && e3.infoFor3D && (e3.geometryType = "mesh"), null == e3.extent)
      try {
        const { data: s6 } = await j(this.layer.url, this._getLayerRequestOptions({ signal: t }));
        s6.spatialReference && (e3.extent = { xmin: 0, ymin: 0, xmax: 0, ymax: 0, spatialReference: s6.spatialReference });
      } catch (s6) {
        f(s6);
      }
    return e3;
  }
  async _getFeatureJSON(e3, t) {
    const { geometry: s6 } = e3, r3 = { ...e3.attributes };
    if (null != t && "mesh" === (s6 == null ? void 0 : s6.type)) {
      const { transformFieldRoles: e4 } = t, { origin: a2, spatialReference: i2, transform: o3 } = s6, n3 = this.layer.spatialReference;
      await Rn(i2, n3);
      const u = nn(a2, n3);
      if (r3[e4.originX] = u.x, r3[e4.originY] = u.y, r3[e4.originZ] = u.z ?? 0, null != o3) {
        const { translation: t2, scale: a3, rotation: u2 } = o3, { vertexSpace: l } = s6, d = l.isGeoreferenced ? 1 : W(i2) / W(n3);
        r3[e4.translationX] = t2[0] * d, r3[e4.translationY] = -t2[2] * d, r3[e4.translationZ] = t2[1] * d, r3[e4.scaleX] = a3[0], r3[e4.scaleY] = a3[2], r3[e4.scaleZ] = a3[1], r3[e4.rotationX] = u2[0], r3[e4.rotationY] = u2[2], r3[e4.rotationZ] = u2[1], r3[e4.rotationDeg] = u2[3];
      }
      return { geometry: null, attributes: r3 };
    }
    return null == s6 ? { attributes: r3 } : "mesh" === s6.type || "extent" === s6.type ? null : { geometry: s6.toJSON(), attributes: r3 };
  }
  async _getAttachmentEditsJSON(e3) {
    const t = await Promise.all((e3.addAttachments ?? []).map((e4) => this._getAttachmentEditJSON(e4))), s6 = await Promise.all((e3.updateAttachments ?? []).map((e4) => this._getAttachmentEditJSON(e4))), r3 = e3.deleteAttachments ?? [];
    return t.length || s6.length || r3.length ? { adds: t, updates: s6, deletes: [...r3] } : null;
  }
  async _getAttachmentEditJSON(e3) {
    const { feature: t, attachment: s6 } = e3, { globalId: r3, name: a2, contentType: i2, data: o3, uploadId: n3 } = s6, u = { globalId: r3, parentGlobalId: null, contentType: null, name: null, uploadId: null, data: null };
    if (t && (u.parentGlobalId = "attributes" in t ? t.attributes && t.attributes[this.layer.globalIdField] : t.globalId), n3)
      u.uploadId = n3;
    else if (o3) {
      const e4 = await Jt(o3);
      e4 && (u.contentType = e4.mediaType, u.data = e4.data), o3 instanceof File && (u.name = o3.name);
    }
    return a2 && (u.name = a2), i2 && (u.contentType = i2), u;
  }
  async _uploadMeshesAndGetAssetMapEditsJSON(e3) {
    const { addAssetFeatures: t } = e3;
    if (!(t == null ? void 0 : t.length))
      return null;
    const s6 = await this._filterRedundantAssetMaps(t);
    if (!(t == null ? void 0 : t.length))
      return null;
    const r3 = new Array(), a2 = /* @__PURE__ */ new Map();
    for (const i2 of s6) {
      const { geometry: e4 } = i2, { vertexSpace: t2 } = e4;
      if (t2.isRelative)
        r3.push(e4);
      else {
        const t3 = n2(e4);
        a2.set(t3, e4), i2.geometry = t3, r3.push(t3);
      }
    }
    await this.uploadAssets(r3);
    for (const [i2, o3] of a2)
      o3.addExternalSources(i2.metadata.externalSources.items);
    return { adds: this._getAssetMapEditsJSON(s6), updates: [], deletes: [] };
  }
  _getAssetMapEditsJSON(e3) {
    const t = new Array(), s6 = this.layer.globalIdField, r3 = this.layer.parsedUrl;
    for (const a2 of e3) {
      const e4 = a2.geometry, { metadata: i2 } = e4, o3 = i2.getExternalSourcesOnService(r3), n3 = a2.getAttribute(s6);
      if (0 === o3.length) {
        s.getLogger(this).error(`Skipping feature ${n3}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);
        continue;
      }
      const { source: u } = o3.find(A) ?? o3[0], { vertexSpace: d } = e4, c2 = d.isGeoreferenced ? ["PROJECT_VERTICES"] : [];
      for (const s7 of u)
        1 === s7.parts.length ? t.push({ globalId: r(), parentGlobalId: n3, assetName: s7.assetName, assetHash: s7.parts[0].partHash, flags: c2 }) : s.getLogger(this).error(`Skipping asset ${s7.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);
    }
    return t;
  }
  _getFeatureIds(e3, t) {
    if (!e3 || 0 === e3.length)
      return [];
    if (t && b2(e3))
      return e3.map((e4) => e4.globalId);
    if (f3(e3))
      return e3.map((e4) => e4.objectId);
    const { layer: s6 } = this, r3 = t ? s6.globalIdField : s6.objectIdField;
    return r3 ? e3.map((e4) => e4.getAttribute(r3)) : [];
  }
  _createEditsResult(e3) {
    var _a, _b, _c, _d, _e, _f;
    const t = e3.data, { layerId: s6 } = this.layer, r3 = [];
    let a2 = null;
    if (Array.isArray(t))
      for (const u of t)
        r3.push({ id: u.id, editedFeatures: u.editedFeatures }), u.id === s6 && (a2 = { addResults: u.addResults ?? [], updateResults: u.updateResults ?? [], deleteResults: u.deleteResults ?? [], attachments: u.attachments, editMoment: u.editMoment });
    else
      a2 = t;
    const i2 = a2 == null ? void 0 : a2.assetMaps;
    if (i2) {
      for (const e4 of i2.addResults)
        e4.success || s.getLogger(this).error(`Failed to map asset to feature with globalId ${e4.globalId}.`);
      for (const e4 of i2.updateResults)
        e4.success || s.getLogger(this).error(`Failed to map asset to feature with globalId ${e4.globalId}.`);
    }
    const o3 = a2 == null ? void 0 : a2.attachments, n3 = { addFeatureResults: ((_a = a2 == null ? void 0 : a2.addResults) == null ? void 0 : _a.map(this._createFeatureEditResult, this)) ?? [], updateFeatureResults: ((_b = a2 == null ? void 0 : a2.updateResults) == null ? void 0 : _b.map(this._createFeatureEditResult, this)) ?? [], deleteFeatureResults: ((_c = a2 == null ? void 0 : a2.deleteResults) == null ? void 0 : _c.map(this._createFeatureEditResult, this)) ?? [], addAttachmentResults: o3 && o3.addResults ? o3.addResults.map(this._createFeatureEditResult, this) : [], updateAttachmentResults: o3 && o3.updateResults ? o3.updateResults.map(this._createFeatureEditResult, this) : [], deleteAttachmentResults: o3 && o3.deleteResults ? o3.deleteResults.map(this._createFeatureEditResult, this) : [] };
    if ((a2 == null ? void 0 : a2.editMoment) && (n3.editMoment = a2.editMoment), r3.length > 0) {
      n3.editedFeatureResults = [];
      for (const e4 of r3) {
        const { editedFeatures: t2 } = e4, s7 = (t2 == null ? void 0 : t2.spatialReference) ? new f2(t2.spatialReference) : null;
        n3.editedFeatureResults.push({ layerId: e4.id, editedFeatures: { adds: ((_d = t2 == null ? void 0 : t2.adds) == null ? void 0 : _d.map((e5) => this._createEditedFeature(e5, s7))) || [], updates: ((_e = t2 == null ? void 0 : t2.updates) == null ? void 0 : _e.map((e5) => ({ original: this._createEditedFeature(e5[0], s7), current: this._createEditedFeature(e5[1], s7) }))) || [], deletes: ((_f = t2 == null ? void 0 : t2.deletes) == null ? void 0 : _f.map((e5) => this._createEditedFeature(e5, s7))) || [], spatialReference: s7 } });
      }
    }
    return n3;
  }
  _createEditedFeature(e3, s6) {
    return new h({ attributes: e3.attributes, geometry: p({ ...e3.geometry, spatialReference: s6 }) });
  }
  _createFeatureEditResult(e3) {
    const t = true === e3.success ? null : e3.error || { code: void 0, description: void 0 };
    return { objectId: e3.objectId, globalId: e3.globalId, error: t ? new s2("feature-layer-source:edit-failure", t.description, { code: t.code }) : null };
  }
  _createAttachmentErrorResult(e3, t) {
    const s6 = t.details.messages && t.details.messages[0] || t.message, r3 = t.details.httpStatus || t.details.messageCode;
    return { objectId: e3, globalId: null, error: new s2("feature-layer-source:attachment-failure", s6, { code: r3 }) };
  }
  _getFormDataForAttachment(e3, t) {
    const s6 = e3 instanceof FormData ? e3 : e3 && e3.elements ? new FormData(e3) : null;
    if (s6)
      for (const r3 in t) {
        const e4 = t[r3];
        null != e4 && (s6.set ? s6.set(r3, e4) : s6.append(r3, e4));
      }
    return s6;
  }
  _getLayerRequestOptions(e3 = {}) {
    const { parsedUrl: t, gdbVersion: s6, dynamicDataSource: r3 } = this.layer;
    return { ...e3, query: { gdbVersion: s6, layer: r3 ? JSON.stringify({ source: r3 }) : void 0, ...t.query, f: "json", ...this._createRequestQueryOptions(e3) }, responseType: "json" };
  }
  async _filterRedundantAssetMaps(e3) {
    const { layer: t } = this, { globalIdField: s6, infoFor3D: r3, parsedUrl: a2 } = t;
    if (null == r3 || null == s6)
      return e3;
    const o3 = m2(r3);
    if (null == o3)
      return e3;
    const n3 = V(a2.path, `../${o3.id}`), u = new Array(), l = new Array();
    for (const i2 of e3)
      i2.geometry.metadata.getExternalSourcesOnService(a2).length > 0 ? l.push(i2) : u.push(i2);
    const d = l.map((e4) => e4.getAttribute(s6)).filter(R);
    if (0 === d.length)
      return e3;
    const { assetMapFieldRoles: { parentGlobalId: c2, assetHash: p2 } } = r3, h2 = new b();
    h2.where = `${c2} IN (${d.map((e4) => `'${e4}'`)})`, h2.outFields = [p2, c2], h2.returnGeometry = false;
    const y2 = await s4(n3, h2), { features: f4 } = y2;
    return 0 === f4.length ? e3 : [...u, ...l.filter((e4) => {
      const t2 = e4.getAttribute(s6);
      if (!t2)
        return true;
      const { metadata: r4 } = e4.geometry, i2 = f4.filter((e5) => e5.getAttribute(c2) === t2);
      if (0 === i2.length)
        return true;
      const o4 = i2.map((e5) => e5.getAttribute(p2));
      return r4.getExternalSourcesOnService(a2).flatMap(({ source: e5 }) => e5.flatMap((e6) => e6.parts.map((e7) => e7.partHash))).some((e5) => o4.every((t3) => e5 !== t3));
    })];
  }
};
e([y()], C.prototype, "type", void 0), e([y({ constructOnly: true })], C.prototype, "layer", void 0), e([y({ readOnly: true })], C.prototype, "queryTask", null), C = e([a("esri.layers.graphics.sources.FeatureLayerSource")], C);
var D = 1e3;
var L = C;
export {
  L as default
};
//# sourceMappingURL=FeatureLayerSource-CARLIMSS.js.map
