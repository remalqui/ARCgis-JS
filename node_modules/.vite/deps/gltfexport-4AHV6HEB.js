import {
  a,
  c as c2,
  g,
  r as r3
} from "./chunk-QVFTB6AS.js";
import {
  t as t2
} from "./chunk-OP5PHDH5.js";
import "./chunk-MT6BDG6P.js";
import {
  c2 as c
} from "./chunk-6ZYJGHGB.js";
import {
  C,
  D
} from "./chunk-BCDDCNQ2.js";
import {
  E2 as E
} from "./chunk-FQ5QI2CC.js";
import "./chunk-QQMWRKOQ.js";
import {
  K,
  k
} from "./chunk-2CQBXY7G.js";
import {
  p
} from "./chunk-SUQV3FHQ.js";
import {
  e as e2,
  o as o2,
  r as r2
} from "./chunk-AEPMR2T7.js";
import "./chunk-EF6YPOUN.js";
import {
  m
} from "./chunk-T5KDTHII.js";
import "./chunk-GXWNOUDM.js";
import "./chunk-AYMF6OMA.js";
import "./chunk-FJXAEGHD.js";
import "./chunk-DTEODQ6R.js";
import "./chunk-SS33L3LC.js";
import "./chunk-X4Y5OF5X.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import {
  M
} from "./chunk-MOPR7RFH.js";
import {
  F,
  _2 as _,
  e2 as e,
  f,
  l,
  n,
  o,
  t,
  z
} from "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-3GSONYPC.js";
import {
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import {
  r
} from "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  lt
} from "./chunk-O3CHVGVF.js";
import {
  j
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import {
  L
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var t3;
!function(t4) {
  t4[t4.JSON = 1313821514] = "JSON", t4[t4.BIN = 5130562] = "BIN";
}(t3 || (t3 = {}));
var e3 = class _e {
  constructor(i2, r7) {
    if (!i2)
      throw new Error("GLB requires a JSON gltf chunk");
    this._length = _e.HEADER_SIZE, this._length += _e.CHUNK_HEADER_SIZE;
    const n2 = this._textToArrayBuffer(i2);
    if (this._length += this._alignTo(n2.byteLength, 4), r7 && (this._length += _e.CHUNK_HEADER_SIZE, this._length += r7.byteLength, r7.byteLength % 4))
      throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this._length), this._outView = new DataView(this.buffer), this._writeHeader();
    const h = this._writeChunk(n2, 12, t3.JSON, 32);
    r7 && this._writeChunk(r7, h, t3.BIN);
  }
  _writeHeader() {
    this._outView.setUint32(0, _e.MAGIC, true), this._outView.setUint32(4, _e.VERSION, true), this._outView.setUint32(8, this._length, true);
  }
  _writeChunk(t4, e4, i2, r7 = 0) {
    const n2 = this._alignTo(t4.byteLength, 4);
    for (this._outView.setUint32(e4, n2, true), this._outView.setUint32(e4 += 4, i2, true), this._writeArrayBuffer(this._outView.buffer, t4, e4 += 4, 0, t4.byteLength), e4 += t4.byteLength; e4 % 4; )
      r7 && this._outView.setUint8(e4, r7), e4++;
    return e4;
  }
  _writeArrayBuffer(t4, e4, i2, r7, n2) {
    new Uint8Array(t4, i2, n2).set(new Uint8Array(e4, r7, n2), 0);
  }
  _textToArrayBuffer(t4) {
    return new TextEncoder().encode(t4).buffer;
  }
  _alignTo(t4, e4) {
    return e4 * Math.ceil(t4 / e4);
  }
};
e3.HEADER_SIZE = 12, e3.CHUNK_HEADER_SIZE = 8, e3.MAGIC = 1179937895, e3.VERSION = 2;

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/types.js
var E2;
var A;
var R;
var L2;
var o3;
var I;
var N;
!function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(E2 || (E2 = {})), function(E3) {
  E3[E3.External = 0] = "External", E3[E3.DataURI = 1] = "DataURI", E3[E3.GLB = 2] = "GLB";
}(A || (A = {})), function(E3) {
  E3[E3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", E3[E3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(R || (R = {})), function(E3) {
  E3.SCALAR = "SCALAR", E3.VEC2 = "VEC2", E3.VEC3 = "VEC3", E3.VEC4 = "VEC4", E3.MAT2 = "MAT2", E3.MAT3 = "MAT3", E3.MAT4 = "MAT4";
}(L2 || (L2 = {})), function(E3) {
  E3[E3.POINTS = 0] = "POINTS", E3[E3.LINES = 1] = "LINES", E3[E3.LINE_LOOP = 2] = "LINE_LOOP", E3[E3.LINE_STRIP = 3] = "LINE_STRIP", E3[E3.TRIANGLES = 4] = "TRIANGLES", E3[E3.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", E3[E3.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
}(o3 || (o3 = {})), function(E3) {
  E3.OPAQUE = "OPAQUE", E3.MASK = "MASK", E3.BLEND = "BLEND";
}(I || (I = {})), function(E3) {
  E3[E3.NoColor = 0] = "NoColor", E3[E3.FaceColor = 1] = "FaceColor", E3[E3.VertexColor = 2] = "VertexColor";
}(N || (N = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var r4 = class {
  constructor(e4, s4, i2, r7, n2) {
    this._buffer = e4, this._componentType = i2, this._dataType = r7, this._data = [], this._isFinalized = false, this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, s4.bufferViews || (s4.bufferViews = []), this.index = s4.bufferViews.length, this._bufferView = { buffer: e4.index, byteLength: -1, target: n2 };
    const a3 = this._getElementSize();
    a3 >= 4 && n2 !== R.ELEMENT_ARRAY_BUFFER && (this._bufferView.byteStride = a3), s4.bufferViews.push(this._bufferView), this._numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e4) {
    const t4 = this._data.length;
    if (this._data.push(e4), this._accessorIndex >= 0) {
      const s4 = t4 % this._numComponentsForDataType, i2 = this._accessorMin[s4];
      this._accessorMin[s4] = "number" != typeof i2 ? e4 : Math.min(i2, e4);
      const r7 = this._accessorMax[s4];
      this._accessorMax[s4] = "number" != typeof r7 ? e4 : Math.max(r7, e4);
    }
  }
  get dataSize() {
    return this._data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e4(e5, t4) {
      return t4 * Math.ceil(e5 / t4);
    }
    return e4(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this._isFinalized)
      throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  _createTypedArray(e4, t4) {
    switch (this._componentType) {
      case C.BYTE:
        return new Int8Array(e4, t4);
      case C.FLOAT:
        return new Float32Array(e4, t4);
      case C.SHORT:
        return new Int16Array(e4, t4);
      case C.UNSIGNED_BYTE:
        return new Uint8Array(e4, t4);
      case C.UNSIGNED_INT:
        return new Uint32Array(e4, t4);
      case C.UNSIGNED_SHORT:
        return new Uint16Array(e4, t4);
    }
  }
  writeOutToBuffer(e4, t4) {
    this._createTypedArray(e4, t4).set(this._data);
  }
  writeAsync(e4) {
    if (this._asyncWritePromise)
      throw new Error("Can't write multiple bufferView values asynchronously");
    return this._asyncWritePromise = e4.then((e5) => {
      const t4 = new Uint8Array(e5);
      for (let s4 = 0; s4 < t4.length; ++s4)
        this._data.push(t4[s4]);
      delete this._asyncWritePromise;
    }), this._asyncWritePromise;
  }
  startAccessor(e4) {
    if (this._accessorIndex >= 0)
      throw new Error("Accessor was started without ending the previous one");
    this._accessorIndex = this._data.length, this._accessorAttribute = e4;
    const t4 = this._numComponentsForDataType;
    this._accessorMin = new Array(t4), this._accessorMax = new Array(t4);
  }
  endAccessor() {
    if (this._accessorIndex < 0)
      throw new Error("An accessor was not started, but was attempted to be ended");
    const e4 = this._getElementSize(), t4 = this._numComponentsForDataType, s4 = (this._data.length - this._accessorIndex) / t4;
    if (s4 % 1)
      throw new Error("An accessor was ended with missing component values");
    for (let i2 = 0; i2 < this._accessorMin.length; ++i2)
      "number" != typeof this._accessorMin[i2] && (this._accessorMin[i2] = 0), "number" != typeof this._accessorMax[i2] && (this._accessorMax[i2] = 0);
    const r7 = { byteOffset: e4 * (this._accessorIndex / t4), componentType: this._componentType, count: s4, type: this._dataType, min: this._accessorMin, max: this._accessorMax, name: this._accessorAttribute };
    switch (this._accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this._componentType) {
          case C.UNSIGNED_BYTE:
          case C.UNSIGNED_SHORT:
            r7.normalized = true;
        }
    }
    return this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, r7;
  }
  get finalized() {
    return this._finalizedPromise ? this._finalizedPromise : this._isFinalized ? this._finalizedPromise = Promise.resolve() : this._finalizedPromise = new Promise((e4) => this._finalizedPromiseResolve = e4);
  }
  finalize() {
    const t4 = this._bufferView;
    return new Promise((t5) => {
      const s4 = this._buffer.getViewFinalizePromises(this);
      this._asyncWritePromise && s4.push(this._asyncWritePromise), t5(j(s4));
    }).then(() => {
      this._isFinalized = true, t4.byteOffset = this.getByteOffset(), t4.byteLength = this.dataSize, this._finalizedPromiseResolve && this._finalizedPromiseResolve();
    });
  }
  _getElementSize() {
    return this._sizeComponentType() * this._numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this._componentType) {
      case C.BYTE:
      case C.UNSIGNED_BYTE:
        return 1;
      case C.SHORT:
      case C.UNSIGNED_SHORT:
        return 2;
      case C.UNSIGNED_INT:
      case C.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this._dataType) {
      case L2.SCALAR:
        return 1;
      case L2.VEC2:
        return 2;
      case L2.VEC3:
        return 3;
      case L2.VEC4:
      case L2.MAT2:
        return 4;
      case L2.MAT3:
        return 9;
      case L2.MAT4:
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var r5 = class {
  constructor(e4) {
    this._gltf = e4, this._bufferViews = [], this._isFinalized = false, e4.buffers || (e4.buffers = []), this.index = e4.buffers.length;
    const i2 = { byteLength: -1 };
    e4.buffers.push(i2), this._buffer = i2;
  }
  addBufferView(e4, r7, t4) {
    if (this._finalizePromise)
      throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f5 = new r4(this, this._gltf, e4, r7, t4);
    return this._bufferViews.push(f5), f5;
  }
  getByteOffset(e4) {
    let i2 = 0;
    for (const r7 of this._bufferViews) {
      if (r7 === e4)
        return i2;
      i2 += r7.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e4) {
    const i2 = [];
    for (const r7 of this._bufferViews) {
      if (e4 && r7 === e4)
        return i2;
      i2.push(r7.finalized);
    }
    return i2;
  }
  getArrayBuffer() {
    if (!this._isFinalized)
      throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e4 = this._getTotalSize(), i2 = new ArrayBuffer(e4);
    let r7 = 0;
    for (const t4 of this._bufferViews)
      t4.writeOutToBuffer(i2, r7), r7 += t4.byteSize;
    return i2;
  }
  finalize() {
    var _a;
    if (this._finalizePromise)
      throw new Error(`Buffer ${this.index} was already finalized`);
    return this._finalizePromise = new Promise((i2) => {
      i2(j(this.getViewFinalizePromises()));
    }).then(() => {
      this._isFinalized = true;
      const e4 = this.getArrayBuffer();
      this._buffer.byteLength = e4.byteLength, this._buffer.uri = e4;
    }), (_a = this._gltf.extras) == null ? void 0 : _a.promises.push(this._finalizePromise), this._finalizePromise;
  }
  _getTotalSize() {
    let e4 = 0;
    for (const i2 of this._bufferViews)
      e4 += i2.byteSize;
    return e4;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function r6(n2, t4) {
  if (n2.components)
    for (const e4 of n2.components)
      e4.faces && "smooth" === e4.shading && a2(e4, t4);
}
function a2(s4, i2) {
  null == i2.normal && (i2.normal = new Float32Array(i2.position.length));
  const r7 = s4.faces, { position: a3, normal: c4 } = i2, h = r7.length / 3;
  for (let o4 = 0; o4 < h; ++o4) {
    const s5 = 3 * r7[3 * o4], i3 = 3 * r7[3 * o4 + 1], p4 = 3 * r7[3 * o4 + 2], h2 = o(f2, a3[s5], a3[s5 + 1], a3[s5 + 2]), u2 = o(l2, a3[i3], a3[i3 + 1], a3[i3 + 2]), g2 = o(m2, a3[p4], a3[p4 + 1], a3[p4 + 2]), x2 = e(u2, u2, h2), v = e(g2, g2, h2), R2 = _(x2, x2, v);
    c4[s5] += R2[0], c4[s5 + 1] += R2[1], c4[s5 + 2] += R2[2], c4[i3] += R2[0], c4[i3 + 1] += R2[1], c4[i3 + 2] += R2[2], c4[p4] += R2[0], c4[p4 + 1] += R2[1], c4[p4 + 2] += R2[2];
  }
  for (let t4 = 0; t4 < c4.length; t4 += 3)
    o(p2, c4[t4], c4[t4 + 1], c4[t4 + 2]), z(p2, p2), c4[t4] = p2[0], c4[t4 + 1] = p2[1], c4[t4 + 2] = p2[2];
}
function c3(n2) {
  const { vertexSpace: t4 } = n2;
  if (t4.isRelative)
    return t4.getOriginPoint(n2.spatialReference);
  const { extent: e4 } = n2, o4 = e4.xmax - e4.width / 2, s4 = e4.ymax - e4.height / 2, r7 = e4.zmin;
  return new x({ x: o4, y: s4, z: r7, spatialReference: e4.spatialReference });
}
var f2 = n();
var l2 = n();
var m2 = n();
var p2 = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var I2 = s.getLogger("gltf");
var N2 = class {
  constructor(e4, t4, s4) {
    this.params = {}, this._materialMap = new Array(), this._imageMap = /* @__PURE__ */ new Map(), this._textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e4.copyright, generator: e4.generator }, extras: { options: t4, binChunkBuffer: null, promises: [] } }, s4 && (this.params = s4), this._addScenes(e4);
  }
  _addScenes(e4) {
    this.gltf.scene = e4.defaultScene;
    const t4 = this.gltf.extras, s4 = t4.options.bufferOutputType === E2.GLB || t4.options.imageOutputType === A.GLB;
    s4 && (t4.binChunkBuffer = new r5(this.gltf)), e4.forEachScene((e5) => {
      this._addScene(e5);
    }), s4 && t4.binChunkBuffer.finalize();
  }
  _addScene(e4) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name), e4.forEachNode((e5) => {
      t4.nodes || (t4.nodes = []);
      const s4 = this._addNode(e5);
      t4.nodes.push(s4);
    }), this.gltf.scenes.push(t4);
  }
  _addNode(e4) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name);
    const s4 = e4.translation;
    F(s4, f) || (t4.translation = t(s4));
    const h = e4.rotation;
    K(h, o2) || (t4.rotation = r2(h));
    const u2 = e4.scale;
    F(u2, l) || (t4.scale = t(u2)), e4.mesh && e4.mesh.vertexAttributes.position ? t4.mesh = this._addMesh(e4.mesh) : e4.forEachNode((e5) => {
      t4.children || (t4.children = []);
      const s5 = this._addNode(e5);
      t4.children.push(s5);
    });
    const f5 = this.gltf.nodes.length;
    return this.gltf.nodes.push(t4), f5;
  }
  _addMesh(e4) {
    this.gltf.meshes || (this.gltf.meshes = []);
    const t4 = { primitives: [] }, s4 = this.gltf.extras, r7 = s4.options.bufferOutputType === E2.GLB;
    let i2;
    i2 = r7 ? s4.binChunkBuffer : new r5(this.gltf), this.params.origin || (this.params.origin = c3(e4));
    const { ignoreLocalTransform: a3 } = this.params, o4 = a3 ? null : e4.transform, { vertexSpace: n2 } = e4, c4 = a3 ? n2.isRelative ? new m({ origin: t(n2.origin) }) : new p() : n2, f5 = E(e4.vertexAttributes, c4, o4, this.params.origin, { geographic: this.params.geographic, unit: "meters" });
    r6(e4, f5), this._flipYZAxis(f5);
    const x2 = i2.addBufferView(C.FLOAT, L2.VEC3, R.ARRAY_BUFFER);
    let A2, b, E3, M2;
    f5.normal && (A2 = i2.addBufferView(C.FLOAT, L2.VEC3, R.ARRAY_BUFFER)), e4.vertexAttributes.uv && (b = i2.addBufferView(C.FLOAT, L2.VEC2, R.ARRAY_BUFFER)), f5.tangent && (E3 = i2.addBufferView(C.FLOAT, L2.VEC4, R.ARRAY_BUFFER)), e4.vertexAttributes.color && (M2 = i2.addBufferView(C.UNSIGNED_BYTE, L2.VEC4, R.ARRAY_BUFFER)), x2.startAccessor("POSITION"), A2 && A2.startAccessor("NORMAL"), b && b.startAccessor("TEXCOORD_0"), E3 && E3.startAccessor("TANGENT"), M2 && M2.startAccessor("COLOR_0");
    const w = f5.position.length / 3, { position: I3, normal: N3, tangent: B } = f5, { color: C2, uv: v } = e4.vertexAttributes;
    for (let l3 = 0; l3 < w; ++l3)
      x2.push(I3[3 * l3]), x2.push(I3[3 * l3 + 1]), x2.push(I3[3 * l3 + 2]), A2 && null != N3 && (A2.push(N3[3 * l3]), A2.push(N3[3 * l3 + 1]), A2.push(N3[3 * l3 + 2])), b && null != v && (b.push(v[2 * l3]), b.push(v[2 * l3 + 1])), E3 && null != B && (E3.push(B[4 * l3]), E3.push(B[4 * l3 + 1]), E3.push(B[4 * l3 + 2]), E3.push(B[4 * l3 + 3])), M2 && null != C2 && (M2.push(C2[4 * l3]), M2.push(C2[4 * l3 + 1]), M2.push(C2[4 * l3 + 2]), M2.push(C2[4 * l3 + 3]));
    const S = x2.endAccessor(), L3 = this._addAccessor(x2.index, S);
    let F2, y, k2, V, j2;
    if (A2) {
      const e5 = A2.endAccessor();
      F2 = this._addAccessor(A2.index, e5);
    }
    if (b) {
      const e5 = b.endAccessor();
      y = this._addAccessor(b.index, e5);
    }
    if (E3) {
      const e5 = E3.endAccessor();
      k2 = this._addAccessor(E3.index, e5);
    }
    if (M2) {
      const e5 = M2.endAccessor();
      V = this._addAccessor(M2.index, e5);
    }
    e4.components && e4.components.length > 0 && e4.components[0].faces ? (j2 = i2.addBufferView(C.UNSIGNED_INT, L2.SCALAR, R.ELEMENT_ARRAY_BUFFER), this._addMeshVertexIndexed(j2, e4.components, t4, L3, F2, y, k2, V)) : this._addMeshVertexNonIndexed(e4.components, t4, L3, F2, y, k2, V), x2.finalize(), A2 && A2.finalize(), b && b.finalize(), E3 && E3.finalize(), j2 && j2.finalize(), M2 && M2.finalize(), r7 || i2.finalize();
    const D2 = this.gltf.meshes.length;
    return this.gltf.meshes.push(t4), D2;
  }
  _flipYZAxis({ position: e4, normal: t4, tangent: s4 }) {
    this._flipYZBuffer(e4, 3), this._flipYZBuffer(t4, 3), this._flipYZBuffer(s4, 4);
  }
  _flipYZBuffer(e4, t4) {
    if (null != e4)
      for (let s4 = 1, r7 = 2; s4 < e4.length; s4 += t4, r7 += t4) {
        const t5 = e4[s4], i2 = e4[r7];
        e4[s4] = i2, e4[r7] = -t5;
      }
  }
  _addMaterial(e4) {
    if (null === e4)
      return;
    const t4 = this._materialMap.indexOf(e4);
    if (-1 !== t4)
      return t4;
    this.gltf.materials || (this.gltf.materials = []);
    const s4 = {};
    switch (e4.alphaMode) {
      case "mask":
        s4.alphaMode = I.MASK;
        break;
      case "auto":
      case "blend":
        s4.alphaMode = I.BLEND;
    }
    0.5 !== e4.alphaCutoff && (s4.alphaCutoff = e4.alphaCutoff), e4.doubleSided && (s4.doubleSided = e4.doubleSided), s4.pbrMetallicRoughness = {};
    const r7 = (e5) => e5 ** 2.1, i2 = (e5) => {
      const t5 = e5.toRgba();
      return t5[0] = r7(t5[0] / 255), t5[1] = r7(t5[1] / 255), t5[2] = r7(t5[2] / 255), t5;
    };
    if (null != e4.color && (s4.pbrMetallicRoughness.baseColorFactor = i2(e4.color)), null != e4.colorTexture && (s4.pbrMetallicRoughness.baseColorTexture = this._createTextureInfo(e4.colorTexture, e4.colorTextureTransform)), null != e4.normalTexture && (s4.normalTexture = this._createTextureInfo(e4.normalTexture, e4.normalTextureTransform)), e4 instanceof c) {
      if (null != e4.emissiveTexture && (s4.emissiveTexture = this._createTextureInfo(e4.emissiveTexture, e4.emissiveTextureTransform)), null != e4.emissiveColor) {
        const t5 = i2(e4.emissiveColor);
        s4.emissiveFactor = [t5[0], t5[1], t5[2]];
      }
      null != e4.occlusionTexture && (s4.occlusionTexture = this._createTextureInfo(e4.occlusionTexture, e4.occlusionTextureTransform)), null != e4.metallicRoughnessTexture && (s4.pbrMetallicRoughness.metallicRoughnessTexture = this._createTextureInfo(e4.metallicRoughnessTexture, e4.metallicRoughnessTextureTransform)), s4.pbrMetallicRoughness.metallicFactor = e4.metallic, s4.pbrMetallicRoughness.roughnessFactor = e4.roughness;
    } else
      s4.pbrMetallicRoughness.metallicFactor = 1, s4.pbrMetallicRoughness.roughnessFactor = 1, I2.warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");
    const a3 = this.gltf.materials.length;
    return this.gltf.materials.push(s4), this._materialMap.push(e4), a3;
  }
  _createTextureInfo(e4, t4) {
    const r7 = { index: this._addTexture(e4) };
    return t4 ? (r7.extensions || (r7.extensions = {}), r7.extensions.KHR_texture_transform = { scale: t4.scale, offset: t4.offset, rotation: M(t4.rotation) }, r7) : r7;
  }
  _addTexture(e4) {
    const s4 = this.gltf.textures ?? [];
    return this.gltf.textures = s4, r(this._textureMap, e4, () => {
      const t4 = { sampler: this._addSampler(e4), source: this._addImage(e4) }, r7 = s4.length;
      return s4.push(t4), r7;
    });
  }
  _addImage(e4) {
    const t4 = this._imageMap.get(e4);
    if (null != t4)
      return t4;
    this.gltf.images || (this.gltf.images = []);
    const s4 = {};
    if (e4.url)
      s4.uri = e4.url;
    else {
      const t5 = e4.data;
      s4.extras = t5;
      for (let e5 = 0; e5 < this.gltf.images.length; ++e5)
        if (t5 === this.gltf.images[e5].extras)
          return e5;
      const r8 = this.gltf.extras;
      switch (r8.options.imageOutputType) {
        case A.GLB: {
          const e5 = r8.binChunkBuffer.addBufferView(C.UNSIGNED_BYTE, L2.SCALAR);
          if (t2(t5))
            null != t5.data && e5.writeOutToBuffer(t5.data, 0);
          else {
            const r9 = r3(t5).then(({ data: e6, type: t6 }) => (s4.mimeType = t6, e6));
            e5.writeAsync(r9).then(() => {
              e5.finalize();
            });
          }
          s4.bufferView = e5.index;
          break;
        }
        case A.DataURI:
          if (t2(t5)) {
            I2.warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          s4.uri = a(t5);
          break;
        default:
          if (t2(t5)) {
            I2.warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          r8.promises.push(r3(t5).then(({ data: e5, type: t6 }) => {
            s4.uri = e5, s4.mimeType = t6;
          }));
      }
    }
    const r7 = this.gltf.images.length;
    return this.gltf.images.push(s4), this._imageMap.set(e4, r7), r7;
  }
  _addSampler(e4) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t4 = D.REPEAT, s4 = D.REPEAT;
    if ("string" == typeof e4.wrap)
      switch (e4.wrap) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE, s4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT, s4 = D.MIRRORED_REPEAT;
      }
    else {
      switch (e4.wrap.vertical) {
        case "clamp":
          s4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          s4 = D.MIRRORED_REPEAT;
      }
      switch (e4.wrap.horizontal) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT;
      }
    }
    const r7 = { wrapS: t4, wrapT: s4 };
    for (let a3 = 0; a3 < this.gltf.samplers.length; ++a3)
      if (JSON.stringify(r7) === JSON.stringify(this.gltf.samplers[a3]))
        return a3;
    const i2 = this.gltf.samplers.length;
    return this.gltf.samplers.push(r7), i2;
  }
  _addAccessor(e4, t4) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s4 = { bufferView: e4, byteOffset: t4.byteOffset, componentType: t4.componentType, count: t4.count, type: t4.type, min: t4.min, max: t4.max, name: t4.name };
    t4.normalized && (s4.normalized = true);
    const r7 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s4), r7;
  }
  _addMeshVertexIndexed(e4, t4, s4, r7, i2, a3, o4, n2) {
    for (const l3 of t4) {
      e4.startAccessor("INDICES");
      for (let s5 = 0; s5 < l3.faces.length; ++s5)
        e4.push(l3.faces[s5]);
      const t5 = e4.endAccessor(), c4 = { attributes: { POSITION: r7 }, indices: this._addAccessor(e4.index, t5), material: this._addMaterial(l3.material) };
      i2 && "flat" !== l3.shading && (c4.attributes.NORMAL = i2), a3 && (c4.attributes.TEXCOORD_0 = a3), o4 && "flat" !== l3.shading && (c4.attributes.TANGENT = o4), n2 && (c4.attributes.COLOR_0 = n2), s4.primitives.push(c4);
    }
  }
  _addMeshVertexNonIndexed(e4, t4, s4, r7, i2, a3, o4) {
    const n2 = { attributes: { POSITION: s4 } };
    r7 && (n2.attributes.NORMAL = r7), i2 && (n2.attributes.TEXCOORD_0 = i2), a3 && (n2.attributes.TANGENT = a3), o4 && (n2.attributes.COLOR_0 = o4), e4 && (n2.material = this._addMaterial(e4[0].material)), t4.primitives.push(n2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s2 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e4) {
    if (this._scenes.includes(e4))
      throw new Error("Scene already added");
    this._scenes.push(e4);
  }
  removeScene(s4) {
    L(this._scenes, s4);
  }
  forEachScene(e4) {
    this._scenes.forEach(e4);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2))
      throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var i = class {
  constructor(s4) {
    this.mesh = s4, this.name = "", this.translation = n(), this.rotation = e2(), this.scale = t(l), this._nodes = [];
  }
  addNode(s4) {
    if (this._nodes.includes(s4))
      throw new Error("Node already added");
    this._nodes.push(s4);
  }
  forEachNode(s4) {
    this._nodes.forEach(s4);
  }
  set rotationAngles(t4) {
    k(this.rotation, t4[0], t4[1], t4[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/index.js
var f3 = "model.gltf";
var u = "model.glb";
function p3(p4, m4, c4) {
  var _a;
  const l3 = new N2(p4, m4 = m4 || {}, c4);
  let g2 = l3.params;
  g2 ? g2.origin || (g2.origin = new x({ x: -1, y: -1, z: -1 })) : g2 = { origin: new x({ x: -1, y: -1, z: -1 }) };
  const y = g2.origin, d2 = l3.gltf, j2 = ((_a = d2.extras) == null ? void 0 : _a.promises) ?? [];
  let x2 = 1, b = 1, h = null;
  return j(j2).then(() => {
    const e4 = { origin: y };
    delete d2.extras;
    const t4 = "number" == typeof m4.jsonSpacing ? m4.jsonSpacing : 4, o4 = JSON.stringify(d2, (t5, r7) => {
      if ("extras" !== t5) {
        if (r7 instanceof ArrayBuffer) {
          if (g(r7))
            switch (m4.imageOutputType) {
              case A.DataURI:
              case A.GLB:
                break;
              case A.External:
              default: {
                const t6 = `img${b}.png`;
                return b++, e4[t6] = r7, t6;
              }
            }
          switch (m4.bufferOutputType) {
            case E2.DataURI:
              return c2(r7);
            case E2.GLB:
              if (h)
                throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
              return void (h = r7);
            case E2.External:
            default: {
              const t6 = `data${x2}.bin`;
              return x2++, e4[t6] = r7, t6;
            }
          }
        }
        return r7;
      }
    }, t4);
    return m4.bufferOutputType === E2.GLB || m4.imageOutputType === A.GLB ? e4[u] = new e3(o4, h).buffer : e4[f3] = o4, e4;
  });
}
function m3(e4, t4) {
  return p3(e4, { bufferOutputType: E2.GLB, imageOutputType: A.GLB, jsonSpacing: 0 }, t4);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
var s3 = class {
  constructor(e4, o4) {
    this._file = { type: "model/gltf-binary", data: e4 }, this.origin = o4;
  }
  buffer() {
    return Promise.resolve(this._file);
  }
  download(o4) {
    lt(new Blob([this._file.data], { type: this._file.type }), o4);
  }
};
function f4(e4, f5) {
  const d2 = new s2(), l3 = new d();
  return d2.addScene(l3), l3.addNode(new i(e4)), m3(d2, f5).then((e5) => new s3(e5[u], e5.origin));
}
export {
  f4 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-4AHV6HEB.js.map
