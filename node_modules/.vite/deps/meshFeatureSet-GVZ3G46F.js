import {
  a as a6,
  h as h5,
  i as i2,
  m as m4,
  o as o3
} from "./chunk-5U4S3W7H.js";
import {
  g as g4,
  p as p4
} from "./chunk-25AMRHMP.js";
import "./chunk-6ZYJGHGB.js";
import {
  d
} from "./chunk-RNXN3MSP.js";
import {
  i
} from "./chunk-PR2OEILG.js";
import {
  e as e3
} from "./chunk-7LLYVI2T.js";
import {
  t
} from "./chunk-L7P4URYM.js";
import {
  D,
  E,
  I,
  N,
  O as O2,
  R,
  _ as _2,
  g as g3,
  h as h2,
  h2 as h3,
  j as j2,
  l as l3,
  o as o2,
  q,
  r as r3,
  v,
  w,
  x as x2
} from "./chunk-FQ5QI2CC.js";
import {
  c as c2
} from "./chunk-QQMWRKOQ.js";
import "./chunk-2CQBXY7G.js";
import {
  a as a4,
  e as e6,
  m as m3,
  p as p3,
  t as t2
} from "./chunk-SUQV3FHQ.js";
import "./chunk-AEPMR2T7.js";
import {
  e as e4
} from "./chunk-EF6YPOUN.js";
import {
  m as m2
} from "./chunk-T5KDTHII.js";
import "./chunk-GXWNOUDM.js";
import {
  e as e5
} from "./chunk-AYMF6OMA.js";
import "./chunk-FJXAEGHD.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import "./chunk-DTEODQ6R.js";
import {
  h as h4
} from "./chunk-4SARN32Z.js";
import "./chunk-QA4FMJA6.js";
import "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import {
  a as a3
} from "./chunk-SS33L3LC.js";
import "./chunk-X4Y5OF5X.js";
import {
  a as a5
} from "./chunk-LNMNRMVX.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import {
  l as l2
} from "./chunk-KTEJJM3A.js";
import {
  In,
  zn
} from "./chunk-SO6DBMQG.js";
import {
  g as g2
} from "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  e as e7
} from "./chunk-XR4HIGQP.js";
import "./chunk-KIEN3CY2.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-7KX64CAH.js";
import {
  _
} from "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import {
  h,
  j
} from "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import {
  O2 as O,
  S,
  e2,
  f as f2,
  g,
  n,
  o,
  r as r2,
  u2 as u,
  z
} from "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-CWQ6Q3PH.js";
import {
  l
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import {
  m
} from "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  f,
  p2,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import {
  r
} from "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  G,
  Ut
} from "./chunk-O3CHVGVF.js";
import {
  P,
  a,
  c,
  p,
  s as s3
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function l4(t3) {
  const r4 = f3(t3.rings, t3.hasZ, a7.CCW_IS_HOLE), l7 = new Array();
  let h10 = 0, g9 = 0;
  for (const o4 of r4.polygons) {
    const t4 = o4.count, i4 = o4.index, c6 = a4(r4.position, 3 * i4, 3 * t4), f7 = o4.holeIndices.map((n2) => n2 - i4), a9 = t(i(c6, f7, 3));
    l7.push({ position: c6, faces: a9 }), h10 += c6.length, g9 += a9.length;
  }
  const u5 = c3(l7, h10, g9), p9 = Array.isArray(u5.position) ? e3(u5.position, 3, { originalIndices: u5.faces }) : e3(u5.position.buffer, 6, { originalIndices: u5.faces });
  return u5.position = e6(new Float64Array(p9.buffer)), u5.faces = p9.indices, u5;
}
function c3(n2, t3, e9) {
  if (1 === n2.length)
    return n2[0];
  const o4 = t2(t3), i4 = new Array(e9);
  let l7 = 0, c6 = 0, f7 = 0;
  for (const r4 of n2) {
    for (let n3 = 0; n3 < r4.position.length; n3++)
      o4[l7++] = r4.position[n3];
    for (const n3 of r4.faces)
      i4[c6++] = n3 + f7;
    f7 = l7 / 3;
  }
  return { position: o4, faces: t(i4) };
}
function f3(n2, t3, e9) {
  const o4 = n2.length, s4 = new Array(o4), i4 = new Array(o4), l7 = new Array(o4);
  let c6 = 0, f7 = 0, u5 = 0, p9 = 0;
  for (let r4 = 0; r4 < o4; ++r4)
    p9 += n2[r4].length;
  const d8 = t2(3 * p9);
  let y7 = 0;
  for (let r4 = o4 - 1; r4 >= 0; r4--) {
    const p10 = n2[r4], m9 = e9 === a7.CCW_IS_HOLE && g5(p10);
    if (m9 && 1 !== o4)
      s4[c6++] = p10;
    else {
      let n3 = p10.length;
      for (let t4 = 0; t4 < c6; ++t4)
        n3 += s4[t4].length;
      const e10 = { index: y7, pathLengths: new Array(c6 + 1), count: n3, holeIndices: new Array(c6) };
      e10.pathLengths[0] = p10.length, p10.length > 0 && (l7[u5++] = { index: y7, count: p10.length }), y7 = m9 ? h6(p10, p10.length - 1, -1, d8, y7, p10.length, t3) : h6(p10, 0, 1, d8, y7, p10.length, t3);
      for (let o5 = 0; o5 < c6; ++o5) {
        const n4 = s4[o5];
        e10.holeIndices[o5] = y7, e10.pathLengths[o5 + 1] = n4.length, n4.length > 0 && (l7[u5++] = { index: y7, count: n4.length }), y7 = h6(n4, 0, 1, d8, y7, n4.length, t3);
      }
      c6 = 0, e10.count > 0 && (i4[f7++] = e10);
    }
  }
  for (let r4 = 0; r4 < c6; ++r4) {
    const n3 = s4[r4];
    n3.length > 0 && (l7[u5++] = { index: y7, count: n3.length }), y7 = h6(n3, 0, 1, d8, y7, n3.length, t3);
  }
  return i4.length = f7, l7.length = u5, { position: d8, polygons: i4, outlines: l7 };
}
function h6(n2, t3, e9, o4, r4, s4, i4) {
  r4 *= 3;
  for (let l7 = 0; l7 < s4; ++l7) {
    const s5 = n2[t3];
    o4[r4++] = s5[0], o4[r4++] = s5[1], o4[r4++] = i4 ? s5[2] : 0, t3 += e9;
  }
  return r4 / 3;
}
function g5(n2) {
  return !h(n2, false, false);
}
var a7;
!function(n2) {
  n2[n2.NONE = 0] = "NONE", n2[n2.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(a7 || (a7 = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/bounds.js
function e8({ xmin: t3, xmax: e9, ymin: i4, ymax: o4, zmin: r4, zmax: x6 }, l7, c6, s4) {
  r4 ?? (r4 = 0), x6 ?? (x6 = 0), a8 ?? (a8 = new Float64Array(24));
  const f7 = a8;
  return f7[0] = t3, f7[1] = i4, f7[2] = r4, f7[3] = t3, f7[4] = o4, f7[5] = r4, f7[6] = e9, f7[7] = o4, f7[8] = r4, f7[9] = e9, f7[10] = i4, f7[11] = r4, f7[12] = t3, f7[13] = i4, f7[14] = x6, f7[15] = t3, f7[16] = o4, f7[17] = x6, f7[18] = e9, f7[19] = o4, f7[20] = x6, f7[21] = e9, f7[22] = i4, f7[23] = x6, I({ positions: f7, transform: l7, vertexSpace: c6, inSpatialReference: s4, outSpatialReference: s4, outPositions: f7, local: false }), m5(f7, s4);
}
var a8 = null;
function m5(n2, e9) {
  let a9 = 1 / 0, m9 = 1 / 0, i4 = 1 / 0, o4 = -1 / 0, r4 = -1 / 0, x6 = -1 / 0;
  const l7 = n2.length;
  let c6 = 0;
  for (; c6 < l7; ) {
    const t3 = n2[c6++], e10 = n2[c6++], l8 = n2[c6++];
    a9 = Math.min(a9, t3), m9 = Math.min(m9, e10), i4 = Math.min(i4, l8), o4 = Math.max(o4, t3), r4 = Math.max(r4, e10), x6 = Math.max(x6, l8);
  }
  return new M({ xmin: a9, ymin: m9, zmin: i4, xmax: o4, ymax: r4, zmax: x6, spatialReference: e9 });
}

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var l5 = "esri.geometry.support.meshUtils.centerAt";
function p5(e9, t3, i4) {
  if (!e9.vertexAttributes || !e9.vertexAttributes.position)
    return;
  const { vertexSpace: r4 } = e9, o4 = (i4 == null ? void 0 : i4.origin) ?? e9.origin;
  if (r4.isRelative)
    o2(r4, l5, i4), f4(e9, t3, o4);
  else {
    r3(e9.spatialReference, i4) ? g6(e9, t3, o4) : d2(e9, t3, o4);
  }
}
function f4(n2, s4, a9) {
  const { vertexSpace: c6 } = n2;
  if (!c6.isRelative)
    return;
  const p9 = j3, f7 = u2;
  if (!In(s4, f7, n2.spatialReference))
    return void s.getLogger(l5).error(`Failed to project centerAt location (wkid:${s4.spatialReference.wkid}) to mesh spatial reference (wkid:${n2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  if (!In(a9, p9, n2.spatialReference)) {
    const t3 = n2.origin;
    p9[0] = t3.x, p9[1] = t3.y, p9[2] = t3.z, s.getLogger(l5).error(`Failed to project specified origin (wkid:${a9.spatialReference.wkid}) to mesh spatial reference (wkid:${n2.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  const g9 = e2(b, f7, p9), d8 = c6.origin;
  c6.origin = u(n(), d8, g9);
}
function g6(e9, t3, i4) {
  const r4 = D(e9.vertexAttributes, i4, { geographic: true }), { position: o4, normal: n2, tangent: s4 } = O2(r4, t3, { geographic: true });
  e9.vertexAttributes.position = o4, e9.vertexAttributes.normal = n2, e9.vertexAttributes.tangent = s4, e9.vertexAttributesChanged();
}
function d2(t3, i4, r4) {
  const n2 = j3, s4 = u2;
  if (In(i4, s4, t3.spatialReference)) {
    if (!In(r4, n2, t3.spatialReference)) {
      const i5 = t3.origin;
      n2[0] = i5.x, n2[1] = i5.y, n2[2] = i5.z, s.getLogger(l5).error(`Failed to project specified origin (wkid:${r4.spatialReference.wkid}) to mesh spatial reference (wkid:${t3.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
    }
    m6(t3.vertexAttributes.position, s4, n2), t3.vertexAttributesChanged();
  } else
    s.getLogger(l5).error(`Failed to project centerAt location (wkid:${i4.spatialReference.wkid}) to mesh spatial reference (wkid:${t3.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
}
function m6(e9, t3, i4) {
  if (e9)
    for (let r4 = 0; r4 < e9.length; r4 += 3)
      for (let o4 = 0; o4 < 3; o4++)
        e9[r4 + o4] += t3[o4] - i4[o4];
}
var u2 = n();
var j3 = n();
var b = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function c4(e9, r4, n2) {
  const { source: o4 } = r4, { loadGLTFMesh: i4 } = await p(import("./loadGLTFMesh-DFHDBP3Q.js"), n2), a9 = await f5(o4, n2);
  s3(n2);
  const c6 = i4(new x({ x: 0, y: 0, z: 0, spatialReference: e9.spatialReference }), a9.url, { resolveFile: u3(a9), useTransform: true, signal: n2 == null ? void 0 : n2.signal });
  c6.then(() => a9.dispose(), () => a9.dispose());
  const { vertexAttributes: m9, components: p9 } = await c6;
  e9.vertexAttributes = m9, e9.components = p9;
}
function u3(e9) {
  const t3 = Ut(e9.url);
  return (s4) => {
    const r4 = G(s4, t3, t3), n2 = r4 ? r4.replace(/^ *\.\//, "") : null;
    return (n2 ? e9.files.get(n2) : null) ?? s4;
  };
}
async function f5(t3, s4) {
  if (Array.isArray(t3)) {
    if (!t3.length)
      throw new s2("mesh-load-external:missing-assets", "There must be at least one file to load");
    return t3[0] instanceof File ? h7(t3) : w2(t3, s4);
  }
  return p6(t3);
}
async function m7(e9, t3) {
  const { parts: r4 } = e9;
  if (1 === r4.length)
    return new b2(r4[0].partUrl);
  const n2 = await e9.toBlob(t3);
  return s3(t3), b2.fromBlob(n2);
}
function p6(e9) {
  return b2.fromBlob(e9);
}
function h7(e9) {
  return g7(e9.map((e10) => ({ name: e10.name, mimeType: e10.type, source: p6(e10) })));
}
async function w2(e9, t3) {
  const i4 = await P(e9.map(async (e10) => {
    const r4 = await m7(e10);
    return s3(t3), { name: e10.assetName, mimeType: e10.assetMimeType, source: r4 };
  }));
  if (a(t3))
    throw i4.forEach((e10) => e10.source.dispose()), c();
  return g7(i4);
}
var y2 = /^(model\/gltf\+json)|(model\/gltf-binary)$/;
var d3 = /\.(gltf|glb)/i;
function g7(t3) {
  const s4 = /* @__PURE__ */ new Map();
  let r4 = null;
  for (const { name: e9, mimeType: n2, source: o4 } of t3)
    (null == r4 || y2.test(n2) || d3.test(e9)) && (r4 = o4.url), s4.set(e9, o4.url), o4.files.forEach((e10, t4) => s4.set(t4, e10));
  if (null == r4)
    throw new s2("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new b2(r4, () => t3.forEach(({ source: e9 }) => e9.dispose()), s4);
}
var b2 = class _b {
  constructor(e9, t3 = () => {
  }, s4 = /* @__PURE__ */ new Map()) {
    this.url = e9, this.dispose = t3, this.files = s4;
  }
  static fromBlob(e9) {
    const t3 = URL.createObjectURL(e9);
    return new _b(t3, () => URL.revokeObjectURL(t3));
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var p7 = class extends l2 {
  constructor() {
    super(), this.externalSources = new V(), this._explicitDisplaySource = null;
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(r4) {
    if (null != r4 && !o3(r4))
      throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = r4, r4 && this.externalSources.every((e9) => !h5(e9, r4)) && this.externalSources.add(r4);
  }
  clearSources() {
    this.displaySource = null, this.externalSources.removeAll();
  }
  getExternalSourcesOnService(r4) {
    return this.externalSources.items.filter((e9) => m4(e9, r4));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(o3);
  }
};
e([y()], p7.prototype, "externalSources", void 0), e([y()], p7.prototype, "displaySource", null), e([y()], p7.prototype, "_implicitDisplaySource", null), e([y()], p7.prototype, "_explicitDisplaySource", void 0), p7 = e([a2("esri.geometry.support.meshUtils.Metadata")], p7);

// node_modules/@arcgis/core/geometry/support/meshUtils/offset.js
var v2 = "esri.geometry.support.meshUtils.offset";
function x3(t3, e9, r4) {
  if (!t3.vertexAttributes || !t3.vertexAttributes.position)
    return;
  const { vertexSpace: n2 } = t3;
  if (n2.isRelative)
    o2(n2, v2, r4), j4(n2, e9);
  else {
    r3(t3.spatialReference, r4) ? A(t3, e9) : b3(t3, e9);
  }
}
function j4(t3, e9) {
  const r4 = t3.origin;
  t3.origin = u(n(), r4, e9);
}
function A(e9, r4) {
  const n2 = e9.spatialReference, i4 = e9.vertexAttributes.position, u5 = e9.vertexAttributes.normal, a9 = e9.vertexAttributes.tangent, v4 = new Float64Array(i4.length), x6 = null != u5 ? new Float32Array(u5.length) : null, j6 = null != a9 ? new Float32Array(a9.length) : null, A4 = e9.extent.center, b5 = y3;
  zn(n2, [A4.x, A4.y, A4.z], R2, c2(n2)), a3(d4, R2), S(b5, r4, d4), h3(i4, n2, v4), null != u5 && null != x6 && _2(u5, i4, v4, n2, x6), null != a9 && null != j6 && R(a9, i4, v4, n2, j6), k(v4, b5), E(v4, i4, n2), null != u5 && null != x6 && j2(x6, i4, v4, n2, u5), null != a9 && null != j6 && v(j6, i4, v4, n2, a9), e9.vertexAttributesChanged();
}
function b3(t3, e9) {
  k(t3.vertexAttributes.position, e9), t3.vertexAttributesChanged();
}
function k(t3, e9) {
  if (t3)
    for (let r4 = 0; r4 < t3.length; r4 += 3)
      for (let n2 = 0; n2 < 3; n2++)
        t3[r4 + n2] += e9[n2];
}
var y3 = n();
var R2 = e5();
var d4 = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function i3() {
  const { faceDescriptions: t3, faceVertexOffsets: e9, uvScales: n2 } = y4, r4 = 4 * t3.length, o4 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a9 = new Float32Array(2 * r4), i4 = new Uint32Array(2 * t3.length * 3);
  let l7 = 0, c6 = 0, f7 = 0, u5 = 0;
  for (let h10 = 0; h10 < t3.length; h10++) {
    const r5 = t3[h10], p9 = l7 / 3;
    for (const t4 of e9)
      i4[u5++] = p9 + t4;
    const w6 = r5.corners;
    for (let t4 = 0; t4 < 4; t4++) {
      const e10 = w6[t4];
      let i5 = 0;
      a9[f7++] = 0.25 * n2[t4][0] + r5.uvOrigin[0], a9[f7++] = r5.uvOrigin[1] - 0.25 * n2[t4][1];
      for (let t5 = 0; t5 < 3; t5++)
        0 !== r5.axis[t5] ? (o4[l7++] = 0.5 * r5.axis[t5], s4[c6++] = r5.axis[t5]) : (o4[l7++] = 0.5 * e10[i5++], s4[c6++] = 0);
    }
  }
  return { position: o4, normal: s4, uv: a9, faces: i4 };
}
function l6(t3, e9) {
  const n2 = t3.components[0], r4 = n2.faces, s4 = d5[e9], a9 = 6 * s4, i4 = new Array(6), l7 = new Array(r4.length - 6);
  let c6 = 0, f7 = 0;
  for (let o4 = 0; o4 < r4.length; o4++)
    o4 >= a9 && o4 < a9 + 6 ? i4[c6++] = r4[o4] : l7[f7++] = r4[o4];
  if (null != t3.vertexAttributes.uv) {
    const e10 = new Float32Array(t3.vertexAttributes.uv), n3 = 4 * s4 * 2, r5 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t4 = 0; t4 < r5.length; t4++)
      e10[n3 + t4] = r5[t4];
    t3.vertexAttributes.uv = e10;
  }
  return t3.components = [new g4({ faces: i4, material: n2.material }), new g4({ faces: l7 })], t3;
}
function c5(t3 = 0) {
  const e9 = Math.round(8 * 2 ** t3), n2 = 2 * e9, r4 = (e9 - 1) * (n2 + 1) + 2 * n2, o4 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a9 = new Float32Array(2 * r4), i4 = new Uint32Array(3 * ((e9 - 1) * n2 * 2));
  let l7 = 0, c6 = 0, f7 = 0, u5 = 0;
  for (let h10 = 0; h10 <= e9; h10++) {
    const t4 = h10 / e9 * Math.PI + 0.5 * Math.PI, r5 = Math.cos(t4), p9 = Math.sin(t4);
    M2[2] = p9;
    const w6 = 0 === h10 || h10 === e9, m9 = w6 ? n2 - 1 : n2;
    for (let v4 = 0; v4 <= m9; v4++) {
      const t5 = v4 / m9 * 2 * Math.PI;
      M2[0] = -Math.sin(t5) * r5, M2[1] = Math.cos(t5) * r5;
      for (let e10 = 0; e10 < 3; e10++)
        o4[l7] = 0.5 * M2[e10], s4[l7] = M2[e10], ++l7;
      a9[c6++] = (v4 + (w6 ? 0.5 : 0)) / n2, a9[c6++] = h10 / e9, 0 !== h10 && v4 !== n2 && (h10 !== e9 && (i4[f7++] = u5, i4[f7++] = u5 + 1, i4[f7++] = u5 - n2), 1 !== h10 && (i4[f7++] = u5, i4[f7++] = u5 - n2, i4[f7++] = u5 - n2 - 1)), u5++;
    }
  }
  return { position: o4, normal: s4, uv: a9, faces: i4 };
}
function f6(t3 = 0) {
  const e9 = 5, n2 = Math.round(16 * 2 ** t3), r4 = (e9 - 1) * (n2 + 1) + 2 * n2, o4 = new Float64Array(3 * r4), s4 = new Float32Array(3 * r4), a9 = new Float32Array(2 * r4), i4 = new Uint32Array(3 * (4 * n2));
  let l7 = 0, c6 = 0, f7 = 0, u5 = 0, h10 = 0;
  for (let p9 = 0; p9 <= e9; p9++) {
    const t4 = 0 === p9 || p9 === e9, r5 = p9 <= 1 || p9 >= e9 - 1, w6 = 2 === p9 || 4 === p9, m9 = t4 ? n2 - 1 : n2;
    for (let v4 = 0; v4 <= m9; v4++) {
      const g9 = v4 / m9 * 2 * Math.PI, A4 = t4 ? 0 : 0.5;
      M2[0] = A4 * Math.sin(g9), M2[1] = A4 * -Math.cos(g9), M2[2] = p9 <= 2 ? 0.5 : -0.5;
      for (let t5 = 0; t5 < 3; t5++)
        o4[l7++] = M2[t5], s4[c6++] = r5 ? 2 === t5 ? p9 <= 1 ? 1 : -1 : 0 : 2 === t5 ? 0 : M2[t5] / A4;
      a9[f7++] = (v4 + (t4 ? 0.5 : 0)) / n2, a9[f7++] = p9 <= 1 ? 1 * p9 / 3 : p9 <= 3 ? 1 * (p9 - 2) / 3 + 1 / 3 : 1 * (p9 - 4) / 3 + 2 / 3, w6 || 0 === p9 || v4 === n2 || (p9 !== e9 && (i4[u5++] = h10, i4[u5++] = h10 + 1, i4[u5++] = h10 - n2), 1 !== p9 && (i4[u5++] = h10, i4[u5++] = h10 - n2, i4[u5++] = h10 - n2 - 1)), h10++;
    }
  }
  return { position: o4, normal: s4, uv: a9, faces: i4 };
}
function u4(t3, e9) {
  const n2 = "number" == typeof e9 ? e9 : null != e9 ? e9.width : 1, r4 = "number" == typeof e9 ? e9 : null != e9 ? e9.height : 1;
  switch (t3) {
    case "up":
    case "down":
      return { width: n2, depth: r4 };
    case "north":
    case "south":
      return { width: n2, height: r4 };
    case "east":
    case "west":
      return { depth: n2, height: r4 };
  }
}
function h8(t3) {
  const e9 = v3.facingAxisOrderSwap[t3], n2 = v3.position, r4 = v3.normal, o4 = new Float64Array(n2.length), s4 = new Float32Array(r4.length);
  let a9 = 0;
  for (let i4 = 0; i4 < 4; i4++) {
    const t4 = a9;
    for (let i5 = 0; i5 < 3; i5++) {
      const l7 = e9[i5], c6 = Math.abs(l7) - 1, f7 = l7 >= 0 ? 1 : -1;
      o4[a9] = n2[t4 + c6] * f7, s4[a9] = r4[t4 + c6] * f7, a9++;
    }
  }
  return { position: o4, normal: s4, uv: new Float32Array(v3.uv), faces: new Uint32Array(v3.faces), isPlane: true };
}
var p8 = 1;
var w3 = 2;
var m8 = 3;
var v3 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [m8, p8, w3], west: [-m8, -p8, w3], north: [-p8, m8, w3], south: [p8, -m8, w3], up: [p8, w3, m8], down: [p8, -w3, -m8] } };
function g8(t3, e9, n2) {
  t3.isPlane || A2(t3), x4(t3, n2 == null ? void 0 : n2.size);
  const { vertexAttributes: r4, vertexSpace: i4, transform: l7 } = q(t3, e9, n2);
  return { vertexAttributes: new p4({ ...r4, uv: t3.uv }), vertexSpace: i4, transform: l7, components: [new g4({ faces: t3.faces, material: n2 && n2.material || null })], spatialReference: e9.spatialReference };
}
function A2(t3) {
  for (let e9 = 0; e9 < t3.position.length; e9 += 3)
    t3.position[e9 + 2] += 0.5;
}
function x4(t3, r4) {
  if (null == r4)
    return;
  const o4 = "number" == typeof r4 ? [r4, r4, r4] : [null != r4.width ? r4.width : 1, null != r4.depth ? r4.depth : 1, null != r4.height ? r4.height : 1];
  F[0] = o4[0], F[4] = o4[1], F[8] = o4[2];
  for (let n2 = 0; n2 < t3.position.length; n2 += 3) {
    for (let e9 = 0; e9 < 3; e9++)
      M2[e9] = t3.position[n2 + e9];
    S(M2, M2, F);
    for (let e9 = 0; e9 < 3; e9++)
      t3.position[n2 + e9] = M2[e9];
  }
  if (o4[0] !== o4[1] || o4[1] !== o4[2]) {
    F[0] = 1 / o4[0], F[4] = 1 / o4[1], F[8] = 1 / o4[2];
    for (let r5 = 0; r5 < t3.normal.length; r5 += 3) {
      for (let e9 = 0; e9 < 3; e9++)
        M2[e9] = t3.normal[r5 + e9];
      S(M2, M2, F), z(M2, M2);
      for (let e9 = 0; e9 < 3; e9++)
        t3.normal[r5 + e9] = M2[e9];
    }
  }
}
var y4 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var d5 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var M2 = n();
var F = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var U = "esri.geometry.support.meshUtils.rotate";
function z2(t3, e9, r4) {
  if (!t3.vertexAttributes || !t3.vertexAttributes.position || 0 === e9[3])
    return;
  const { spatialReference: o4, vertexSpace: n2 } = t3;
  if (n2.isRelative) {
    o2(n2, U, r4);
    const o5 = (r4 == null ? void 0 : r4.origin) ?? t3.origin;
    t3.transform ?? (t3.transform = new N()), C(t3.transform, n2, e9, o5);
  } else {
    const n3 = (r4 == null ? void 0 : r4.origin) ?? t3.origin;
    r3(o4, r4) ? I2(t3, e9, n3) : $(t3, e9, n3);
  }
}
function C(t3, e9, r4, o4) {
  const n2 = e9.origin, l7 = o(E2, o4.x, o4.y, o4.z ?? 0), c6 = e2(E2, l7, n2);
  t3.applyLocalInverse(c6, M3), t3.rotation = g3(t3.rotation, r4, h2()), t3.applyLocalInverse(c6, c6), e2(c6, c6, M3), t3.translation = u(n(), t3.translation, c6);
}
function I2(t3, r4, o4) {
  const n2 = t3.spatialReference, i4 = c2(n2), s4 = Z;
  In(o4, s4, i4) || In(t3.origin, s4, i4);
  const a9 = t3.vertexAttributes.position, c6 = t3.vertexAttributes.normal, f7 = t3.vertexAttributes.tangent, m9 = new Float64Array(a9.length), j6 = null != c6 ? new Float32Array(c6.length) : null, h10 = null != f7 ? new Float32Array(f7.length) : null;
  zn(i4, s4, S2, i4), a3(T, S2);
  const x6 = P2;
  S(x2(P2), x2(r4), T), x6[3] = r4[3], h3(a9, n2, m9), null != c6 && null != j6 && _2(c6, a9, m9, n2, j6), null != f7 && null != h10 && R(f7, a9, m9, n2, h10), D2(m9, x6, 3, s4), E(m9, a9, n2), null != c6 && null != j6 && (D2(j6, x6, 3), j2(j6, a9, m9, n2, c6)), null != f7 && null != h10 && (D2(h10, x6, 4), v(h10, a9, m9, n2, f7)), t3.vertexAttributesChanged();
}
function $(e9, r4, o4) {
  const n2 = Z;
  if (!In(o4, n2, e9.spatialReference)) {
    const r5 = e9.origin;
    n2[0] = r5.x, n2[1] = r5.y, n2[2] = r5.z, s.getLogger(U).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${e9.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  D2(e9.vertexAttributes.position, r4, 3, n2), D2(e9.vertexAttributes.normal, r4, 3), D2(e9.vertexAttributes.tangent, r4, 4), e9.vertexAttributesChanged();
}
function D2(t3, e9, r4, n2 = f2) {
  if (null != t3) {
    g2(S2, w(e9), x2(e9));
    for (let e10 = 0; e10 < t3.length; e10 += r4) {
      for (let r5 = 0; r5 < 3; r5++)
        E2[r5] = t3[e10 + r5] - n2[r5];
      O(E2, E2, S2);
      for (let r5 = 0; r5 < 3; r5++)
        t3[e10 + r5] = E2[r5] + n2[r5];
    }
  }
}
var E2 = n();
var M3 = n();
var P2 = h2();
var S2 = e5();
var T = e4();
var Z = n();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var x5 = "esri.geometry.support.meshUtils.scale";
function b4(e9, t3, r4) {
  if (!e9.vertexAttributes || !e9.vertexAttributes.position)
    return;
  const { spatialReference: o4, vertexSpace: n2 } = e9;
  if (n2.isRelative) {
    o2(n2, x5, r4);
    const o5 = (r4 == null ? void 0 : r4.origin) ?? e9.origin;
    e9.transform ?? (e9.transform = new N()), A3(e9.transform, n2, t3, o5);
  } else {
    const n3 = r3(o4, r4), i4 = (r4 == null ? void 0 : r4.origin) ?? e9.origin;
    n3 ? d6(e9, t3, i4) : y5(e9, t3, i4);
  }
}
function A3(e9, s4, l7, a9) {
  const c6 = s4.origin, p9 = o(R3, a9.x, a9.y, a9.z), f7 = e2(R3, p9, c6);
  e9.applyLocalInverse(f7, k2);
  const u5 = g(n(), e9.scale, l7);
  e9.scale = u5, e9.applyLocalInverse(f7, f7), e2(f7, f7, k2), e9.translation = u(n(), e9.translation, f7);
}
function d6(e9, t3, r4) {
  const o4 = e9.spatialReference, n2 = c2(o4), i4 = F2;
  In(r4, i4, n2) || In(e9.origin, i4, n2);
  const s4 = e9.vertexAttributes.position, c6 = e9.vertexAttributes.normal, p9 = e9.vertexAttributes.tangent, f7 = new Float64Array(s4.length), x6 = null != c6 ? new Float32Array(c6.length) : null, b5 = null != p9 ? new Float32Array(p9.length) : null;
  h3(s4, o4, f7), null != c6 && null != x6 && _2(c6, s4, f7, o4, x6), null != p9 && null != b5 && R(p9, s4, f7, o4, b5), w4(f7, t3, i4), E(f7, s4, o4), null != c6 && null != x6 && j2(x6, s4, f7, o4, c6), null != p9 && null != b5 && v(b5, s4, f7, o4, p9), e9.vertexAttributesChanged();
}
function y5(t3, r4, o4) {
  const n2 = F2;
  if (!In(o4, n2, t3.spatialReference)) {
    const r5 = t3.origin;
    n2[0] = r5.x, n2[1] = r5.y, n2[2] = r5.z, s.getLogger(x5).error(`Failed to project specified origin (wkid:${o4.spatialReference.wkid}) to mesh spatial reference (wkid:${t3.spatialReference.wkid}). Projection may be possible after calling projection.load().`);
  }
  w4(t3.vertexAttributes.position, r4, n2), t3.vertexAttributesChanged();
}
function w4(e9, t3, r4 = f2) {
  if (e9)
    for (let n2 = 0; n2 < e9.length; n2 += 3) {
      for (let t4 = 0; t4 < 3; t4++)
        R3[t4] = e9[n2 + t4] - r4[t4];
      g(R3, R3, t3);
      for (let t4 = 0; t4 < 3; t4++)
        e9[n2 + t4] = R3[t4] + r4[t4];
    }
}
var R3 = n();
var k2 = n();
var F2 = n();

// node_modules/@arcgis/core/geometry/Mesh.js
var B;
var k3 = "esri.geometry.Mesh";
var D3 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: p3, "georeferenced-relative": m2, local: m3 } };
var N2 = B = class extends a5(_.LoadableMixin(m(p2))) {
  constructor(e9) {
    super(e9), this.components = null, this.vertexSpace = new p3(), this.transform = null, this.metadata = new p7(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new p4(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.handles.add(l(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e9) => e9.clone()) };
      }, () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    var _a;
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != ((_a = this.metadata.displaySource) == null ? void 0 : _a.extent);
  }
  get _transformedExtent() {
    const { components: e9, spatialReference: t3, vertexAttributes: r4, vertexSpace: o4 } = this, s4 = r4.position;
    if (0 === s4.length || e9 && 0 === e9.length)
      return new M({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t3 });
    if ("local" === o4.type) {
      const { _untransformedExtent: e10, transform: r5 } = this;
      return e8(e10, r5, o4, t3);
    }
    if ("georeferenced-relative" === o4.type) {
      const { transform: e10 } = this, r5 = I({ positions: s4, transform: e10, vertexSpace: o4, inSpatialReference: t3, outSpatialReference: t3, local: false });
      return m5(r5, t3);
    }
    return m5(s4, t3);
  }
  get _untransformedExtent() {
    return m5(this.vertexAttributes.position, this.spatialReference);
  }
  get anchor() {
    const { vertexSpace: e9 } = this;
    if (e9.isRelative)
      return e9.getOriginPoint(this.spatialReference);
    const { center: t3, zmin: r4 } = this._transformedExtent;
    return new x({ x: t3.x, y: t3.y, z: r4, spatialReference: this.spatialReference });
  }
  get origin() {
    const { vertexSpace: e9 } = this;
    return e9.isRelative ? e9.getOriginPoint(this.spatialReference) : this._transformedExtent.center;
  }
  get extent() {
    var _a, _b;
    return this.loaded || null == ((_b = (_a = this.metadata) == null ? void 0 : _a.displaySource) == null ? void 0 : _b.extent) ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e9) {
    this.loaded ? (this.components || (this.components = []), this.components.push(g4.from(e9)), this.notifyChange("components")) : s.getLogger(this).error("addComponent()", "Mesh must be loaded before applying operations");
  }
  removeComponent(e9) {
    if (this.loaded) {
      if (this.components) {
        const t3 = this.components.indexOf(e9);
        if (-1 !== t3)
          return this.components.splice(t3, 1), void this.notifyChange("components");
      }
      s.getLogger(this).error("removeComponent()", "Provided component is not part of the list of components");
    } else
      s.getLogger(this).error("removeComponent()", "Mesh must be loaded before applying operations");
  }
  rotate(e9, t3, r4, o4) {
    return l3(e9, t3, r4, H), z2(this, H, o4), this;
  }
  offset(e9, t3, r4, o4) {
    return this.loaded ? (Z2[0] = e9, Z2[1] = t3, Z2[2] = r4, x3(this, Z2, o4), this) : (s.getLogger(this).error("offset()", "Mesh must be loaded before applying operations"), this);
  }
  scale(e9, t3) {
    return this.loaded ? (b4(this, e9, t3), this) : (s.getLogger(this).error("scale()", "Mesh must be loaded before applying operations"), this);
  }
  centerAt(e9, t3) {
    return this.loaded ? (p5(this, e9, t3), this) : (s.getLogger(this).error("centerAt()", "Mesh must be loaded before applying operations"), this);
  }
  load(e9) {
    const { metadata: { displaySource: t3 } } = this;
    return t3 && this.addResolvingPromise(c4(this, t3, e9)), Promise.resolve(this);
  }
  addExternalSources(e9) {
    this.metadata.externalSources.addMany(e9);
  }
  updateDisplaySource(e9) {
    this.metadata.displaySource = e9;
  }
  clone() {
    return this.cloneWithVertexSpace(this.vertexSpace.clone());
  }
  cloneWithVertexSpace(e9) {
    var _a;
    let t3 = null;
    if (this.components) {
      const e10 = /* @__PURE__ */ new Map(), r5 = /* @__PURE__ */ new Map();
      t3 = this.components.map((t4) => t4.cloneWithDeduplication(e10, r5));
    }
    const r4 = { components: t3, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes.clone(), vertexSpace: e9, transform: ((_a = this.transform) == null ? void 0 : _a.clone()) ?? null, metadata: this.metadata.clone() };
    return new B(r4);
  }
  cloneShallow() {
    return new B({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e9) {
    const t3 = import("./gltfexport-4AHV6HEB.js"), r4 = this.load(), o4 = await Promise.all([t3, r4]), { toBinaryGLTF: s4 } = o4[0];
    return s4(this, e9);
  }
  get memoryUsage() {
    let e9 = 0;
    if (e9 += this.vertexAttributes.memoryUsage, null != this.components)
      for (const t3 of this.components)
        e9 += t3.memoryUsage;
    return e9;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  static createBox(e9, t3) {
    if (!(e9 instanceof x))
      return s.getLogger(k3).error(".createBox()", "expected location to be a Point instance"), null;
    const r4 = new B(g8(i3(), e9, t3));
    return t3 && t3.imageFace && "all" !== t3.imageFace ? l6(r4, t3.imageFace) : r4;
  }
  static createSphere(e9, t3) {
    return e9 instanceof x ? new B(g8(c5(t3 && t3.densificationFactor || 0), e9, t3)) : (s.getLogger(k3).error(".createSphere()", "expected location to be a Point instance"), null);
  }
  static createCylinder(e9, t3) {
    return e9 instanceof x ? new B(g8(f6(t3 && t3.densificationFactor || 0), e9, t3)) : (s.getLogger(k3).error(".createCylinder()", "expected location to be a Point instance"), null);
  }
  static createPlane(e9, t3) {
    if (!(e9 instanceof x))
      return s.getLogger(k3).error(".createPlane()", "expected location to be a Point instance"), null;
    const r4 = (t3 == null ? void 0 : t3.facing) ?? "up", o4 = u4(r4, t3 == null ? void 0 : t3.size);
    return new B(g8(h8(r4), e9, { ...t3, size: o4 }));
  }
  static createFromPolygon(e9, t3) {
    if (!(e9 instanceof j))
      return s.getLogger(k3).error(".createFromPolygon()", "expected polygon to be a Polygon instance"), null;
    const r4 = l4(e9);
    return new B({ vertexAttributes: new p4({ position: r4.position }), components: [new g4({ faces: r4.faces, shading: "flat", material: (t3 == null ? void 0 : t3.material) ?? null })], spatialReference: e9.spatialReference, vertexSpace: new p3() });
  }
  static async createFromGLTF(e9, r4, o4) {
    if (!(e9 instanceof x))
      throw s.getLogger(k3).error(".createfromGLTF()", "expected location to be a Point instance"), new s2("invalid-input", "Expected location to be a Point instance");
    const { loadGLTFMesh: n2 } = await p(import("./loadGLTFMesh-DFHDBP3Q.js"), o4);
    return new B(await n2(e9, r4, o4));
  }
  static async createFromFiles(e9, r4, o4) {
    if (!(e9 instanceof x)) {
      const e10 = "Expected location to be a Point instance";
      throw s.getLogger(k3).error(".createFromFiles()", e10), new s2("invalid-input", e10);
    }
    const n2 = B.createWithExternalSource(e9, r4), i4 = o4 == null ? void 0 : o4.layer;
    if (!i4) {
      const e10 = "A layer is needed to convert the files";
      throw s.getLogger(k3).error(".createFromFiles()", e10), new s2("invalid-input", e10);
    }
    const [a9] = await i4.uploadAssets([n2], o4);
    return a9;
  }
  static createWithExternalSource(e9, t3, r4) {
    var _a;
    const o4 = (r4 == null ? void 0 : r4.extent) ?? null, { x: s4, y: n2, z: i4, spatialReference: a9 } = e9, c6 = ((_a = r4 == null ? void 0 : r4.transform) == null ? void 0 : _a.clone()) ?? new N(), p9 = (r4 == null ? void 0 : r4.vertexSpace) ?? new m3({ origin: [s4, n2, i4 ?? 0] }), l7 = { source: t3, extent: o4 }, m9 = new p7();
    return m9.externalSources.push(l7), new B({ metadata: m9, transform: c6, vertexSpace: p9, spatialReference: a9 });
  }
  static createIncomplete(e9, r4) {
    var _a;
    const { x: o4, y: s4, z: n2, spatialReference: i4 } = e9, a9 = ((_a = r4 == null ? void 0 : r4.transform) == null ? void 0 : _a.clone()) ?? new N(), c6 = (r4 == null ? void 0 : r4.vertexSpace) ?? new m3({ origin: [o4, s4, n2 ?? 0] }), p9 = new B({ transform: a9, vertexSpace: c6, spatialReference: i4 });
    return p9.addResolvingPromise(Promise.reject(new s2("mesh-incomplete", "Mesh resources are not complete"))), p9;
  }
};
e([y({ type: [g4], json: { write: true } })], N2.prototype, "components", void 0), e([y({ nonNullable: true, types: D3, constructOnly: true, json: { write: true } })], N2.prototype, "vertexSpace", void 0), e([y({ type: N, json: { write: true } })], N2.prototype, "transform", void 0), e([y({ constructOnly: true })], N2.prototype, "metadata", void 0), e([y()], N2.prototype, "hasExtent", null), e([y()], N2.prototype, "_transformedExtent", null), e([y()], N2.prototype, "_untransformedExtent", null), e([y()], N2.prototype, "anchor", null), e([y()], N2.prototype, "origin", null), e([y({ readOnly: true, json: { read: false } })], N2.prototype, "extent", null), e([y({ readOnly: true, json: { read: false, write: true, default: true } })], N2.prototype, "hasZ", void 0), e([y({ readOnly: true, json: { read: false, write: true, default: false } })], N2.prototype, "hasM", void 0), e([y({ type: p4, nonNullable: true, json: { write: true } })], N2.prototype, "vertexAttributes", void 0), N2 = B = e([a2(k3)], N2);
var Z2 = n();
var H = h2();
var I3 = N2;

// node_modules/@arcgis/core/rest/support/meshFeatureSet.js
var h9 = () => s.getLogger("esri.rest.support.meshFeatureSet");
function y6(t3, r4, o4) {
  const n2 = o4.features;
  o4.features = [], delete o4.geometryType;
  const s4 = d.fromJSON(o4);
  if (s4.geometryType = "mesh", !o4.assetMaps)
    return s4;
  const i4 = M4(r4, o4.assetMaps), u5 = t3.sourceSpatialReference ?? f.WGS84, c6 = o4.globalIdFieldName, { outFields: f7 } = t3, m9 = null != f7 && f7.length > 0 ? E3(f7.includes("*") ? null : new Set(f7)) : () => ({});
  for (const a9 of n2) {
    const t4 = S3(a9, c6, u5, r4, i4);
    null != t4 && s4.features.push(new h4({ geometry: t4, attributes: m9(a9) }));
  }
  return s4;
}
function E3(e9) {
  return ({ attributes: t3 }) => {
    if (!t3)
      return {};
    if (!e9)
      return t3;
    for (const r4 in t3)
      e9.has(r4) || delete t3[r4];
    return t3;
  };
}
function S3(e9, t3, r4, o4, i4) {
  const a9 = e9.attributes[t3], f7 = i4.get(a9);
  if (null == f7)
    return h9().error("mesh-feature-set:asset-not-found", "Service returned a feature which was not found in the asset map", e9), null;
  if (!e9.geometry)
    return h9().error("mesh-feature-set:no-geometry", "Service returned a feature without geometry", e9), null;
  const { originPoint: m9, originVector: p9 } = d7(e9, r4, o4), l7 = M.fromJSON(e9.geometry);
  l7.spatialReference = r4;
  const g9 = j5(e9.attributes, o4), y7 = f7.projectVertices ? new m2({ origin: p9 }) : new m3({ origin: p9 }), E4 = T2(f7);
  return E4 ? I3.createWithExternalSource(m9, E4, { extent: l7, transform: g9, vertexSpace: y7 }) : I3.createIncomplete(m9, { extent: l7, transform: g9, vertexSpace: y7 });
}
function d7({ attributes: e9 }, t3, { transformFieldRoles: r4 }) {
  const n2 = e9[r4.originX], s4 = e9[r4.originY], a9 = e9[r4.originZ];
  return { originPoint: new x({ x: n2, y: s4, z: a9, spatialReference: t3 }), originVector: r2(n2, s4, a9) };
}
function j5(e9, { transformFieldRoles: t3 }) {
  return new N({ translation: [e9[t3.translationX], -e9[t3.translationZ], e9[t3.translationY]], rotationAxis: [e9[t3.rotationX], e9[t3.rotationZ], e9[t3.rotationY]], rotationAngle: e9[t3.rotationDeg], scale: [e9[t3.scaleX], e9[t3.scaleY], e9[t3.scaleZ]] });
}
var w5;
function M4(e9, t3) {
  const o4 = /* @__PURE__ */ new Map();
  for (const n2 of t3) {
    const t4 = n2.parentGlobalId;
    if (null == t4)
      continue;
    const s4 = n2.assetName, i4 = n2.assetType, a9 = n2.assetHash, u5 = n2.assetURL, c6 = n2.conversionStatus, f7 = n2.seqNo, m9 = e7(i4, e9.supportedFormats);
    if (!m9) {
      h9().error("mesh-feature-set:unknown-format", `Service returned an asset of type ${i4}, but it does not list it as a supported type`);
      continue;
    }
    const p9 = r(o4, t4, () => ({ projectVertices: P3(n2.flags).projectVertices, files: /* @__PURE__ */ new Map() }));
    r(p9.files, s4, () => ({ name: s4, type: i4, mimeType: m9, status: D4(c6), parts: [] })).parts[f7] = { hash: a9, url: u5 };
  }
  return o4;
}
function T2(e9) {
  const t3 = Array.from(e9.files.values()), r4 = new Array();
  for (const o4 of t3) {
    if (o4.status !== w5.COMPLETED)
      return null;
    const e10 = new Array();
    for (const t4 of o4.parts) {
      if (!t4)
        return null;
      e10.push(new i2(t4.url, t4.hash));
    }
    r4.push(new a6(o4.name, o4.mimeType, e10));
  }
  return r4;
}
function D4(e9) {
  switch (e9) {
    case "COMPLETED":
    case "SUBMITTED":
      return w5.COMPLETED;
    case "INPROGRESS":
      return w5.PENDING;
    default:
      return w5.FAILED;
  }
}
function P3(e9) {
  return { projectVertices: e9.includes("PROJECT_VERTICES") };
}
!function(e9) {
  e9[e9.FAILED = 0] = "FAILED", e9[e9.PENDING = 1] = "PENDING", e9[e9.COMPLETED = 2] = "COMPLETED";
}(w5 || (w5 = {}));
export {
  M4 as assetMapFromAssetMapsJSON,
  S3 as extractMesh,
  y6 as meshFeatureSetFromJSON
};
//# sourceMappingURL=meshFeatureSet-GVZ3G46F.js.map
