import {
  _,
  f,
  g,
  u,
  w as w2,
  x
} from "./chunk-34QQ6GDH.js";
import {
  i
} from "./chunk-UX5D32RO.js";
import {
  S,
  l as l2,
  o as o4,
  r as r2,
  s as s2,
  t,
  y as y2
} from "./chunk-FHYNSVC4.js";
import {
  C,
  S2,
  m,
  m3 as m2,
  w,
  y as y3
} from "./chunk-VFQINJTY.js";
import {
  o as o3
} from "./chunk-EIE3W25Z.js";
import {
  o as o2
} from "./chunk-7E3Q7HTF.js";
import {
  o2 as o,
  r
} from "./chunk-SFV6XLDZ.js";
import {
  s
} from "./chunk-VBD33VNW.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a
} from "./chunk-I5JT24BO.js";

// node_modules/@arcgis/core/core/sql.js
async function e2(e3, n3) {
  const { WhereClause: r3 } = await import("./WhereClause-TU447WGJ.js");
  return r3.create(e3, n3);
}
function n(e3, n3) {
  return null != e3 ? null != n3 ? `(${e3}) AND (${n3})` : e3 : n3;
}

// node_modules/@arcgis/core/layers/support/LabelExpressionInfo.js
var l3;
var n2 = l3 = class extends l {
  constructor() {
    super(...arguments), this.expression = null, this.title = null, this.value = null;
  }
  readExpression(r3, e3) {
    return e3.value ? w2(e3.value) : r3;
  }
  writeExpression(r3, e3, s3) {
    null != this.value && (r3 = w2(this.value)), null != r3 && (e3[s3] = r3);
  }
  clone() {
    return new l3({ expression: this.expression, title: this.title, value: this.value });
  }
};
e([y({ type: String, json: { write: { writerEnsuresNonNull: true } } })], n2.prototype, "expression", void 0), e([o("expression", ["expression", "value"])], n2.prototype, "readExpression", null), e([r("expression")], n2.prototype, "writeExpression", null), e([y({ type: String, json: { write: true, origins: { "web-scene": { write: false } } } })], n2.prototype, "title", void 0), e([y({ json: { read: false, write: false } })], n2.prototype, "value", void 0), n2 = l3 = e([a2("esri.layers.support.LabelExpressionInfo")], n2);
var a3 = n2;

// node_modules/@arcgis/core/symbols/support/defaults.js
var S3 = y3.fromJSON(l2);
var u2 = m.fromJSON(o4);
var c = S2.fromJSON(S);
var a4 = m2.fromJSON(t);
var N = y3.fromJSON(r2);
var O = m.fromJSON(s2);
var y4 = S2.fromJSON(y2);

// node_modules/@arcgis/core/layers/support/LabelClass.js
var h;
var P = new s({ esriServerPointLabelPlacementAboveCenter: "above-center", esriServerPointLabelPlacementAboveLeft: "above-left", esriServerPointLabelPlacementAboveRight: "above-right", esriServerPointLabelPlacementBelowCenter: "below-center", esriServerPointLabelPlacementBelowLeft: "below-left", esriServerPointLabelPlacementBelowRight: "below-right", esriServerPointLabelPlacementCenterCenter: "center-center", esriServerPointLabelPlacementCenterLeft: "center-left", esriServerPointLabelPlacementCenterRight: "center-right", esriServerLinePlacementAboveAfter: "above-after", esriServerLinePlacementAboveAlong: "above-along", esriServerLinePlacementAboveBefore: "above-before", esriServerLinePlacementAboveStart: "above-start", esriServerLinePlacementAboveEnd: "above-end", esriServerLinePlacementBelowAfter: "below-after", esriServerLinePlacementBelowAlong: "below-along", esriServerLinePlacementBelowBefore: "below-before", esriServerLinePlacementBelowStart: "below-start", esriServerLinePlacementBelowEnd: "below-end", esriServerLinePlacementCenterAfter: "center-after", esriServerLinePlacementCenterAlong: "center-along", esriServerLinePlacementCenterBefore: "center-before", esriServerLinePlacementCenterStart: "center-start", esriServerLinePlacementCenterEnd: "center-end", esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal" }, { ignoreUnknown: true });
function x2(e3, r3, t2) {
  return { enabled: !o2(t2 == null ? void 0 : t2.layer) };
}
function L(e3) {
  var _a;
  return !e3 || "service" !== e3.origin && !("map-image" === ((_a = e3.layer) == null ? void 0 : _a.type));
}
function g2(e3) {
  return "map-image" === (e3 == null ? void 0 : e3.type);
}
function E(e3) {
  var _a, _b;
  return !!g2(e3) && !!((_b = (_a = e3.capabilities) == null ? void 0 : _a.exportMap) == null ? void 0 : _b.supportsArcadeExpressionForLabeling);
}
function j(e3) {
  return L(e3) || E(e3 == null ? void 0 : e3.layer);
}
var A = h = class extends l {
  static evaluateWhere(e3, r3) {
    const t2 = (e4, r4, t3) => {
      switch (r4) {
        case "=":
          return e4 == t3;
        case "<>":
          return e4 != t3;
        case ">":
          return e4 > t3;
        case ">=":
          return e4 >= t3;
        case "<":
          return e4 < t3;
        case "<=":
          return e4 <= t3;
      }
      return false;
    };
    try {
      if (null == e3)
        return true;
      const o5 = e3.split(" ");
      if (3 === o5.length)
        return t2(r3[o5[0]], o5[1], o5[2]);
      if (7 === o5.length) {
        const e4 = t2(r3[o5[0]], o5[1], o5[2]), i2 = o5[3], n3 = t2(r3[o5[4]], o5[5], o5[6]);
        switch (i2) {
          case "AND":
            return e4 && n3;
          case "OR":
            return e4 || n3;
        }
      }
      return false;
    } catch (o5) {
      console.log("Error.: can't parse = " + e3);
    }
  }
  constructor(e3) {
    super(e3), this.type = "label", this.name = null, this.allowOverrun = false, this.deconflictionStrategy = "static", this.labelExpression = null, this.labelExpressionInfo = null, this.labelPlacement = null, this.labelPosition = "curved", this.maxScale = 0, this.minScale = 0, this.repeatLabel = true, this.repeatLabelDistance = null, this.symbol = a4, this.useCodedValues = void 0, this.where = null;
  }
  readLabelExpression(e3, r3) {
    const t2 = r3.labelExpressionInfo;
    if (!t2 || !t2.value && !t2.expression)
      return e3;
  }
  writeLabelExpression(e3, r3, t2) {
    if (this.labelExpressionInfo) {
      if (null != this.labelExpressionInfo.value)
        e3 = u(this.labelExpressionInfo.value);
      else if (null != this.labelExpressionInfo.expression) {
        const r4 = _(this.labelExpressionInfo.expression);
        r4 && (e3 = "[" + r4 + "]");
      }
    }
    null != e3 && (r3[t2] = e3);
  }
  writeLabelExpressionInfo(e3, r3, t2, o5) {
    if (null == e3 && null != this.labelExpression && L(o5))
      e3 = new a3({ expression: this.getLabelExpressionArcade() });
    else if (!e3)
      return;
    const i2 = e3.toJSON(o5);
    i2.expression && (r3[t2] = i2);
  }
  writeMaxScale(e3, r3) {
    (e3 || this.minScale) && (r3.maxScale = e3);
  }
  writeMinScale(e3, r3) {
    (e3 || this.maxScale) && (r3.minScale = e3);
  }
  getLabelExpression() {
    return x(this);
  }
  getLabelExpressionArcade() {
    return f(this);
  }
  getLabelExpressionSingleField() {
    return g(this);
  }
  hash() {
    return JSON.stringify(this);
  }
  clone() {
    return new h({ allowOverrun: this.allowOverrun, deconflictionStrategy: this.deconflictionStrategy, labelExpression: this.labelExpression, labelExpressionInfo: a(this.labelExpressionInfo), labelPosition: this.labelPosition, labelPlacement: this.labelPlacement, maxScale: this.maxScale, minScale: this.minScale, name: this.name, repeatLabel: this.repeatLabel, repeatLabelDistance: this.repeatLabelDistance, symbol: a(this.symbol), where: this.where, useCodedValues: this.useCodedValues });
  }
};
e([y({ type: String, json: { write: true } })], A.prototype, "name", void 0), e([y({ type: Boolean, json: { write: true, default: false, origins: { "web-scene": { write: false }, "portal-item": { default: false, write: { overridePolicy: x2 } } } } })], A.prototype, "allowOverrun", void 0), e([y({ type: String, json: { write: true, default: "static", origins: { "web-scene": { write: false }, "portal-item": { default: "static", write: { overridePolicy: x2 } } } } })], A.prototype, "deconflictionStrategy", void 0), e([y({ type: String, json: { write: { overridePolicy(e3, r3, t2) {
  return this.labelExpressionInfo && "service" === (t2 == null ? void 0 : t2.origin) && E(t2.layer) ? { enabled: false } : { allowNull: true };
} } } })], A.prototype, "labelExpression", void 0), e([o("labelExpression")], A.prototype, "readLabelExpression", null), e([r("labelExpression")], A.prototype, "writeLabelExpression", null), e([y({ type: a3, json: { write: { overridePolicy: (e3, r3, t2) => j(t2) ? { allowNull: true } : { enabled: false } } } })], A.prototype, "labelExpressionInfo", void 0), e([r("labelExpressionInfo")], A.prototype, "writeLabelExpressionInfo", null), e([y({ type: P.apiValues, json: { type: P.jsonValues, read: P.read, write: P.write } })], A.prototype, "labelPlacement", void 0), e([y({ type: ["curved", "parallel"], json: { write: true, origins: { "web-map": { write: false }, "web-scene": { write: false }, "portal-item": { write: false } } } })], A.prototype, "labelPosition", void 0), e([y({ type: Number })], A.prototype, "maxScale", void 0), e([r("maxScale")], A.prototype, "writeMaxScale", null), e([y({ type: Number })], A.prototype, "minScale", void 0), e([r("minScale")], A.prototype, "writeMinScale", null), e([y({ type: Boolean, json: { write: true, origins: { "web-scene": { write: false }, "portal-item": { write: { overridePolicy: x2 } } } } })], A.prototype, "repeatLabel", void 0), e([y({ type: Number, cast: o3, json: { write: true, origins: { "web-scene": { write: false }, "portal-item": { write: { overridePolicy: x2 } } } } })], A.prototype, "repeatLabelDistance", void 0), e([y({ types: C, json: { origins: { "web-scene": { types: w, write: i, default: null } }, write: i, default: null } })], A.prototype, "symbol", void 0), e([y({ type: Boolean, json: { write: true } })], A.prototype, "useCodedValues", void 0), e([y({ type: String, json: { write: true } })], A.prototype, "where", void 0), A = h = e([a2("esri.layers.support.LabelClass")], A);
var C2 = A;

export {
  e2 as e,
  n,
  S3 as S,
  u2 as u,
  c,
  N,
  O,
  y4 as y,
  C2 as C
};
//# sourceMappingURL=chunk-TNXVIMSN.js.map
