import {
  g
} from "./chunk-OE4BQAGN.js";
import "./chunk-MW2UW5KK.js";
import {
  i as i5,
  le,
  t as t5
} from "./chunk-PPF3HWPU.js";
import {
  n as n3,
  p as p5
} from "./chunk-6YPETR6R.js";
import {
  l as l4,
  m as m2,
  s as s5,
  u as u2
} from "./chunk-R7ZVTG2X.js";
import {
  K,
  N
} from "./chunk-YPIJJVCA.js";
import "./chunk-6S2FCH6S.js";
import "./chunk-HLVYJZGQ.js";
import "./chunk-TYYAH2P4.js";
import "./chunk-U3JB4DA4.js";
import "./chunk-56WQONSA.js";
import "./chunk-TTCCMCQH.js";
import "./chunk-T3UXUOZW.js";
import "./chunk-FLVP2XLK.js";
import "./chunk-3SADEOML.js";
import "./chunk-V3KDZQUR.js";
import "./chunk-XSL4XKVS.js";
import "./chunk-PLCQTNGD.js";
import {
  p as p2,
  t as t3
} from "./chunk-UMKNA5PR.js";
import "./chunk-YM46NRFF.js";
import "./chunk-QRIMDBVP.js";
import "./chunk-DIRCMTXV.js";
import {
  p
} from "./chunk-7XRP3RPT.js";
import "./chunk-2YTFL6AC.js";
import {
  i as i3
} from "./chunk-CGPOGDO6.js";
import {
  l as l2
} from "./chunk-ZCZT2HZV.js";
import "./chunk-62M25QKF.js";
import {
  s as s4
} from "./chunk-W52WZL2F.js";
import "./chunk-7MOGRCW6.js";
import {
  i as i4
} from "./chunk-3Y3ICAIL.js";
import {
  C
} from "./chunk-TNXVIMSN.js";
import "./chunk-XFLBB3FK.js";
import "./chunk-77BBQQ7Y.js";
import "./chunk-FGWFWDIM.js";
import {
  p as p3
} from "./chunk-UCGDNB2P.js";
import {
  n as n2
} from "./chunk-E4GDJ764.js";
import "./chunk-Z2T56FN3.js";
import "./chunk-ZMKH5ZRU.js";
import {
  j as j4
} from "./chunk-P46VVEIN.js";
import "./chunk-X34I34RW.js";
import "./chunk-5NBE4HDI.js";
import "./chunk-4NLQ63FV.js";
import "./chunk-Y7HVH6RU.js";
import {
  t as t2
} from "./chunk-2HDAD5Q3.js";
import {
  c as c4
} from "./chunk-PPU6QR6F.js";
import {
  O
} from "./chunk-PCVJI7J2.js";
import {
  c as c3,
  d as d2,
  l as l3,
  m,
  p as p4
} from "./chunk-HZHMZHPT.js";
import "./chunk-NU5WEWCI.js";
import "./chunk-UIVGJZCT.js";
import "./chunk-MVR2W3C6.js";
import "./chunk-7MFOV26D.js";
import "./chunk-RNXN3MSP.js";
import "./chunk-DIXAOEHS.js";
import "./chunk-4NWXO2LT.js";
import "./chunk-6ETVGJDF.js";
import "./chunk-34QQ6GDH.js";
import "./chunk-KTII3LWY.js";
import "./chunk-RL6GG46M.js";
import {
  c
} from "./chunk-MLNTHYHD.js";
import {
  t as t4
} from "./chunk-I3XMP33U.js";
import "./chunk-JDYLSHC3.js";
import "./chunk-QAWS7Y22.js";
import {
  n
} from "./chunk-UX5D32RO.js";
import "./chunk-FHYNSVC4.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-QQMWRKOQ.js";
import "./chunk-2CQBXY7G.js";
import "./chunk-AEPMR2T7.js";
import "./chunk-EF6YPOUN.js";
import "./chunk-AYMF6OMA.js";
import "./chunk-WWUAHPIM.js";
import "./chunk-NYLF7BL2.js";
import {
  b
} from "./chunk-YC4PIRSZ.js";
import "./chunk-MSLDEOHR.js";
import "./chunk-32JSK7KN.js";
import "./chunk-YIJWIXDP.js";
import {
  r as r2
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import "./chunk-SCOBW7KR.js";
import "./chunk-AHAGGZUI.js";
import "./chunk-X5SMFNYP.js";
import "./chunk-5WXPQVZD.js";
import "./chunk-AF36K5Y6.js";
import "./chunk-5K6FTFN4.js";
import "./chunk-CNCZBOLJ.js";
import "./chunk-QXPTMFGZ.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import {
  k
} from "./chunk-QA4FMJA6.js";
import "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-VZAEQ6CY.js";
import "./chunk-SS33L3LC.js";
import "./chunk-MUO4EIZP.js";
import "./chunk-42RWGG3D.js";
import {
  w
} from "./chunk-G5WJIWPP.js";
import "./chunk-LNMNRMVX.js";
import {
  i
} from "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import {
  i as i2
} from "./chunk-KTEJJM3A.js";
import {
  Cn,
  Gn
} from "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import {
  b as b2,
  c2
} from "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-CGK6BJQA.js";
import {
  b as b3
} from "./chunk-XU2Q4SCK.js";
import "./chunk-KIEN3CY2.js";
import "./chunk-4CZO65BK.js";
import "./chunk-7E3Q7HTF.js";
import "./chunk-FXDEKQIL.js";
import {
  r as r3
} from "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-D5MIJ6WT.js";
import "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import {
  j as j3
} from "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-5EXFDBQJ.js";
import "./chunk-4NOOGA4U.js";
import "./chunk-CWQ6Q3PH.js";
import {
  U,
  a as a3,
  j
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-74O2T7JC.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import "./chunk-3GSONYPC.js";
import {
  o2 as o
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import {
  l,
  u2 as u
} from "./chunk-7A5C2EQ3.js";
import {
  r2 as r,
  t2 as t,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2,
  e2,
  s2 as s3
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-DEI4XQQ6.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  V as V2
} from "./chunk-O3CHVGVF.js";
import {
  d,
  f
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/RangeInfo.js
var s6 = class extends l {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
e([y({ type: String, json: { read: true, write: true } })], s6.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], s6.prototype, "field", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s6.prototype, "currentRangeExtent", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s6.prototype, "fullRangeExtent", void 0), e([y({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: true } })], s6.prototype, "type", void 0), s6 = e([a2("esri.layers.support.RangeInfo")], s6);

// node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c5;
var p6 = c5 = class extends u(V.ofType(j3)) {
  constructor(e3) {
    super(e3);
  }
  clone() {
    return new c5(this.items.map((e3) => e3.clone()));
  }
  write(e3, r4) {
    return this.toJSON(r4);
  }
  toJSON(e3) {
    var _a;
    const r4 = (_a = e3 == null ? void 0 : e3.layer) == null ? void 0 : _a.spatialReference;
    return r4 ? this.toArray().map((t6) => {
      if (!r4.equals(t6.spatialReference)) {
        if (!Cn(t6.spatialReference, r4))
          return e3 && e3.messages && e3.messages.push(new s3("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", { modification: this, spatialReference: e3.layer.spatialReference, context: e3 })), null;
        const s8 = new j3();
        Gn(t6, s8, r4), t6 = s8;
      }
      const s7 = t6.toJSON(e3);
      return delete s7.spatialReference, s7;
    }).filter((e4) => null != e4) : ((e3 == null ? void 0 : e3.messages) && e3.messages.push(new s3("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", { modification: this, spatialReference: e3.layer.spatialReference, context: e3 })), this.toArray().map((r5) => r5.toJSON(e3)));
  }
  static fromJSON(e3, r4) {
    const t6 = new c5();
    return e3.forEach((e4) => t6.add(j3.fromJSON(e4, r4))), t6;
  }
};
p6 = c5 = e([a2("esri.layers.support.PolygonCollection")], p6);
var l5 = p6;

// node_modules/@arcgis/core/layers/support/SceneFilter.js
var h2;
var g2 = h2 = class extends l {
  constructor(e3) {
    super(e3), this.spatialRelationship = "disjoint", this.geometries = new l5(), this._geometriesSource = null, this._handles = new t();
  }
  initialize() {
    this._handles.add(a3(() => this.geometries, "after-changes", () => this.geometries = this.geometries, U));
  }
  destroy() {
    this._handles.destroy();
  }
  readGeometries(e3, r4, o2) {
    Array.isArray(e3) ? this.geometries = l5.fromJSON(e3, o2) : this._geometriesSource = { url: i(e3, o2), context: o2 };
  }
  async loadGeometries(e3, o2) {
    if (null == this._geometriesSource)
      return;
    const { url: s7, context: t6 } = this._geometriesSource, i6 = await j2(s7, { responseType: "json", signal: o2 == null ? void 0 : o2.signal }), a4 = e3.toJSON(), p7 = i6.data.map((e4) => ({ ...e4, spatialReference: a4 }));
    this.geometries = l5.fromJSON(p7, t6), this._geometriesSource = null;
  }
  clone() {
    const e3 = new h2({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e3._geometriesSource = this._geometriesSource, e3;
  }
};
e([y({ type: ["disjoint", "contains"], nonNullable: true, json: { write: true } })], g2.prototype, "spatialRelationship", void 0), e([y({ type: l5, nonNullable: true, json: { write: true } }), g({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries" })], g2.prototype, "geometries", void 0), e([o(["web-scene", "portal-item"], "geometries")], g2.prototype, "readGeometries", null), g2 = h2 = e([a2("esri.layers.support.SceneFilter")], g2);
var d3 = g2;

// node_modules/@arcgis/core/layers/SceneLayer.js
var oe = ["3DObject", "Point"];
var ae = s4();
var ne = class extends c(N(l2(c4(j4(t2(O(i3(i2(b3))))))))) {
  constructor(...e3) {
    super(...e3), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true;
  }
  normalizeCtorArgs(e3, t6) {
    return "string" == typeof e3 ? { url: e3, ...t6 } : e3;
  }
  destroy() {
    this._set("renderer", null);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t6) {
    var _a, _b, _c;
    const r4 = (_b = (_a = this.getFeatureType(t6 == null ? void 0 : t6.feature)) == null ? void 0 : _a.domains) == null ? void 0 : _b[e3];
    return r4 && "inherited" !== r4.type ? r4 : ((_c = this.getField(e3)) == null ? void 0 : _c.domain) ?? null;
  }
  getFeatureType(e3) {
    return e3 && this.associatedLayer ? this.associatedLayer.getFeatureType(e3) : null;
  }
  get types() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.types) ?? [];
  }
  get typeIdField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.typeIdField) ?? null;
  }
  get templates() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.templates) ?? null;
  }
  get formTemplate() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.formTemplate) ?? null;
  }
  get fieldsIndex() {
    return new r2(this.fields);
  }
  readNodePages(e3, t6, r4) {
    return "Point" === t6.layerType && (e3 = t6.pointNodePages), null == e3 || "object" != typeof e3 ? null : s5.fromJSON(e3, r4);
  }
  set elevationInfo(e3) {
    this._set("elevationInfo", e3), this.loaded && this._validateElevationInfo();
  }
  get geometryType() {
    return le2[this.profile] || "mesh";
  }
  set renderer(e3) {
    c2(e3, this.fieldsIndex), this._set("renderer", e3);
  }
  readCachedDrawingInfo(e3) {
    return null != e3 && "object" == typeof e3 || (e3 = {}), null == e3.color && (e3.color = false), e3;
  }
  get capabilities() {
    var _a, _b;
    const e3 = ((_a = this.associatedLayer) == null ? void 0 : _a.capabilities) ?? t5, { query: t6, editing: { supportsGlobalId: r4, supportsRollbackOnFailure: s7, supportsUploadWithItemId: i6, supportsGeometryUpdate: o2, supportsReturnServiceEditsInSourceSpatialReference: a4 }, data: { supportsZ: n4, supportsM: p7, isVersioned: l6, supportsAttachment: d4 }, operations: { supportsEditing: y2, supportsAdd: u3, supportsUpdate: c6, supportsDelete: h3, supportsQuery: f2, supportsQueryAttachments: m3, supportsAsyncConvert3D: g3 } } = e3, v = e3.operations.supportsChangeTracking, b4 = !!((_b = this.associatedLayer) == null ? void 0 : _b.infoFor3D) && n();
    return { query: t6, editing: { supportsGlobalId: r4, supportsReturnServiceEditsInSourceSpatialReference: a4, supportsRollbackOnFailure: s7, supportsGeometryUpdate: b4 && o2, supportsUploadWithItemId: i6 }, data: { supportsAttachment: d4, supportsZ: n4, supportsM: p7, isVersioned: l6 }, operations: { supportsQuery: f2, supportsQueryAttachments: m3, supportsEditing: y2 && v, supportsAdd: b4 && u3 && v, supportsDelete: b4 && h3 && v, supportsUpdate: c6 && v, supportsAsyncConvert3D: g3 } };
  }
  get editingEnabled() {
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this.userHasEditingPrivileges;
  }
  set editingEnabled(e3) {
    this._overrideIfSome("editingEnabled", e3);
  }
  get infoFor3D() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) ?? null;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e3, t6) {
    return !e3 && t6.fields && t6.fields.some((t7) => ("esriFieldTypeOID" === t7.type && (e3 = t7.name), !!e3)), e3 || void 0;
  }
  readGlobalIdField(e3, t6) {
    return !e3 && t6.fields && t6.fields.some((t7) => ("esriFieldTypeGlobalID" === t7.type && (e3 = t7.name), !!e3)), e3 || void 0;
  }
  get displayField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.displayField) ?? null;
  }
  readProfile(e3, t6) {
    const r4 = t6.store.profile;
    return null != r4 && pe[r4] ? pe[r4] : (s.getLogger(this).error("Unknown or missing profile", { profile: r4, layer: this }), "mesh-pyramids");
  }
  load(e3) {
    const t6 = null != e3 ? e3.signal : null, r4 = this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e3).catch(f).then(() => this._fetchService(t6)).then(() => Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t6), this._setAssociatedFeatureLayer(t6), this._loadFilterGeometries()])).then(() => this._validateElevationInfo()).then(() => this._applyAssociatedLayerOverrides()).then(() => this._populateFieldUsageInfo()).then(() => t4(this, { origin: "service" }, t6)).then(() => c2(this.renderer, this.fieldsIndex)).then(() => this.finishLoadEditablePortalLayer(e3));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter)
      try {
        await this.filter.loadGeometries(this.spatialReference);
      } catch (e3) {
        s.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e3 }), this.filter = null;
      }
  }
  createQuery() {
    const e3 = new b();
    return "mesh" !== this.geometryType && (e3.returnGeometry = true, e3.returnZ = true), e3.where = this.definitionExpression || "1=1", e3.sqlFormat = "standard", e3.outFields = ["*"], e3;
  }
  queryExtent(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryExtent(e3 || this.createQuery(), t6));
  }
  queryFeatureCount(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryFeatureCount(e3 || this.createQuery(), t6));
  }
  queryFeatures(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryFeatures(e3 || this.createQuery(), t6)).then((e4) => {
      if (e4 == null ? void 0 : e4.features)
        for (const t7 of e4.features)
          t7.layer = this, t7.sourceLayer = this;
      return e4;
    });
  }
  async queryCachedAttributes(e3, t6) {
    const r4 = b2(this.fieldsIndex, await n3(this, p5(this)));
    return le(this.parsedUrl.path, this.attributeStorageInfo ?? [], e3, t6, r4);
  }
  async queryCachedFeature(e3, r4) {
    const s7 = await this.queryCachedAttributes(e3, [r4]);
    if (!s7 || 0 === s7.length)
      throw new s2("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const i6 = new h();
    return i6.attributes = s7[0], i6.layer = this, i6.sourceLayer = this, i6;
  }
  queryObjectIds(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryObjectIds(e3 || this.createQuery(), t6));
  }
  queryAttachments(e3, t6) {
    return this._getAssociatedLayerForQuery().then((r4) => r4.queryAttachments(e3, t6));
  }
  getFieldUsageInfo(e3) {
    const t6 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e3] || t6 : (s.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t6);
  }
  createPopupTemplate(e3) {
    return p3(this, e3);
  }
  _getAssociatedLayerForQuery() {
    const e3 = this.associatedLayer;
    return (e3 == null ? void 0 : e3.loaded) ? Promise.resolve(e3) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer)
      throw new s2("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e3) {
      throw new s2("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e3 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e3) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t6) => t6.name === e3);
  }
  async queryCachedStatistics(e3, t6) {
    if (await this.load(t6), !this.statisticsInfo)
      throw new s2("scenelayer:no-cached-statistics", "Cached statistics are not available for this layer");
    const r4 = this.fieldsIndex.get(e3);
    if (!r4)
      throw new s2("scenelayer:field-unexisting", `Field '${e3}' does not exist on the layer`);
    for (const s7 of this.statisticsInfo)
      if (s7.name === r4.name) {
        const e4 = V2(this.parsedUrl.path, s7.href);
        return j2(e4, { query: { f: "json", token: this.apiKey }, responseType: "json", signal: t6 ? t6.signal : null }).then((e5) => e5.data);
      }
    throw new s2("scenelayer:no-cached-statistics", "Cached statistics for this attribute are not available");
  }
  async saveAs(e3, t6) {
    return this._debouncedSaveOperations(K.SAVE_AS, { ...t6, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e3);
  }
  async save() {
    const e3 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(K.SAVE, e3);
  }
  async applyEdits(e3, t6) {
    const { applyEdits: r4 } = await import("./editingSupport-6GK7R2PV.js");
    if (await this.load(), !this.associatedLayer)
      throw new s2(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), r4(this, this.associatedLayer.source, e3, t6);
  }
  async uploadAssets(e3, t6) {
    if (await this.load(), null == this.associatedLayer)
      throw new s2(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e3, t6);
  }
  on(e3, t6) {
    return super.on(e3, t6);
  }
  validateLayer(e3) {
    if (e3.layerType && !oe.includes(e3.layerType))
      throw new s2("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e3.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor))
      throw new s2("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2)
      throw new s2("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t6(e4, t7) {
      let r4 = false, s7 = false;
      if (null == e4)
        r4 = true, s7 = true;
      else {
        const i6 = t7 && t7.isGeographic;
        switch (e4) {
          case "east-north-up":
          case "earth-centered":
            r4 = true, s7 = i6;
            break;
          case "vertex-reference-frame":
            r4 = true, s7 = !i6;
            break;
          default:
            r4 = false;
        }
      }
      if (!r4)
        throw new s2("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!s7)
        throw new s2("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t6(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e3 = [];
    if ("points" === this.profile)
      e3.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile)
        throw new s2("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e3.push("3DObject");
    }
    return e3;
  }
  _populateFieldUsageInfo() {
    var _a, _b;
    if (this._fieldUsageInfo = {}, this.fields)
      for (const e3 of this.fields) {
        const t6 = !(!this.attributeStorageInfo || !this.attributeStorageInfo.some((t7) => t7.name === e3.name)), r4 = !!((_b = (_a = this.associatedLayer) == null ? void 0 : _a.fields) == null ? void 0 : _b.some((t7) => t7 && e3.name === t7.name)), s7 = { supportsLabelingInfo: t6, supportsRenderer: t6, supportsPopupTemplate: t6 || r4, supportsLayerQuery: r4 };
        this._fieldUsageInfo[e3.name] = s7;
      }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides(), this._applyAssociatedLayerExtentOverride();
  }
  _applyAssociatedLayerFieldsOverrides() {
    var _a;
    if (!((_a = this.associatedLayer) == null ? void 0 : _a.fields))
      return;
    let e3 = null;
    for (const t6 of this.associatedLayer.fields) {
      const r4 = this.getField(t6.name);
      r4 ? (!r4.domain && t6.domain && (r4.domain = t6.domain.clone()), r4.editable = t6.editable, r4.nullable = t6.nullable, r4.length = t6.length) : (e3 || (e3 = this.fields ? this.fields.slice() : []), e3.push(t6.clone()));
    }
    e3 && this._set("fields", e3);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (!this.associatedLayer)
      return;
    const e3 = ["popupTemplate", "popupEnabled"], t6 = e2(this);
    for (let r4 = 0; r4 < e3.length; r4++) {
      const s7 = e3[r4], i6 = this.originIdOf(s7), o2 = this.associatedLayer.originIdOf(s7);
      i6 < o2 && (o2 === r.SERVICE || o2 === r.PORTAL_ITEM) && t6.setAtOrigin(s7, this.associatedLayer[s7], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    var _a, _b, _c, _d, _e, _f, _g;
    const e3 = (_b = (_a = this.associatedLayer) == null ? void 0 : _a.editingInfo) == null ? void 0 : _b.lastEditDate, t6 = (_c = this.associatedLayer) == null ? void 0 : _c.serverGens, r4 = (_d = this.associatedLayer) == null ? void 0 : _d.getAtOrigin("fullExtent", "service");
    if (!n() || null == ((_e = this.associatedLayer) == null ? void 0 : _e.infoFor3D) || !r4 || !w((_f = this.associatedLayer) == null ? void 0 : _f.url) || !e3 || ((_g = this.serviceUpdateTimeStamp) == null ? void 0 : _g.lastUpdate) === e3.getTime() || !this.serviceUpdateTimeStamp && (t6 == null ? void 0 : t6.minServerGen) === (t6 == null ? void 0 : t6.serverGen))
      return;
    e2(this).setAtOrigin("fullExtent", r4.clone(), r.SERVICE);
  }
  async _setAssociatedFeatureLayer(e3) {
    if (!["mesh-pyramids", "points"].includes(this.profile))
      return;
    const t6 = new i5(this.parsedUrl, this.portalItem, this.apiKey, e3);
    try {
      this.associatedLayer = await t6.fetch();
    } catch (r4) {
      d(r4) || this._logWarningOnPopupEnabled();
    }
  }
  async _logWarningOnPopupEnabled() {
    await j(() => this.popupEnabled && null != this.popupTemplate);
    const e3 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? s.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e3}`) : s.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e3}`);
  }
  _validateElevationInfo() {
    const e3 = this.elevationInfo;
    e3 && ("mesh-pyramids" === this.profile && "relative-to-scene" === e3.mode && s.getLogger(this).warn(".elevationInfo=", "Mesh scene layers don't support relative-to-scene elevation mode"), e3.featureExpressionInfo && "0" !== e3.featureExpressionInfo.expression && s.getLogger(this).warn(".elevationInfo=", "Scene layers do not support featureExpressionInfo"));
  }
};
e([y({ types: { key: "type", base: t3, typeMap: { selection: p2 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], ne.prototype, "featureReduction", void 0), e([y({ type: [s6], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], ne.prototype, "rangeInfos", void 0), e([y({ json: { read: false } })], ne.prototype, "associatedLayer", void 0), e([y({ type: ["show", "hide"] })], ne.prototype, "listMode", void 0), e([y({ type: ["ArcGISSceneServiceLayer"] })], ne.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], ne.prototype, "type", void 0), e([y({ ...ae.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], ne.prototype, "fields", void 0), e([y()], ne.prototype, "types", null), e([y()], ne.prototype, "typeIdField", null), e([y()], ne.prototype, "templates", null), e([y()], ne.prototype, "formTemplate", null), e([y({ readOnly: true })], ne.prototype, "fieldsIndex", null), e([y({ type: p, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], ne.prototype, "floorInfo", void 0), e([y(ae.outFields)], ne.prototype, "outFields", void 0), e([y({ type: s5, readOnly: true, json: { read: false } })], ne.prototype, "nodePages", void 0), e([o("service", "nodePages", ["nodePages", "pointNodePages"])], ne.prototype, "readNodePages", null), e([y({ type: [l4], readOnly: true })], ne.prototype, "materialDefinitions", void 0), e([y({ type: [u2], readOnly: true })], ne.prototype, "textureSetDefinitions", void 0), e([y({ type: [m2], readOnly: true })], ne.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], ne.prototype, "serviceUpdateTimeStamp", void 0), e([y({ readOnly: true })], ne.prototype, "attributeStorageInfo", void 0), e([y({ readOnly: true })], ne.prototype, "statisticsInfo", void 0), e([y({ type: V.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], ne.prototype, "excludeObjectIds", void 0), e([y({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], ne.prototype, "definitionExpression", void 0), e([y({ type: d3, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], ne.prototype, "filter", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], ne.prototype, "path", void 0), e([y(d2)], ne.prototype, "elevationInfo", null), e([y({ type: String })], ne.prototype, "geometryType", null), e([y(m)], ne.prototype, "labelsVisible", void 0), e([y({ type: [C], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: i4 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: i4 }, write: true } })], ne.prototype, "labelingInfo", void 0), e([y(c3)], ne.prototype, "legendEnabled", void 0), e([y({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e3, t6) {
  var _a, _b;
  if ("number" == typeof e3 && e3 >= 0 && e3 <= 1)
    return e3;
  const r4 = (_b = (_a = t6.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.transparency;
  return void 0 !== r4 ? r3(r4) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], ne.prototype, "opacity", void 0), e([y({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], ne.prototype, "priority", void 0), e([y({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], ne.prototype, "semantic", void 0), e([y({ types: n2, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], ne.prototype, "renderer", null), e([y({ json: { read: false } })], ne.prototype, "cachedDrawingInfo", void 0), e([o("service", "cachedDrawingInfo")], ne.prototype, "readCachedDrawingInfo", null), e([y({ readOnly: true, json: { read: false } })], ne.prototype, "capabilities", null), e([y({ type: Boolean, json: { read: false } })], ne.prototype, "editingEnabled", null), e([y({ readOnly: true, json: { write: false, read: false } })], ne.prototype, "infoFor3D", null), e([y(p4)], ne.prototype, "popupEnabled", void 0), e([y({ type: k, json: { name: "popupInfo", write: true } })], ne.prototype, "popupTemplate", void 0), e([y({ readOnly: true, json: { read: false } })], ne.prototype, "defaultPopupTemplate", null), e([y({ type: String, json: { read: false } })], ne.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["objectIdField", "fields"])], ne.prototype, "readObjectIdField", null), e([y({ type: String, json: { read: false } })], ne.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["globalIdField", "fields"])], ne.prototype, "readGlobalIdField", null), e([y({ readOnly: true, type: String, json: { read: false } })], ne.prototype, "displayField", null), e([y({ type: String, json: { read: false } })], ne.prototype, "profile", void 0), e([o("service", "profile", ["store.profile"])], ne.prototype, "readProfile", null), e([y({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], ne.prototype, "normalReferenceFrame", void 0), e([y(l3)], ne.prototype, "screenSizePerspectiveEnabled", void 0), ne = e([a2("esri.layers.SceneLayer")], ne);
var pe = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var le2 = { "mesh-pyramids": "mesh", points: "point", lines: "polyline", polygons: "polygon" };
var de = ne;
export {
  de as default
};
//# sourceMappingURL=SceneLayer-EJUXMI6X.js.map
