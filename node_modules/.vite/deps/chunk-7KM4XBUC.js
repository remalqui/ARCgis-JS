import {
  f
} from "./chunk-SFV6XLDZ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  o,
  t
} from "./chunk-I5JT24BO.js";

// node_modules/@arcgis/core/support/arcadeOnDemand.js
var a = s.getLogger("esri.support.arcadeOnDemand");
var s3;
function i() {
  return s3 || (s3 = (async () => {
    const e2 = await import("./arcadeUtils-Y5ZGURJB.js");
    return { arcade: e2.arcade, arcadeUtils: e2, Dictionary: e2.Dictionary, Feature: e2.arcadeFeature };
  })()), s3;
}
var c = (e2, r, t2) => u.create(e2, r, t2, null, ["$feature"], []);
var n = (e2, r, t2) => u.create(e2, r, t2, null, ["$feature", "$view"], []);
var l = (e2, r, t2, a4) => u.create(e2, r, t2, a4, ["$feature", "$view"], []);
var u = class _u {
  constructor(e2, r, t2, a4, s5, i2, c3) {
    this.services = null, this.script = e2, this.evaluate = a4;
    const n3 = Array.isArray(i2) ? i2 : i2.fields;
    this.fields = n3, this._syntaxTree = t2, this._arcade = r, this._arcadeFeature = s5, this._spatialReference = c3, this._referencesGeometry = r.scriptTouchesGeometry(this._syntaxTree), this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale");
  }
  static async create(r, s5, c3, n3, o2, l2) {
    const { arcade: p2, Feature: m2, Dictionary: f3 } = await i(), d2 = f.fromJSON(s5);
    let y2;
    try {
      y2 = p2.parseScript(r, l2);
    } catch (x) {
      return a.error(new s2("arcade-bad-expression", "Failed to parse arcade script", { script: r, error: x })), null;
    }
    const h2 = o2.reduce((e2, r2) => ({ ...e2, [r2]: null }), {});
    let w2 = null;
    null != n3 && (w2 = new f3(n3), w2.immutable = true, h2.$config = null);
    const g2 = p2.scriptUsesGeometryEngine(y2), v2 = g2 && p2.enableGeometrySupport(), _2 = p2.scriptUsesFeatureSet(y2) && p2.enableFeatureSetSupport(), F2 = p2.scriptIsAsync(y2), S2 = F2 && p2.enableAsyncSupport(), $2 = { vars: h2, spatialReference: d2, useAsync: !!S2 };
    await Promise.all([v2, _2, S2]);
    const b2 = /* @__PURE__ */ new Set();
    await p2.loadDependentModules(b2, y2, null, F2, g2);
    const j2 = new f3();
    j2.immutable = false, j2.setField("scale", 0);
    const G2 = p2.compileScript(y2, $2), R2 = (e2, r2) => ("$view" in e2 && e2.$view && (j2.setField("scale", "object" == typeof e2.$view && "scale" in e2.$view ? e2.$view.scale : void 0), e2.$view = j2), w2 && (e2.$config = w2), G2({ vars: e2, spatialReference: d2, services: r2 }));
    return new _u(r, p2, y2, R2, new m2(), c3, d2);
  }
  repurposeFeature(e2) {
    return e2.geometry && !e2.geometry.spatialReference && (e2.geometry.spatialReference = this._spatialReference), this._arcadeFeature.repurposeFromGraphicLikeObject(e2.geometry, e2.attributes, { fields: this.fields }), this._arcadeFeature;
  }
  referencesGeometry() {
    return this._referencesGeometry;
  }
  referencesScale() {
    return this._referencesScale;
  }
};

// node_modules/@arcgis/core/layers/support/domainUtils.js
var e;
function n2(n3, a4) {
  switch (n3.type) {
    case "range": {
      const r = "range" in n3 ? n3.range[0] : n3.minValue, u3 = "range" in n3 ? n3.range[1] : n3.maxValue;
      if (null != r && +a4 < r || null != u3 && +a4 > u3)
        return e.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (null == n3.codedValues || n3.codedValues.every((e2) => null == e2 || e2.code !== a4))
        return e.INVALID_CODED_VALUE;
  }
  return null;
}
!function(e2) {
  e2.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", e2.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
}(e || (e = {}));

// node_modules/@arcgis/core/layers/support/fieldUtils.js
var s4 = /^([0-9_])/;
var a3 = /[^a-z0-9_\u0080-\uffff]+/gi;
function u2(e2) {
  if (null == e2)
    return null;
  return e2.trim().replaceAll(a3, "_").replace(s4, "F$1") || null;
}
var f2 = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"];
var d = ["field", "normalizationField"];
function c2(e2, n3) {
  if (null != e2 && null != n3) {
    for (const i2 of Array.isArray(e2) ? e2 : [e2])
      if (m(f2, i2, n3), "visualVariables" in i2 && i2.visualVariables)
        for (const e3 of i2.visualVariables)
          m(d, e3, n3);
  }
}
function m(e2, t2, r) {
  if (e2)
    for (const l2 of e2) {
      const e3 = t(l2, t2), o2 = e3 && "function" != typeof e3 && r.get(e3);
      o2 && o(l2, o2.name, t2);
    }
}
function p(e2, n3) {
  var _a;
  if (null != e2 && ((_a = n3 == null ? void 0 : n3.fields) == null ? void 0 : _a.length))
    if ("startField" in e2) {
      const i2 = n3.get(e2.startField), t2 = n3.get(e2.endField);
      e2.startField = (i2 == null ? void 0 : i2.name) ?? null, e2.endField = (t2 == null ? void 0 : t2.name) ?? null;
    } else {
      const i2 = n3.get(e2.startTimeField), t2 = n3.get(e2.endTimeField);
      e2.startTimeField = (i2 == null ? void 0 : i2.name) ?? null, e2.endTimeField = (t2 == null ? void 0 : t2.name) ?? null;
    }
}
var y = /* @__PURE__ */ new Set();
function g(e2, n3) {
  return e2 && n3 ? (y.clear(), F(y, e2, n3), Array.from(y).sort()) : [];
}
function F(e2, n3, i2) {
  var _a;
  if (i2)
    if ((_a = n3 == null ? void 0 : n3.fields) == null ? void 0 : _a.length)
      if (i2.includes("*"))
        for (const { name: t2 } of n3.fields)
          e2.add(t2);
      else
        for (const t2 of i2)
          I(e2, n3, t2);
    else {
      if (i2.includes("*"))
        return e2.clear(), void e2.add("*");
      for (const n4 of i2)
        null != n4 && e2.add(n4);
    }
}
function I(e2, n3, i2) {
  if ("string" == typeof i2)
    if (n3) {
      const t2 = n3.get(i2);
      t2 && e2.add(t2.name);
    } else
      e2.add(i2);
}
function b(e2, n3) {
  return null == n3 || null == e2 ? [] : n3.includes("*") ? (e2.fields ?? []).map((e3) => e3.name) : n3;
}
async function T(e2, n3, i2) {
  var _a;
  if (!i2)
    return;
  const { arcadeUtils: t2 } = await i(), r = t2.extractFieldNames(i2, (_a = n3 == null ? void 0 : n3.fields) == null ? void 0 : _a.map((e3) => e3.name));
  for (const l2 of r)
    I(e2, n3, l2);
}
async function h(n3, i2, t2) {
  if (t2 && "1=1" !== t2) {
    const { WhereClause: r } = await import("./WhereClause-TU447WGJ.js"), l2 = r.create(t2, i2);
    if (!l2.isStandardized)
      throw new s2("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: t2 });
    F(n3, i2, l2.fieldNames);
  }
}
function w({ displayField: e2, fields: n3 }) {
  return e2 || (n3 && n3.length ? E(n3, "name-or-title") || E(n3, "unique-identifier") || E(n3, "type-or-category") || _(n3) : null);
}
function _(e2) {
  for (const n3 of e2) {
    if (!n3 || !n3.name)
      continue;
    const e3 = n3.name.toLowerCase();
    if (e3.includes("name") || e3.includes("title"))
      return n3.name;
  }
  return null;
}
function E(e2, n3) {
  for (const i2 of e2)
    if (i2 && i2.valueType && i2.valueType === n3)
      return i2.name;
  return null;
}
async function v(e2, n3) {
  var _a;
  if (!n3)
    return;
  const i2 = (_a = n3.elevationInfo) == null ? void 0 : _a.featureExpressionInfo;
  return i2 ? i2.collectRequiredFields(e2, n3.fieldsIndex) : void 0;
}
function S(e2, n3, i2) {
  i2.onStatisticExpression ? T(e2, n3, i2.onStatisticExpression.expression) : e2.add(i2.onStatisticField);
}
async function $(e2, n3, i2) {
  if (!n3 || !i2 || !("fields" in i2))
    return;
  const t2 = [], r = i2.popupTemplate;
  t2.push(N(e2, n3, r)), i2.fields && t2.push(...i2.fields.map(async (i3) => S(e2, n3.fieldsIndex, i3))), await Promise.all(t2);
}
async function N(e2, n3, i2) {
  const t2 = [];
  (i2 == null ? void 0 : i2.expressionInfos) && t2.push(...i2.expressionInfos.map((i3) => T(e2, n3.fieldsIndex, i3.expression)));
  const r = i2 == null ? void 0 : i2.content;
  if (Array.isArray(r))
    for (const l2 of r)
      "expression" === l2.type && l2.expressionInfo && t2.push(T(e2, n3.fieldsIndex, l2.expressionInfo.expression));
  await Promise.all(t2);
}
async function L(e2, n3, i2) {
  n3 && (n3.timeInfo && null != i2 && i2.timeExtent && F(e2, n3.fieldsIndex, [n3.timeInfo.startField, n3.timeInfo.endField]), n3.floorInfo && F(e2, n3.fieldsIndex, [n3.floorInfo.floorField]), null != i2 && null != i2.where && await h(e2, n3.fieldsIndex, i2.where));
}
async function D(e2, n3, i2) {
  n3 && i2 && await Promise.all(i2.map((i3) => O(e2, n3, i3)));
}
async function O(e2, n3, i2) {
  n3 && i2 && (i2.valueExpression ? await T(e2, n3.fieldsIndex, i2.valueExpression) : i2.field && I(e2, n3.fieldsIndex, i2.field));
}
function C(e2) {
  return e2 ? g(e2.fieldsIndex, P(e2)) : [];
}
function j(e2) {
  if (!e2)
    return [];
  const n3 = e2.geometryFieldsInfo;
  return n3 ? g(e2.fieldsIndex, [n3.shapeAreaField, n3.shapeLengthField]) : [];
}
var U = ["oid", "global-id", "guid"];
var R = ["oid", "global-id"];
var k = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /shape/i, /perimeter/i, /objectid/i, /_i$/i];
function z(e2) {
  const n3 = /* @__PURE__ */ new Set();
  G(e2).forEach((e3) => n3.add(e3)), j(e2).forEach((e3) => n3.add(e3.toLowerCase()));
  const i2 = e2 && "infoFor3D" in e2 ? e2.infoFor3D : void 0;
  return i2 && (Object.values(i2.assetMapFieldRoles).forEach((e3) => n3.add(e3.toLowerCase())), Object.values(i2.transformFieldRoles).forEach((e3) => n3.add(e3.toLowerCase()))), Array.from(n3);
}
function P(e2) {
  if (!e2)
    return [];
  const n3 = "editFieldsInfo" in e2 && e2.editFieldsInfo;
  if (!n3)
    return [];
  const { creationDateField: i2, creatorField: t2, editDateField: r, editorField: l2 } = n3;
  return [i2, t2, r, l2].filter(Boolean);
}
function G(e2) {
  return P(e2).map((e3) => e3.toLowerCase());
}
function M(e2, n3) {
  var _a;
  return e2.editable && !U.includes(e2.type) && !G(n3).includes(((_a = e2.name) == null ? void 0 : _a.toLowerCase()) ?? "");
}
function W(e2, n3) {
  var _a;
  const i2 = ((_a = e2.name) == null ? void 0 : _a.toLowerCase()) ?? "";
  return !(null != (n3 == null ? void 0 : n3.objectIdField) && i2 === n3.objectIdField.toLowerCase() || null != (n3 == null ? void 0 : n3.globalIdField) && i2 === n3.globalIdField.toLowerCase() || z(n3).includes(i2) || R.includes(e2.type) || k.some((e3) => e3.test(i2)));
}
async function q(e2, n3) {
  const { labelingInfo: i2, fieldsIndex: t2 } = n3;
  i2 && i2.length && await Promise.all(i2.map((n4) => Y(e2, t2, n4)));
}
async function Y(e2, n3, i2) {
  if (!i2)
    return;
  const t2 = i2.getLabelExpression(), r = i2.where;
  if ("arcade" === t2.type)
    await T(e2, n3, t2.expression);
  else {
    const i3 = t2.expression.match(/{[^}]*}/g);
    i3 && i3.forEach((i4) => {
      I(e2, n3, i4.slice(1, -1));
    });
  }
  await h(e2, n3, r);
}
function B(e2) {
  const n3 = e2.defaultValue;
  return void 0 !== n3 && ie(e2, n3) ? n3 : e2.nullable ? null : void 0;
}
function J(e2) {
  return "number" == typeof e2 && !isNaN(e2) && isFinite(e2);
}
function H(e2) {
  return null === e2 || J(e2);
}
var K = "isInteger" in Number ? Number.isInteger : (e2) => "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
function Q(e2) {
  return null === e2 || K(e2);
}
function Z(e2) {
  return null != e2 && "string" == typeof e2;
}
function ee(e2) {
  return null === e2 || Z(e2);
}
function ne() {
  return true;
}
function ie(e2, n3) {
  let i2;
  switch (e2.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
      i2 = e2.nullable ? Q : K;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      i2 = e2.nullable ? H : J;
      break;
    case "string":
    case "esriFieldTypeString":
      i2 = e2.nullable ? ee : Z;
      break;
    default:
      i2 = ne;
  }
  return 1 === arguments.length ? i2 : i2(n3);
}
var te = ["integer", "small-integer", "single", "double"];
var re = /* @__PURE__ */ new Set([...te, "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]);
var le = ["date", "date-only", "time-only", "timestamp-offset"];
var oe = /* @__PURE__ */ new Set([...le, "esriFieldTypeDate", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
function se(e2) {
  return null != e2 && re.has(e2.type);
}
function ae(e2) {
  return null != e2 && ("string" === e2.type || "esriFieldTypeString" === e2.type);
}
function ue(e2) {
  return null != e2 && oe.has(e2.type);
}
var de;
var ce;
function me(e2) {
  return null == e2 || "number" == typeof e2 && isNaN(e2) ? null : e2;
}
function pe(e2, n3) {
  return null == e2 || e2.nullable && null === n3 ? null : se(e2) && !ye(e2.type, Number(n3)) ? de.OUT_OF_RANGE : ie(e2, n3) ? e2.domain ? n2(e2.domain, n3) : null : ce.INVALID_TYPE;
}
function ye(e2, n3) {
  const i2 = "string" == typeof e2 ? Fe(e2) : e2;
  if (!i2)
    return false;
  const t2 = i2.min, r = i2.max;
  return i2.isInteger ? K(n3) && n3 >= t2 && n3 <= r : n3 >= t2 && n3 <= r;
}
function Fe(e2) {
  switch (e2) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return be;
    case "esriFieldTypeInteger":
    case "integer":
      return xe;
    case "esriFieldTypeBigInteger":
    case "big-integer":
      return Te;
    case "esriFieldTypeSingle":
    case "single":
      return he;
    case "esriFieldTypeDouble":
    case "double":
      return we;
  }
}
!function(e2) {
  e2.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
}(de || (de = {})), function(e2) {
  e2.INVALID_TYPE = "type-validation-error::invalid-type";
}(ce || (ce = {}));
var be = { min: -32768, max: 32767, isInteger: true };
var xe = { min: -2147483648, max: 2147483647, isInteger: true };
var Te = { min: -Number.MAX_SAFE_INTEGER, max: Number.MAX_SAFE_INTEGER, isInteger: true };
var he = { min: -34e37, max: 12e37, isInteger: false };
var we = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: false };
function _e(e2, n3, i2) {
  switch (e2) {
    case e.INVALID_CODED_VALUE:
      return `Value ${i2} is not in the coded domain - field: ${n3.name}, domain: ${JSON.stringify(n3.domain)}`;
    case e.VALUE_OUT_OF_RANGE:
      return `Value ${i2} is out of the range of valid values - field: ${n3.name}, domain: ${JSON.stringify(n3.domain)}`;
    case ce.INVALID_TYPE:
      return `Value ${i2} is not a valid value for the field type - field: ${n3.name}, type: ${n3.type}, nullable: ${n3.nullable}`;
    case de.OUT_OF_RANGE: {
      const { min: e3, max: t2 } = Fe(n3.type);
      return `Value ${i2} is out of range for the number type - field: ${n3.name}, type: ${n3.type}, value range is ${e3} to ${t2}`;
    }
  }
}
function Ee(e2, n3) {
  return !Ae(e2, n3, null);
}
function Ae(e2, n3, i2) {
  if (!n3 || !n3.attributes || !e2) {
    if (null != i2)
      for (const n4 of e2 ?? [])
        i2.add(n4);
    return true;
  }
  const t2 = n3.attributes;
  let r = false;
  for (const l2 of e2)
    if (!(l2 in t2)) {
      if (r = true, null == i2)
        break;
      i2.add(l2);
    }
  return r;
}
function Se(e2) {
  return !!e2 && ["raster.itempixelvalue", "raster.servicepixelvalue"].some((n3) => e2.toLowerCase().startsWith(n3));
}

export {
  i,
  c,
  n,
  l,
  u,
  u2,
  c2,
  p,
  g,
  F,
  I,
  b,
  T,
  w,
  v,
  $,
  L,
  D,
  C,
  M,
  W,
  q,
  B,
  se,
  ae,
  ue,
  me,
  pe,
  _e,
  Ee,
  Se
};
//# sourceMappingURL=chunk-7KM4XBUC.js.map
