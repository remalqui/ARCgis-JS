import {
  l as l2
} from "./chunk-I67PIYR2.js";
import {
  o as o2
} from "./chunk-HV6PC35G.js";
import {
  i
} from "./chunk-NSS3KYAR.js";
import {
  t as t2
} from "./chunk-IUXYWQJG.js";
import {
  a as a5
} from "./chunk-77BBQQ7Y.js";
import {
  j as j2
} from "./chunk-P46VVEIN.js";
import {
  p
} from "./chunk-X34I34RW.js";
import {
  a as a4
} from "./chunk-5NBE4HDI.js";
import "./chunk-4NLQ63FV.js";
import "./chunk-Y7HVH6RU.js";
import {
  t
} from "./chunk-2HDAD5Q3.js";
import {
  c as c3
} from "./chunk-PPU6QR6F.js";
import {
  O,
  S as S3
} from "./chunk-PCVJI7J2.js";
import {
  c as c2,
  f as f3
} from "./chunk-HZHMZHPT.js";
import "./chunk-JDYLSHC3.js";
import "./chunk-NYLF7BL2.js";
import "./chunk-32JSK7KN.js";
import "./chunk-CNCZBOLJ.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import {
  k
} from "./chunk-QA4FMJA6.js";
import "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-42RWGG3D.js";
import {
  C
} from "./chunk-G5WJIWPP.js";
import "./chunk-LNMNRMVX.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  n
} from "./chunk-PXHKLVGZ.js";
import {
  b
} from "./chunk-XU2Q4SCK.js";
import {
  s as s5
} from "./chunk-KIEN3CY2.js";
import "./chunk-7E3Q7HTF.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-D5MIJ6WT.js";
import "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-CWQ6Q3PH.js";
import {
  U,
  a as a3,
  l
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  S2,
  f as f2,
  o2 as o,
  r
} from "./chunk-SFV6XLDZ.js";
import {
  s as s4
} from "./chunk-3PLRSFLA.js";
import {
  s as s3
} from "./chunk-VBD33VNW.js";
import {
  c
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import {
  T,
  d
} from "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  $,
  L,
  S,
  kt
} from "./chunk-O3CHVGVF.js";
import {
  f
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  R
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/WMSSublayer.js
var h2;
var c4 = 0;
var m = h2 = class extends s5(S3) {
  constructor(e2) {
    super(e2), this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.legendUrl = null, this.legendEnabled = true, this.layer = null, this.maxScale = 0, this.minScale = 0, this.name = null, this.parent = null, this.popupEnabled = false, this.queryable = false, this.sublayers = null, this.spatialReferences = null, this.title = null, this.addHandles([a3(() => this.sublayers, "after-add", ({ item: e3 }) => {
      e3.parent = this, e3.layer = this.layer;
    }, U), a3(() => this.sublayers, "after-remove", ({ item: e3 }) => {
      e3.layer = e3.parent = null;
    }, U), l(() => this.sublayers, (e3, t3) => {
      if (t3)
        for (const r2 of t3)
          r2.layer = r2.parent = null;
      if (e3)
        for (const r2 of e3)
          r2.parent = this, r2.layer = this.layer;
    }, U), l(() => this.layer, (e3) => {
      if (this.sublayers)
        for (const t3 of this.sublayers)
          t3.layer = e3;
    }, U)]);
  }
  get id() {
    const e2 = this._get("id");
    return e2 ?? c4++;
  }
  set id(e2) {
    this._set("id", e2);
  }
  readLegendUrl(e2, t3) {
    return t3.legendUrl ?? t3.legendURL ?? null;
  }
  get effectiveScaleRange() {
    const { minScale: e2, maxScale: t3 } = this;
    return { minScale: e2, maxScale: t3 };
  }
  castSublayers(e2) {
    return d(V.ofType(h2), e2);
  }
  set visible(e2) {
    this._setAndNotifyLayer("visible", e2);
  }
  clone() {
    var _a, _b;
    const e2 = new h2();
    return this.hasOwnProperty("description") && (e2.description = this.description), this.hasOwnProperty("fullExtent") && (e2.fullExtent = this.fullExtent.clone()), this.hasOwnProperty("fullExtents") && (e2.fullExtents = ((_a = this.fullExtents) == null ? void 0 : _a.map((e3) => e3.clone())) ?? null), this.hasOwnProperty("legendUrl") && (e2.legendUrl = this.legendUrl), this.hasOwnProperty("legendEnabled") && (e2.legendEnabled = this.legendEnabled), this.hasOwnProperty("layer") && (e2.layer = this.layer), this.hasOwnProperty("name") && (e2.name = this.name), this.hasOwnProperty("parent") && (e2.parent = this.parent), this.hasOwnProperty("queryable") && (e2.queryable = this.queryable), this.hasOwnProperty("sublayers") && (e2.sublayers = this.sublayers && this.sublayers.map((e3) => e3.clone())), this.hasOwnProperty("spatialReferences") && (e2.spatialReferences = (_b = this.spatialReferences) == null ? void 0 : _b.map((e3) => e3)), this.hasOwnProperty("visible") && (e2.visible = this.visible), this.hasOwnProperty("title") && (e2.title = this.title), e2;
  }
  _setAndNotifyLayer(e2, t3) {
    const r2 = this.layer;
    this._get(e2) !== t3 && (this._set(e2, t3), r2 && r2.emit("wms-sublayer-update", { propertyName: e2, id: this.id }));
  }
};
e([y()], m.prototype, "description", void 0), e([y({ readOnly: true })], m.prototype, "dimensions", void 0), e([y({ type: M, json: { name: "extent" } })], m.prototype, "fullExtent", void 0), e([y()], m.prototype, "fullExtents", void 0), e([y({ type: Number, json: { write: { enabled: false, overridePolicy: () => ({ ignoreOrigin: true, enabled: true }) } } })], m.prototype, "id", null), e([y({ type: String, json: { name: "legendUrl", write: { ignoreOrigin: true } } })], m.prototype, "legendUrl", void 0), e([o("legendUrl", ["legendUrl", "legendURL"])], m.prototype, "readLegendUrl", null), e([y({ type: Boolean, json: { name: "showLegend", origins: { "web-map": { read: false, write: false }, "web-scene": { read: false, write: false } } } })], m.prototype, "legendEnabled", void 0), e([y()], m.prototype, "layer", void 0), e([y()], m.prototype, "maxScale", void 0), e([y()], m.prototype, "minScale", void 0), e([y({ readOnly: true })], m.prototype, "effectiveScaleRange", null), e([y({ type: String, json: { write: { ignoreOrigin: true } } })], m.prototype, "name", void 0), e([y()], m.prototype, "parent", void 0), e([y({ type: Boolean, json: { read: { source: "showPopup" }, write: { ignoreOrigin: true, target: "showPopup" } } })], m.prototype, "popupEnabled", void 0), e([y({ type: Boolean, json: { write: { ignoreOrigin: true } } })], m.prototype, "queryable", void 0), e([y()], m.prototype, "sublayers", void 0), e([s4("sublayers")], m.prototype, "castSublayers", null), e([y({ type: [Number], json: { read: { source: "spatialReferences" } } })], m.prototype, "spatialReferences", void 0), e([y({ type: String, json: { write: { ignoreOrigin: true } } })], m.prototype, "title", void 0), e([y({ type: Boolean, value: true, json: { read: { source: "defaultVisibility" } } })], m.prototype, "visible", null), m = h2 = e([a2("esri.layers.support.WMSSublayer")], m);
var f4 = m;

// node_modules/@arcgis/core/layers/support/wmsUtils.js
var o3 = { 84: 4326, 83: 4269, 27: 4267 };
function l3(n2) {
  if (!n2)
    return null;
  const i2 = { idCounter: -1 };
  if ("string" == typeof n2) {
    n2 = new DOMParser().parseFromString(n2, "text/xml");
  }
  const s6 = n2.documentElement;
  if ("ServiceExceptionReport" === s6.nodeName) {
    const e2 = Array.prototype.slice.call(s6.childNodes).map((e3) => e3.textContent).join("\r\n");
    throw new s2("wmslayer:wms-capabilities-xml-is-not-valid", "The server returned errors when the WMS capabilities were requested.", e2);
  }
  const o4 = d2("Capability", s6), l4 = d2("Service", s6), a7 = o4 && d2("Request", o4);
  if (!o4 || !l4 || !a7)
    return null;
  const m3 = d2("Layer", o4);
  if (!m3)
    return null;
  const f6 = "WMS_Capabilities" === s6.nodeName || "WMT_MS_Capabilities" === s6.nodeName ? s6.getAttribute("version") : "1.3.0", p3 = h3("Title", l4, "") || h3("Name", l4, ""), x2 = h3("AccessConstraints", l4, ""), y3 = /^none$/i.test(x2) ? "" : x2, S5 = h3("Abstract", l4, ""), E = parseInt(h3("MaxWidth", l4, "5000"), 10), w2 = parseInt(h3("MaxHeight", l4, "5000"), 10), L2 = N(a7, "GetMap"), M3 = g(a7, "GetMap"), C3 = b2(m3, f6, i2);
  if (!C3)
    return null;
  let v2, I2 = 0;
  const R3 = Array.prototype.slice.call(o4.childNodes), U3 = C3.sublayers ?? [], T3 = (e2) => {
    null != e2 && U3.push(e2);
  };
  R3.forEach((e2) => {
    "Layer" === e2.nodeName && (0 === I2 ? v2 = e2 : 1 === I2 ? (C3.name && (C3.name = "", T3(b2(v2, f6, i2))), T3(b2(e2, f6, i2))) : T3(b2(e2, f6, i2)), I2++);
  });
  let V4 = C3.sublayers, O3 = C3.extent;
  const _2 = C3.fullExtents ?? [];
  if (V4 || (V4 = []), 0 === V4.length && V4.push(C3), !O3) {
    const e2 = new M(V4[0].extent);
    C3.extent = e2.toJSON(), O3 = C3.extent;
  }
  const B = C3.spatialReferences.length > 0 ? C3.spatialReferences : u(C3), D = g(a7, "GetFeatureInfo"), j3 = D ? N(a7, "GetFeatureInfo") : null, k2 = c5(V4), q = C3.minScale || 0, X2 = C3.maxScale || 0, G = C3.dimensions ?? [], W = k2.reduce((e2, t3) => e2.concat(t3.dimensions ?? []), []), P = G.concat(W).filter(F);
  let $2 = null;
  if (P.length) {
    const t3 = P.map((e2) => {
      const { extent: t4 } = e2;
      return A(t4) ? t4.map((e3) => e3.getTime()) : t4 == null ? void 0 : t4.map((e3) => [e3.min.getTime(), e3.max.getTime()]);
    }).flat(2).filter(R);
    $2 = { startTimeField: null, endTimeField: null, trackIdField: void 0, timeExtent: [Math.min(...t3), Math.max(...t3)] };
  }
  return { copyright: y3, description: S5, dimensions: G, extent: O3, fullExtents: _2, featureInfoFormats: j3, featureInfoUrl: D, mapUrl: M3, maxWidth: E, maxHeight: w2, maxScale: X2, minScale: q, layers: k2, spatialReferences: B, supportedImageFormatTypes: L2, timeInfo: $2, title: p3, version: f6 };
}
function a6(e2) {
  const t3 = e2.filter((e3) => e3.popupEnabled && e3.name && e3.queryable);
  return t3.length ? t3.map(({ name: e3 }) => e3).join() : null;
}
function u(e2) {
  if (e2.spatialReferences.length > 0)
    return e2.spatialReferences;
  if (e2.sublayers)
    for (const t3 of e2.sublayers) {
      const e3 = u(t3);
      if (e3.length > 0)
        return e3;
    }
  return [];
}
function c5(e2) {
  var _a;
  let t3 = [];
  for (const n2 of e2)
    t3.push(n2), ((_a = n2.sublayers) == null ? void 0 : _a.length) && (t3 = t3.concat(c5(n2.sublayers)), delete n2.sublayers);
  return t3;
}
function m2(e2, t3, n2) {
  return t3.getAttribute(e2) ?? n2;
}
function f5(e2, t3, n2, r2) {
  const i2 = d2(e2, n2);
  return i2 ? m2(t3, i2, r2) : r2;
}
function d2(e2, t3) {
  for (let n2 = 0; n2 < t3.childNodes.length; n2++) {
    const r2 = t3.childNodes[n2];
    if (S4(r2) && r2.nodeName === e2)
      return r2;
  }
  return null;
}
function p2(e2, t3) {
  if (null == t3)
    return [];
  const n2 = [];
  for (let r2 = 0; r2 < t3.childNodes.length; r2++) {
    const i2 = t3.childNodes[r2];
    S4(i2) && i2.nodeName === e2 && n2.push(i2);
  }
  return n2;
}
function h3(e2, t3, n2) {
  var _a;
  return ((_a = d2(e2, t3)) == null ? void 0 : _a.textContent) ?? n2;
}
function x(e2, t3, n2) {
  if (!e2)
    return null;
  const s6 = parseFloat(e2.getAttribute("minx")), o4 = parseFloat(e2.getAttribute("miny")), l4 = parseFloat(e2.getAttribute("maxx")), a7 = parseFloat(e2.getAttribute("maxy"));
  let u2, c6, m3, f6;
  n2 ? (u2 = isNaN(o4) ? -Number.MAX_VALUE : o4, c6 = isNaN(s6) ? -Number.MAX_VALUE : s6, m3 = isNaN(a7) ? Number.MAX_VALUE : a7, f6 = isNaN(l4) ? Number.MAX_VALUE : l4) : (u2 = isNaN(s6) ? -Number.MAX_VALUE : s6, c6 = isNaN(o4) ? -Number.MAX_VALUE : o4, m3 = isNaN(l4) ? Number.MAX_VALUE : l4, f6 = isNaN(a7) ? Number.MAX_VALUE : a7);
  const d3 = new f2({ wkid: t3 });
  return new M({ xmin: u2, ymin: c6, xmax: m3, ymax: f6, spatialReference: d3 });
}
function g(e2, t3) {
  const n2 = d2(t3, e2);
  if (n2) {
    const e3 = d2("DCPType", n2);
    if (e3) {
      const t4 = d2("HTTP", e3);
      if (t4) {
        const e4 = d2("Get", t4);
        if (e4) {
          let t5 = f5("OnlineResource", "xlink:href", e4, null);
          if (t5)
            return t5.indexOf("&") === t5.length - 1 && (t5 = t5.substring(0, t5.length - 1)), M2(t5, ["service", "request"]);
        }
      }
    }
  }
  return null;
}
function N(t3, n2) {
  const r2 = p2("Operation", t3);
  if (!r2.length) {
    return p2("Format", d2(n2, t3)).map(({ textContent: e2 }) => e2).filter(R);
  }
  const i2 = [];
  for (const e2 of r2)
    if (e2.getAttribute("name") === n2) {
      const t4 = p2("Format", e2);
      for (const { textContent: e3 } of t4)
        null != e3 && i2.push(e3);
    }
  return i2;
}
function y2(e2, t3, n2) {
  const r2 = d2(t3, e2);
  if (!r2)
    return n2;
  const { textContent: i2 } = r2;
  if (null == i2 || "" === i2)
    return n2;
  const s6 = Number(i2);
  return isNaN(s6) ? n2 : s6;
}
function b2(e2, t3, n2) {
  if (!e2)
    return null;
  const l4 = { id: n2.idCounter++, fullExtents: [], parentLayerId: null, queryable: "1" === e2.getAttribute("queryable"), spatialReferences: [], sublayers: null }, a7 = d2("LatLonBoundingBox", e2), u2 = d2("EX_GeographicBoundingBox", e2);
  let c6 = null;
  a7 && (c6 = x(a7, 4326)), u2 && (c6 = new M(0, 0, 0, 0, new f2({ wkid: 4326 })), c6.xmin = parseFloat(h3("westBoundLongitude", u2, "0")), c6.ymin = parseFloat(h3("southBoundLatitude", u2, "0")), c6.xmax = parseFloat(h3("eastBoundLongitude", u2, "0")), c6.ymax = parseFloat(h3("northBoundLatitude", u2, "0"))), a7 || u2 || (c6 = new M(-180, -90, 180, 90, new f2({ wkid: 4326 }))), l4.minScale = y2(e2, "MaxScaleDenominator", 0), l4.maxScale = y2(e2, "MinScaleDenominator", 0);
  const f6 = ["1.0.0", "1.1.0", "1.1.1"].includes(t3) ? "SRS" : "CRS";
  return Array.prototype.slice.call(e2.childNodes).forEach((e3) => {
    var _a;
    if ("Name" === e3.nodeName)
      l4.name = e3.textContent || "";
    else if ("Title" === e3.nodeName)
      l4.title = e3.textContent || "";
    else if ("Abstract" === e3.nodeName)
      l4.description = e3.textContent || "";
    else if ("BoundingBox" === e3.nodeName) {
      const n3 = e3.getAttribute(f6);
      if (n3 && 0 === n3.indexOf("EPSG:")) {
        const r3 = parseInt(n3.substring(5), 10);
        0 === r3 || isNaN(r3) || c6 || (c6 = "1.3.0" === t3 ? x(e3, r3, o2(r3)) : x(e3, r3));
      }
      const r2 = n3 && n3.indexOf(":");
      if (r2 && r2 > -1) {
        let i2 = parseInt(n3.substring(r2 + 1, n3.length), 10);
        0 === i2 || isNaN(i2) || (i2 = o3[i2] ?? i2);
        const a8 = "1.3.0" === t3 ? x(e3, i2, o2(i2)) : x(e3, i2);
        a8 && l4.fullExtents && l4.fullExtents.push(a8);
      }
    } else if (e3.nodeName === f6) {
      (((_a = e3.textContent) == null ? void 0 : _a.split(" ")) ?? []).forEach((e4) => {
        const t4 = e4.includes(":") ? parseInt(e4.split(":")[1], 10) : parseInt(e4, 10);
        if (0 !== t4 && !isNaN(t4)) {
          const e5 = o3[t4] ?? t4;
          l4.spatialReferences.includes(e5) || l4.spatialReferences.push(e5);
        }
      });
    } else if ("Style" !== e3.nodeName || l4.legendUrl) {
      if ("Layer" === e3.nodeName) {
        const r2 = b2(e3, t3, n2);
        r2 && (r2.parentLayerId = l4.id, l4.sublayers || (l4.sublayers = []), l4.sublayers.push(r2));
      }
    } else {
      const t4 = d2("LegendURL", e3);
      if (t4) {
        const e4 = d2("OnlineResource", t4);
        e4 && (l4.legendUrl = e4.getAttribute("xlink:href"));
      }
    }
  }), l4.extent = c6 == null ? void 0 : c6.toJSON(), l4.dimensions = p2("Dimension", e2).filter((e3) => e3.getAttribute("name") && e3.getAttribute("units") && e3.textContent).map((e3) => {
    const t4 = e3.getAttribute("name"), n3 = e3.getAttribute("units"), r2 = e3.textContent, i2 = e3.getAttribute("unitSymbol") ?? void 0, s6 = e3.getAttribute("default") ?? void 0, o4 = "0" !== m2("default", e3, "0"), l5 = "0" !== m2("nearestValue", e3, "0"), a8 = "0" !== m2("current", e3, "0");
    if (F({ name: t4, units: n3 })) {
      return { name: "time", units: "ISO8601", extent: I(r2), default: I(s6), multipleValues: o4, nearestValue: l5, current: a8 };
    }
    if (w({ name: t4, units: n3 })) {
      return { name: "elevation", units: n3, extent: C2(r2), unitSymbol: i2, default: C2(s6), multipleValues: o4, nearestValue: l5 };
    }
    return { name: t4, units: n3, extent: v(r2), unitSymbol: i2, default: v(s6), multipleValues: o4, nearestValue: l5 };
  }), l4;
}
function A(e2) {
  return Array.isArray(e2) && e2.length > 0 && e2[0] instanceof Date;
}
function S4(e2) {
  return e2.nodeType === Node.ELEMENT_NODE;
}
function w(e2) {
  return /^elevation$/i.test(e2.name) && /^(epsg|crs):\d+$/i.test(e2.units);
}
function F(e2) {
  return /^time$/i.test(e2.name) && /^iso8601$/i.test(e2.units);
}
function M2(e2, t3) {
  const r2 = [], i2 = L(e2);
  for (const n2 in i2.query)
    i2.query.hasOwnProperty(n2) && (t3.includes(n2.toLowerCase()) || r2.push(n2 + "=" + i2.query[n2]));
  return i2.path + (r2.length ? "?" + r2.join("&") : "");
}
function C2(t3) {
  if (!t3)
    return;
  const n2 = t3.includes("/"), r2 = t3.split(",");
  return n2 ? r2.map((e2) => {
    const t4 = e2.split("/");
    if (t4.length < 2)
      return null;
    return { min: parseFloat(t4[0]), max: parseFloat(t4[1]), resolution: t4.length >= 3 && "0" !== t4[2] ? parseFloat(t4[2]) : void 0 };
  }).filter(R) : r2.map((e2) => parseFloat(e2));
}
function v(t3) {
  if (!t3)
    return;
  const n2 = t3.includes("/"), r2 = t3.split(",");
  return n2 ? r2.map((e2) => {
    const t4 = e2.split("/");
    if (t4.length < 2)
      return null;
    return { min: t4[0], max: t4[1], resolution: t4.length >= 3 && "0" !== t4[2] ? t4[2] : void 0 };
  }).filter(R) : r2;
}
function I(t3) {
  if (!t3)
    return;
  const n2 = t3.includes("/"), r2 = t3.split(",");
  return n2 ? r2.map((e2) => {
    const t4 = e2.split("/");
    if (t4.length < 2)
      return null;
    return { min: new Date(t4[0]), max: new Date(t4[1]), resolution: t4.length >= 3 && "0" !== t4[2] ? R2(t4[2]) : void 0 };
  }).filter(R) : r2.map((e2) => new Date(e2));
}
function R2(e2) {
  const t3 = /(?:p(\d+y|\d+(?:.|,)\d+y)?(\d+m|\d+(?:.|,)\d+m)?(\d+d|\d+(?:.|,)\d+d)?)?(?:t(\d+h|\d+(?:.|,)\d+h)?(\d+m|\d+(?:.|,)\d+m)?(\d+s|\d+(?:.|,)\d+s)?)?/i, n2 = e2.match(t3);
  if (!n2)
    return null;
  return { years: U2(n2[1]), months: U2(n2[2]), days: U2(n2[3]), hours: U2(n2[4]), minutes: U2(n2[5]), seconds: U2(n2[6]) };
}
function U2(e2) {
  if (!e2)
    return 0;
  const t3 = /(?:\d+(?:.|,)\d+|\d+)/, n2 = e2.match(t3);
  if (!n2)
    return 0;
  const r2 = n2[0].replace(",", ".");
  return Number(r2);
}
function T2(e2) {
  return e2.toISOString().replace(/\.[0-9]{3}/, "");
}
var V2 = /* @__PURE__ */ new Set([102100, 3857, 102113, 900913]);
var O2 = /* @__PURE__ */ new Set([3395, 54004]);
function _(e2, t3) {
  let n2 = e2.wkid;
  return null == t3 ? n2 : (null != n2 && t3.includes(n2) || !e2.latestWkid || (n2 = e2.latestWkid), null != n2 && V2.has(n2) ? t3.find((e3) => V2.has(e3)) || t3.find((e3) => O2.has(e3)) || 102100 : n2);
}

// node_modules/@arcgis/core/layers/WMSLayer.js
var J = new s3({ bmp: "image/bmp", gif: "image/gif", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml" }, { ignoreUnknown: false });
function V3(e2) {
  return "text/html" === e2;
}
function z(e2) {
  return "text/plain" === e2;
}
var Q = class extends a4(a5(p(t(c3(j2(O(b))))))) {
  constructor(...e2) {
    super(...e2), this.allSublayers = new n({ getCollections: () => [this.sublayers], getChildrenFunction: (e3) => e3.sublayers }), this.customParameters = null, this.customLayerParameters = null, this.copyright = null, this.description = null, this.dimensions = null, this.fullExtent = null, this.fullExtents = null, this.featureInfoFormats = null, this.featureInfoUrl = null, this.fetchFeatureInfoFunction = null, this.imageFormat = null, this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.legendEnabled = true, this.mapUrl = null, this.isReference = null, this.operationalLayerType = "WMS", this.spatialReference = null, this.spatialReferences = null, this.sublayers = null, this.type = "wms", this.version = null, this.addHandles([a3(() => this.sublayers, "after-add", ({ item: e3 }) => {
      e3.parent = e3.layer = this;
    }, U), a3(() => this.sublayers, "after-remove", ({ item: e3 }) => {
      e3.layer = e3.parent = null;
    }, U), l(() => this.sublayers, (e3, t3) => {
      if (t3)
        for (const r2 of t3)
          r2.layer = r2.parent = null;
      if (e3)
        for (const r2 of e3)
          r2.parent = r2.layer = this;
    }, U)]);
  }
  normalizeCtorArgs(e2, t3) {
    return "string" == typeof e2 ? { url: e2, ...t3 } : e2;
  }
  destroy() {
    this.allSublayers.destroy();
  }
  load(e2) {
    const t3 = null != e2 ? e2.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["WMS"] }, e2).catch(f).then(() => this._fetchService(t3))), Promise.resolve(this);
  }
  readFullExtentFromItemOrMap(e2, t3) {
    const r2 = t3.extent;
    return r2 ? new M({ xmin: r2[0][0], ymin: r2[0][1], xmax: r2[1][0], ymax: r2[1][1] }) : null;
  }
  writeFullExtent(e2, t3) {
    t3.extent = [[e2.xmin, e2.ymin], [e2.xmax, e2.ymax]];
  }
  get featureInfoFormat() {
    return null == this.featureInfoFormats ? null : this.featureInfoFormats.find(V3) ?? this.featureInfoFormats.find(z) ?? null;
  }
  set featureInfoFormat(e2) {
    null == e2 ? (this.revert("featureInfoFormat", "service"), this._clearOverride("featureInfoFormat")) : (V3(e2) || z(e2)) && this._override("featureInfoFormat", e2);
  }
  readImageFormat(e2, t3) {
    const r2 = t3.supportedImageFormatTypes;
    return r2 && r2.includes("image/png") ? "image/png" : r2 && r2[0];
  }
  readSpatialReferenceFromItemOrDocument(e2, t3) {
    return new f2(t3.spatialReferences[0]);
  }
  writeSpatialReferences(e2, t3) {
    var _a;
    const r2 = (_a = this.spatialReference) == null ? void 0 : _a.wkid;
    e2 && r2 ? (t3.spatialReferences = e2.filter((e3) => e3 !== r2), t3.spatialReferences.unshift(r2)) : t3.spatialReferences = e2;
  }
  readSublayersFromItemOrMap(e2, t3, r2) {
    return X(t3.layers, r2, t3.visibleLayers);
  }
  readSublayers(e2, t3, r2) {
    return X(t3.layers, r2);
  }
  writeSublayers(e2, t3, r2, o4) {
    var _a, _b;
    t3.layers = [];
    const s6 = /* @__PURE__ */ new Map(), i2 = e2.flatten(({ sublayers: e3 }) => e3 ?? []);
    for (const a7 of i2)
      if ("number" == typeof ((_a = a7.parent) == null ? void 0 : _a.id)) {
        const e3 = s6.get(a7.parent.id);
        null != e3 ? e3.push(a7.id) : s6.set(a7.parent.id, [a7.id]);
      }
    for (const a7 of i2) {
      const e3 = { sublayer: a7, ...o4 }, r3 = a7.write({ parentLayerId: "number" == typeof ((_b = a7.parent) == null ? void 0 : _b.id) ? a7.parent.id : -1 }, e3);
      if (s6.has(a7.id) && (r3.sublayerIds = s6.get(a7.id)), !a7.sublayers && a7.name) {
        const r4 = a7.write({}, e3);
        delete r4.id, t3.layers.push(r4);
      }
    }
    t3.visibleLayers = i2.filter(({ visible: e3, sublayers: t4 }) => e3 && !t4).map(({ name: e3 }) => e3).toArray();
  }
  set url(e2) {
    if (!e2)
      return void this._set("url", e2);
    const { path: t3, query: r2 } = L(e2);
    for (const s6 in r2)
      /^(request|service)$/i.test(s6) && delete r2[s6];
    const o4 = kt(t3, r2 ?? {});
    this._set("url", o4);
  }
  createExportImageParameters(e2, t3, r2, o4) {
    const s6 = (o4 == null ? void 0 : o4.pixelRatio) ?? 1, i2 = i({ extent: e2, width: t3 }) * s6, a7 = new l2({ layer: this, scale: i2 }), { xmin: n2, ymin: l4, xmax: p3, ymax: m3, spatialReference: u2 } = e2, c6 = _(u2, this.spatialReferences), f6 = "1.3.0" === this.version && o2(c6) ? `${l4},${n2},${m3},${p3}` : `${n2},${l4},${p3},${m3}`, y3 = a7.toJSON();
    return { bbox: f6, ["1.3.0" === this.version ? "crs" : "srs"]: null == c6 || isNaN(c6) ? void 0 : "EPSG:" + c6, ...y3 };
  }
  async fetchImage(e2, t3, r2, o4) {
    var _a, _b;
    const i2 = this.mapUrl, a7 = this.createExportImageParameters(e2, t3, r2, o4);
    if (!a7.layers) {
      const e3 = document.createElement("canvas");
      return e3.width = t3, e3.height = r2, e3;
    }
    const n2 = (_a = o4 == null ? void 0 : o4.timeExtent) == null ? void 0 : _a.start, l4 = (_b = o4 == null ? void 0 : o4.timeExtent) == null ? void 0 : _b.end, p3 = null != n2 && null != l4 ? n2.getTime() === l4.getTime() ? T2(n2) : `${T2(n2)}/${T2(l4)}` : void 0, m3 = { responseType: "image", query: this._mixCustomParameters({ width: t3, height: r2, ...a7, time: p3, ...this.refreshParameters }), signal: o4 == null ? void 0 : o4.signal };
    return j(i2 ?? "", m3).then((e3) => e3.data);
  }
  async fetchImageBitmap(e2, t3, r2, o4) {
    var _a, _b;
    const i2 = this.mapUrl ?? "", a7 = this.createExportImageParameters(e2, t3, r2, o4);
    if (!a7.layers) {
      const e3 = document.createElement("canvas");
      return e3.width = t3, e3.height = r2, e3;
    }
    const n2 = (_a = o4 == null ? void 0 : o4.timeExtent) == null ? void 0 : _a.start, l4 = (_b = o4 == null ? void 0 : o4.timeExtent) == null ? void 0 : _b.end, p3 = null != n2 && null != l4 ? n2.getTime() === l4.getTime() ? T2(n2) : `${T2(n2)}/${T2(l4)}` : void 0, m3 = { responseType: "blob", query: this._mixCustomParameters({ width: t3, height: r2, ...a7, time: p3, ...this.refreshParameters }), signal: o4 == null ? void 0 : o4.signal }, { data: u2 } = await j(i2, m3);
    return t2(u2, i2, o4 == null ? void 0 : o4.signal);
  }
  fetchFeatureInfo(e2, t3, r2, o4, s6) {
    const i2 = i({ extent: e2, width: t3 }), a7 = new l2({ layer: this, scale: i2 }), n2 = a6(a7.visibleSublayers);
    if (null == this.featureInfoUrl || null == n2)
      return Promise.resolve([]);
    if (null == this.fetchFeatureInfoFunction && null == this.featureInfoFormat)
      return Promise.resolve([]);
    const l4 = "1.3.0" === this.version ? { I: o4, J: s6 } : { x: o4, y: s6 }, p3 = { query_layers: n2, request: "GetFeatureInfo", info_format: this.featureInfoFormat, feature_count: 25, width: t3, height: r2, ...l4 }, m3 = { ...this.createExportImageParameters(e2, t3, r2), ...p3 }, u2 = this._mixCustomParameters(m3);
    return null != this.fetchFeatureInfoFunction ? this.fetchFeatureInfoFunction(u2) : this._defaultFetchFeatureInfoFunction(kt(this.featureInfoUrl, u2));
  }
  findSublayerById(e2) {
    return this.allSublayers.find((t3) => t3.id === e2);
  }
  findSublayerByName(e2) {
    return this.allSublayers.find((t3) => t3.name === e2);
  }
  serviceSupportsSpatialReference(e2) {
    return C(this.url) || null != this.spatialReferences && this.spatialReferences.some((t3) => {
      const r2 = 900913 === t3 ? f2.WebMercator : new f2({ wkid: t3 });
      return S2(r2, e2);
    });
  }
  _defaultFetchFeatureInfoFunction(e2) {
    const t3 = document.createElement("iframe");
    t3.src = S(e2), t3.style.border = "none", t3.style.margin = "0", t3.style.width = "100%", t3.setAttribute("sandbox", "");
    const s6 = new k({ title: this.title, content: t3 }), i2 = new h({ sourceLayer: this, popupTemplate: s6 });
    return Promise.resolve([i2]);
  }
  async _fetchService(e2) {
    var _a;
    if (!this.resourceInfo && ((_a = this.parsedUrl) == null ? void 0 : _a.path)) {
      const { path: t3, query: r2 } = this.parsedUrl, { data: o4 } = await j(t3, { query: { SERVICE: "WMS", REQUEST: "GetCapabilities", ...r2, ...this.customParameters }, responseType: "xml", signal: e2 });
      this.resourceInfo = l3(o4);
    }
    if (this.parsedUrl) {
      const e3 = new $(this.parsedUrl.path), { httpsDomains: r2 } = s.request;
      "https" !== e3.scheme || e3.port && "443" !== e3.port || !e3.host || r2.includes(e3.host) || r2.push(e3.host);
    }
    this.read(this.resourceInfo, { origin: "service" });
  }
  _mixCustomParameters(e2) {
    if (!this.customLayerParameters && !this.customParameters)
      return e2;
    const t3 = { ...this.customParameters, ...this.customLayerParameters };
    for (const r2 in t3)
      e2[r2.toLowerCase()] = t3[r2];
    return e2;
  }
};
function K(e2, t3) {
  return e2.some((e3) => {
    for (const r2 in e3)
      if (c(e3, r2, null, t3))
        return true;
    return false;
  });
}
function X(e2, t3, r2) {
  e2 = e2 ?? [];
  const o4 = /* @__PURE__ */ new Map();
  e2.every((e3) => null == e3.id) && (e2 = a(e2)).forEach((e3, t4) => e3.id = t4);
  for (const i2 of e2) {
    const e3 = new f4();
    e3.read(i2, t3), r2 && !r2.includes(e3.name) && (e3.visible = false), o4.set(e3.id, e3);
  }
  const s6 = [];
  for (const a7 of e2) {
    const e3 = null != a7.id ? o4.get(a7.id) : null;
    if (e3)
      if (null != a7.parentLayerId && a7.parentLayerId >= 0) {
        const t4 = o4.get(a7.parentLayerId);
        if (!t4)
          continue;
        t4.sublayers || (t4.sublayers = new V()), t4.sublayers.push(e3);
      } else
        s6.push(e3);
  }
  return s6;
}
e([y({ readOnly: true })], Q.prototype, "allSublayers", void 0), e([y({ json: { type: Object, write: true } })], Q.prototype, "customParameters", void 0), e([y({ json: { type: Object, write: true } })], Q.prototype, "customLayerParameters", void 0), e([y({ type: String, json: { write: true } })], Q.prototype, "copyright", void 0), e([y()], Q.prototype, "description", void 0), e([y({ readOnly: true })], Q.prototype, "dimensions", void 0), e([y({ json: { type: [[Number]], read: { source: "extent" }, write: { target: "extent" }, origins: { "web-document": { write: { ignoreOrigin: true } }, "portal-item": { write: { ignoreOrigin: true } } } } })], Q.prototype, "fullExtent", void 0), e([o(["web-document", "portal-item"], "fullExtent", ["extent"])], Q.prototype, "readFullExtentFromItemOrMap", null), e([r(["web-document", "portal-item"], "fullExtent", { extent: { type: [[Number]] } })], Q.prototype, "writeFullExtent", null), e([y()], Q.prototype, "fullExtents", void 0), e([y({ type: String, json: { write: { ignoreOrigin: true } } })], Q.prototype, "featureInfoFormat", null), e([y({ type: [String], readOnly: true })], Q.prototype, "featureInfoFormats", void 0), e([y({ type: String, json: { write: { ignoreOrigin: true } } })], Q.prototype, "featureInfoUrl", void 0), e([y()], Q.prototype, "fetchFeatureInfoFunction", void 0), e([y({ type: String, json: { origins: { "web-document": { default: "image/png", type: J.jsonValues, read: { reader: J.read, source: "format" }, write: { writer: J.write, target: "format" } } } } })], Q.prototype, "imageFormat", void 0), e([o("imageFormat", ["supportedImageFormatTypes"])], Q.prototype, "readImageFormat", null), e([y({ type: Number, json: { read: { source: "maxHeight" }, write: { target: "maxHeight" } } })], Q.prototype, "imageMaxHeight", void 0), e([y({ type: Number, json: { read: { source: "maxWidth" }, write: { target: "maxWidth" } } })], Q.prototype, "imageMaxWidth", void 0), e([y()], Q.prototype, "imageTransparency", void 0), e([y(c2)], Q.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide", "hide-children"] })], Q.prototype, "listMode", void 0), e([y({ type: String, json: { write: { ignoreOrigin: true } } })], Q.prototype, "mapUrl", void 0), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], Q.prototype, "isReference", void 0), e([y({ type: ["WMS"] })], Q.prototype, "operationalLayerType", void 0), e([y()], Q.prototype, "resourceInfo", void 0), e([y({ type: f2, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, write: false } })], Q.prototype, "spatialReference", void 0), e([o(["web-document", "portal-item"], "spatialReference", ["spatialReferences"])], Q.prototype, "readSpatialReferenceFromItemOrDocument", null), e([y({ type: [T], json: { read: false, origins: { service: { read: true }, "web-document": { read: false, write: { ignoreOrigin: true } }, "portal-item": { read: false, write: { ignoreOrigin: true } } } } })], Q.prototype, "spatialReferences", void 0), e([r(["web-document", "portal-item"], "spatialReferences")], Q.prototype, "writeSpatialReferences", null), e([y({ type: V.ofType(f4), json: { write: { target: "layers", overridePolicy(e2, t3, r2) {
  if (K(this.allSublayers, r2))
    return { ignoreOrigin: true };
} } } })], Q.prototype, "sublayers", void 0), e([o(["web-document", "portal-item"], "sublayers", ["layers", "visibleLayers"])], Q.prototype, "readSublayersFromItemOrMap", null), e([o("service", "sublayers", ["layers"])], Q.prototype, "readSublayers", null), e([r("sublayers", { layers: { type: [f4] }, visibleLayers: { type: [String] } })], Q.prototype, "writeSublayers", null), e([y({ json: { read: false }, readOnly: true, value: "wms" })], Q.prototype, "type", void 0), e([y(f3)], Q.prototype, "url", null), e([y({ type: String, json: { write: { ignoreOrigin: true } } })], Q.prototype, "version", void 0), Q = e([a2("esri.layers.WMSLayer")], Q);
var Y = Q;
export {
  Y as default
};
//# sourceMappingURL=WMSLayer-ICMY7QS2.js.map
