import {
  F as F2,
  K,
  M,
  O,
  R,
  S,
  W,
  b,
  h,
  m as m2,
  p,
  x
} from "./chunk-TQF2QRC7.js";
import {
  T as T2
} from "./chunk-C3ULZZZU.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import {
  f as f2,
  n as n2,
  o,
  s as s2,
  t
} from "./chunk-Z36PKTLY.js";
import {
  F,
  I,
  P,
  a,
  c as c2,
  d,
  g,
  i2 as i,
  l,
  m,
  n2 as n,
  s3 as s,
  u as u2
} from "./chunk-RFI4CCAC.js";
import {
  c
} from "./chunk-YAWND7HF.js";
import {
  DateTime
} from "./chunk-ODFH3BSN.js";
import {
  f
} from "./chunk-SFV6XLDZ.js";
import {
  T
} from "./chunk-HNHXEGH2.js";
import {
  u
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/arcade/featureset/support/cache.js
var a2 = class {
  constructor() {
    this._databaseTypeMetaData = {}, this._layerInfo = {};
  }
  clearDatabaseType(a3) {
    void 0 === this._databaseTypeMetaData[a3] && delete this._databaseTypeMetaData[a3];
  }
  getDatabaseType(a3) {
    return "MUSTBESET" === a3 || void 0 === this._databaseTypeMetaData[a3] ? null : this._databaseTypeMetaData[a3];
  }
  setDatabaseType(a3, e2) {
    this._databaseTypeMetaData[a3] = e2;
  }
  getLayerInfo(a3) {
    return void 0 === this._layerInfo[a3] ? null : this._layerInfo[a3];
  }
  setLayerInfo(a3, e2) {
    this._layerInfo[a3] = e2;
  }
  clearLayerInfo(a3) {
    void 0 !== this._layerInfo[a3] && delete this._layerInfo[a3];
  }
};
a2.applicationCache = null;

// node_modules/@arcgis/core/arcade/featureset/support/sqlUtils.js
function u3(e2, r2) {
  return y(e2 == null ? void 0 : e2.parseTree, r2, e2 == null ? void 0 : e2.parameters);
}
function f3(e2, r2, t3) {
  return y(e2, r2, t3);
}
function p2(e2, t3, a3, s4) {
  return f2.create(y(e2.parseTree, i.Standardised, e2.parameters, t3, a3), s4);
}
function m4(e2, t3, a3 = "AND") {
  return f2.create("((" + u3(e2, i.Standardised) + ")" + a3 + "(" + u3(t3, i.Standardised) + "))", e2.fieldsIndex);
}
function y(e2, n3, o3, i3 = null, u5 = null, l3 = null) {
  let d3, f6, p4, m6;
  switch (e2.type) {
    case "interval":
      return R2(y(e2.value, n3, o3, i3, u5, l3), e2.qualifier, e2.op);
    case "case-expression": {
      let r2 = " CASE ";
      "simple" === e2.format && (r2 += y(e2.operand, n3, o3, i3, u5, l3));
      for (let t3 = 0; t3 < e2.clauses.length; t3++)
        r2 += " WHEN " + y(e2.clauses[t3].operand, n3, o3, i3, u5, l3) + " THEN " + y(e2.clauses[t3].value, n3, o3, i3, u5, l3);
      return null !== e2.else && (r2 += " ELSE " + y(e2.else, n3, o3, i3, u5, l3)), r2 += " END ", r2;
    }
    case "parameter": {
      const r2 = o3[e2.value.toLowerCase()];
      if ("string" == typeof r2) {
        return "'" + o3[e2.value.toLowerCase()].toString().replaceAll("'", "''") + "'";
      }
      if (c2(r2))
        return T3(r2, n3, l3);
      if (a(r2))
        return h2(r2, n3, l3);
      if (r2 instanceof Array) {
        const e3 = [];
        for (let s4 = 0; s4 < r2.length; s4++)
          "string" == typeof r2[s4] ? e3.push("'" + r2[s4].toString().replaceAll("'", "''") + "'") : c2(r2[s4]) ? e3.push(T3(r2[s4], n3, l3)) : a(r2[s4]) ? e3.push(h2(r2[s4], n3, l3)) : e3.push(r2[s4].toString());
        return e3;
      }
      return r2.toString();
    }
    case "expression-list":
      f6 = [];
      for (const r2 of e2.value)
        f6.push(y(r2, n3, o3, i3, u5, l3));
      return f6;
    case "unary-expression":
      return " ( NOT " + y(e2.expr, n3, o3, i3, u5, l3) + " ) ";
    case "binary-expression":
      switch (e2.operator) {
        case "AND":
          return " (" + y(e2.left, n3, o3, i3, u5, l3) + " AND " + y(e2.right, n3, o3, i3, u5, l3) + ") ";
        case "OR":
          return " (" + y(e2.left, n3, o3, i3, u5, l3) + " OR " + y(e2.right, n3, o3, i3, u5, l3) + ") ";
        case "IS":
          if ("null" !== e2.right.type)
            throw new s2(t.UnsupportedIsRhs);
          return " (" + y(e2.left, n3, o3, i3, u5, l3) + " IS NULL )";
        case "ISNOT":
          if ("null" !== e2.right.type)
            throw new s2(t.UnsupportedIsRhs);
          return " (" + y(e2.left, n3, o3, i3, u5, l3) + " IS NOT NULL )";
        case "IN":
          return d3 = [], "expression-list" === e2.right.type ? (d3 = y(e2.right, n3, o3, i3, u5), " (" + y(e2.left, n3, o3, i3, u5, l3) + " IN (" + d3.join(",") + ")) ") : (m6 = y(e2.right, n3, o3, i3, u5, l3), m6 instanceof Array ? " (" + y(e2.left, n3, o3, i3, u5, l3) + " IN (" + m6.join(",") + ")) " : " (" + y(e2.left, n3, o3, i3, u5, l3) + " IN (" + m6 + ")) ");
        case "NOT IN":
          return d3 = [], "expression-list" === e2.right.type ? (d3 = y(e2.right, n3, o3, i3, u5), " (" + y(e2.left, n3, o3, i3, u5, l3) + " NOT IN (" + d3.join(",") + ")) ") : (m6 = y(e2.right, n3, o3, i3, u5, l3), m6 instanceof Array ? " (" + y(e2.left, n3, o3, i3, u5, l3) + " NOT IN (" + m6.join(",") + ")) " : " (" + y(e2.left, n3, o3, i3, u5, l3) + " NOT IN (" + m6 + ")) ");
        case "BETWEEN":
          return p4 = y(e2.right, n3, o3, i3, u5, l3), " (" + y(e2.left, n3, o3, i3, u5, l3) + " BETWEEN " + p4[0] + " AND " + p4[1] + " ) ";
        case "NOTBETWEEN":
          return p4 = y(e2.right, n3, o3, i3, u5, l3), " (" + y(e2.left, n3, o3, i3, u5, l3) + " NOT BETWEEN " + p4[0] + " AND " + p4[1] + " ) ";
        case "LIKE":
          return "" !== e2.escape ? " (" + y(e2.left, n3, o3, i3, u5, l3) + " LIKE " + y(e2.right, n3, o3, i3, u5, l3) + " ESCAPE '" + e2.escape + "') " : " (" + y(e2.left, n3, o3, i3, u5, l3) + " LIKE " + y(e2.right, n3, o3, i3, u5, l3) + ") ";
        case "NOT LIKE":
          return "" !== e2.escape ? " (" + y(e2.left, n3, o3, i3, u5, l3) + " NOT LIKE " + y(e2.right, n3, o3, i3, u5, l3) + " ESCAPE '" + e2.escape + "') " : " (" + y(e2.left, n3, o3, i3, u5, l3) + " NOT LIKE " + y(e2.right, n3, o3, i3, u5, l3) + ") ";
        case "<>":
        case "<":
        case ">":
        case ">=":
        case "<=":
        case "=":
        case "*":
        case "-":
        case "+":
        case "/":
          return " (" + y(e2.left, n3, o3, i3, u5, l3) + " " + e2.operator + " " + y(e2.right, n3, o3, i3, u5, l3) + ") ";
        case "||":
          return " (" + y(e2.left, n3, o3, i3, u5, l3) + " " + (n3 === i.SqlServer ? "+" : e2.operator) + " " + y(e2.right, n3, o3, i3, u5, l3) + ") ";
      }
      throw new s2(t.UnsupportedOperator, { operator: e2.operator });
    case "null":
      return "null";
    case "boolean":
      return true === e2.value ? "1" : "0";
    case "string":
      return "'" + e2.value.toString().replaceAll("'", "''") + "'";
    case "timestamp":
    case "date":
      return T3(e2.value, n3, l3);
    case "number":
      return e2.value.toString();
    case "current-time":
      return L("date" === e2.mode, n3);
    case "column-reference":
      return i3 && i3.toLowerCase() === e2.column.toLowerCase() ? "(" + u5 + ")" : e2.column;
    case "data-type":
      return e2.value;
    case "function": {
      const r2 = y(e2.args, n3, o3, i3, u5, l3);
      return g2(e2.name, r2, n3);
    }
  }
  throw new s2(t.UnsupportedSyntax, { node: e2.type });
}
function g2(e2, t3, a3) {
  switch (e2.toLowerCase().trim()) {
    case "cos":
    case "sin":
    case "tan":
    case "cosh":
    case "tanh":
    case "sinh":
    case "acos":
    case "asin":
    case "atan":
    case "floor":
    case "log10":
    case "log":
    case "abs":
      if (1 !== t3.length)
        throw new s2(t.InvalidFunctionParameters, { function: e2.toLowerCase().trim() });
      return `${e2.toUpperCase().trim()}(${t3[0]})`;
    case "ceiling":
    case "ceil":
      if (1 !== t3.length)
        throw new s2(t.InvalidFunctionParameters, { function: "ceiling" });
      switch (a3) {
        case i.Standardised:
        case i.StandardisedNoInterval:
      }
      return "CEILING(" + t3[0] + ")";
    case "mod":
    case "power":
    case "nullif":
      if (2 !== t3.length)
        throw new s2(t.InvalidFunctionParameters, { function: e2.toLowerCase().trim() });
      return `${e2.toUpperCase().trim()}(${t3[0]},${t3[1]})`;
    case "round":
      if (2 === t3.length)
        return "ROUND(" + t3[0] + "," + t3[1] + ")";
      if (1 === t3.length)
        return "ROUND(" + t3[0] + ")";
      throw new s2(t.InvalidFunctionParameters, { function: "round" });
    case "truncate":
      if (t3.length < 1 || t3.length > 2)
        throw new s2(t.InvalidFunctionParameters, { function: "truncate" });
      return a3 === i.SqlServer ? "ROUND(" + t3[0] + (1 === t3.length ? "0" : "," + t3[1]) + ",1)" : "TRUNCATE(" + t3[0] + (1 === t3.length ? ")" : "," + t3[1] + ")");
    case "char_length":
    case "len":
      if (1 !== t3.length)
        throw new s2(t.InvalidFunctionParameters, { function: "char_length" });
      switch (a3) {
        case i.SqlServer:
          return "LEN(" + t3[0] + ")";
        case i.Oracle:
          return "LENGTH(" + t3[0] + ")";
        default:
          return "CHAR_LENGTH(" + t3[0] + ")";
      }
    case "coalesce":
    case "concat": {
      if (t3.length < 1)
        throw new s2(t.InvalidFunctionParameters, { function: e2.toLowerCase() });
      let r2 = e2.toUpperCase().trim() + "(";
      for (let e3 = 0; e3 < t3.length; e3++)
        0 !== e3 && (r2 += ","), r2 += t3[e3];
      return r2 += ")", r2;
    }
    case "lower":
    case "lcase":
      if (1 !== t3.length)
        throw new s2(t.InvalidFunctionParameters, { function: "lower" });
      return "LOWER(" + t3[0] + ")";
    case "upper":
    case "ucase":
      if (1 !== t3.length)
        throw new s2(t.InvalidFunctionParameters, { function: "upper" });
      return "UPPER(" + t3[0] + ")";
    case "substring": {
      let e3 = "";
      switch (a3) {
        case i.Oracle:
          return e3 = "SUBSTR(" + t3[0] + "," + t3[1], 3 === t3.length && (e3 += "," + t3[2]), e3 += ")", e3;
        case i.SqlServer:
          return e3 = 3 === t3.length ? "SUBSTRING(" + t3[0] + "," + t3[1] + "," + t3[2] + ")" : "SUBSTRING(" + t3[0] + ",  " + t3[1] + ", LEN(" + t3[0] + ") - " + t3[1] + ")", e3;
        default:
          return e3 = "SUBSTRING(" + t3[0] + " FROM " + t3[1], 3 === t3.length && (e3 += " FOR " + t3[2]), e3 += ")", e3;
      }
    }
    case "extract":
      return "EXTRACT(" + t3[0].replaceAll("'", "") + " FROM " + t3[1] + ")";
    case "cast": {
      let e3 = "";
      switch (a3) {
        case i.Oracle:
          switch (t3[1].type) {
            case "date":
              e3 = "DATE";
              break;
            case "float":
              e3 = "DOUBLE";
              break;
            case "integer":
              e3 = "INTEGER";
              break;
            case "real":
              e3 = "REAL";
              break;
            case "smallint":
              e3 = "SMALLINT";
              break;
            case "timestamp":
              e3 = "TIMESTAMP";
              break;
            case "varchar":
              e3 = "VARCHAR(" + t3[1].size.toString() + ")";
          }
          return `CAST(${t3[0]} AS ${e3})`;
        case i.Postgres:
          switch (t3[1].type) {
            case "date":
              e3 = "DATE";
              break;
            case "float":
              e3 = "DOUBLE PRECISION";
              break;
            case "integer":
              e3 = "INT";
              break;
            case "real":
              e3 = "REAL";
              break;
            case "smallint":
              e3 = "SMALLINT";
              break;
            case "timestamp":
              e3 = "TIMESTAMP";
              break;
            case "varchar":
              e3 = "VARCHAR(" + t3[1].size.toString() + ")";
          }
          return `CAST(${t3[0]} AS ${e3})`;
        case i.SqlServer:
          switch (t3[1].type) {
            case "date":
              e3 = "DATE";
              break;
            case "float":
              e3 = "FLOAT";
              break;
            case "integer":
              e3 = "INT";
              break;
            case "real":
              e3 = "REAL";
              break;
            case "smallint":
              e3 = "SMALLINT";
              break;
            case "timestamp":
              e3 = "DATETIME";
              break;
            case "varchar":
              e3 = "VARCHAR(" + t3[1].size.toString() + ")";
          }
          return `CAST(${t3[0]} AS ${e3})`;
        default:
          switch (t3[1].type) {
            case "date":
              e3 = "DATE";
              break;
            case "float":
              e3 = "FLOAT";
              break;
            case "integer":
              e3 = "INTEGER";
              break;
            case "real":
              e3 = "REAL";
              break;
            case "smallint":
              e3 = "SMALLINT";
              break;
            case "timestamp":
              e3 = "TIMESTAMP";
              break;
            case "varchar":
              e3 = "VARCHAR(" + t3[1].size.toString() + ")";
          }
          return `CAST(${t3[0]} AS ${e3})`;
      }
    }
  }
  throw new s2(t.InvalidFunctionParameters, { function: e2 });
}
function h2(t3, a3, n3, s4) {
  (n3 == null ? void 0 : n3.outputTimeReference) && (t3 = c.arcadeDateAndZoneToArcadeDate(t3, n3 == null ? void 0 : n3.outputTimeReference));
  const c3 = t3.toDateTime(), o3 = 0 === c3.hour && 0 === c3.minute && 0 === c3.second && 0 === c3.millisecond;
  switch (a3) {
    case i.FILEGDB:
    case i.Standardised:
    case i.StandardisedNoInterval:
      return o3 ? `date '${c3.toFormat("yyyy-LL-dd")}'` : `date '${c3.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
    case i.Oracle:
      return o3 ? `TO_DATE('${c3.toFormat("yyyy-LL-dd")}','YYYY-MM-DD')` : `TO_DATE('${c3.toFormat("yyyy-LL-dd HH:mm:ss")}','YYYY-MM-DD HH24:MI:SS')`;
    case i.SqlServer:
      return `'${c3.toFormat(o3 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    case i.PGDB:
      return `#${c3.toFormat(o3 ? "LL-dd-yyyy" : "LL-dd-yyyy HH:mm:ss")}#`;
    case i.Postgres:
      return `TIMESTAMP '${c3.toFormat(o3 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    default:
      return `date '${c3.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
  }
}
function T3(e2, a3, n3, s4) {
  let c3 = c2(e2) ? DateTime.fromJSDate(e2) : DateTime.fromSQL(e2);
  const o3 = 0 === c3.hour && 0 === c3.minute && 0 === c3.second && 0 === c3.millisecond;
  switch ((n3 == null ? void 0 : n3.inputTimeReference) && (c3 = DateTime.fromObject({ day: c3.day, year: c3.year, month: c3.month, hour: c3.hour, minute: c3.minute, second: c3.second, millisecond: c3.millisecond }, { zone: n3.inputTimeReference })), (n3 == null ? void 0 : n3.outputTimeReference) && (c3 = c3.setZone(n3.outputTimeReference)), a3) {
    case i.FILEGDB:
    case i.Standardised:
    case i.StandardisedNoInterval:
      return o3 ? `date '${c3.toFormat("yyyy-LL-dd")}'` : `date '${c3.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
    case i.Oracle:
      return o3 ? `TO_DATE('${c3.toFormat("yyyy-LL-dd")}','YYYY-MM-DD')` : `TO_DATE('${c3.toFormat("yyyy-LL-dd HH:mm:ss")}','YYYY-MM-DD HH24:MI:SS')`;
    case i.SqlServer:
      return `'${c3.toFormat(o3 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    case i.PGDB:
      return `#${c3.toFormat(o3 ? "LL-dd-yyyy" : "LL-dd-yyyy HH:mm:ss")}#`;
    case i.Postgres:
      return `TIMESTAMP '${c3.toFormat(o3 ? "yyyy-LL-dd" : "yyyy-LL-dd HH:mm:ss")}'`;
    default:
      return `date '${c3.toFormat("yyyy-LL-dd HH:mm:ss")}'`;
  }
}
function L(e2, t3) {
  switch (t3) {
    case i.FILEGDB:
    case i.Standardised:
    case i.StandardisedNoInterval:
    case i.Oracle:
      return e2 ? "CURRENT_DATE" : "CURRENT_TIMESTAMP";
    case i.SqlServer:
      return e2 ? "CAST(GETDATE() AS DATE)" : "GETDATE()";
    case i.PGDB:
    case i.Postgres:
    default:
      return e2 ? "CURRENT_DATE" : "CURRENT_TIMESTAMP";
  }
}
function S2(e2, r2, t3 = {}) {
  const a3 = {}, n3 = {}, s4 = { esriFieldTypeSmallInteger: "integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "double", esriFieldTypeDouble: "double", esriFieldTypeString: "string", esriFieldTypeDate: "date", esriFieldTypeOID: "integer", esriFieldTypeGUID: "guid", esriFieldTypeGlobalID: "guid", oid: "integer", long: "integer", "small-integer": "integer", integer: "integer", single: "double", double: "double", date: "date", guid: "guid", globalid: "guid", string: "string" };
  for (const c3 of r2) {
    const e3 = c3.type ? s4[c3.type] : void 0;
    a3[c3.name.toLowerCase()] = void 0 === e3 ? "" : e3;
  }
  for (const c3 in t3) {
    const e3 = s4[t3[c3]];
    n3[c3.toLowerCase()] = void 0 === e3 ? "" : e3;
  }
  switch (E(a3, e2.parseTree, e2.parameters, n3)) {
    case "double":
      return "double";
    case "integer":
      return "integer";
    case "date":
      return "date";
    case "string":
      return "string";
    case "global-id":
    case "guid":
      return "guid";
  }
  return "";
}
function E(e2, r2, n3, o3) {
  var _a, _b;
  let i3;
  switch (r2.type) {
    case "interval":
      return "integer";
    case "case-expression": {
      const t3 = [];
      if ("simple" === r2.format) {
        for (let a3 = 0; a3 < r2.clauses.length; a3++)
          t3.push(E(e2, r2.clauses[a3].value, n3, o3));
        null !== r2.else && t3.push(E(e2, r2.else, n3, o3));
      } else {
        for (let a3 = 0; a3 < r2.clauses.length; a3++)
          t3.push(E(e2, r2.else, n3, o3));
        null !== r2.else && t3.push(E(e2, r2.else, n3, o3));
      }
      return w(t3);
    }
    case "parameter": {
      const e3 = o3[r2.value.toLowerCase()];
      if (void 0 === e3 && n3) {
        const e4 = n3[r2.value.toLowerCase()];
        if (void 0 === e4)
          return "";
        if (null === e4)
          return "";
        if ("string" == typeof e4 || e4 instanceof String)
          return "string";
        if ("boolean" == typeof e4)
          return "boolean";
        if (c2(e4))
          return "date";
        if (a(e4))
          return "date";
        if ("number" == typeof e4)
          return e4 % 1 == 0 ? "integer" : "double";
      }
      return void 0 === e3 ? "" : e3;
    }
    case "expression-list": {
      const t3 = [];
      for (const a3 of r2.value)
        t3.push(E(e2, a3, n3, o3));
      return t3;
    }
    case "unary-expression":
      return "boolean";
    case "binary-expression":
      switch (r2.operator) {
        case "AND":
        case "OR":
        case "IN":
        case "NOT IN":
        case "BETWEEN":
        case "NOTBETWEEN":
        case "LIKE":
        case "NOT LIKE":
        case "<>":
        case "<":
        case ">":
        case ">=":
        case "<=":
        case "=":
          return "boolean";
        case "IS":
        case "ISNOT":
          if ("null" !== r2.right.type)
            throw new s2(t.UnsupportedIsRhs);
          return "boolean";
        case "*":
        case "-":
        case "+":
        case "/":
          return w([E(e2, r2.left, n3, o3), E(e2, r2.right, n3, o3)]);
        case "||":
          return "string";
        default:
          throw new s2(t.UnsupportedOperator, { operator: r2.operator });
      }
    case "null":
      return "";
    case "boolean":
      return "boolean";
    case "string":
      return "string";
    case "number":
      return null === r2.value ? "" : r2.value % 1 == 0 ? "integer" : "double";
    case "date":
    case "timestamp":
    case "current-time":
      return "date";
    case "column-reference": {
      const t3 = e2[r2.column.toLowerCase()];
      return void 0 === t3 ? "" : t3;
    }
    case "function":
      switch (r2.name.toLowerCase()) {
        case "cast":
          switch (((_b = (_a = r2.args) == null ? void 0 : _a.value[1]) == null ? void 0 : _b.value.type) ?? "") {
            case "integer":
            case "smallint":
              return "integer";
            case "real":
            case "float":
              return "double";
            case "date":
            case "timestamp":
              return "date";
            case "varchar":
              return "string";
            default:
              return "";
          }
        case "position":
        case "extract":
        case "char_length":
        case "mod":
          return "integer";
        case "round":
          if (i3 = E(e2, r2.args, n3, o3), i3 instanceof Array) {
            if (i3.length <= 0)
              return "double";
            i3 = i3[0];
          }
          return i3;
        case "sign":
          return "integer";
        case "ceiling":
        case "floor":
        case "abs":
          return i3 = E(e2, r2.args, n3, o3), i3 instanceof Array && (i3 = w(i3)), "integer" === i3 || "double" === i3 ? i3 : "double";
        case "area":
        case "length":
        case "log":
        case "log10":
        case "sin":
        case "cos":
        case "tan":
        case "asin":
        case "acos":
        case "atan":
        case "cosh":
        case "sinh":
        case "tanh":
        case "power":
          return "double";
        case "substring":
        case "trim":
        case "concat":
        case "lower":
        case "upper":
          return "string";
        case "truncate":
          return "double";
        case "nullif":
        case "coalesce":
          return i3 = E(e2, r2.args, n3, o3), i3 instanceof Array ? i3.length > 0 ? i3[0] : "" : i3;
      }
      return "";
  }
  throw new s2(t.UnsupportedSyntax, { node: r2.type });
}
var I2 = { boolean: 1, string: 2, integer: 3, double: 4, date: 5 };
function w(e2) {
  if (e2) {
    let r2 = "";
    for (const t3 of e2)
      "" !== t3 && (r2 = "" === r2 || I2[r2] < I2[t3] ? t3 : r2);
    return r2;
  }
  return "";
}
function A(e2, r2) {
  return b2(e2.parseTree, r2);
}
function N(e2) {
  return "column-reference" === (e2 == null ? void 0 : e2.parseTree.type);
}
function b2(e2, r2) {
  if (null == e2)
    return false;
  switch (e2.type) {
    case "when-clause":
      return b2(e2.operand, r2) || b2(e2.value, r2);
    case "case-expression":
      for (const t3 of e2.clauses)
        if (b2(t3, r2))
          return true;
      return !("simple" !== e2.format || !b2(e2.operand, r2)) || !(null === e2.else || !b2(e2.else, r2));
    case "parameter":
    case "null":
    case "boolean":
    case "date":
    case "timestamp":
    case "string":
    case "number":
      return false;
    case "expression-list":
      for (const t3 of e2.value)
        if (b2(t3, r2))
          return true;
      return false;
    case "unary-expression":
      return b2(e2.expr, r2);
    case "binary-expression":
      return b2(e2.left, r2) || b2(e2.right, r2);
    case "column-reference":
      return r2.toLowerCase() === e2.column.toLowerCase();
    case "function":
      return b2(e2.args, r2);
  }
  return false;
}
function v(e2) {
  let r2 = "";
  return r2 += e2.period.toUpperCase(), r2;
}
function R2(e2, r2, t3) {
  let a3 = "";
  return a3 = "interval-period" === r2.type ? v(r2) : v(r2.start) + " TO " + v(r2.end), "INTERVAL " + t3 + " " + e2 + " " + a3;
}

// node_modules/@arcgis/core/arcade/featureset/support/FeatureSetIterator.js
var e = class {
  constructor(t3, e2) {
    this._lastId = -1, this._progress = e2, this._parent = t3;
  }
  reset() {
    this._lastId = -1;
  }
  nextBatch(e2) {
    if (null !== this._parent._mainSetInUse)
      return this._parent._mainSetInUse.then((t3) => this.nextBatch(e2), (t3) => this.nextBatch(e2));
    const n3 = { returnpromise: null, hasset: false }, s4 = [];
    return n3.returnpromise = new Promise((a3, i3) => {
      this._parent._getSet(this._progress).then((r2) => {
        const h4 = u(r2._known, "known");
        let _ = h4.length - 1;
        if ("GETPAGES" === h4[h4.length - 1] && (_ -= 1), this._lastId + e2 > _ && h4.length > 0 && "GETPAGES" === h4[h4.length - 1])
          return void this._parent._expandPagedSet(r2, this._parent._maxQueryRate(), 0, 0, this._progress).then((t3) => {
            n3.hasset = true, this._parent._mainSetInUse = null, this.nextBatch(e2).then(a3, i3);
          }, (t3) => {
            n3.hasset = true, this._parent._mainSetInUse = null, i3(t3);
          });
        const l3 = u(r2._candidates, "candidates");
        if (_ >= this._lastId + e2 || 0 === l3.length) {
          for (let t3 = 0; t3 < e2; t3++) {
            const e3 = t3 + this._lastId + 1;
            if (e3 >= h4.length)
              break;
            s4[t3] = h4[e3];
          }
          return this._lastId += s4.length, 0 === s4.length && (n3.hasset = true, this._parent._mainSetInUse = null, a3([])), void this._parent._getFeatureBatch(s4, this._progress).then((t3) => {
            n3.hasset = true, this._parent._mainSetInUse = null, a3(t3);
          }, (t3) => {
            n3.hasset = true, this._parent._mainSetInUse = null, i3(t3);
          });
        }
        this._parent._refineSetBlock(r2, this._parent._maxProcessingRate(), this._progress).then(() => {
          n3.hasset = true, this._parent._mainSetInUse = null, this.nextBatch(e2).then(a3, i3);
        }, (t3) => {
          n3.hasset = true, this._parent._mainSetInUse = null, i3(t3);
        });
      }, (t3) => {
        n3.hasset = true, this._parent._mainSetInUse = null, i3(t3);
      });
    }), false === n3.hasset && (this._parent._mainSetInUse = n3.returnpromise, n3.hasset = true), n3.returnpromise;
  }
  next() {
    if (null !== this._parent._mainSetInUse)
      return this._parent._mainSetInUse.then((t3) => this.next(), (t3) => this.next());
    const e2 = { returnpromise: null, hasset: false };
    return e2.returnpromise = new Promise((n3, s4) => {
      this._parent._getSet(this._progress).then((a3) => {
        const i3 = u(a3._known, "known");
        if (this._lastId < i3.length - 1)
          "GETPAGES" === i3[this._lastId + 1] ? this._parent._expandPagedSet(a3, this._parent._maxQueryRate(), 0, 0, this._progress).then((t3) => (e2.hasset = true, this._parent._mainSetInUse = null, this.next())).then(n3, s4) : (this._lastId += 1, this._parent._getFeature(a3, i3[this._lastId], this._progress).then((t3) => {
            e2.hasset = true, this._parent._mainSetInUse = null, n3(t3);
          }, (t3) => {
            e2.hasset = true, this._parent._mainSetInUse = null, s4(t3);
          }));
        else {
          u(a3._candidates, "candidates").length > 0 ? this._parent._refineSetBlock(a3, this._parent._maxProcessingRate(), this._progress).then(() => {
            e2.hasset = true, this._parent._mainSetInUse = null, this.next().then(n3, s4);
          }, (t3) => {
            e2.hasset = true, this._parent._mainSetInUse = null, s4(t3);
          }) : (e2.hasset = true, this._parent._mainSetInUse = null, n3(null));
        }
      }, (t3) => {
        e2.hasset = true, this._parent._mainSetInUse = null, s4(t3);
      });
    }), false === e2.hasset && (this._parent._mainSetInUse = e2.returnpromise, e2.hasset = true), e2.returnpromise;
  }
  async count() {
    if (-1 !== this._parent._totalCount)
      return this._parent._totalCount;
    const t3 = await this._parent._getSet(this._progress), e2 = await this._refineAllSets(t3);
    return this._parent._totalCount = e2._known.length, this._parent._totalCount;
  }
  async _refineAllSets(t3) {
    if (t3._known.length > 0 && "GETPAGES" === t3._known[t3._known.length - 1])
      return await this._parent._expandPagedSet(t3, this._parent._maxQueryRate(), 0, 1, this._progress), this._refineAllSets(t3);
    if (t3._candidates.length > 0) {
      if ("GETPAGES" === t3._known[t3._candidates.length - 1])
        return await this._parent._expandPagedSet(t3, this._parent._maxQueryRate(), 0, 2, this._progress), this._refineAllSets(t3);
      const e2 = await this._parent._refineSetBlock(t3, this._parent._maxProcessingRate(), this._progress);
      return e2._candidates.length > 0 ? this._refineAllSets(e2) : e2;
    }
    return t3;
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/IdSet.js
var t2 = class {
  constructor(t3, s4, e2, i3) {
    this._lastFetchedIndex = 0, this._ordered = false, this.pagesDefinition = null, this._candidates = t3, this._known = s4, this._ordered = e2, this.pagesDefinition = i3;
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/stats.js
function s3(t3) {
  return t3 = +t3, isFinite(t3) ? t3 - t3 % 1 || (t3 < 0 ? -0 : 0 === t3 ? t3 : 0) : t3;
}
function i2(t3) {
  let n3 = 0;
  for (let e2 = 0; e2 < t3.length; e2++)
    n3 += t3[e2];
  return n3 / t3.length;
}
function l2(t3) {
  const n3 = i2(t3);
  let e2 = 0;
  for (let r2 = 0; r2 < t3.length; r2++)
    e2 += (n3 - t3[r2]) ** 2;
  return e2 / t3.length;
}
function o2(t3) {
  const n3 = i2(t3);
  let e2 = 0;
  for (let r2 = 0; r2 < t3.length; r2++)
    e2 += (n3 - t3[r2]) ** 2;
  return e2 / (t3.length - 1);
}
function h3(t3) {
  let n3 = 0;
  for (let e2 = 0; e2 < t3.length; e2++)
    n3 += t3[e2];
  return n3;
}
function f4(t3, n3) {
  const c3 = [], u5 = {}, s4 = [];
  for (let i3 = 0; i3 < t3.length; i3++) {
    if (void 0 !== t3[i3] && null !== t3[i3]) {
      const n4 = t3[i3];
      if (u2(n4) || s(n4))
        void 0 === u5[n4] && (c3.push(n4), u5[n4] = 1);
      else {
        let t4 = false;
        for (let e2 = 0; e2 < s4.length; e2++)
          true === m(s4[e2], n4) && (t4 = true);
        false === t4 && (s4.push(n4), c3.push(n4));
      }
    }
    if (c3.length >= n3 && -1 !== n3)
      return c3;
  }
  return c3;
}
function m5(t3) {
  switch (t3.toLowerCase()) {
    case "distinct":
      return "distinct";
    case "avg":
    case "mean":
      return "avg";
    case "min":
      return "min";
    case "sum":
      return "sum";
    case "max":
      return "max";
    case "stdev":
    case "stddev":
      return "stddev";
    case "var":
    case "variance":
      return "var";
    case "count":
      return "count";
  }
  return "";
}
function g3(t3, n3, e2 = 1e3) {
  switch (t3.toLowerCase()) {
    case "distinct":
      return f4(n3, e2);
    case "avg":
    case "mean":
      return i2(n3);
    case "min":
      return Math.min.apply(Math, n3);
    case "sum":
      return h3(n3);
    case "max":
      return Math.max.apply(Math, n3);
    case "stdev":
    case "stddev":
      return Math.sqrt(l2(n3));
    case "var":
    case "variance":
      return l2(n3);
    case "count":
      return n3.length;
  }
  return 0;
}
async function w2(t3, n3, e2) {
  const r2 = await k(t3, n3, e2, true);
  return 0 === r2.length ? null : Math.min.apply(Math, r2);
}
async function d2(t3, n3, e2) {
  const r2 = await k(t3, n3, e2, true);
  return 0 === r2.length ? null : Math.max.apply(Math, r2);
}
async function p3(t3, n3, e2) {
  let r2 = "";
  n3 && !N(n3) && (r2 = S2(n3, t3.fields));
  const a3 = await k(t3, n3, e2, true);
  if (0 === a3.length)
    return null;
  const l3 = i2(a3);
  return null === l3 ? l3 : "integer" === r2 ? s3(l3) : l3;
}
async function v2(t3, n3, e2) {
  const r2 = await k(t3, n3, e2, true);
  return 0 === r2.length ? null : o2(r2);
}
async function y2(t3, n3, e2) {
  const r2 = await k(t3, n3, e2, true);
  return 0 === r2.length ? null : Math.sqrt(o2(r2));
}
async function x2(t3, n3, e2) {
  const r2 = await k(t3, n3, e2, true);
  return 0 === r2.length ? null : h3(r2);
}
async function M2(t3, n3) {
  return t3.iterator(n3).count();
}
async function k(e2, r2, a3, c3 = false) {
  const u5 = e2.iterator(a3), s4 = [], i3 = { ticker: 0 };
  let l3 = await u5.next();
  for (; null !== l3; ) {
    if (i3.ticker++, a3.aborted)
      throw new o(n2.Cancelled);
    i3.ticker % 100 == 0 && (i3.ticker = 0, await new Promise((t3) => {
      setTimeout(t3, 0);
    }));
    const e3 = r2 == null ? void 0 : r2.calculateValue(l3);
    null === e3 ? false === c3 && (s4[s4.length] = e3) : s4[s4.length] = e3, l3 = await u5.next();
  }
  return s4;
}
async function C(e2, r2, a3 = 1e3, c3 = null) {
  const u5 = e2.iterator(c3), s4 = [], i3 = {}, l3 = { ticker: 0 };
  let o3 = await u5.next();
  for (; null !== o3; ) {
    if (l3.ticker++, c3 && c3.aborted)
      throw new o(n2.Cancelled);
    l3.ticker % 100 == 0 && (l3.ticker = 0, await new Promise((t3) => {
      setTimeout(t3, 0);
    }));
    const e3 = r2 == null ? void 0 : r2.calculateValue(o3);
    if (null != e3 && void 0 === i3[e3] && (s4.push(e3), i3[e3] = 1), s4.length >= a3 && -1 !== a3)
      return s4;
    o3 = await u5.next();
  }
  return s4;
}

// node_modules/@arcgis/core/arcade/featureset/support/FeatureSet.js
var v3 = class _v {
  constructor(e2) {
    this.recentlyUsedQueries = null, this.featureSetQueryInterceptor = null, this._idstates = [], this._parent = null, this._wset = null, this._mainSetInUse = null, this._maxProcessing = 200, this._maxQuery = 500, this._totalCount = -1, this._databaseType = i.NotEvaluated, this._databaseTypeProbed = null, this.declaredRootClass = "esri.arcade.featureset.support.FeatureSet", this._featureCache = [], this.typeIdField = null, this.types = null, this.fields = null, this.geometryType = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = null, this.hasM = false, this.hasZ = false, this._transparent = false, this.loaded = false, this._loadPromise = null, this._fieldsIndex = null, this._dateFieldIndex = null, e2 && e2.lrucache && (this.recentlyUsedQueries = e2.lrucache), e2 && e2.interceptor && (this.featureSetQueryInterceptor = e2.interceptor);
  }
  optimisePagingFeatureQueries(e2) {
    this._parent && this._parent.optimisePagingFeatureQueries(e2);
  }
  _hasMemorySource() {
    return true;
  }
  prop(e2, t3) {
    return void 0 === t3 ? this[e2] : (void 0 !== this[e2] && (this[e2] = t3), this);
  }
  end() {
    return null !== this._parent && true === this._parent._transparent ? this._parent.end() : this._parent;
  }
  _ensureLoaded() {
    return this.load();
  }
  load() {
    return null === this._loadPromise && (this._loadPromise = this.loadImpl()), this._loadPromise;
  }
  async loadImpl() {
    var _a, _b;
    return true === ((_a = this._parent) == null ? void 0 : _a.loaded) ? (this._initialiseFeatureSet(), this) : (await ((_b = this._parent) == null ? void 0 : _b.load()), this._initialiseFeatureSet(), this);
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.fields = this._parent.fields.slice(0), this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.fields = [], this.typeIdField = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = new f({ wkid: 4326 }), this.geometryType = P.point);
  }
  getField(e2, t3) {
    let s4;
    return (t3 = t3 || this.fields) && (e2 = e2.toLowerCase(), t3.some((t4) => (t4 && t4.name.toLowerCase() === e2 && (s4 = t4), !!s4))), s4;
  }
  getFieldsIndex() {
    return null === this._fieldsIndex && (this._fieldsIndex = new r(this.fields)), this._fieldsIndex;
  }
  _maxProcessingRate() {
    return null !== this._parent ? Math.min(this._maxProcessing, this._parent._maxProcessingRate()) : Math.min(this._maxProcessing, this._maxQueryRate());
  }
  _maxQueryRate() {
    return null !== this._parent ? Math.max(this._maxQuery, this._parent._maxQueryRate()) : this._maxQuery;
  }
  _checkCancelled(e2) {
    if (null != e2 && e2.aborted)
      throw new o(n2.Cancelled);
  }
  nativeCapabilities() {
    return this._parent.nativeCapabilities();
  }
  async _canDoAggregates(e2, t3, s4, r2, n3) {
    return null !== this._parent && this._parent._canDoAggregates(e2, t3, s4, r2, n3);
  }
  async _getAggregatePagesDataSourceDefinition(e2, t3, n3, i3, a3, l3, u5) {
    if (null === this._parent)
      throw new o(n2.NeverReach);
    return this._parent._getAggregatePagesDataSourceDefinition(e2, t3, n3, i3, a3, l3, u5);
  }
  async _getAgregagtePhysicalPage(e2, t3, n3) {
    if (null === this._parent)
      throw new o(n2.NeverReach);
    return this._parent._getAgregagtePhysicalPage(e2, t3, n3);
  }
  async databaseType() {
    if (this._databaseType === i.NotEvaluated) {
      if (null !== a2.applicationCache) {
        const e2 = a2.applicationCache.getDatabaseType(this._cacheableFeatureSetSourceKey());
        if (null !== e2)
          return e2;
      }
      if (null !== this._databaseTypeProbed)
        return this._databaseTypeProbed;
      try {
        this._databaseTypeProbed = this._getDatabaseTypeImpl(), null !== a2.applicationCache && a2.applicationCache.setDatabaseType(this._cacheableFeatureSetSourceKey(), this._databaseTypeProbed);
      } catch (e2) {
        throw null !== a2.applicationCache && a2.applicationCache.clearDatabaseType(this._cacheableFeatureSetSourceKey()), e2;
      }
      return this._databaseTypeProbed;
    }
    return this._databaseType;
  }
  async _getDatabaseTypeImpl() {
    const e2 = [{ thetype: i.SqlServer, testwhere: "(CAST( '2015-01-01' as DATETIME) = CAST( '2015-01-01' as DATETIME)) AND OBJECTID<0" }, { thetype: i.Oracle, testwhere: "(TO_DATE('2003-11-18','YYYY-MM-DD') = TO_DATE('2003-11-18','YYYY-MM-DD')) AND OBJECTID<0" }, { thetype: i.StandardisedNoInterval, testwhere: "(date '2015-01-01 10:10:10' = date '2015-01-01 10:10:10') AND OBJECTID<0" }];
    for (const t3 of e2) {
      if (true === await this._runDatabaseProbe(t3.testwhere))
        return t3.thetype;
    }
    return i.StandardisedNoInterval;
  }
  _cacheableFeatureSetSourceKey() {
    return "MUSTBESET";
  }
  async _runDatabaseProbe(e2) {
    if (null !== this._parent)
      return this._parent._runDatabaseProbe(e2);
    throw new o(n2.NotImplemented);
  }
  isTable() {
    var _a;
    return ((_a = this._parent) == null ? void 0 : _a.isTable()) ?? false;
  }
  _featureFromCache(e2) {
    if (void 0 !== this._featureCache[e2])
      return this._featureCache[e2];
  }
  _isInFeatureSet(e2) {
    return n.Unknown;
  }
  _getSet(e2) {
    throw new o(n2.NotImplemented);
  }
  async _getFeature(e2, t3, n3) {
    if (this._checkCancelled(n3), void 0 !== this._featureFromCache(t3))
      return this._featureFromCache(t3);
    if (await this._getFeatures(e2, t3, this._maxProcessingRate(), n3), this._checkCancelled(n3), void 0 !== this._featureFromCache(t3))
      return this._featureFromCache(t3);
    throw new o(n2.MissingFeatures);
  }
  async _getFeatureBatch(e2, t3) {
    this._checkCancelled(t3);
    const s4 = new t2([], e2, false, null), r2 = [];
    await this._getFeatures(s4, -1, e2.length, t3), this._checkCancelled(t3);
    for (const n3 of e2)
      void 0 !== this._featureFromCache(n3) && r2.push(this._featureFromCache(n3));
    return r2;
  }
  async _getFeatures(e2, t3, s4, r2) {
    return "success";
  }
  _getFilteredSet(e2, t3, n3, i3, a3) {
    throw new o(n2.NotImplemented);
  }
  async _refineSetBlock(e2, t3, s4) {
    if (true === this._checkIfNeedToExpandCandidatePage(e2, this._maxQueryRate()))
      return await this._expandPagedSet(e2, this._maxQueryRate(), 0, 0, s4), this._refineSetBlock(e2, t3, s4);
    this._checkCancelled(s4);
    const r2 = e2._candidates.length;
    this._refineKnowns(e2, t3);
    let n3 = r2 - e2._candidates.length;
    if (0 === e2._candidates.length)
      return e2;
    if (n3 >= t3)
      return e2;
    if (await this._refineIfParentKnown(e2, t3 - n3, s4), this._checkCancelled(s4), this._refineKnowns(e2, t3 - n3), n3 = r2 - e2._candidates.length, n3 < t3 && e2._candidates.length > 0) {
      const r3 = t3 - n3, i3 = this._prepareFetchAndRefineSet(e2._candidates);
      return await this._fetchAndRefineFeatures(i3, i3.length > r3 ? r3 : e2._candidates.length, s4), this._checkCancelled(s4), this._refineKnowns(e2, t3 - n3), e2;
    }
    return e2;
  }
  _fetchAndRefineFeatures(e2, t3, s4) {
    return null;
  }
  _prepareFetchAndRefineSet(e2) {
    const t3 = [];
    for (let s4 = 0; s4 < e2.length; s4++)
      this._isPhysicalFeature(e2[s4]) && t3.push(e2[s4]);
    return t3;
  }
  _isPhysicalFeature(e2) {
    return null === this._parent || this._parent._isPhysicalFeature(e2);
  }
  _refineKnowns(e2, t3) {
    let s4 = 0, r2 = null;
    const n3 = [];
    t3 = this._maxQueryRate();
    for (let i3 = 0; i3 < e2._candidates.length && "GETPAGES" !== e2._candidates[i3]; i3++) {
      let a3 = false;
      const l3 = this._candidateIdTransform(e2._candidates[i3]);
      l3 !== e2._candidates[i3] && (a3 = true);
      const h4 = this._isInFeatureSet(l3);
      if (h4 === n.InFeatureSet)
        true === a3 ? e2._known.includes(l3) || (e2._known.push(l3), s4 += 1) : (e2._known.push(e2._candidates[i3]), s4 += 1), null === r2 ? r2 = { start: i3, end: i3 } : r2.end === i3 - 1 ? r2.end = i3 : (n3.push(r2), r2 = { start: i3, end: i3 });
      else if (h4 === n.NotInFeatureSet)
        null === r2 ? r2 = { start: i3, end: i3 } : r2.end === i3 - 1 ? r2.end = i3 : (n3.push(r2), r2 = { start: i3, end: i3 }), s4 += 1;
      else if (h4 === n.Unknown && (s4 += 1, true === e2._ordered))
        break;
      if (s4 >= t3)
        break;
    }
    null !== r2 && n3.push(r2);
    for (let i3 = n3.length - 1; i3 >= 0; i3--)
      e2._candidates.splice(n3[i3].start, n3[i3].end - n3[i3].start + 1);
  }
  _refineIfParentKnown(e2, t3, s4) {
    const r2 = new t2([], [], e2._ordered, null);
    return r2._candidates = e2._candidates.slice(0), this._parent._refineSetBlock(r2, t3, s4);
  }
  _candidateIdTransform(e2) {
    return this._parent._candidateIdTransform(e2);
  }
  _checkIfNeedToExpandKnownPage(e2, t3) {
    if (null === e2.pagesDefinition)
      return false;
    let s4 = 0;
    for (let r2 = e2._lastFetchedIndex; r2 < e2._known.length; r2++) {
      if ("GETPAGES" === e2._known[r2])
        return true;
      if (void 0 === this._featureCache[e2._known[r2]] && (s4 += 1, s4 >= t3))
        break;
    }
    return false;
  }
  _checkIfNeedToExpandCandidatePage(e2, t3) {
    if (null === e2.pagesDefinition)
      return false;
    let s4 = 0;
    for (let r2 = 0; r2 < e2._candidates.length; r2++) {
      if ("GETPAGES" === e2._candidates[r2])
        return true;
      if (s4 += 1, s4 >= t3)
        break;
    }
    return false;
  }
  async _expandPagedSet(e2, t3, n3, i3, a3) {
    if (null === this._parent)
      throw new o(n2.NotImplemented);
    return this._parent._expandPagedSet(e2, t3, n3, i3, a3);
  }
  async _expandPagedSetFeatureSet(e2, t3, s4, r2, n3) {
    if (e2._known.length > 0 && "GETPAGES" === e2._known[e2._known.length - 1] && (r2 = 1), 0 === r2 && e2._candidates.length > 0 && "GETPAGES" === e2._candidates[e2._candidates.length - 1] && (r2 = 2), 0 === r2)
      return "finished";
    const i3 = await this._getPage(e2, r2, n3);
    return s4 + i3 < t3 ? this._expandPagedSet(e2, t3, s4 + i3, 0, n3) : "success";
  }
  async _getPage(e2, t3, s4) {
    const r2 = 1 === t3 ? e2._known : e2._candidates;
    if (e2.pagesDefinition.internal.set.length > e2.pagesDefinition.resultOffset || true === e2.pagesDefinition.internal.fullyResolved) {
      r2.length = r2.length - 1;
      let t4 = 0;
      for (let n3 = 0; n3 < e2.pagesDefinition.resultRecordCount && !(e2.pagesDefinition.resultOffset + n3 >= e2.pagesDefinition.internal.set.length); n3++)
        r2[r2.length] = e2.pagesDefinition.internal.set[e2.pagesDefinition.resultOffset + n3], t4++;
      e2.pagesDefinition.resultOffset += t4;
      let s5 = false;
      return true === e2.pagesDefinition.internal.fullyResolved && e2.pagesDefinition.internal.set.length <= e2.pagesDefinition.resultOffset && (s5 = true), false === s5 && r2.push("GETPAGES"), t4;
    }
    return await this._getPhysicalPage(e2, t3, s4), this._getPage(e2, t3, s4);
  }
  _getPhysicalPage(e2, t3, s4) {
    return null;
  }
  _clonePageDefinition(e2) {
    return null === this._parent ? null : this._parent._clonePageDefinition(e2);
  }
  _first(e2) {
    return this.iterator(e2).next();
  }
  first(e2) {
    return this._first(e2);
  }
  async calculateStatistic(e2, t3, s4, r2) {
    await this._ensureLoaded();
    let n3 = await this._stat(e2, t3, "", null, null, s4, r2);
    return false === n3.calculated && (n3 = await this._manualStat(e2, t3, s4, r2)), n3.result;
  }
  async _manualStat(e2, t3, s4, r2) {
    let n3 = null;
    switch (e2.toLowerCase()) {
      case "count":
        return n3 = await M2(this, r2), { calculated: true, result: n3 };
      case "distinct":
        return n3 = await C(this, t3, s4, r2), { calculated: true, result: n3 };
      case "avg":
      case "mean":
        return n3 = await p3(this, t3, r2), { calculated: true, result: n3 };
      case "stdev":
        return n3 = await y2(this, t3, r2), { calculated: true, result: n3 };
      case "variance":
        return n3 = await v2(this, t3, r2), { calculated: true, result: n3 };
      case "sum":
        return n3 = await x2(this, t3, r2), { calculated: true, result: n3 };
      case "min":
        return n3 = await w2(this, t3, r2), { calculated: true, result: n3 };
      case "max":
        return n3 = await d2(this, t3, r2), { calculated: true, result: n3 };
      default:
        return { calculated: true, result: 0 };
    }
  }
  async _stat(e2, t3, s4, r2, n3, i3, a3) {
    const l3 = await this._parent._stat(e2, t3, s4, r2, n3, i3, a3);
    return false === l3.calculated ? null === n3 && "" === s4 && null === r2 ? this._manualStat(e2, t3, i3, a3) : { calculated: false } : l3;
  }
  _unionAllGeomSelf(e2) {
    const t3 = this.iterator(this._defaultTracker(e2)), s4 = [];
    return new Promise((e3, r2) => {
      this._unionShapeInBatches(s4, t3, e3, r2);
    });
  }
  _unionAllGeom(e2) {
    return new Promise((t3, s4) => {
      const r2 = this.iterator(this._defaultTracker(e2)), n3 = [];
      this._unionShapeInBatches(n3, r2, t3, s4);
    });
  }
  _unionShapeInBatches(e2, t3, s4, r2) {
    t3.next().then((n3) => {
      try {
        null !== n3 && null !== n3.geometry && e2.push(n3.geometry), e2.length > 30 || null === n3 && e2.length > 1 ? b(e2).then((i3) => {
          try {
            null === n3 ? s4(i3) : (e2 = [i3], this._unionShapeInBatches(e2, t3, s4, r2));
          } catch (a3) {
            r2(a3);
          }
        }, r2) : null === n3 ? 1 === e2.length ? s4(e2[0]) : s4(null) : this._unionShapeInBatches(e2, t3, s4, r2);
      } catch (i3) {
        r2(i3);
      }
    }, r2);
  }
  iterator(e2) {
    return new e(this, e2);
  }
  intersection(e2, t3 = false) {
    return _v._featuresetFunctions.intersection.bind(this)(e2, t3);
  }
  difference(e2, t3 = false, s4 = true) {
    return _v._featuresetFunctions.difference.bind(this)(e2, t3, s4);
  }
  symmetricDifference(e2, t3 = false, s4 = true) {
    return _v._featuresetFunctions.symmetricDifference.bind(this)(e2, t3, s4);
  }
  morphShape(e2, t3, s4 = "unknown", r2 = null) {
    return _v._featuresetFunctions.morphShape.bind(this)(e2, t3, s4, r2);
  }
  morphShapeAndAttributes(e2, t3, s4 = "unknown") {
    return _v._featuresetFunctions.morphShapeAndAttributes.bind(this)(e2, t3, s4);
  }
  union(e2, t3 = false) {
    return _v._featuresetFunctions.union.bind(this)(e2, t3);
  }
  intersects(e2) {
    return _v._featuresetFunctions.intersects.bind(this)(e2);
  }
  envelopeIntersects(e2) {
    return _v._featuresetFunctions.envelopeIntersects.bind(this)(e2);
  }
  contains(e2) {
    return _v._featuresetFunctions.contains.bind(this)(e2);
  }
  overlaps(e2) {
    return _v._featuresetFunctions.overlaps.bind(this)(e2);
  }
  relate(e2, t3) {
    return _v._featuresetFunctions.relate.bind(this)(e2, t3);
  }
  within(e2) {
    return _v._featuresetFunctions.within.bind(this)(e2);
  }
  touches(e2) {
    return _v._featuresetFunctions.touches.bind(this)(e2);
  }
  top(e2) {
    return _v._featuresetFunctions.top.bind(this)(e2);
  }
  crosses(e2) {
    return _v._featuresetFunctions.crosses.bind(this)(e2);
  }
  buffer(e2, t3, s4, r2 = true) {
    return _v._featuresetFunctions.buffer.bind(this)(e2, t3, s4, r2);
  }
  filter(e2, t3 = null) {
    return _v._featuresetFunctions.filter.bind(this)(e2, t3);
  }
  orderBy(e2) {
    return _v._featuresetFunctions.orderBy.bind(this)(e2);
  }
  dissolve(e2, t3) {
    return _v._featuresetFunctions.dissolve.bind(this)(e2, t3);
  }
  groupby(e2, t3) {
    return _v._featuresetFunctions.groupby.bind(this)(e2, t3);
  }
  reduce(e2, t3 = null, s4) {
    return new Promise((r2, n3) => {
      this._reduceImpl(this.iterator(this._defaultTracker(s4)), e2, t3, 0, r2, n3, 0);
    });
  }
  _reduceImpl(e2, t3, s4, r2, n3, i3, a3) {
    try {
      if (++a3 > 1e3)
        return void setTimeout(() => {
          a3 = 0, this._reduceImpl(e2, t3, s4, r2, n3, i3, a3);
        });
      e2.next().then((l3) => {
        try {
          if (null === l3)
            n3(s4);
          else {
            const u5 = t3(s4, l3, r2, this);
            T(u5) ? u5.then((s5) => {
              this._reduceImpl(e2, t3, s5, r2 + 1, n3, i3, a3);
            }, i3) : this._reduceImpl(e2, t3, u5, r2 + 1, n3, i3, a3);
          }
        } catch (u5) {
          i3(u5);
        }
      }, i3);
    } catch (l3) {
      i3(l3);
    }
  }
  removeField(e2) {
    return _v._featuresetFunctions.removeField.bind(this)(e2);
  }
  addField(e2, t3, s4 = null) {
    return _v._featuresetFunctions.addField.bind(this)(e2, t3, s4);
  }
  sumArea(e2, t3 = false, s4) {
    const r2 = d(e2);
    return this.reduce((e3, s5) => null === s5.geometry ? 0 : t3 ? K(s5.geometry, r2).then((t4) => e3 + t4) : W(s5.geometry, r2).then((t4) => e3 + t4), 0, s4);
  }
  sumLength(e2, t3 = false, s4) {
    const r2 = F(e2);
    return this.reduce((e3, s5) => null === s5.geometry ? 0 : t3 ? M(s5.geometry, r2).then((t4) => e3 + t4) : F2(s5.geometry, r2).then((t4) => e3 + t4), 0, s4);
  }
  _substituteVars(e2, t3) {
    if (null !== t3) {
      const s4 = {};
      for (const e3 in t3)
        s4[e3.toLowerCase()] = t3[e3];
      e2.parameters = s4;
    }
  }
  async distinct(e2, t3 = 1e3, s4 = null, r2) {
    await this.load();
    const n3 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(n3, s4), this.calculateStatistic("distinct", n3, t3, this._defaultTracker(r2));
  }
  async min(e2, t3 = null, s4) {
    await this.load();
    const r2 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(r2, t3), this.calculateStatistic("min", r2, -1, this._defaultTracker(s4));
  }
  async max(e2, t3 = null, s4) {
    await this.load();
    const r2 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(r2, t3), this.calculateStatistic("max", r2, -1, this._defaultTracker(s4));
  }
  async avg(e2, t3 = null, s4) {
    await this.load();
    const r2 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(r2, t3), this.calculateStatistic("avg", r2, -1, this._defaultTracker(s4));
  }
  async sum(e2, t3 = null, s4) {
    await this.load();
    const r2 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(r2, t3), this.calculateStatistic("sum", r2, -1, this._defaultTracker(s4));
  }
  async stdev(e2, t3 = null, s4) {
    await this.load();
    const r2 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(r2, t3), this.calculateStatistic("stdev", r2, -1, this._defaultTracker(s4));
  }
  async variance(e2, t3 = null, s4) {
    await this.load();
    const r2 = f2.create(e2, this.getFieldsIndex());
    return this._substituteVars(r2, t3), this.calculateStatistic("variance", r2, -1, this._defaultTracker(s4));
  }
  async count(e2) {
    return await this.load(), this.calculateStatistic("count", f2.create("1", this.getFieldsIndex()), -1, this._defaultTracker(e2));
  }
  _defaultTracker(e2) {
    return e2 ?? { aborted: false };
  }
  forEach(e2, t3) {
    return new Promise((s4, r2) => {
      this._forEachImpl(this.iterator(this._defaultTracker(t3)), e2, this, s4, r2, 0);
    });
  }
  _forEachImpl(e2, t3, s4, r2, n3, i3) {
    try {
      if (++i3 > 1e3)
        return void setTimeout(() => {
          i3 = 0, this._forEachImpl(e2, t3, s4, r2, n3, i3);
        }, 0);
      e2.next().then((a3) => {
        try {
          if (null === a3)
            r2(s4);
          else {
            const l3 = t3(a3);
            null == l3 ? this._forEachImpl(e2, t3, s4, r2, n3, i3) : T(l3) ? l3.then(() => {
              try {
                this._forEachImpl(e2, t3, s4, r2, n3, i3);
              } catch (a4) {
                n3(a4);
              }
            }, n3) : this._forEachImpl(e2, t3, s4, r2, n3, i3);
          }
        } catch (l3) {
          n3(l3);
        }
      }, n3);
    } catch (a3) {
      n3(a3);
    }
  }
  convertToJSON(e2) {
    const t3 = { layerDefinition: { geometryType: this.geometryType, fields: [] }, featureSet: { features: [], geometryType: this.geometryType } };
    for (let s4 = 0; s4 < this.fields.length; s4++)
      t3.layerDefinition.fields.push(l(this.fields[s4]));
    return this.reduce((e3, s4) => {
      const r2 = { geometry: s4.geometry && s4.geometry.toJSON(), attributes: {} };
      for (const t4 in s4.attributes)
        r2.attributes[t4] = s4.attributes[t4];
      return t3.featureSet.features.push(r2), 1;
    }, 0, e2).then(() => t3);
  }
  castToText(e2 = false) {
    return "object, FeatureSet";
  }
  queryAttachments(e2, t3, s4, r2, n3) {
    return this._parent.queryAttachments(e2, t3, s4, r2, n3);
  }
  serviceUrl() {
    return this._parent.serviceUrl();
  }
  subtypes() {
    return this.typeIdField ? { subtypeField: this.typeIdField, subtypes: this.types ? this.types.map((e2) => ({ name: e2.name, code: e2.id })) : [] } : null;
  }
  relationshipMetaData() {
    return this._parent.relationshipMetaData();
  }
  get gdbVersion() {
    return this._parent ? this._parent.gdbVersion : "";
  }
  schema() {
    const e2 = [];
    for (const t3 of this.fields)
      e2.push(l(t3));
    return { objectIdField: this.objectIdField, globalIdField: this.globalIdField, geometryType: void 0 === I[this.geometryType] ? "esriGeometryNull" : I[this.geometryType], fields: e2 };
  }
  async convertToText(e2, t3) {
    if ("schema" === e2)
      return await this._ensureLoaded(), JSON.stringify(this.schema());
    if ("featureset" === e2) {
      await this._ensureLoaded();
      const e3 = [];
      await this.reduce((t4, s5) => {
        const r2 = { geometry: s5.geometry ? s5.geometry.toJSON() : null, attributes: s5.attributes };
        return null !== r2.geometry && r2.geometry.spatialReference && delete r2.geometry.spatialReference, e3.push(r2), 1;
      }, 0, t3);
      const s4 = this.schema();
      return s4.features = e3, s4.spatialReference = this.spatialReference.toJSON(), JSON.stringify(s4);
    }
    return this.castToText();
  }
  getFeatureByObjectId(e2, t3) {
    return this._parent.getFeatureByObjectId(e2, t3);
  }
  getOwningSystemUrl() {
    return this._parent.getOwningSystemUrl();
  }
  getIdentityUser() {
    return this._parent.getIdentityUser();
  }
  getRootFeatureSet() {
    return null !== this._parent ? this._parent.getRootFeatureSet() : this;
  }
  getDataSourceFeatureSet() {
    return null !== this._parent ? this._parent.getDataSourceFeatureSet() : this;
  }
  castAsJson(e2 = null) {
    return "keeptype" === (e2 == null ? void 0 : e2.featureset) ? this : "none" === (e2 == null ? void 0 : e2.featureset) ? null : { type: "FeatureSet" };
  }
  async castAsJsonAsync(e2 = null, t3 = null) {
    var _a;
    if ("keeptype" === (t3 == null ? void 0 : t3.featureset))
      return this;
    if ("schema" === (t3 == null ? void 0 : t3.featureset))
      return await this._ensureLoaded(), JSON.parse(JSON.stringify(this.schema()));
    if ("none" === (t3 == null ? void 0 : t3.featureset))
      return null;
    await this._ensureLoaded();
    const s4 = [];
    await this.reduce((e3, r3) => {
      const n3 = { geometry: r3.geometry ? true === (t3 == null ? void 0 : t3.keepGeometryType) ? r3.geometry : r3.geometry.toJSON() : null, attributes: r3.attributes };
      return null !== n3.geometry && n3.geometry.spatialReference && true !== (t3 == null ? void 0 : t3.keepGeometryType) && delete n3.geometry.spatialReference, s4.push(n3), 1;
    }, 0, e2);
    const r2 = this.schema();
    return r2.features = s4, r2.spatialReference = true === (t3 == null ? void 0 : t3.keepGeometryType) ? this.spatialReference : (_a = this.spatialReference) == null ? void 0 : _a.toJSON(), r2;
  }
  get dateTimeReferenceFieldIndex() {
    return null === this._dateFieldIndex && (this._dateFieldIndex = T2.create(this.getFieldsIndex(), this)), this._dateFieldIndex;
  }
  fieldTimeZone(e2) {
    return this.dateTimeReferenceFieldIndex.fieldTimeZone(e2);
  }
  get preferredTimeReference() {
    var _a;
    return ((_a = this._parent) == null ? void 0 : _a.preferredTimeReference) ?? null;
  }
  get dateFieldsTimeReference() {
    var _a;
    return ((_a = this._parent) == null ? void 0 : _a.dateFieldsTimeReference) ?? null;
  }
  get datesInUnknownTimezone() {
    return this._parent.datesInUnknownTimezone;
  }
  get editFieldsInfo() {
    var _a;
    return ((_a = this._parent) == null ? void 0 : _a.editFieldsInfo) ?? null;
  }
  get timeInfo() {
    var _a;
    return ((_a = this._parent) == null ? void 0 : _a.timeInfo) ?? null;
  }
};
v3._featuresetFunctions = {};

// node_modules/@arcgis/core/arcade/featureset/sources/Empty.js
var u4 = class extends v3 {
  constructor(e2) {
    super(e2), this.declaredClass = "esri.layers.featureset.sources.Empty", this._maxProcessing = 1e3, this._wset = new t2([], [], false, null), this._parent = e2.parentfeatureset, this._databaseType = i.Standardised;
  }
  async _getSet() {
    return this._wset;
  }
  optimisePagingFeatureQueries() {
  }
  _isInFeatureSet() {
    return n.NotInFeatureSet;
  }
  async _getFeature() {
    throw new o(n2.NeverReach);
  }
  async queryAttachments() {
    return [];
  }
  async _getFeatures() {
    return "success";
  }
  _featureFromCache() {
    return null;
  }
  async _fetchAndRefineFeatures() {
    throw new o(n2.NeverReach);
  }
  async _getFilteredSet() {
    return new t2([], [], false, null);
  }
  _stat(e2, t3, r2, s4, a3, n3, u5) {
    return this._manualStat(e2, t3, n3, u5);
  }
  async _canDoAggregates() {
    return false;
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/SpatialFilter.js
var f5 = class _f extends v3 {
  constructor(e2) {
    super(e2), this._relation = "", this._relationGeom = null, this._relationString = "", this.declaredClass = "esri.arcade.featureset.actions.SpatialFilter", this._relationString = e2.relationString, this._parent = e2.parentfeatureset, this._maxProcessing = 40, this._relation = e2.relation, this._relationGeom = e2.relationGeom;
  }
  async _getSet(e2) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t3 = await this._parent._getFilteredSet("esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, null, null, e2);
      return this._checkCancelled(e2), this._wset = new t2(t3._candidates.slice(0), t3._known.slice(0), t3._ordered, this._clonePageDefinition(t3.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e2) {
    let t3 = this._parent._isInFeatureSet(e2);
    return t3 === n.NotInFeatureSet ? t3 : (t3 = this._idstates[e2], void 0 === t3 ? n.Unknown : t3);
  }
  _getFeature(e2, t3, i3) {
    return this._parent._getFeature(e2, t3, i3);
  }
  _getFeatures(e2, t3, i3, r2) {
    return this._parent._getFeatures(e2, t3, i3, r2);
  }
  _featureFromCache(e2) {
    return this._parent._featureFromCache(e2);
  }
  async executeSpatialRelationTest(e2) {
    if (null === e2.geometry)
      return false;
    switch (this._relation) {
      case "esriSpatialRelEnvelopeIntersects":
        return h(g(this._relationGeom), g(e2.geometry));
      case "esriSpatialRelIntersects":
        return h(this._relationGeom, e2.geometry);
      case "esriSpatialRelContains":
        return p(this._relationGeom, e2.geometry);
      case "esriSpatialRelOverlaps":
        return O(this._relationGeom, e2.geometry);
      case "esriSpatialRelWithin":
        return x(this._relationGeom, e2.geometry);
      case "esriSpatialRelTouches":
        return S(this._relationGeom, e2.geometry);
      case "esriSpatialRelCrosses":
        return m2(this._relationGeom, e2.geometry);
      case "esriSpatialRelRelation":
        return R(this._relationGeom, e2.geometry, this._relationString ?? "");
    }
  }
  async _fetchAndRefineFeatures(e2, t3, i3) {
    var _a;
    const r2 = new t2([], e2, false, null), s4 = Math.min(t3, e2.length);
    await ((_a = this._parent) == null ? void 0 : _a._getFeatures(r2, -1, s4, i3)), this._checkCancelled(i3);
    const o3 = [];
    for (let n3 = 0; n3 < s4; n3++) {
      const t4 = this._parent._featureFromCache(e2[n3]);
      o3.push(await this.executeSpatialRelationTest(t4));
    }
    for (let n3 = 0; n3 < t3; n3++)
      true === o3[n3] ? this._idstates[e2[n3]] = n.InFeatureSet : this._idstates[e2[n3]] = n.NotInFeatureSet;
    return "success";
  }
  async _getFilteredSet(e2, t3, i3, r2, a3) {
    await this._ensureLoaded();
    const s4 = await this._parent._getFilteredSet("esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, i3, r2, a3);
    let o3;
    return this._checkCancelled(a3), o3 = null !== t3 ? new t2(s4._candidates.slice(0).concat(s4._known.slice(0)), [], s4._ordered, this._clonePageDefinition(s4.pagesDefinition)) : new t2(s4._candidates.slice(0), s4._known.slice(0), s4._ordered, this._clonePageDefinition(s4.pagesDefinition)), o3;
  }
  async _stat(e2, t3, i3, r2, n3, a3, s4) {
    if ("" !== i3)
      return { calculated: false };
    const o3 = await this._parent._stat(e2, t3, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, n3, a3, s4);
    return false === o3.calculated ? null === n3 && "" === i3 && null === r2 ? this._manualStat(e2, t3, a3, s4) : { calculated: false } : o3;
  }
  async _canDoAggregates(e2, t3, i3, r2, n3) {
    return "" === i3 && null === r2 && (null !== this._parent && this._parent._canDoAggregates(e2, t3, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, n3));
  }
  async _getAggregatePagesDataSourceDefinition(e2, r2, n3, a3, s4, o3, l3) {
    if (null === this._parent)
      throw new o(n2.NeverReach);
    return this._parent._getAggregatePagesDataSourceDefinition(e2, r2, "esriSpatialRelRelation" !== this._relation ? this._relation : this._relation + ":" + this._relationString, this._relationGeom, s4, o3, l3);
  }
  static registerAction() {
    v3._featuresetFunctions.intersects = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelIntersects", relationGeom: t3 });
    }, v3._featuresetFunctions.envelopeIntersects = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelEnvelopeIntersects", relationGeom: t3 });
    }, v3._featuresetFunctions.contains = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelContains", relationGeom: t3 });
    }, v3._featuresetFunctions.overlaps = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelOverlaps", relationGeom: t3 });
    }, v3._featuresetFunctions.within = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelWithin", relationGeom: t3 });
    }, v3._featuresetFunctions.touches = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelTouches", relationGeom: t3 });
    }, v3._featuresetFunctions.crosses = function(t3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelCrosses", relationGeom: t3 });
    }, v3._featuresetFunctions.relate = function(t3, i3) {
      return null == t3 ? new u4({ parentfeatureset: this }) : new _f({ parentfeatureset: this, relation: "esriSpatialRelRelation", relationGeom: t3, relationString: i3 });
    };
  }
};

export {
  a2 as a,
  t2 as t,
  u3 as u,
  f3 as f,
  p2 as p,
  m4 as m,
  g2 as g,
  h2 as h,
  T3 as T,
  L,
  S2 as S,
  A,
  N,
  R2 as R,
  m5 as m2,
  g3 as g2,
  v3 as v,
  u4 as u2,
  f5 as f2
};
//# sourceMappingURL=chunk-EX7KRNYS.js.map
