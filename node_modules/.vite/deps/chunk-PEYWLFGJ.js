import {
  E,
  R,
  T,
  a as a2,
  e,
  o,
  u
} from "./chunk-NE5U5H4D.js";
import {
  A,
  B,
  C,
  F,
  G,
  M,
  U,
  V,
  X,
  n,
  t as t2
} from "./chunk-BCDDCNQ2.js";
import {
  n as n2
} from "./chunk-OMDLZQUU.js";
import {
  i,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";
import {
  a2 as a,
  c2 as c,
  d,
  y
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var f = s.getLogger("esri.views.webgl.VertexArrayObject");
var u2 = class {
  constructor(t3, e2, i3, r, n4 = null) {
    this._context = t3, this._locations = e2, this._layout = i3, this._buffers = r, this._indexBuffer = n4, this._glName = null, this._initialized = false, t3.instanceCounter.increment(V.VertexArrayObject, this);
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get vertexBuffers() {
    return this._buffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  get byteSize() {
    return Object.keys(this._buffers).reduce((t3, e2) => t3 + this._buffers[e2].byteLength, null != this._indexBuffer ? this._indexBuffer.byteLength : 0);
  }
  get layout() {
    return this._layout;
  }
  get locations() {
    return this._locations;
  }
  get memoryEstimate() {
    return this.byteSize + (Object.keys(this._buffers).length + (this._indexBuffer ? 1 : 0)) * y;
  }
  dispose() {
    var _a;
    if (this._context) {
      this._context.getBoundVAO() === this && this._context.bindVAO(null);
      for (const t3 in this._buffers)
        (_a = this._buffers[t3]) == null ? void 0 : _a.dispose(), delete this._buffers[t3];
      this._indexBuffer = t(this._indexBuffer), this.disposeVAOOnly();
    } else
      (this._glName || Object.getOwnPropertyNames(this._buffers).length > 0) && f.warn("Leaked WebGL VAO");
  }
  disposeVAOOnly() {
    var _a, _b;
    if (this._glName) {
      const t3 = (_b = (_a = this._context) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.vao;
      t3.deleteVertexArray(this._glName), this._glName = null;
    }
    this._context.instanceCounter.decrement(V.VertexArrayObject, this), this._context = i(this._context);
  }
  initialize() {
    if (this._initialized)
      return;
    const t3 = this._context.capabilities.vao;
    if (t3) {
      const e2 = t3.createVertexArray();
      t3.bindVertexArray(e2), this._bindLayout(), t3.bindVertexArray(null), this._glName = e2;
    }
    this._initialized = true;
  }
  bind() {
    this.initialize();
    const t3 = this._context.capabilities.vao;
    t3 ? t3.bindVertexArray(this.glName) : (this._context.bindVAO(null), this._bindLayout());
  }
  _bindLayout() {
    const { _buffers: t3, _layout: e2, _indexBuffer: i3 } = this;
    t3 || f.error("Vertex buffer dictionary is empty!");
    const r = this._context.gl;
    for (const s2 in t3) {
      const i4 = t3[s2];
      i4 || f.error("Vertex buffer is uninitialized!");
      const r2 = e2[s2];
      r2 || f.error("Vertex element descriptor is empty!"), R(this._context, this._locations, i4, r2);
    }
    if (null != i3) {
      !!this._context.capabilities.vao ? r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, i3.glName) : this._context.bindBuffer(i3);
    }
  }
  unbind() {
    this.initialize();
    const t3 = this._context.capabilities.vao;
    t3 ? t3.bindVertexArray(null) : this._unbindLayout();
  }
  _unbindLayout() {
    const { _buffers: t3, _layout: e2 } = this;
    t3 || f.error("Vertex buffer dictionary is empty!");
    for (const i3 in t3) {
      const r = t3[i3];
      r || f.error("Vertex buffer is uninitialized!");
      const s2 = e2[i3];
      o(this._context, this._locations, r, s2);
    }
    null != this._indexBuffer && this._context.unbindBuffer(this._indexBuffer.bufferType);
  }
};

// node_modules/@arcgis/core/views/webgl/BufferObject.js
var h = s.getLogger("esri.views.webgl.BufferObject");
var c2 = class _c {
  static createIndex(e2, t3, r) {
    return new _c(e2, A.ELEMENT_ARRAY_BUFFER, t3, r);
  }
  static createVertex(e2, t3, r) {
    return new _c(e2, A.ARRAY_BUFFER, t3, r);
  }
  static createUniform(e2, t3, r) {
    if (e2.type !== n2.WEBGL2)
      throw new Error("Uniform buffers are supported in WebGL2 only!");
    return new _c(e2, A.UNIFORM_BUFFER, t3, r);
  }
  static createPixelPack(e2, t3 = F.STREAM_READ, r) {
    if (e2.type !== n2.WEBGL2)
      throw new Error("Pixel pack buffers are supported in WebGL2 only!");
    const i3 = new _c(e2, A.PIXEL_PACK_BUFFER, t3);
    return r && i3.setSize(r), i3;
  }
  static createPixelUnpack(e2, t3 = F.STREAM_DRAW, r) {
    if (e2.type !== n2.WEBGL2)
      throw new Error("Pixel unpack buffers are supported in WebGL2 only!");
    return new _c(e2, A.PIXEL_UNPACK_BUFFER, t3, r);
  }
  constructor(e2, t3, r, i3) {
    this._context = e2, this.bufferType = t3, this.usage = r, this._glName = null, this._size = -1, this._indexType = void 0, e2.instanceCounter.increment(V.BufferObject, this), this._glName = this._context.gl.createBuffer(), u(this._context.gl), i3 && this.setData(i3);
  }
  get glName() {
    return this._glName;
  }
  get size() {
    return this._size;
  }
  get indexType() {
    return this._indexType;
  }
  get byteLength() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER ? this._indexType === C.UNSIGNED_INT ? 4 * this._size : 2 * this._size : this._size;
  }
  get _isVAOAware() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER || this.bufferType === A.ARRAY_BUFFER;
  }
  dispose() {
    var _a;
    if ((_a = this._context) == null ? void 0 : _a.gl) {
      if (this._glName) {
        this._context.gl.deleteBuffer(this._glName), this._glName = null;
      }
      this._context.instanceCounter.decrement(V.BufferObject, this), this._context = i(this._context);
    } else
      this._glName && h.warn("Leaked WebGL buffer object");
  }
  setSize(e2, t3 = null) {
    if (e2 <= 0 && h.error("Buffer size needs to be positive!"), this.bufferType === A.ELEMENT_ARRAY_BUFFER && null != t3)
      switch (this._indexType = t3, t3) {
        case C.UNSIGNED_SHORT:
          e2 *= 2;
          break;
        case C.UNSIGNED_INT:
          e2 *= 4;
      }
    this._setBufferData(e2);
  }
  setData(e2) {
    if (!e2)
      return;
    let t3 = e2.byteLength;
    this.bufferType === A.ELEMENT_ARRAY_BUFFER && (c(e2) && (t3 /= 2, this._indexType = C.UNSIGNED_SHORT), a(e2) && (t3 /= 4, this._indexType = C.UNSIGNED_INT)), this._setBufferData(t3, e2);
  }
  _setBufferData(e2, t3 = null) {
    this._size = e2;
    const r = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const i3 = this._context.gl;
    null != t3 ? i3.bufferData(this.bufferType, t3, this.usage) : i3.bufferData(this.bufferType, e2, this.usage), u(i3), this._isVAOAware && this._context.bindVAO(r);
  }
  setSubData(e2, t3, r, i3) {
    if (!e2)
      return;
    (t3 < 0 || t3 * e2.BYTES_PER_ELEMENT >= this.byteLength) && h.error("offset is out of range!"), r >= i3 && h.error("end must be bigger than start!"), (t3 + (i3 - r)) * e2.BYTES_PER_ELEMENT > this.byteLength && h.error("An attempt to write beyond the end of the buffer!");
    const s2 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const a3 = this._context.gl;
    if (this._context.type === n2.WEBGL2)
      a3.bufferSubData(this.bufferType, t3 * e2.BYTES_PER_ELEMENT, e2, r, i3 - r);
    else {
      const s3 = 0 === r && i3 === e2.length ? e2 : e2.subarray(r, i3);
      a3.bufferSubData(this.bufferType, t3 * e2.BYTES_PER_ELEMENT, s3);
    }
    u(a3), this._isVAOAware && this._context.bindVAO(s2);
  }
  getSubData(e2, t3 = 0, r, i3) {
    if (this._context.type !== n2.WEBGL2)
      return void h.error("Get buffer subdata is supported in WebGL2 only!");
    if (r < 0 || i3 < 0)
      return void h.error("Problem getting subdata: offset and length were less than zero!");
    const s2 = E2(e2) ? e2.BYTES_PER_ELEMENT : 1;
    if (s2 * ((r ?? 0) + (i3 ?? 0)) > e2.byteLength)
      return void h.error("Problem getting subdata: offset and length exceeded destination size!");
    t3 + s2 * (i3 ?? 0) > this.byteLength && h.warn("Potential problem getting subdata: requested data exceeds buffer size!");
    const n4 = this._context.gl;
    this._context.bindBuffer(this, A.COPY_READ_BUFFER), n4.getBufferSubData(A.COPY_READ_BUFFER, t3, e2, r, i3), this._context.unbindBuffer(A.COPY_READ_BUFFER);
  }
  async getSubDataAsync(e2, t3 = 0, r, i3) {
    this._context.type === n2.WEBGL2 ? (await this._context.clientWaitAsync(), this.getSubData(e2, t3, r, i3)) : h.error("Get buffer subdata is supported in WebGL2 only!");
  }
};
function E2(t3) {
  return d(t3);
}

// node_modules/@arcgis/core/views/webgl/RenderbufferDescriptor.js
var i2 = class {
  constructor(t3, i3, h3 = i3) {
    this.internalFormat = t3, this.width = i3, this.height = h3, this.multisampled = false, this.samples = 1;
  }
};
function h2(i3) {
  return i3.width <= 0 || i3.height <= 0 || null == i3.internalFormat ? 0 : i3.width * i3.height * E(i3.internalFormat);
}

// node_modules/@arcgis/core/views/webgl/Renderbuffer.js
var n3 = class {
  constructor(e2, i3) {
    this._context = e2, this._descriptor = i3, this.type = e.RenderBuffer, this._context.instanceCounter.increment(V.Renderbuffer, this);
    const n4 = this._context.gl;
    this.glName = n4.createRenderbuffer(), this._context.bindRenderbuffer(this);
    const { width: o2, height: h3, internalFormat: c3, multisampled: f2 } = i3;
    if (f2) {
      if (this._context.type !== n2.WEBGL2)
        throw new Error("Multisampled renderbuffers are not supported in WebGL1!");
      n4.renderbufferStorageMultisample(n4.RENDERBUFFER, this.samples, c3, o2, h3);
    } else
      n4.renderbufferStorage(n4.RENDERBUFFER, c3, o2, h3);
  }
  get descriptor() {
    return this._descriptor;
  }
  get samples() {
    const e2 = this._descriptor.samples, t3 = this._context.parameters.maxSamples;
    return e2 ? Math.min(e2, t3) : t3;
  }
  get gpuMemoryUsage() {
    return h2(this._descriptor);
  }
  resize(e2, t3) {
    const r = this._descriptor;
    if (r.width === e2 && r.height === t3)
      return;
    r.width = e2, r.height = t3;
    const s2 = this._context.gl;
    if (this._context.bindRenderbuffer(this), r.multisampled) {
      s2.renderbufferStorageMultisample(s2.RENDERBUFFER, this.samples, r.internalFormat, r.width, r.height);
    } else
      s2.renderbufferStorage(s2.RENDERBUFFER, r.internalFormat, r.width, r.height);
  }
  dispose() {
    this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(V.Renderbuffer, this), this._context = i(this._context));
  }
};

// node_modules/@arcgis/core/views/webgl/FramebufferObject.js
var E3 = s.getLogger("esri.views.webgl.FramebufferObject");
var x = class _x {
  constructor(t3, e2, i3 = null) {
    this._context = t3, this._glName = null, this._colorAttachments = /* @__PURE__ */ new Map(), this._depthBuffer = null, this._stencilBuffer = null, this._depthStencilTexture = null, this._initialized = false, t3.instanceCounter.increment(V.FramebufferObject, this);
    const r = g(e2) ? e2 : new T(this._context, e2);
    if (this._colorAttachments.set(X.COLOR_ATTACHMENT0, r), this._validateTextureDescriptor(r.descriptor), this._validateColorAttachmentPoint(X.COLOR_ATTACHMENT0), null != i3)
      if (b(i3))
        this._context.capabilities.depthTexture || console.error("Setting the depth/stencil texture as an attachment requires WEBGL_depth_texture or WebGL2"), this._depthStencilTexture = g(i3) ? i3 : new T(this._context, i3), this._validateTextureDescriptor(this._depthStencilTexture.descriptor);
      else {
        const t4 = A2(i3) ? i3 : new n3(this._context, i3), e3 = t4.descriptor;
        e3.internalFormat === B.STENCIL_INDEX8 ? this._stencilBuffer = t4 : this._depthBuffer = t4, this._validateRenderBufferDescriptor(e3);
      }
  }
  dispose() {
    var _a, _b;
    if (0 === this._colorAttachments.size && !this._glName)
      return;
    const t3 = this._context.getBoundFramebufferObject();
    if (this._colorAttachments.forEach((t4, e2) => {
      var _a2;
      return (_a2 = this.detachColorTexture(e2)) == null ? void 0 : _a2.dispose();
    }), (_a = this.detachDepthStencilBuffer()) == null ? void 0 : _a.dispose(), (_b = this.detachDepthStencilTexture()) == null ? void 0 : _b.dispose(), this._glName) {
      this._context.gl.deleteFramebuffer(this._glName), this._glName = null;
    }
    this._context.bindFramebuffer(t3), this._context.instanceCounter.decrement(V.FramebufferObject, this);
  }
  get glName() {
    return this._glName;
  }
  get colorTexture() {
    return this._colorAttachments.get(X.COLOR_ATTACHMENT0);
  }
  get depthStencilAttachment() {
    return this._depthStencilTexture || this._depthBuffer || this._stencilBuffer;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get width() {
    var _a;
    const t3 = this._colorAttachments.get(X.COLOR_ATTACHMENT0);
    return ((_a = t3 == null ? void 0 : t3.descriptor) == null ? void 0 : _a.width) ?? 0;
  }
  get height() {
    var _a;
    const t3 = this._colorAttachments.get(X.COLOR_ATTACHMENT0);
    return ((_a = t3 == null ? void 0 : t3.descriptor) == null ? void 0 : _a.height) ?? 0;
  }
  get gpuMemoryUsage() {
    var _a;
    return [...this._colorAttachments].reduce((t3, [e2, i3]) => t3 + i3.gpuMemoryUsage, ((_a = this.depthStencilAttachment) == null ? void 0 : _a.gpuMemoryUsage) ?? 0);
  }
  getColorTexture(t3) {
    const e2 = this._colorAttachments.get(t3);
    return e2 && g(e2) ? e2 : null;
  }
  attachColorTexture(t3, e2 = X.COLOR_ATTACHMENT0) {
    var _a;
    if (!t3)
      return;
    this._validateColorAttachmentPoint(e2);
    const i3 = t3.descriptor;
    this._validateTextureDescriptor(i3), (_a = this.detachColorTexture(e2)) == null ? void 0 : _a.dispose(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, e2)), this._colorAttachments.set(e2, t3);
  }
  detachColorTexture(t3 = X.COLOR_ATTACHMENT0) {
    const e2 = this._colorAttachments.get(t3);
    if (e2)
      return this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3)), this._colorAttachments.delete(t3), e2;
  }
  setColorTextureTarget(t3, e2 = X.COLOR_ATTACHMENT0) {
    const i3 = this._colorAttachments.get(e2);
    i3 && this._framebufferTexture2D(i3.glName, e2, t3);
  }
  attachDepthStencil(t3) {
    if (t3)
      switch (t3.type) {
        case e.Texture:
          return this._attachDepthStencilTexture(t3);
        case e.RenderBuffer:
          return this._attachDepthStencilBuffer(t3);
      }
  }
  _attachDepthStencilTexture(t3) {
    var _a;
    if (null == t3)
      return;
    const e2 = t3.descriptor;
    e2.pixelFormat !== G.DEPTH_STENCIL && e2.pixelFormat !== G.DEPTH24_STENCIL8 && console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"), e2.dataType !== U.UNSIGNED_INT_24_8 && console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"), this._context.capabilities.depthTexture || console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"), this._validateTextureDescriptor(e2), this._disposeDepthStencilAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, t2)), (_a = this._depthStencilTexture) == null ? void 0 : _a.dispose(), this._depthStencilTexture = t3;
  }
  detachDepthStencilTexture() {
    const t3 = this._depthStencilTexture;
    return t3 && this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t2)), this._depthStencilTexture = null, t3;
  }
  _attachDepthStencilBuffer(t3) {
    var _a;
    if (null == t3)
      return;
    const e2 = t3.descriptor;
    if (e2.internalFormat !== B.DEPTH_STENCIL && e2.internalFormat !== B.DEPTH_COMPONENT16 && console.error("Depth/Stencil buffer must have correct internalFormat"), this._validateRenderBufferDescriptor(e2), this._disposeDepthStencilAttachments(), this._initialized) {
      this._context.bindFramebuffer(this);
      const i3 = this._context.gl, r = this._getGLAttachmentPoint(e2);
      i3.framebufferRenderbuffer(n.FRAMEBUFFER, r, i3.RENDERBUFFER, t3.glName);
    }
    (_a = this._depthBuffer) == null ? void 0 : _a.dispose(), this._depthBuffer = t3;
  }
  detachDepthStencilBuffer() {
    const t3 = this._depthBuffer;
    if (t3 && this._initialized) {
      this._context.bindFramebuffer(this);
      const e2 = this._context.gl, i3 = this._getGLAttachmentPoint(t3.descriptor);
      e2.framebufferRenderbuffer(n.FRAMEBUFFER, i3, e2.RENDERBUFFER, null), t3.dispose();
    }
    return this._depthBuffer = null, t3;
  }
  copyToTexture(t3, e2, i3, r, s2, h3, n4) {
    (t3 < 0 || e2 < 0 || s2 < 0 || h3 < 0) && console.error("Offsets cannot be negative!"), (i3 <= 0 || r <= 0) && console.error("Copy width and height must be greater than zero!");
    const o2 = n4.descriptor;
    n4.descriptor.target !== M.TEXTURE_2D && console.error("Texture target must be TEXTURE_2D!"), (null == (o2 == null ? void 0 : o2.width) || null == (o2 == null ? void 0 : o2.height) || t3 + i3 > this.width || e2 + r > this.height || s2 + i3 > o2.width || h3 + r > o2.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");
    const c3 = this._context, a3 = c3.bindTexture(n4, T.TEXTURE_UNIT_FOR_UPDATES);
    c3.setActiveTexture(T.TEXTURE_UNIT_FOR_UPDATES), c3.bindFramebuffer(this), c3.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, s2, h3, t3, e2, i3, r), c3.bindTexture(a3, T.TEXTURE_UNIT_FOR_UPDATES);
  }
  readPixels(t3, e2, i3, r, s2, h3, n4) {
    (i3 <= 0 || r <= 0) && console.error("Copy width and height must be greater than zero!"), n4 || console.error("Target memory is not initialized!"), this._context.bindFramebuffer(this);
    this._context.gl.readPixels(t3, e2, i3, r, s2, h3, n4);
  }
  async readPixelsAsync(t3, e2, h3, n4, o2, c3, a3) {
    if (this._context.type !== n2.WEBGL2)
      return a2() && console.warn("Attempting to read pixels using pixel buffer object without WebGL2"), void this.readPixels(t3, e2, h3, n4, o2, c3, a3);
    const u3 = this._context.gl, _ = c2.createPixelPack(this._context, F.STREAM_READ, a3.byteLength);
    this._context.bindBuffer(_), this._context.bindFramebuffer(this), u3.readPixels(t3, e2, h3, n4, o2, c3, 0), this._context.unbindBuffer(A.PIXEL_PACK_BUFFER), await _.getSubDataAsync(a3), _.dispose();
  }
  resize(t3, e2) {
    var _a, _b, _c;
    if (this.width === t3 && this.height === e2)
      return;
    const i3 = { width: t3, height: e2 };
    R2(i3, this._context.parameters.maxTextureSize), this._colorAttachments.forEach((t4) => t4.resize(i3.width, i3.height)), (_a = this._depthStencilTexture) == null ? void 0 : _a.resize(i3.width, i3.height), this._initialized && (R2(i3, this._context.parameters.maxRenderbufferSize), (_b = this._depthBuffer) == null ? void 0 : _b.resize(i3.width, i3.height), (_c = this._stencilBuffer) == null ? void 0 : _c.resize(i3.width, i3.height), this._context.getBoundFramebufferObject() === this && this._context.bindFramebuffer(null), this._initialized = false);
  }
  initializeAndBind(t3 = n.FRAMEBUFFER) {
    const e2 = this._context.gl;
    if (this._initialized)
      return void e2.bindFramebuffer(t3, this.glName);
    this._glName && e2.deleteFramebuffer(this._glName);
    const i3 = e2.createFramebuffer();
    e2.bindFramebuffer(t3, i3), this._colorAttachments.forEach((e3, i4) => this._framebufferTexture2D(e3.glName, i4, N(e3), t3));
    const s2 = this._depthBuffer || this._stencilBuffer;
    if (s2) {
      const i4 = this._getGLAttachmentPoint(s2.descriptor);
      e2.framebufferRenderbuffer(t3, i4, e2.RENDERBUFFER, s2.glName);
    } else
      this._depthStencilTexture && this._framebufferTexture2D(this._depthStencilTexture.glName, e2.DEPTH_STENCIL_ATTACHMENT, N(this._depthStencilTexture), t3);
    if (a2()) {
      e2.checkFramebufferStatus(t3) !== e2.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
    this._glName = i3, this._initialized = true;
  }
  _framebufferTexture2D(t3, e2 = X.COLOR_ATTACHMENT0, i3 = M.TEXTURE_2D, r = n.FRAMEBUFFER, s2 = 0) {
    this._context.gl.framebufferTexture2D(r, e2, i3, t3, s2);
  }
  _disposeDepthStencilAttachments() {
    const t3 = this._context.gl;
    if (this._depthBuffer) {
      if (this._initialized) {
        this._context.bindFramebuffer(this);
        const e2 = this._getGLAttachmentPoint(this._depthBuffer.descriptor);
        t3.framebufferRenderbuffer(n.FRAMEBUFFER, e2, t3.RENDERBUFFER, null);
      }
      this._depthBuffer = t(this._depthBuffer);
    }
    this._stencilBuffer && (this._initialized && (this._context.bindFramebuffer(this), t3.framebufferRenderbuffer(n.FRAMEBUFFER, t3.STENCIL_ATTACHMENT, t3.RENDERBUFFER, null)), this._stencilBuffer = t(this._stencilBuffer)), this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3.DEPTH_STENCIL_ATTACHMENT)), this._depthStencilTexture = t(this._depthStencilTexture));
  }
  _validateTextureDescriptor(t3) {
    t3.target !== M.TEXTURE_2D && t3.target !== M.TEXTURE_CUBE_MAP && console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"), R2(t3, this._context.parameters.maxTextureSize), this._validateBufferDimensions(t3);
  }
  _validateRenderBufferDescriptor(t3) {
    R2(t3, this._context.parameters.maxRenderbufferSize), this._validateBufferDimensions(t3);
  }
  _validateBufferDimensions(t3) {
    t3.width <= 0 && (t3.width = this.width), t3.height <= 0 && (t3.height = this.height), this.width > 0 && this.height > 0 && (this.width === t3.width && this.height === t3.height || console.error("Attachment size must match framebuffer size!"));
  }
  _getGLAttachmentPoint(t3) {
    switch (t3.internalFormat) {
      case B.DEPTH_COMPONENT16:
      case B.DEPTH_COMPONENT24:
      case B.DEPTH_COMPONENT32F:
        return this._context.gl.DEPTH_ATTACHMENT;
      case B.DEPTH24_STENCIL8:
      case B.DEPTH32F_STENCIL8:
      case B.DEPTH_STENCIL:
        return this._context.gl.DEPTH_STENCIL_ATTACHMENT;
      case B.STENCIL_INDEX8:
        return this._context.gl.STENCIL_ATTACHMENT;
    }
  }
  _validateColorAttachmentPoint(e2) {
    if (-1 === _x._MAX_COLOR_ATTACHMENTS) {
      const t3 = this._context.capabilities.drawBuffers;
      if (t3) {
        const e3 = this._context.gl;
        _x._MAX_COLOR_ATTACHMENTS = e3.getParameter(t3.MAX_COLOR_ATTACHMENTS);
      } else
        _x._MAX_COLOR_ATTACHMENTS = 1;
    }
    const i3 = e2 - X.COLOR_ATTACHMENT0;
    i3 + 1 > _x._MAX_COLOR_ATTACHMENTS && s.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${i3 + 1}. Implementation supports up to ${_x._MAX_COLOR_ATTACHMENTS} color attachments`);
  }
};
function g(t3) {
  return null != t3 && "type" in t3 && t3.type === e.Texture;
}
function A2(t3) {
  return null != t3 && "type" in t3 && t3.type === e.RenderBuffer;
}
function b(t3) {
  return g(t3) || null != t3 && "pixelFormat" in t3;
}
function R2(t3, e2) {
  const i3 = Math.max(t3.width, t3.height);
  if (i3 > e2) {
    E3.warn(`Resizing FBO attachment size ${t3.width}x${t3.height} to device limit ${e2}`);
    const r = e2 / i3;
    return t3.width = Math.round(t3.width * r), t3.height = Math.round(t3.height * r), false;
  }
  return true;
}
function N(t3) {
  return t3.descriptor.target === M.TEXTURE_CUBE_MAP ? M.TEXTURE_CUBE_MAP_POSITIVE_X : M.TEXTURE_2D;
}
x._MAX_COLOR_ATTACHMENTS = -1;

export {
  u2 as u,
  c2 as c,
  i2 as i,
  n3 as n,
  x
};
//# sourceMappingURL=chunk-PEYWLFGJ.js.map
