import {
  U,
  a as a2,
  f,
  l
} from "./chunk-XN5VV437.js";
import {
  m,
  t2 as t,
  v,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a,
  e as e2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";

// node_modules/@arcgis/core/core/support/WatchUpdatingTracking.js
var c = class extends m {
  constructor() {
    super(...arguments), this.updating = false, this._handleId = 0, this._handles = new t(), this._scheduleHandleId = 0, this._pendingPromises = /* @__PURE__ */ new Set();
  }
  destroy() {
    this.removeAll(), this._handles.destroy();
  }
  add(s, e3, t2 = {}) {
    return this._installWatch(s, e3, t2, l);
  }
  addWhen(s, e3, t2 = {}) {
    return this._installWatch(s, e3, t2, f);
  }
  addOnCollectionChange(s, e3, { initial: t2 = false, final: n = false } = {}) {
    const d2 = ++this._handleId;
    return this._handles.add([a2(s, "after-changes", this._createSyncUpdatingCallback(), U), a2(s, "change", e3, { onListenerAdd: t2 ? (s2) => e3({ added: s2.toArray(), removed: [] }) : void 0, onListenerRemove: n ? (s2) => e3({ added: [], removed: s2.toArray() }) : void 0 })], d2), e2(() => this._handles.remove(d2));
  }
  addPromise(s) {
    if (null == s)
      return s;
    const e3 = ++this._handleId;
    this._handles.add({ remove: () => {
      this._pendingPromises.delete(s) && (0 !== this._pendingPromises.size || this._handles.has(_) || this._set("updating", false));
    } }, e3), this._pendingPromises.add(s), this._set("updating", true);
    const t2 = () => this._handles.remove(e3);
    return s.then(t2, t2), s;
  }
  removeAll() {
    this._pendingPromises.clear(), this._handles.removeAll(), this._set("updating", false);
  }
  _installWatch(s, e3, t2 = {}, n) {
    const d2 = ++this._handleId;
    t2.sync || this._installSyncUpdatingWatch(s, d2);
    const a4 = n(s, e3, t2);
    return this._handles.add(a4, d2), e2(() => this._handles.remove(d2));
  }
  _installSyncUpdatingWatch(s, e3) {
    const t2 = this._createSyncUpdatingCallback(), i = l(s, t2, { sync: true, equals: () => false });
    return this._handles.add(i, e3), i;
  }
  _createSyncUpdatingCallback() {
    return () => {
      this._handles.remove(_), ++this._scheduleHandleId;
      const s = this._scheduleHandleId;
      this._get("updating") || this._set("updating", true), this._handles.add(v(() => {
        s === this._scheduleHandleId && (this._set("updating", this._pendingPromises.size > 0), this._handles.remove(_));
      }), _);
    };
  }
};
e([y({ readOnly: true })], c.prototype, "updating", void 0), c = e([a("esri.core.support.WatchUpdatingTracking")], c);
var _ = -42;

// node_modules/@arcgis/core/core/HandleOwner.js
var a3 = (e3) => {
  let a4 = class extends e3 {
    constructor() {
      super(...arguments), this._handles = new t(), this._updatingHandles = new c();
    }
    destroy() {
      this.destroyed || (this._handles.destroy(), this._updatingHandles.destroy());
    }
    get handles() {
      return this._handles;
    }
    get updatingHandles() {
      return this._updatingHandles;
    }
  };
  return e([y({ readOnly: true })], a4.prototype, "handles", null), e([y({ readOnly: true })], a4.prototype, "updatingHandles", null), a4 = e([a("esri.core.HandleOwner")], a4), a4;
};
var d = class extends a3(m) {
};
d = e([a("esri.core.HandleOwner")], d);

export {
  c,
  a3 as a,
  d
};
//# sourceMappingURL=chunk-LNMNRMVX.js.map
