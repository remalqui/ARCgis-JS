import {
  m
} from "./chunk-32JSK7KN.js";
import {
  h as h2
} from "./chunk-4SARN32Z.js";
import {
  n
} from "./chunk-4CZO65BK.js";
import {
  h
} from "./chunk-KKGH4SRQ.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/renderers/visualVariables/support/sizeVariableUtils.js
var n2;
var i;
function e(n3) {
  return n3 && "esri.renderers.visualVariables.SizeVariable" === n3.declaredClass;
}
function l(n3) {
  return null != n3 && !isNaN(n3) && isFinite(n3);
}
function t(i2) {
  return i2.valueExpression ? n2.Expression : i2.field && "string" == typeof i2.field ? n2.Field : n2.Unknown;
}
function a(e2, l2) {
  const a2 = l2 || t(e2), o = e2.valueUnit || "unknown";
  return a2 === n2.Unknown ? i.Constant : e2.stops ? i.Stops : null != e2.minSize && null != e2.maxSize && null != e2.minDataValue && null != e2.maxDataValue ? i.ClampedLinear : "unknown" === o ? null != e2.minSize && null != e2.minDataValue ? e2.minSize && e2.minDataValue ? i.Proportional : i.Additive : i.Identity : i.RealWorldSize;
}
!function(n3) {
  n3.Unknown = "unknown", n3.Expression = "expression", n3.Field = "field";
}(n2 || (n2 = {})), function(n3) {
  n3.Unknown = "unknown", n3.Stops = "stops", n3.ClampedLinear = "clamped-linear", n3.Proportional = "proportional", n3.Additive = "additive", n3.Constant = "constant", n3.Identity = "identity", n3.RealWorldSize = "real-world-size";
}(i || (i = {}));

// node_modules/@arcgis/core/renderers/visualVariables/support/visualVariableUtils.js
var c = s.getLogger("esri.renderers.visualVariables.support.visualVariableUtils");
var u = new h2();
var f = Math.PI;
var d = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function p(a2, n3, i2) {
  const r = "visualVariables" in a2 && a2.visualVariables ? a2.visualVariables.find((e2) => "color" === e2.type) : a2;
  if (!r)
    return;
  if ("esri.renderers.visualVariables.ColorVariable" !== r.declaredClass)
    return void c.warn("The visualVariable should be an instance of esri.renderers.visualVariables.ColorVariable");
  const t2 = "number" == typeof n3, s2 = t2 ? null : n3, l2 = s2 && s2.attributes;
  let o = t2 ? n3 : null;
  const u2 = r.field, { ipData: f2, hasExpression: d2 } = r.cache;
  let p2 = r.cache.compiledFunc;
  if (!u2 && !d2) {
    const e2 = r.stops;
    return e2 && e2[0] && e2[0].color;
  }
  if ("number" != typeof o)
    if (d2) {
      if (null == i2 || null == i2.arcade)
        return void c.error("Use of arcade expressions requires an arcade context");
      const e2 = { viewingMode: i2.viewingMode, scale: i2.scale, spatialReference: i2.spatialReference }, a3 = i2.arcade.arcadeUtils, n4 = a3.getViewInfo(e2), t3 = a3.createExecContext(s2, n4);
      if (!p2) {
        const e3 = a3.createSyntaxTree(r.valueExpression);
        p2 = a3.createFunction(e3), r.cache.compiledFunc = p2;
      }
      o = a3.executeFunction(p2, t3);
    } else
      l2 && (o = l2[u2]);
  const v2 = r.normalizationField, b2 = null != l2 && null != v2 ? parseFloat(l2[v2]) : void 0;
  if (null != o && (!v2 || t2 || !isNaN(b2) && 0 !== b2)) {
    isNaN(b2) || t2 || (o /= b2);
    const a3 = k(o, f2);
    if (a3) {
      const n4 = a3[0], t3 = a3[1], s3 = n4 === t3 ? r.stops[n4].color : h.blendColors(r.stops[n4].color, r.stops[t3].color, a3[2], null != i2 ? i2.color : void 0);
      return new h(s3);
    }
  }
}
function v(e2, a2, n3) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "opacity" === e3.type) : e2;
  if (!i2)
    return;
  if ("esri.renderers.visualVariables.OpacityVariable" !== i2.declaredClass)
    return void c.warn("The visualVariable should be an instance of esri.renderers.visualVariables.OpacityVariable");
  const r = "number" == typeof a2, t2 = r ? null : a2, s2 = t2 && t2.attributes;
  let l2 = r ? a2 : null;
  const o = i2.field, { ipData: u2, hasExpression: f2 } = i2.cache;
  let d2 = i2.cache.compiledFunc;
  if (!o && !f2) {
    const e3 = i2.stops;
    return e3 && e3[0] && e3[0].opacity;
  }
  if ("number" != typeof l2)
    if (f2) {
      if (null == n3 || null == n3.arcade)
        return void c.error("Use of arcade expressions requires an arcade context");
      const e3 = { viewingMode: n3.viewingMode, scale: n3.scale, spatialReference: n3.spatialReference }, a3 = n3.arcade.arcadeUtils, r2 = a3.getViewInfo(e3), s3 = a3.createExecContext(t2, r2);
      if (!d2) {
        const e4 = a3.createSyntaxTree(i2.valueExpression);
        d2 = a3.createFunction(e4), i2.cache.compiledFunc = d2;
      }
      l2 = a3.executeFunction(d2, s3);
    } else
      s2 && (l2 = s2[o]);
  const p2 = i2.normalizationField, v2 = null != s2 && null != p2 ? parseFloat(s2[p2]) : void 0;
  if (null != l2 && (!p2 || r || !isNaN(v2) && 0 !== v2)) {
    isNaN(v2) || r || (l2 /= v2);
    const e3 = k(l2, u2);
    if (e3) {
      const a3 = e3[0], n4 = e3[1];
      if (a3 === n4)
        return i2.stops[a3].opacity;
      {
        const r2 = i2.stops[a3].opacity;
        return r2 + (i2.stops[n4].opacity - r2) * e3[2];
      }
    }
  }
}
function b(e2, a2, n3) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "rotation" === e3.type) : e2;
  if (!i2)
    return;
  if ("esri.renderers.visualVariables.RotationVariable" !== i2.declaredClass)
    return void c.warn("The visualVariable should be an instance of esri.renderers.visualVariables.RotationVariable");
  const r = i2.axis || "heading", t2 = "heading" === r && "arithmetic" === i2.rotationType ? 90 : 0, s2 = "heading" === r && "arithmetic" === i2.rotationType ? -1 : 1, l2 = "number" == typeof a2 ? null : a2, o = l2 && l2.attributes, u2 = i2.field, { hasExpression: f2 } = i2.cache;
  let d2 = i2.cache.compiledFunc, p2 = 0;
  if (!u2 && !f2)
    return p2;
  if (f2) {
    if (null == n3 || null == n3.arcade)
      return void c.error("Use of arcade expressions requires an arcade context");
    const e3 = { viewingMode: n3.viewingMode, scale: n3.scale, spatialReference: n3.spatialReference }, a3 = n3.arcade.arcadeUtils, r2 = a3.getViewInfo(e3), t3 = a3.createExecContext(l2, r2);
    if (!d2) {
      const e4 = a3.createSyntaxTree(i2.valueExpression);
      d2 = a3.createFunction(e4), i2.cache.compiledFunc = d2;
    }
    p2 = a3.executeFunction(d2, t3);
  } else
    o && (p2 = o[u2] || 0);
  return p2 = "number" != typeof p2 || isNaN(p2) ? null : t2 + s2 * p2, p2;
}
function h3(e2, a2, n3) {
  const i2 = "number" == typeof a2, r = i2 ? null : a2, t2 = r && r.attributes;
  let l2 = i2 ? a2 : null;
  const { isScaleDriven: u2 } = e2.cache;
  let f2 = e2.cache.compiledFunc;
  if (u2) {
    const a3 = null != n3 ? n3.scale : void 0, i3 = null != n3 ? n3.view : void 0;
    l2 = null == a3 || "3d" === i3 ? m2(e2) : a3;
  } else if (!i2)
    switch (e2.inputValueType) {
      case n2.Expression: {
        if (null == n3 || null == n3.arcade)
          return void c.error("Use of arcade expressions requires an arcade context");
        const a3 = { viewingMode: n3.viewingMode, scale: n3.scale, spatialReference: n3.spatialReference }, i3 = n3.arcade.arcadeUtils, t3 = i3.getViewInfo(a3), s2 = i3.createExecContext(r, t3);
        if (!f2) {
          const a4 = i3.createSyntaxTree(e2.valueExpression);
          f2 = i3.createFunction(a4), e2.cache.compiledFunc = f2;
        }
        l2 = i3.executeFunction(f2, s2);
        break;
      }
      case n2.Field:
        t2 && (l2 = t2[e2.field]);
        break;
      case n2.Unknown:
        l2 = null;
    }
  if (!l(l2))
    return null;
  if (i2 || !e2.normalizationField)
    return l2;
  const d2 = t2 ? parseFloat(t2[e2.normalizationField]) : null;
  return l(d2) && 0 !== d2 ? l2 / d2 : null;
}
function m2(e2) {
  let a2 = null, n3 = null;
  const i2 = e2.stops;
  return i2 ? (a2 = i2[0].value, n3 = i2[i2.length - 1].value) : (a2 = e2.minDataValue || 0, n3 = e2.maxDataValue || 0), (a2 + n3) / 2;
}
function V(e2, a2, n3) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => "size" === e3.type) : e2;
  if (!i2)
    return;
  if ("esri.renderers.visualVariables.SizeVariable" !== i2.declaredClass)
    return void c.warn("The visualVariable should be an instance of esri.renderers.visualVariables.SizeVariable");
  const r = C(h3(i2, a2, n3), i2, a2, n3, i2.cache.ipData);
  return null == r || isNaN(r) ? 0 : r;
}
function x(e2, a2, n3) {
  return null == e2 ? null : e(e2) ? V(e2, a2, n3) : l(e2) ? e2 : null;
}
function y(e2, a2, n3) {
  return l(n3) && e2 > n3 ? n3 : l(a2) && e2 < a2 ? a2 : e2;
}
function w(e2, a2, n3, i2) {
  return e2 + ((x(a2.minSize, n3, i2) || a2.minDataValue) ?? 0);
}
function g(e2, a2, n3) {
  const i2 = e2.stops;
  let r = i2 && i2.length && i2[0].size;
  return null == r && (r = e2.minSize), x(r, a2, n3);
}
function z(e2, a2, n3, i2) {
  const r = (e2 - a2.minDataValue) / (a2.maxDataValue - a2.minDataValue), t2 = x(a2.minSize, n3, i2), s2 = x(a2.maxSize, n3, i2), l2 = null != i2 ? i2.shape : void 0;
  if (e2 <= a2.minDataValue)
    return t2;
  if (e2 >= a2.maxDataValue)
    return s2;
  if (null == t2 || null == s2)
    return null;
  if ("area" === a2.scaleBy && l2) {
    const e3 = "circle" === l2, a3 = e3 ? f * (t2 / 2) ** 2 : t2 * t2, n4 = a3 + r * ((e3 ? f * (s2 / 2) ** 2 : s2 * s2) - a3);
    return e3 ? 2 * Math.sqrt(n4 / f) : Math.sqrt(n4);
  }
  return t2 + r * (s2 - t2);
}
function F(e2, a2, n3, i2) {
  const r = null != i2 ? i2.shape : void 0, t2 = e2 / a2.minDataValue, s2 = x(a2.minSize, n3, i2), l2 = x(a2.maxSize, n3, i2);
  let o = null;
  return o = "circle" === r ? 2 * Math.sqrt(t2 * (s2 / 2) ** 2) : "square" === r || "diamond" === r || "image" === r ? Math.sqrt(t2 * s2 ** 2) : t2 * s2, y(o, s2, l2);
}
function S(e2, a2, n3, i2, r) {
  var _a, _b, _c;
  const [t2, s2, l2] = k(e2, r);
  if (t2 === s2)
    return x((_a = a2.stops) == null ? void 0 : _a[t2].size, n3, i2);
  {
    const e3 = x((_b = a2.stops) == null ? void 0 : _b[t2].size, n3, i2);
    return e3 + (x((_c = a2.stops) == null ? void 0 : _c[s2].size, n3, i2) - e3) * l2;
  }
}
function E(e2, a2, n3, i2) {
  const t2 = (null != i2 && i2.resolution ? i2.resolution : 1) * m[a2.valueUnit], s2 = x(a2.minSize, n3, i2), l2 = x(a2.maxSize, n3, i2), { valueRepresentation: o } = a2;
  let c2 = null;
  return c2 = "area" === o ? 2 * Math.sqrt(e2 / f) / t2 : "radius" === o || "distance" === o ? 2 * e2 / t2 : e2 / t2, y(c2, s2, l2);
}
function U(e2) {
  return e2;
}
function C(e2, a2, n3, i2, r) {
  switch (a2.transformationType) {
    case i.Additive:
      return w(e2, a2, n3, i2);
    case i.Constant:
      return g(a2, n3, i2);
    case i.ClampedLinear:
      return z(e2, a2, n3, i2);
    case i.Proportional:
      return F(e2, a2, n3, i2);
    case i.Stops:
      return S(e2, a2, n3, i2, r);
    case i.RealWorldSize:
      return E(e2, a2, n3, i2);
    case i.Identity:
      return U(e2);
    case i.Unknown:
      return null;
  }
}
function D(e2, a2, n3) {
  const { isScaleDriven: i2 } = e2.cache;
  if (!(i2 && "3d" === n3 || a2))
    return null;
  const r = { scale: a2, view: n3 };
  let t2 = x(e2.minSize, u, r), s2 = x(e2.maxSize, u, r);
  if (null != t2 || null != s2) {
    if (t2 > s2) {
      const e3 = s2;
      s2 = t2, t2 = e3;
    }
    return { minSize: t2, maxSize: s2 };
  }
}
function M(e2, a2, n3) {
  if (!e2.visualVariables)
    return;
  const i2 = [], r = [], t2 = [], s2 = [], l2 = [];
  for (const o of e2.visualVariables)
    switch (o.type) {
      case "color":
        r.push(o);
        break;
      case "opacity":
        t2.push(o);
        break;
      case "rotation":
        l2.push(o);
        break;
      case "size":
        s2.push(o);
    }
  return r.forEach((e3) => {
    const r2 = p(e3, a2, n3);
    i2.push({ variable: e3, value: r2 });
  }), t2.forEach((e3) => {
    const r2 = v(e3, a2, n3);
    i2.push({ variable: e3, value: r2 });
  }), l2.forEach((e3) => {
    const r2 = b(e3, a2, n3);
    i2.push({ variable: e3, value: r2 });
  }), s2.forEach((e3) => {
    const r2 = V(e3, a2, n3);
    i2.push({ variable: e3, value: r2 });
  }), i2.filter((e3) => null != e3.value);
}
function k(e2, a2) {
  if (!a2)
    return;
  let n3 = 0, i2 = a2.length - 1;
  return a2.some((a3, r) => e2 < a3 ? (i2 = r, true) : (n3 = r, false)), [n3, i2, (e2 - a2[n3]) / (a2[i2] - a2[n3])];
}
function N(e2, a2, i2) {
  const r = ["proportional", "proportional", "proportional"];
  for (const t2 of e2) {
    const e3 = t2.useSymbolValue ? "symbol-value" : V(t2, a2, i2);
    switch (t2.axis) {
      case "width":
        r[0] = e3;
        break;
      case "depth":
        r[1] = e3;
        break;
      case "height":
        r[2] = e3;
        break;
      case "width-and-depth":
        r[0] = e3, r[1] = e3;
        break;
      case "all":
      case void 0:
      case null:
        r[0] = e3, r[1] = e3, r[2] = e3;
        break;
      default:
        n(t2.axis);
    }
  }
  return r;
}

export {
  i,
  e,
  t,
  a,
  d,
  p,
  v,
  b,
  V,
  x,
  C,
  D,
  M,
  N
};
//# sourceMappingURL=chunk-KTII3LWY.js.map
