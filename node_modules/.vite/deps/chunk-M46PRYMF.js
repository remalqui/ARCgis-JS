import {
  t
} from "./chunk-PM77FW2O.js";
import {
  I
} from "./chunk-AC3INPLN.js";
import {
  a,
  s as s2
} from "./chunk-QAWS7Y22.js";
import {
  i as i2
} from "./chunk-FQZ2JEHK.js";
import {
  d,
  i
} from "./chunk-ZBWBCN2I.js";
import {
  n as n2
} from "./chunk-7KM4XBUC.js";
import {
  n
} from "./chunk-WBSPL6CJ.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithCursor.js
function r(r3, a3, t2) {
  if (null == r3)
    return null;
  const u2 = a3.readArcadeFeature();
  try {
    return r3.evaluate({ ...t2, $feature: u2 }, r3.services);
  } catch (n3) {
    return s.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", n3), null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/Store2D.js
var a2 = class {
  constructor(e, s3) {
    this._canCacheExpressionValue = false, this._sourceInfo = e, this._storage = s3, this._bitsets = { computed: s3.getBitset(s3.createBitset()) };
  }
  get storage() {
    return this._storage;
  }
  invalidate() {
    this._bitsets.computed.clear();
  }
  async updateSchema(t2, i3) {
    const a3 = a(this._schema, i3);
    if (this._schema = i3, !i3 || null == a3 || !s2(a3, "attributes"))
      return;
    has("esri-2d-update-debug") && console.debug("Applying Update - Store:", a3), this._bitsets.computed.clear(), t2.targets[i3.name] = true;
    const r3 = i3.attributes, o2 = [], c2 = [];
    for (const e in r3) {
      const s3 = r3[e];
      switch (s3.type) {
        case "field":
          break;
        case "expression":
          o2.push(this._createArcadeComputedField(s3));
          break;
        case "label-expression":
          o2.push(this._createLabelArcadeComputedField(s3));
          break;
        case "statistic":
          c2.push(s3);
      }
    }
    this._computedFields = await Promise.all(o2), this._canCacheExpressionValue = !this._computedFields.some((e) => "expression" === e.type && null != e.expression && e.expression.referencesScale()), this._statisticFields = c2;
  }
  setComputedAttributes(e, s3, t2, i3) {
    const a3 = this._bitsets.computed;
    if (!this._canCacheExpressionValue || !a3.has(t2)) {
      a3.set(t2);
      for (const a4 of this._computedFields) {
        const r3 = this._evaluateField(s3, a4, i3);
        switch (a4.resultType) {
          case "numeric":
            e.setComputedNumericAtIndex(t2, a4.fieldIndex, r3);
            break;
          case "string":
            e.setComputedStringAtIndex(t2, a4.fieldIndex, r3);
        }
      }
    }
  }
  async _createArcadeComputedField(e) {
    const s3 = this._sourceInfo.spatialReference, i3 = this._sourceInfo.fieldsIndex;
    return { ...e, expression: await n2(e.valueExpression, s3, i3) };
  }
  async _createLabelArcadeComputedField(e) {
    const s3 = this._sourceInfo.spatialReference, t2 = this._sourceInfo.fieldsIndex, { createLabelFunction: i3 } = await import("./labelFormatUtils-GVDWRKM3.js"), a3 = await i3(e.label, t2, s3);
    return { ...e, builder: a3 };
  }
  _evaluateField(e, s3, t2) {
    switch (s3.type) {
      case "label-expression": {
        const t3 = e.readArcadeFeature();
        return s3.builder.evaluate(t3) || "";
      }
      case "expression": {
        const { expression: a3 } = s3;
        return r(a3, e, { $view: { scale: t2 } });
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFIndirect.js
var r2 = class _r extends I {
  static from(e, t2) {
    return new _r(e.copy(), t2);
  }
  constructor(r3, t2) {
    super(I.createInstance(), r3.fullSchema()), this._currentIndex = -1, this._reader = r3, this._indices = t2;
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const e = new _r(this._reader.copy(), this._indices);
    return e._currentIndex = this._currentIndex, e;
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); )
      ;
    return this._currentIndex < this._indices.length;
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  setArcadeSpatialReference(e) {
    this._reader.setArcadeSpatialReference(e);
  }
  attachStorage(e) {
    this._reader.attachStorage(e);
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  getStorage() {
    return this._reader.getStorage();
  }
  getComputedNumeric(e) {
    return this._reader.getComputedNumericAtIndex(0);
  }
  setComputedNumeric(e, r3) {
    return this._reader.setComputedNumericAtIndex(r3, 0);
  }
  getComputedString(e) {
    return this._reader.getComputedStringAtIndex(0);
  }
  setComputedString(e, r3) {
    return this._reader.setComputedStringAtIndex(0, r3);
  }
  getComputedNumericAtIndex(e) {
    return this._reader.getComputedNumericAtIndex(e);
  }
  setComputedNumericAtIndex(e, r3) {
    this._reader.setComputedNumericAtIndex(e, r3);
  }
  getComputedStringAtIndex(e) {
    return this._reader.getComputedStringAtIndex(e);
  }
  setComputedStringAtIndex(e, r3) {
    return this._reader.setComputedStringAtIndex(e, r3);
  }
  transform(e, r3, t2, d3) {
    const a3 = this.copy();
    return a3._reader = this._reader.transform(e, r3, t2, d3), a3;
  }
  readAttribute(e, r3 = false) {
    return this._reader.readAttribute(e, r3);
  }
  readAttributes() {
    return this._reader.readAttributes();
  }
  joinAttributes(e) {
    return this._reader.joinAttributes(e);
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(e) {
    return this.readAttribute(e, true);
  }
  hasField(e) {
    return this._reader.hasField(e);
  }
  setField(e, r3) {
    return this._reader.setField(e, r3);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(e = false) {
    return this._reader.castToText(e);
  }
  getQuantizationTransform() {
    return this._reader.getQuantizationTransform();
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(e) {
    return this._reader.setDisplayId(e);
  }
  getGroupId() {
    return this._reader.getGroupId();
  }
  setGroupId(e) {
    return this._reader.setGroupId(e);
  }
  getXHydrated() {
    return this._reader.getXHydrated();
  }
  getYHydrated() {
    return this._reader.getYHydrated();
  }
  getX() {
    return this._reader.getX();
  }
  getY() {
    return this._reader.getY();
  }
  setIndex(e) {
    return this._reader.setIndex(e);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readLegacyFeature() {
    return this._reader.readLegacyFeature();
  }
  readOptimizedFeature() {
    return this._reader.readOptimizedFeature();
  }
  readLegacyPointGeometry() {
    return this._reader.readLegacyPointGeometry();
  }
  readLegacyGeometry() {
    return this._reader.readLegacyGeometry();
  }
  readLegacyCentroid() {
    return this._reader.readLegacyCentroid();
  }
  readGeometryArea() {
    return this._reader.readGeometryArea();
  }
  readUnquantizedGeometry() {
    return this._reader.readUnquantizedGeometry();
  }
  readHydratedGeometry() {
    return this._reader.readHydratedGeometry();
  }
  readGeometry() {
    return this._reader.readGeometry();
  }
  readCentroid() {
    return this._reader.readCentroid();
  }
  _readAttribute(e, r3) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStore2D.js
var o = i();
function d2(t2, e) {
  return t2 << 16 | e;
}
function h(t2) {
  return (4294901760 & t2) >>> 16;
}
function c(t2) {
  return 65535 & t2;
}
var I2 = { getObjectId: (t2) => t2.getObjectId(), getAttributes: (t2) => t2.readAttributes(), getAttribute: (t2, e) => t2.readAttribute(e), cloneWithGeometry: (t2, e) => t2, getGeometry: (t2) => t2.readHydratedGeometry(), getCentroid: (t2, e) => t2.readCentroid() };
var u = class extends a2 {
  constructor(a3, r3, n3) {
    super(a3, r3), this.featureAdapter = I2, this.events = new n(), this._featureSetsByInstance = /* @__PURE__ */ new Map(), this._objectIdToDisplayId = /* @__PURE__ */ new Map(), this._spatialIndexInvalid = true, this._indexSearchCache = new t(50), this._index = i2(9, (t2) => ({ minX: this._storage.getXMin(t2), minY: this._storage.getYMin(t2), maxX: this._storage.getXMax(t2), maxY: this._storage.getYMax(t2) })), this.mode = n3;
  }
  get storeStatistics() {
    let t2 = 0, e = 0, s3 = 0;
    return this.forEach((a3) => {
      const r3 = a3.readGeometry();
      r3 && (e += r3.isPoint ? 1 : r3.lengths.reduce((t3, e2) => t3 + e2, 0), s3 += r3.isPoint ? 1 : r3.lengths.length, t2 += 1);
    }), { featureCount: t2, vertexCount: e, ringCount: s3 };
  }
  hasInstance(t2) {
    return this._featureSetsByInstance.has(t2);
  }
  onTileData(t2, e) {
    if (null == e.addOrUpdate)
      return e;
    if (e.addOrUpdate.attachStorage(this._storage), "snapshot" === this.mode) {
      const s4 = e.addOrUpdate.getCursor();
      for (; s4.next(); ) {
        const e2 = s4.getDisplayId();
        this.setComputedAttributes(this._storage, s4, e2, t2.scale);
      }
      return e;
    }
    this._featureSetsByInstance.set(e.addOrUpdate.instance, e.addOrUpdate);
    const s3 = e.addOrUpdate.getCursor();
    for (; s3.next(); )
      this._insertFeature(s3, t2.scale);
    return this._spatialIndexInvalid = true, this.events.emit("changed"), e;
  }
  search(t2) {
    this._rebuildIndex();
    const e = t2.id, s3 = this._indexSearchCache.find((t3) => t3.tileId === e);
    if (null != s3)
      return s3.readers;
    const a3 = /* @__PURE__ */ new Map(), r3 = this._searchIndex(t2.bounds), n3 = [];
    for (const i3 of r3) {
      const t3 = this._storage.getInstanceId(i3), e2 = h(t3), s4 = c(t3);
      a3.has(e2) || a3.set(e2, []);
      a3.get(e2).push(s4);
    }
    return a3.forEach((t3, e2) => {
      const s4 = this._featureSetsByInstance.get(e2);
      n3.push(r2.from(s4, t3));
    }), this._indexSearchCache.enqueue({ tileId: e, readers: n3 }), n3;
  }
  insert(t2) {
    const e = t2.getCursor(), s3 = this._storage;
    for (; e.next(); ) {
      const t3 = d2(e.instance, e.getIndex()), a3 = e.getObjectId(), r3 = this._objectIdToDisplayId.get(a3) ?? this._storage.createDisplayId();
      e.setDisplayId(r3), s3.setInstanceId(r3, t3), this._objectIdToDisplayId.set(a3, r3);
    }
    this._featureSetsByInstance.set(t2.instance, t2), this._spatialIndexInvalid = true;
  }
  remove(t2) {
    const e = this._objectIdToDisplayId.get(t2);
    if (!e)
      return;
    const s3 = this._storage.getInstanceId(e), a3 = c(s3), r3 = h(s3), n3 = this._featureSetsByInstance.get(r3);
    this._objectIdToDisplayId.delete(t2), this._storage.releaseDisplayId(e), n3.removeAtIndex(a3), n3.isEmpty && this._featureSetsByInstance.delete(r3), this._spatialIndexInvalid = true;
  }
  forEach(t2) {
    this._objectIdToDisplayId.forEach((e) => {
      const s3 = this._storage.getInstanceId(e), a3 = this._lookupFeature(s3);
      t2(a3);
    });
  }
  forEachUnsafe(t2) {
    this._objectIdToDisplayId.forEach((e) => {
      const s3 = this._storage.getInstanceId(e), a3 = h(s3), r3 = c(s3), n3 = this._getFeatureSet(a3);
      n3.setIndex(r3), t2(n3);
    });
  }
  forEachInBounds(t2, e) {
    const s3 = this._searchIndex(t2);
    for (const a3 of s3) {
      e(this.lookupFeatureByDisplayId(a3, this._storage));
    }
  }
  forEachBounds(t2, e) {
    this._rebuildIndex();
    for (const s3 of t2) {
      if (!s3.readGeometry())
        continue;
      const t3 = s3.getDisplayId();
      d(o, this._storage.getXMin(t3), this._storage.getYMin(t3), this._storage.getXMax(t3), this._storage.getYMax(t3)), e(o);
    }
  }
  sweepFeatures(t2, e, s3) {
    this._spatialIndexInvalid = true, this._objectIdToDisplayId.forEach((a3, r3) => {
      t2.has(a3) || (e.releaseDisplayId(a3), s3 && s3.unsetAttributeData(a3), this._objectIdToDisplayId.delete(r3));
    }), this.events.emit("changed");
  }
  sweepFeatureSets(t2) {
    this._spatialIndexInvalid = true, this._featureSetsByInstance.forEach((e, s3) => {
      t2.has(s3) || this._featureSetsByInstance.delete(s3);
    });
  }
  lookupObjectId(t2, e) {
    const s3 = this.lookupFeatureByDisplayId(t2, e);
    return null == s3 ? null : s3.getObjectId();
  }
  lookupDisplayId(t2) {
    return this._objectIdToDisplayId.get(t2);
  }
  lookupFeatureByDisplayId(t2, e) {
    const s3 = e.getInstanceId(t2);
    return this._lookupFeature(s3);
  }
  lookupByDisplayIdUnsafe(t2) {
    const e = this._storage.getInstanceId(t2), s3 = h(e), a3 = c(e), r3 = this._getFeatureSet(s3);
    return r3 ? (r3.setIndex(a3), r3) : null;
  }
  _insertFeature(t2, e) {
    const s3 = this._storage, a3 = t2.getObjectId(), r3 = d2(t2.instance, t2.getIndex());
    s3.getInstanceId(t2.getDisplayId());
    let n3 = this._objectIdToDisplayId.get(a3);
    n3 || (n3 = s3.createDisplayId(), this._objectIdToDisplayId.set(a3, n3), this._spatialIndexInvalid = true), t2.setDisplayId(n3), s3.setInstanceId(n3, r3), this.setComputedAttributes(s3, t2, n3, e);
  }
  _searchIndex(t2) {
    this._rebuildIndex();
    const e = { minX: t2[0], minY: t2[1], maxX: t2[2], maxY: t2[3] };
    return this._index.search(e);
  }
  _rebuildIndex() {
    if (!this._spatialIndexInvalid)
      return;
    const t2 = [];
    "snapshot" === this.mode ? this._featureSetsByInstance.forEach((e) => {
      const s3 = e.getCursor();
      for (; s3.next(); ) {
        const e2 = s3.getDisplayId();
        this._storage.setBounds(e2, s3) && t2.push(e2);
      }
    }) : this._objectIdToDisplayId.forEach((e) => {
      const s3 = this._storage.getInstanceId(e);
      this._storage.setBounds(e, this._lookupFeature(s3)) && t2.push(e);
    }), this._index.clear(), this._index.load(t2), this._indexSearchCache.clear(), this._spatialIndexInvalid = false;
  }
  _lookupFeature(t2) {
    const e = h(t2), s3 = this._getFeatureSet(e);
    if (!s3)
      return;
    const a3 = s3.getCursor(), r3 = c(t2);
    return a3.setIndex(r3), a3;
  }
  _getFeatureSet(t2) {
    return this._featureSetsByInstance.get(t2);
  }
};

export {
  a2 as a,
  r2 as r,
  I2 as I,
  u
};
//# sourceMappingURL=chunk-M46PRYMF.js.map
