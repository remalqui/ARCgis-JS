import {
  y as y2
} from "./chunk-RR2V4HRU.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import {
  n
} from "./chunk-BVNZ3ETW.js";
import {
  f as f2,
  p
} from "./chunk-T4XWQYGC.js";
import {
  f,
  o2 as o,
  r
} from "./chunk-SFV6XLDZ.js";
import {
  s
} from "./chunk-VBD33VNW.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a
} from "./chunk-I5JT24BO.js";

// node_modules/@arcgis/core/rest/support/FeatureSet.js
var f3;
var h2 = new s({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh", "": null });
var g = f3 = class extends l {
  constructor(e2) {
    super(e2), this.displayFieldName = null, this.exceededTransferLimit = false, this.features = [], this.fields = null, this.geometryType = null, this.hasM = false, this.hasZ = false, this.queryGeometry = null, this.spatialReference = null;
  }
  readFeatures(e2, t) {
    const o2 = f.fromJSON(t.spatialReference), s2 = [];
    for (let n2 = 0; n2 < e2.length; n2++) {
      const t2 = e2[n2], i = h.fromJSON(t2), l2 = t2.geometry && t2.geometry.spatialReference;
      null == i.geometry || l2 || (i.geometry.spatialReference = o2);
      const a3 = t2.aggregateGeometries, p2 = i.aggregateGeometries;
      if (a3 && null != p2)
        for (const e3 in p2) {
          const t3 = p2[e3], r2 = a3[e3], s3 = r2 == null ? void 0 : r2.spatialReference;
          null == t3 || s3 || (t3.spatialReference = o2);
        }
      s2.push(i);
    }
    return s2;
  }
  writeGeometryType(e2, t, r2, o2) {
    if (e2)
      return void h2.write(e2, t, r2, o2);
    const { features: s2 } = this;
    if (s2) {
      for (const n2 of s2)
        if (n2 && null != n2.geometry)
          return void h2.write(n2.geometry.type, t, r2, o2);
    }
  }
  readQueryGeometry(e2, t) {
    if (!e2)
      return null;
    const r2 = !!e2.spatialReference, o2 = p(e2);
    return o2 && !r2 && t.spatialReference && (o2.spatialReference = f.fromJSON(t.spatialReference)), o2;
  }
  writeSpatialReference(e2, t) {
    if (e2)
      return void (t.spatialReference = e2.toJSON());
    const { features: r2 } = this;
    if (r2) {
      for (const o2 of r2)
        if (o2 && null != o2.geometry && o2.geometry.spatialReference)
          return void (t.spatialReference = o2.geometry.spatialReference.toJSON());
    }
  }
  clone() {
    return new f3(this.cloneProperties());
  }
  cloneProperties() {
    return a({ displayFieldName: this.displayFieldName, exceededTransferLimit: this.exceededTransferLimit, features: this.features, fields: this.fields, geometryType: this.geometryType, hasM: this.hasM, hasZ: this.hasZ, queryGeometry: this.queryGeometry, spatialReference: this.spatialReference, transform: this.transform });
  }
  toJSON(e2) {
    const t = this.write();
    if (t.features && Array.isArray(e2) && e2.length > 0)
      for (let r2 = 0; r2 < t.features.length; r2++) {
        const o2 = t.features[r2];
        if (o2.geometry) {
          const t2 = e2 && e2[r2];
          o2.geometry = t2 && t2.toJSON() || o2.geometry;
        }
      }
    return t;
  }
  quantize(e2) {
    const { scale: [t, r2], translate: [o2, s2] } = e2, n2 = (e3) => Math.round((e3 - o2) / t), i = (e3) => Math.round((s2 - e3) / r2), l2 = this.features, a3 = this._getQuantizationFunction(this.geometryType, n2, i);
    for (let p2 = 0, m = l2.length; p2 < m; p2++)
      (a3 == null ? void 0 : a3(l2[p2].geometry)) || (l2.splice(p2, 1), p2--, m--);
    return this.transform = e2, this;
  }
  unquantize() {
    var _a, _b;
    const { geometryType: e2, features: t, transform: r2 } = this;
    if (!r2)
      return this;
    const { translate: [o2, s2], scale: [n2, i] } = r2, l2 = (e3) => e3 * n2 + o2, a3 = (e3) => s2 - e3 * i;
    let p2 = null, m = null;
    if (this.hasZ && null != ((_a = r2 == null ? void 0 : r2.scale) == null ? void 0 : _a[2])) {
      const { translate: [, , e3], scale: [, , t2] } = r2;
      p2 = (r3) => r3 * t2 + e3;
    }
    if (this.hasM && null != ((_b = r2 == null ? void 0 : r2.scale) == null ? void 0 : _b[3])) {
      const { translate: [, , , e3], scale: [, , , t2] } = r2;
      m = (r3) => null == r3 ? r3 : r3 * t2 + e3;
    }
    const c = this._getHydrationFunction(e2, l2, a3, p2, m);
    for (const { geometry: u } of t)
      null != u && c && c(u);
    return this.transform = null, this;
  }
  _quantizePoints(e2, t, r2) {
    let o2, s2;
    const n2 = [];
    for (let i = 0, l2 = e2.length; i < l2; i++) {
      const l3 = e2[i];
      if (i > 0) {
        const e3 = t(l3[0]), i2 = r2(l3[1]);
        e3 === o2 && i2 === s2 || (n2.push([e3 - o2, i2 - s2]), o2 = e3, s2 = i2);
      } else
        o2 = t(l3[0]), s2 = r2(l3[1]), n2.push([o2, s2]);
    }
    return n2.length > 0 ? n2 : null;
  }
  _getQuantizationFunction(e2, t, r2) {
    return "point" === e2 ? (e3) => (e3.x = t(e3.x), e3.y = r2(e3.y), e3) : "polyline" === e2 || "polygon" === e2 ? (e3) => {
      const o2 = f2(e3) ? e3.rings : e3.paths, s2 = [];
      for (let n2 = 0, i = o2.length; n2 < i; n2++) {
        const e4 = o2[n2], i2 = this._quantizePoints(e4, t, r2);
        i2 && s2.push(i2);
      }
      return s2.length > 0 ? (f2(e3) ? e3.rings = s2 : e3.paths = s2, e3) : null;
    } : "multipoint" === e2 ? (e3) => {
      const o2 = this._quantizePoints(e3.points, t, r2);
      return o2 && o2.length > 0 ? (e3.points = o2, e3) : null;
    } : "extent" === e2 ? (e3) => e3 : null;
  }
  _getHydrationFunction(e2, t, r2, o2, s2) {
    return "point" === e2 ? (e3) => {
      e3.x = t(e3.x), e3.y = r2(e3.y), o2 && (e3.z = o2(e3.z));
    } : "polyline" === e2 || "polygon" === e2 ? (e3) => {
      const n2 = f2(e3) ? e3.rings : e3.paths;
      let i, l2;
      for (let o3 = 0, s3 = n2.length; o3 < s3; o3++) {
        const e4 = n2[o3];
        for (let o4 = 0, s4 = e4.length; o4 < s4; o4++) {
          const s5 = e4[o4];
          o4 > 0 ? (i += s5[0], l2 += s5[1]) : (i = s5[0], l2 = s5[1]), s5[0] = t(i), s5[1] = r2(l2);
        }
      }
      if (o2 && s2)
        for (let t2 = 0, r3 = n2.length; t2 < r3; t2++) {
          const e4 = n2[t2];
          for (let t3 = 0, r4 = e4.length; t3 < r4; t3++) {
            const r5 = e4[t3];
            r5[2] = o2(r5[2]), r5[3] = s2(r5[3]);
          }
        }
      else if (o2)
        for (let t2 = 0, r3 = n2.length; t2 < r3; t2++) {
          const e4 = n2[t2];
          for (let t3 = 0, r4 = e4.length; t3 < r4; t3++) {
            const r5 = e4[t3];
            r5[2] = o2(r5[2]);
          }
        }
      else if (s2)
        for (let t2 = 0, r3 = n2.length; t2 < r3; t2++) {
          const e4 = n2[t2];
          for (let t3 = 0, r4 = e4.length; t3 < r4; t3++) {
            const r5 = e4[t3];
            r5[2] = s2(r5[2]);
          }
        }
    } : "extent" === e2 ? (e3) => {
      e3.xmin = t(e3.xmin), e3.ymin = r2(e3.ymin), e3.xmax = t(e3.xmax), e3.ymax = r2(e3.ymax), o2 && null != e3.zmax && null != e3.zmin && (e3.zmax = o2(e3.zmax), e3.zmin = o2(e3.zmin)), s2 && null != e3.mmax && null != e3.mmin && (e3.mmax = s2(e3.mmax), e3.mmin = s2(e3.mmin));
    } : "multipoint" === e2 ? (e3) => {
      const n2 = e3.points;
      let i, l2;
      for (let o3 = 0, s3 = n2.length; o3 < s3; o3++) {
        const e4 = n2[o3];
        o3 > 0 ? (i += e4[0], l2 += e4[1]) : (i = e4[0], l2 = e4[1]), e4[0] = t(i), e4[1] = r2(l2);
      }
      if (o2 && s2)
        for (let t2 = 0, r3 = n2.length; t2 < r3; t2++) {
          const e4 = n2[t2];
          e4[2] = o2(e4[2]), e4[3] = s2(e4[3]);
        }
      else if (o2)
        for (let t2 = 0, r3 = n2.length; t2 < r3; t2++) {
          const e4 = n2[t2];
          e4[2] = o2(e4[2]);
        }
      else if (s2)
        for (let t2 = 0, r3 = n2.length; t2 < r3; t2++) {
          const e4 = n2[t2];
          e4[2] = s2(e4[2]);
        }
    } : null;
  }
};
e([y({ type: String, json: { write: true } })], g.prototype, "displayFieldName", void 0), e([y({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], g.prototype, "exceededTransferLimit", void 0), e([y({ type: [h], json: { write: true } })], g.prototype, "features", void 0), e([o("features")], g.prototype, "readFeatures", null), e([y({ type: [y2], json: { write: true } })], g.prototype, "fields", void 0), e([y({ type: ["point", "multipoint", "polyline", "polygon", "extent", "mesh"], json: { read: { reader: h2.read } } })], g.prototype, "geometryType", void 0), e([r("geometryType")], g.prototype, "writeGeometryType", null), e([y({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], g.prototype, "hasM", void 0), e([y({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], g.prototype, "hasZ", void 0), e([y({ types: n, json: { write: true } })], g.prototype, "queryGeometry", void 0), e([o("queryGeometry")], g.prototype, "readQueryGeometry", null), e([y({ type: f, json: { write: true } })], g.prototype, "spatialReference", void 0), e([r("spatialReference")], g.prototype, "writeSpatialReference", null), e([y({ json: { write: true } })], g.prototype, "transform", void 0), g = f3 = e([a2("esri.rest.support.FeatureSet")], g), g.prototype.toJSON.isDefaultToJSON = true;
var d = g;

export {
  d
};
//# sourceMappingURL=chunk-RNXN3MSP.js.map
