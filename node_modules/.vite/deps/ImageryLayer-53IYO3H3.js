import {
  N,
  Q,
  S,
  a as a6,
  c as c4,
  c2 as c5,
  d as d2,
  f as f5,
  h as h2,
  i as i2,
  j as j6,
  k as k2,
  l as l5,
  m as m3,
  n as n5,
  q,
  t as t4
} from "./chunk-P425EV6U.js";
import {
  d as d3,
  g,
  m as m2,
  p as p5
} from "./chunk-TW5O5V56.js";
import "./chunk-ZEKM2THG.js";
import {
  t as t3
} from "./chunk-IUXYWQJG.js";
import {
  G,
  I,
  L2,
  P,
  j as j5,
  m,
  n2 as n3,
  n4,
  s2 as s8,
  w
} from "./chunk-QUF6BZJO.js";
import "./chunk-6KMYS2SL.js";
import {
  l2 as l4,
  s as s7,
  s3 as s9,
  u2
} from "./chunk-F72FE4ZJ.js";
import "./chunk-2735WBYK.js";
import {
  n as n2,
  s as s5
} from "./chunk-4QESYAV3.js";
import {
  s as s6
} from "./chunk-P2MEGQP6.js";
import {
  e as e2
} from "./chunk-2YTFL6AC.js";
import {
  l as l3
} from "./chunk-ZCZT2HZV.js";
import "./chunk-XFLBB3FK.js";
import {
  a as a5
} from "./chunk-77BBQQ7Y.js";
import {
  o as o2
} from "./chunk-FGWFWDIM.js";
import {
  p as p3
} from "./chunk-UCGDNB2P.js";
import "./chunk-Z2T56FN3.js";
import {
  b as b3
} from "./chunk-ZMKH5ZRU.js";
import {
  j as j4
} from "./chunk-P46VVEIN.js";
import {
  p as p2
} from "./chunk-X34I34RW.js";
import {
  a as a4
} from "./chunk-5NBE4HDI.js";
import "./chunk-4NLQ63FV.js";
import "./chunk-Y7HVH6RU.js";
import {
  t as t2
} from "./chunk-2HDAD5Q3.js";
import {
  c as c3
} from "./chunk-PPU6QR6F.js";
import {
  O
} from "./chunk-PCVJI7J2.js";
import {
  c as c2,
  f as f4,
  p as p4,
  u as u3
} from "./chunk-HZHMZHPT.js";
import "./chunk-NU5WEWCI.js";
import "./chunk-UIVGJZCT.js";
import "./chunk-MVR2W3C6.js";
import "./chunk-4PJMJTU2.js";
import {
  d
} from "./chunk-RNXN3MSP.js";
import "./chunk-DIXAOEHS.js";
import "./chunk-ZL3HOHNK.js";
import "./chunk-KTII3LWY.js";
import "./chunk-RL6GG46M.js";
import "./chunk-JDYLSHC3.js";
import "./chunk-QAWS7Y22.js";
import "./chunk-UX5D32RO.js";
import "./chunk-NYLF7BL2.js";
import "./chunk-HTY52TPQ.js";
import {
  b as b2
} from "./chunk-YC4PIRSZ.js";
import "./chunk-MSLDEOHR.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-32JSK7KN.js";
import "./chunk-YIJWIXDP.js";
import "./chunk-6DURKJBD.js";
import "./chunk-FN5LEP6H.js";
import {
  r as r2
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import {
  b
} from "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import {
  f as f3,
  i,
  s as s4
} from "./chunk-YBMFRTPB.js";
import "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import {
  y as y2
} from "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import "./chunk-KLV5OJVG.js";
import "./chunk-AF36K5Y6.js";
import "./chunk-5K6FTFN4.js";
import "./chunk-CNCZBOLJ.js";
import "./chunk-QXPTMFGZ.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import {
  k
} from "./chunk-QA4FMJA6.js";
import "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-MUO4EIZP.js";
import {
  c
} from "./chunk-42RWGG3D.js";
import "./chunk-G5WJIWPP.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  t
} from "./chunk-CGK6BJQA.js";
import {
  b as b4
} from "./chunk-XU2Q4SCK.js";
import "./chunk-KIEN3CY2.js";
import "./chunk-4CZO65BK.js";
import "./chunk-7E3Q7HTF.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-4RFFPIT2.js";
import "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-D5MIJ6WT.js";
import "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import {
  n
} from "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import {
  p,
  v as v2
} from "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import {
  j as j3,
  u
} from "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-4NOOGA4U.js";
import "./chunk-CWQ6Q3PH.js";
import {
  l as l2
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-74O2T7JC.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  ce,
  f as f2,
  le,
  o2 as o,
  oe,
  r,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import {
  s as s3
} from "./chunk-VBD33VNW.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  j,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a3
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import {
  T,
  a as a2,
  v
} from "./chunk-2YSHZRCT.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  L
} from "./chunk-O3CHVGVF.js";
import {
  f
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/rasterFunctionUtils.js
var e3 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c6 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m4 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f6 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p6(e4) {
  return f6.has(e4.type);
}
function g2(n9, t6) {
  var _a;
  if (!n9 || !t6)
    return a(n9 || t6);
  const r3 = a(n9);
  if (r3.functionDefinition && t6.rasterFunctionDefinition) {
    const e4 = t6.rasterFunctionDefinition;
    (e4.thumbnail || e4.thumbnailEx) && (e4.thumbnail = e4.thumbnailEx = void 0), d4(r3.functionDefinition.arguments, t6), r3.rasterFunctionDefinition = r3.functionDefinition.toJSON();
  } else if ("none" !== ((_a = t6.functionName) == null ? void 0 : _a.toLowerCase())) {
    b5(r3.functionArguments).Raster = t6;
  }
  return r3;
}
function d4(e4, n9) {
  for (const t6 in e4)
    "raster" === t6.toLowerCase() && ("RasterFunctionVariable" === e4[t6].type ? (e4[t6] = n9.rasterFunctionDefinition, e4[t6].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e4[t6].type && d4(e4[t6].arguments, n9));
}
function h3(n9) {
  const r3 = a(e3[n9.functionName + "Function"]), o3 = n9.functionArguments;
  for (const e4 in o3)
    "raster" === e4.toLowerCase() ? (r3.arguments[e4] = h3(o3[e4]), r3.arguments[e4].type = "RasterFunctionTemplate") : "colormap" === e4.toLowerCase() ? (r3.arguments[e4].value = V(o3[e4]), r3.arguments.ColorSchemeType.value = 0) : r3.arguments[e4].value = o3[e4];
  return r3;
}
function y3(e4, n9) {
  switch (n9 = n9 || {}, e4.type) {
    case "raster-stretch":
      return w2(e4, n9);
    case "class-breaks":
      return x2(e4, n9);
    case "unique-value":
      return A(e4, n9);
    case "raster-colormap":
      return F(e4, n9);
    case "vector-field":
      return T2(e4, n9);
    case "raster-shaded-relief":
      return v3(e4, n9);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b5(e4) {
  const n9 = e4 == null ? void 0 : e4.Raster;
  return n9 && "esri.layers.support.RasterFunction" === n9.declaredClass ? b5(n9.functionArguments) : e4;
}
var R = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T2(e4, t6) {
  const r3 = new N();
  r3.functionName = "VectorFieldRenderer";
  const { dataType: o3, bandNames: a13 } = t6, i6 = "vector-uv" === o3;
  let s10, u8;
  if (a13 && 2 === a13.length) {
    const e5 = a13.map((e6) => e6.toLowerCase());
    s10 = e5.indexOf("magnitude"), u8 = e5.indexOf("direction");
  }
  -1 !== s10 && null !== s10 || (s10 = 0, u8 = 1);
  const c15 = "arithmetic" === e4.rotationType ? 1 : 2, f7 = "flow-from" === e4.flowRepresentation ? 0 : 1, p15 = e4.visualVariables ? e4.visualVariables.find((e5) => "Magnitude" === e5.field) : new b3(), g5 = { magnitudeBandID: s10, directionBandID: u8, isUVComponents: i6, referenceSystem: c15, massFlowAngleRepresentation: f7, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m4[e4.style.toLowerCase().replace("-", "_")], minimumMagnitude: p15.minDataValue, maximumMagnitude: p15.maxDataValue, minimumSymbolSize: p15.minSize, maximumSymbolSize: p15.maxSize };
  r3.functionArguments = g5;
  const d8 = h3(r3);
  return t6.convertToRFT ? N.fromJSON({ rasterFunctionDefinition: d8 }) : r3;
}
function v3(e4, t6) {
  const r3 = t6.convertToRFT;
  if ("elevation" !== t6.dataType && ("generic" !== t6.dataType || 1 !== t6.bandCount || "s16" !== t6.pixelType && "s32" !== t6.pixelType && "f32" !== t6.pixelType && "f64" !== t6.pixelType))
    return new N();
  const i6 = new N();
  i6.functionName = "Hillshade";
  const s10 = "traditional" === e4.hillshadeType ? 0 : 1, u8 = "none" === e4.scalingType ? 1 : 3, l11 = { HillshadeType: s10, SlopeType: u8, ZFactor: e4.zFactor };
  return 0 === s10 && (l11.Azimuth = e4.azimuth, l11.Altitude = e4.altitude), 3 === u8 && (l11.PSPower = e4.pixelSizePower, l11.PSZFactor = e4.pixelSizeFactor), i6.functionArguments = l11, i6.variableName = "Raster", e4.colorRamp && (i6.functionName = "ShadedRelief", r3 ? l11.ColorRamp = I(e4.colorRamp) : l11.Colormap = w(e4.colorRamp)), r3 ? new N({ rasterFunctionDefinition: h3(i6) }) : i6;
}
function w2(e4, t6) {
  var _a;
  const r3 = t6.convertToRFT, s10 = new N();
  s10.functionName = "Stretch";
  const l11 = R[n4.toJSON(e4.stretchType)], c15 = "u8", m7 = { StretchType: l11, Statistics: N2(e4.statistics ?? []), DRA: e4.dynamicRangeAdjustment, UseGamma: e4.useGamma, Gamma: e4.gamma, ComputeGamma: e4.computeGamma };
  if (null != e4.outputMin && (m7.Min = e4.outputMin), null != e4.outputMax && (m7.Max = e4.outputMax), l11 === R.standardDeviation ? (m7.NumberOfStandardDeviations = e4.numberOfStandardDeviations, s10.outputPixelType = c15) : l11 === R.percentClip ? (m7.MinPercent = e4.minPercent, m7.MaxPercent = e4.maxPercent, s10.outputPixelType = c15) : l11 === R.minMax ? s10.outputPixelType = c15 : l11 === R.sigmoid && (m7.SigmoidStrengthLevel = e4.sigmoidStrengthLevel), s10.functionArguments = m7, s10.variableName = "Raster", e4.colorRamp) {
    const u8 = e4.colorRamp, l12 = new N();
    if (r3)
      l12.functionArguments = { ColorRamp: I(u8) };
    else {
      const n9 = s8(u8, true);
      if (n9)
        l12.functionArguments = { colorRamp: n9 };
      else if (!t6.convertColorRampToColormap || "algorithmic" !== u8.type && "multipart" !== u8.type) {
        const n10 = e4.colorRamp.toJSON();
        "algorithmic" === n10.type ? n10.algorithm = n10.algorithm || "esriCIELabAlgorithm" : "multipart" === n10.type && ((_a = n10.colorRamps) == null ? void 0 : _a.length) && n10.colorRamps.forEach((e5) => e5.algorithm = e5.algorithm || "esriCIELabAlgorithm"), l12.functionArguments = { colorRamp: n10 };
      } else
        l12.functionArguments = { Colormap: w(u8) };
    }
    return l12.variableName = "Raster", l12.functionName = "Colormap", l12.functionArguments.Raster = s10, r3 ? new N({ rasterFunctionDefinition: h3(l12) }) : l12;
  }
  return r3 ? new N({ rasterFunctionDefinition: h3(s10) }) : s10;
}
function x2(e4, t6) {
  const r3 = [], o3 = [], a13 = [], i6 = [], s10 = 1e-6, { pixelType: u8, rasterAttributeTable: l11 } = t6, c15 = null == l11 ? null : l11.features, m7 = C(l11);
  if (m7 && c15 && Array.isArray(c15) && e4.classBreakInfos) {
    e4.classBreakInfos.forEach((n9, t7) => {
      var _a;
      const r5 = (_a = n9.symbol) == null ? void 0 : _a.color;
      let o5;
      (r5 == null ? void 0 : r5.a) && null != n9.minValue && null != n9.maxValue && c15.forEach((a14) => {
        null != n9.minValue && null != n9.maxValue && (o5 = a14.attributes[e4.field], (o5 >= n9.minValue && o5 < n9.maxValue || t7 === e4.classBreakInfos.length - 1 && o5 >= n9.minValue) && i6.push([a14.attributes[m7], r5.r, r5.g, r5.b]));
      });
    });
    const r4 = u8 ? S2(i6, u8) : i6, o4 = new N();
    return o4.functionName = "Colormap", o4.functionArguments = {}, o4.functionArguments.Colormap = r4, o4.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h3(o4) }) : o4;
  }
  e4.classBreakInfos.forEach((e5, n9) => {
    if (null == e5.minValue || null == e5.maxValue)
      return;
    const t7 = e5.symbol && e5.symbol.color;
    (t7 == null ? void 0 : t7.a) ? (0 === n9 ? r3.push(e5.minValue, e5.maxValue + s10) : r3.push(e5.minValue + s10, e5.maxValue + s10), o3.push(n9), i6.push([n9, t7.r, t7.g, t7.b])) : a13.push(e5.minValue, e5.maxValue);
  });
  const f7 = u8 ? S2(i6, u8) : i6, p15 = new N();
  p15.functionName = "Remap", p15.functionArguments = { InputRanges: r3, OutputValues: o3, NoDataRanges: a13 }, p15.variableName = "Raster";
  const g5 = new N();
  return g5.functionName = "Colormap", g5.functionArguments = { Colormap: f7, Raster: p15 }, t6.convertToRFT ? new N({ rasterFunctionDefinition: h3(g5) }) : g5;
}
function S2(e4, n9) {
  const t6 = c6.has(n9) ? s7(n9) : null;
  return t6 && e4.push([Math.floor(t6[0] - 1), 0, 0, 0], [Math.ceil(t6[1] + 1), 0, 0, 0]), e4;
}
function C(e4) {
  if (null == e4)
    return;
  const { fields: n9 } = e4, t6 = n9 && n9.find((e5) => e5 && e5.name && "value" === e5.name.toLowerCase());
  return t6 && t6.name;
}
function A(e4, t6) {
  var _a, _b, _c;
  const r3 = [], { pixelType: o3, rasterAttributeTable: a13 } = t6, i6 = null == a13 ? null : a13.features, s10 = C(a13), u8 = (_b = (_a = e4.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), l11 = e4.uniqueValueInfos;
  if (l11)
    if (i6) {
      if (s10) {
        const n9 = /* @__PURE__ */ new Map();
        l11.forEach((e5) => {
          var _a2;
          const t8 = e5.value, r4 = (_a2 = e5.symbol) == null ? void 0 : _a2.color;
          null != t8 && r4 && r4.a && n9.set(String(t8), r4.toRgb());
        });
        const t7 = e4.field;
        i6.forEach(({ attributes: e5 }) => {
          const o4 = String(e5[t7]), a14 = e5[s10], i7 = n9.get(o4);
          i7 ? r3.push([a14, ...i7]) : u8 && r3.push([a14, ...u8]);
        });
      }
    } else
      for (let n9 = 0; n9 < l11.length; n9++) {
        const e5 = l11[n9], t7 = (_c = e5.symbol) == null ? void 0 : _c.color, o4 = +e5.value;
        if (t7 == null ? void 0 : t7.a) {
          if (isNaN(o4))
            return null;
          r3.push([o4, t7.r, t7.g, t7.b]);
        }
      }
  const c15 = o3 && r3.length > 0 ? S2(r3, o3) : r3, m7 = new N();
  return m7.functionName = "Colormap", m7.functionArguments = {}, m7.functionArguments.Colormap = c15, m7.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h3(m7) }) : m7;
}
function F(e4, t6) {
  const r3 = e4.extractColormap();
  if (!r3 || 0 === r3.length)
    return null;
  const { pixelType: o3 } = t6, a13 = o3 ? S2(r3, o3) : r3, i6 = new N();
  return i6.functionName = "Colormap", i6.functionArguments = {}, i6.functionArguments.Colormap = a13, t6.convertToRFT ? new N({ rasterFunctionDefinition: h3(i6) }) : i6;
}
function N2(e4) {
  const n9 = [];
  return e4 == null ? void 0 : e4.forEach((e5) => {
    const t6 = e5;
    if (Array.isArray(t6))
      n9.push(t6);
    else {
      if (null == t6.min || null == t6.max)
        return;
      const e6 = [t6.min, t6.max, t6.avg || 0, t6.stddev || 0];
      n9.push(e6);
    }
  }), n9;
}
function V(e4) {
  const n9 = [], t6 = [];
  return e4.forEach((e5) => {
    n9.push(e5[0]), t6.push(G([...e5.slice(1), 255]));
  }), { type: "RasterColormap", values: n9, colors: t6 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var y4 = class extends l {
  constructor() {
    super(...arguments), this.layer = null, this.compression = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e4, t6, r3) {
    this.layer.version < 10.3 || (t6[r3] = e4);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e4, t6, r3) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e4 && (t6[r3] = e4);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e4, t6, r3) {
    "lerc" === this.format && null != e4 && (t6[r3] = e4);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  writeLercVersion(e4, t6, r3) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t6[r3] = e4);
  }
  get version() {
    const e4 = this.layer;
    return e4.commitProperty("bandIds"), e4.commitProperty("format"), e4.commitProperty("compressionQuality"), e4.commitProperty("compressionTolerance"), e4.commitProperty("interpolation"), e4.commitProperty("noData"), e4.commitProperty("noDataInterpretation"), e4.commitProperty("mosaicRule"), e4.commitProperty("rasterFunction"), e4.commitProperty("adjustAspectRatio"), e4.commitProperty("pixelFilter"), e4.commitProperty("definitionExpression"), e4.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e4) {
    this._set("version", e4);
  }
  get mosaicRule() {
    const e4 = this.layer;
    let t6 = e4.mosaicRule;
    const r3 = e4.definitionExpression;
    return t6 ? r3 && r3 !== t6.where && (t6 = t6.clone(), t6.where = r3) : r3 && (t6 = new j6({ where: r3 })), t6;
  }
  get rasterFunction() {
    var _a, _b;
    const e4 = this.layer;
    let { rasterFunction: t6 } = e4;
    const r3 = e4.pixelFilter, o3 = !e4.format || e4.format.includes("jpg") || e4.format.includes("png");
    t6 = this._addResampleRasterFunction(t6);
    const i6 = (_a = e4.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
    return i6 && (t6 = this._addClipFunction(t6, i6)), o3 && !r3 && "vector-field" !== ((_b = e4.renderer) == null ? void 0 : _b.type) && (t6 = this.combineRendererWithRenderingRule(t6)), t6;
  }
  combineRendererWithRenderingRule(e4) {
    const t6 = this.layer, { rasterInfo: r3, renderer: o3 } = t6;
    if (e4 = e4 || t6.rasterFunction, !o3 || !p6(o3))
      return e4;
    return g2(y3(o3, { rasterAttributeTable: r3.attributeTable, pixelType: r3.pixelType, dataType: r3.dataType, bandNames: r3.bandInfos.map(({ name: e5 }) => e5), convertColorRampToColormap: t6.version < 10.6, convertToRFT: !!(e4 == null ? void 0 : e4.rasterFunctionDefinition), bandCount: r3.bandCount }), e4);
  }
  _addResampleRasterFunction(e4) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e4 == null ? void 0 : e4.functionName))
      return e4;
    const t6 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r3 = this.layer.serviceRasterInfo.pixelSize;
    let o3 = new N({ functionName: "Resample", functionArguments: { ResamplingType: t6, InputCellSize: r3 } });
    return o3 = (e4 == null ? void 0 : e4.rasterFunctionDefinition) ? new N({ rasterFunctionDefinition: h3(o3) }) : o3, g2(o3, e4);
  }
  _addClipFunction(e4, t6) {
    const r3 = new N({ functionName: "Clip", functionArguments: { ClippingGeometry: t6.toJSON(), ClippingType: 1 } });
    return g2(r3, e4);
  }
};
e([y()], y4.prototype, "layer", void 0), e([y({ json: { write: true } })], y4.prototype, "adjustAspectRatio", null), e([r("adjustAspectRatio")], y4.prototype, "writeAdjustAspectRatio", null), e([y({ json: { write: true } })], y4.prototype, "bandIds", null), e([y({ json: { write: true } })], y4.prototype, "compression", void 0), e([y({ json: { write: true } })], y4.prototype, "compressionQuality", null), e([r("compressionQuality")], y4.prototype, "writeCompressionQuality", null), e([y({ json: { write: true } })], y4.prototype, "compressionTolerance", null), e([r("compressionTolerance")], y4.prototype, "writeCompressionTolerance", null), e([y({ json: { write: true } })], y4.prototype, "format", null), e([y({ type: String, json: { read: { reader: a6.read }, write: { writer: a6.write } } })], y4.prototype, "interpolation", null), e([y({ json: { write: true } })], y4.prototype, "noData", null), e([y({ type: String, json: { read: { reader: i2.read }, write: { writer: i2.write } } })], y4.prototype, "noDataInterpretation", null), e([y({ json: { write: true } })], y4.prototype, "pixelType", void 0), e([y({ json: { write: true } })], y4.prototype, "lercVersion", void 0), e([r("lercVersion")], y4.prototype, "writeLercVersion", null), e([y({ type: Number })], y4.prototype, "version", null), e([y({ json: { write: true } })], y4.prototype, "mosaicRule", null), e([y({ json: { write: true, name: "renderingRule" } })], y4.prototype, "rasterFunction", null), y4 = e([a3("esri.layers.mixins.ExportImageServiceParameters")], y4);

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p7 = class extends l {
  constructor(r3) {
    super(r3), this.north = null, this.up = null, this.spatialReference = null;
  }
};
e([y({ type: Number, json: { write: true } })], p7.prototype, "north", void 0), e([y({ type: Number, json: { write: true } })], p7.prototype, "up", void 0), e([y({ type: f2, json: { write: true } })], p7.prototype, "spatialReference", void 0), p7 = e([a3("esri.rest.support.ImageAngleResult")], p7);
var i3 = p7;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var u4 = class extends l {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
e([y({ type: Number, json: { read: true, write: true } })], u4.prototype, "value", void 0), e([y({ type: String, json: { read: true, write: true } })], u4.prototype, "displayValue", void 0), e([y({ type: Number, json: { read: true, write: true } })], u4.prototype, "uncertainty", void 0), u4 = e([a3("esri.rest.support.ImageMeasureResultValue")], u4);
var a7 = class extends u4 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: le.read, write: le.write } })], a7.prototype, "unit", void 0), a7 = e([a3("esri.rest.support.ImageMeasureResultLengthValue")], a7);
var n6 = class extends u4 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: ce.read, write: ce.write } })], n6.prototype, "unit", void 0), n6 = e([a3("esri.rest.support.ImageMeasureResultAreaValue")], n6);
var l6 = class extends u4 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
e([y({ type: String, json: { read: oe.read, write: oe.write } })], l6.prototype, "unit", void 0), l6 = e([a3("esri.rest.support.ImageMeasureResultAngleValue")], l6);
var c7 = class extends l {
  constructor() {
    super(...arguments), this.name = null, this.sensorName = null;
  }
};
e([y({ type: String, json: { read: true, write: true } })], c7.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], c7.prototype, "sensorName", void 0), c7 = e([a3("esri.rest.support.BaseImageMeasureResult")], c7);

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a8 = class extends c7 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
e([y({ type: n6, json: { read: true, write: true } })], a8.prototype, "area", void 0), e([y({ type: a7, json: { read: true, write: true } })], a8.prototype, "perimeter", void 0), a8 = e([a3("esri.rest.support.ImageAreaResult")], a8);
var c8 = a8;

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a9 = class extends c7 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
e([y({ type: a7, json: { read: true, write: true } })], a9.prototype, "distance", void 0), e([y({ type: l6, json: { read: true, write: true } })], a9.prototype, "azimuthAngle", void 0), e([y({ type: l6, json: { read: true, write: true } })], a9.prototype, "elevationAngle", void 0), a9 = e([a3("esri.rest.support.ImageDistanceResult")], a9);
var i4 = a9;

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p8 = class extends c7 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
e([y({ type: a7, json: { read: true, write: true } })], p8.prototype, "height", void 0), p8 = e([a3("esri.rest.support.ImageHeightResult")], p8);
var c9 = p8;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p9 = class extends l {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
e([y({ json: { write: true } })], p9.prototype, "catalogItemVisibilities", void 0), e([y({ type: d, json: { write: true } })], p9.prototype, "catalogItems", void 0), e([y({ type: x, json: { write: true } })], p9.prototype, "location", void 0), e([y({ json: { write: true } })], p9.prototype, "name", void 0), e([y({ json: { write: true } })], p9.prototype, "objectId", void 0), e([y({ json: { write: true } })], p9.prototype, "processedValues", void 0), e([y({ json: { write: true } })], p9.prototype, "properties", void 0), e([y({ json: { write: true } })], p9.prototype, "value", void 0), p9 = e([a3("esri.rest.support.ImageIdentifyResult")], p9);
var l7 = p9;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t5 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
e([y({ json: { write: true } })], t5.prototype, "geometries", void 0), t5 = e([a3("esri.rest.support.ImagePixelLocationResult")], t5);
var p10 = t5;

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p11 = class extends c7 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
e([y({ type: x, json: { name: "point.value", read: true, write: true } })], p11.prototype, "point", void 0), p11 = e([a3("esri.rest.support.ImagePointResult")], p11);
var a10 = p11;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i5 = class extends l {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
e([y({ json: { write: true } })], i5.prototype, "attributes", void 0), e([y({ type: x, json: { write: true } })], i5.prototype, "location", void 0), e([y({ json: { write: true } })], i5.prototype, "locationId", void 0), e([y({ json: { write: true } })], i5.prototype, "rasterId", void 0), e([y({ json: { write: true } })], i5.prototype, "resolution", void 0), e([y({ json: { write: true } })], i5.prototype, "pixelValue", void 0), i5 = e([a3("esri.rest.support.ImageSample")], i5);
var p12 = i5;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p13 = class extends l {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
e([y({ type: [p12], json: { write: true } })], p13.prototype, "samples", void 0), p13 = e([a3("esri.rest.support.ImageSampleResult")], p13);
var c10 = p13;

// node_modules/@arcgis/core/rest/imageService.js
function g3(t6) {
  const e4 = t6 == null ? void 0 : t6.time;
  if (e4 && (null != e4.start || null != e4.end)) {
    const n9 = [];
    null != e4.start && n9.push(e4.start), null == e4.end || n9.includes(e4.end) || n9.push(e4.end), t6.time = n9.join(",");
  }
}
async function y5(t6, r3, s10) {
  const i6 = f3(t6), m7 = r3.geometry ? [r3.geometry] : [], u8 = await b(m7), c15 = r3.toJSON();
  g3(c15);
  const l11 = u8 && u8[0];
  null != l11 && (c15.geometry = l11.toJSON());
  const f7 = s4({ ...i6.query, f: "json", ...c15 });
  return i(f7, s10);
}
async function S3(e4, s10, i6) {
  var _a;
  const m7 = s10.toJSON();
  null != m7.angleName && (m7.angleName = m7.angleName.join(",")), null != s10.point && ((_a = s10.point.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (m7.point.spatialReference = v4(s10.point.spatialReference)), null != s10.spatialReference && s10.spatialReference.imageCoordinateSystem && (m7.spatialReference = G2(s10.spatialReference));
  const u8 = f3(e4), c15 = s4({ ...u8.query, f: "json", ...m7 }), l11 = i(c15, i6), { data: f7 } = await j2(`${u8.path}/computeAngles`, l11);
  return f7.spatialReference = f7.spatialReference ? null != f7.spatialReference.geodataXform ? new f2({ wkid: 0, imageCoordinateSystem: f7.spatialReference }) : f2.fromJSON(f7.spatialReference) : null, "NaN" === f7.north && (f7.north = null), "NaN" === f7.up && (f7.up = null), new i3(f7);
}
async function d5(e4, r3, s10) {
  var _a;
  const i6 = r3.toJSON(), { geometries: m7 } = r3;
  if (m7)
    for (let t6 = 0; t6 < m7.length; t6++)
      ((_a = m7[t6].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (i6.geometries.geometries[t6].spatialReference = v4(m7[t6].spatialReference));
  const u8 = f3(e4), l11 = s4({ ...u8.query, f: "json", ...i6 }), f7 = i(l11, s10), { data: p15 } = await j2(`${u8.path}/computePixelLocation`, f7);
  return p10.fromJSON(p15);
}
async function N3(e4, o3, a13) {
  const r3 = await y5(e4, o3, a13), s10 = f3(e4), { data: i6 } = await j2(`${s10.path}/computeStatisticsHistograms`, r3), { statistics: m7 } = i6;
  return (m7 == null ? void 0 : m7.length) && m7.forEach((t6) => {
    t6.avg = t6.mean, t6.stddev = t6.standardDeviation;
  }), { statistics: m7, histograms: i6.histograms };
}
async function R2(e4, o3, a13) {
  const r3 = await y5(e4, o3, a13), s10 = f3(e4), { data: i6 } = await j2(`${s10.path}/computeHistograms`, r3);
  return { histograms: i6.histograms };
}
async function J(r3, s10, i6) {
  var _a, _b;
  const m7 = s10.toJSON();
  g3(m7), ((_a = m7.outFields) == null ? void 0 : _a.length) && (m7.outFields = m7.outFields.join(","));
  const u8 = await b(s10.geometry), c15 = u8 == null ? void 0 : u8[0];
  null != c15 && (m7.geometry = c15.toJSON());
  const l11 = f3(r3), p15 = s4({ ...l11.query, f: "json", ...m7 }), y11 = i(p15, i6), { data: S4 } = await j2(`${l11.path}/getSamples`, y11), d8 = (_b = S4 == null ? void 0 : S4.samples) == null ? void 0 : _b.map((t6) => {
    const e4 = "NaN" === t6.value || "" === t6.value ? null : t6.value.split(" ").map((t7) => Number(t7));
    return { ...t6, pixelValue: e4 };
  });
  return c10.fromJSON({ samples: d8 });
}
async function O2(r3, s10, i6) {
  const m7 = f3(r3), c15 = s10.geometry ? [s10.geometry] : [];
  return b(c15).then((e4) => {
    const n9 = s10.toJSON(), r4 = e4 && e4[0];
    null != r4 && (n9.geometry = JSON.stringify(r4.toJSON()));
    const u8 = s4({ ...m7.query, f: "json", ...n9 }), c16 = i(u8, i6);
    return j2(m7.path + "/identify", c16);
  }).then((t6) => l7.fromJSON(t6.data));
}
async function h4(t6, e4, n9) {
  const o3 = await C2(t6, e4, [e4.fromGeometry, e4.toGeometry], n9);
  return c9.fromJSON(o3);
}
async function j7(t6, e4, n9) {
  const o3 = await C2(t6, e4, [e4.geometry], n9);
  return c8.fromJSON(o3);
}
async function w3(t6, e4, n9) {
  const o3 = await C2(t6, e4, [e4.geometry], n9);
  return a10.fromJSON(o3);
}
async function I2(t6, e4, n9) {
  const o3 = await C2(t6, e4, [e4.fromGeometry, e4.toGeometry], n9);
  return i4.fromJSON(o3);
}
async function C2(r3, s10, i6, m7) {
  const u8 = f3(r3), c15 = await b(i6), l11 = s10.toJSON();
  null != c15[0] && (l11.fromGeometry = JSON.stringify(q2(c15[0]))), null != c15[1] && (l11.toGeometry = JSON.stringify(q2(c15[1])));
  const f7 = s4({ ...u8.query, f: "json", ...l11 }), p15 = i(f7, m7), { data: g5 } = await j2(u8.path + "/measure", p15);
  return g5;
}
function q2(t6) {
  var _a;
  const e4 = t6.toJSON();
  return ((_a = t6.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (e4.spatialReference = v4(t6.spatialReference)), e4;
}
function v4(t6) {
  const { imageCoordinateSystem: e4 } = t6;
  if (e4) {
    const { id: t7, referenceServiceName: n9 } = e4;
    return null != t7 ? n9 ? { icsid: t7, icsns: n9 } : { icsid: t7 } : { ics: e4 };
  }
  return t6.toJSON();
}
function G2(t6, e4) {
  const n9 = v4(t6), { icsid: o3, icsns: a13, wkid: r3 } = n9;
  return null != o3 ? null == a13 || (e4 == null ? void 0 : e4.toLowerCase().includes("/" + a13.toLowerCase() + "/")) ? `0:${o3}` : JSON.stringify(n9) : r3 ? r3.toString() : JSON.stringify(n9);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n7(n9, m7, p15) {
  var _a, _b;
  const f7 = f3(n9), u8 = s4({ ...f7 == null ? void 0 : f7.query, f: "json" }), h6 = i(u8, p15), d8 = `${f7 == null ? void 0 : f7.path}/${m7}/info`, c15 = j2(`${d8}`, h6), g5 = j2(`${d8}/keyProperties`, h6), x3 = await Promise.allSettled([c15, g5]), y11 = "fulfilled" === x3[0].status ? x3[0].value.data : null, v5 = "fulfilled" === x3[1].status ? x3[1].value.data : null;
  let P2 = null;
  ((_a = y11.statistics) == null ? void 0 : _a.length) && (P2 = y11.statistics.map((e4) => ({ min: e4[0], max: e4[1], avg: e4[2], stddev: e4[3] })));
  const S4 = M.fromJSON(y11.extent), j9 = Math.ceil(S4.width / y11.pixelSizeX - 0.1), w4 = Math.ceil(S4.height / y11.pixelSizeY - 0.1), b6 = S4.spatialReference, k3 = new x({ x: y11.pixelSizeX, y: y11.pixelSizeY, spatialReference: b6 }), z = ((_b = y11.histograms) == null ? void 0 : _b.length) ? y11.histograms : null, L4 = new n3({ origin: y11.origin, blockWidth: y11.blockWidth, blockHeight: y11.blockHeight, firstPyramidLevel: y11.firstPyramidLevel, maximumPyramidLevel: y11.maxPyramidLevel });
  return new m({ width: j9, height: w4, bandCount: y11.bandCount, extent: S4, spatialReference: b6, pixelSize: k3, pixelType: y11.pixelType.toLowerCase(), statistics: P2, histograms: z, keyProperties: v5, storageInfo: L4 });
}

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n8;
var m5 = n8 = class extends l {
  constructor(e4) {
    super(e4), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n8(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
e([y({ type: [String], json: { name: "angleName", write: true } })], m5.prototype, "angleNames", void 0), e([y({ type: x, json: { write: true } })], m5.prototype, "point", void 0), e([y({ type: f2, json: { write: true } })], m5.prototype, "spatialReference", void 0), e([y({ type: T, json: { write: true } })], m5.prototype, "rasterId", void 0), m5 = n8 = e([a3("esri.rest.support.ImageAngleParameters")], m5);
var l8 = m5;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a11 = new s3({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p14 = class extends l {
  constructor() {
    super(...arguments), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
e([y()], p14.prototype, "type", void 0), e([y({ type: a11.apiValues, json: { read: a11.read, write: a11.write } })], p14.prototype, "measureOperation", void 0), e([y({ type: j6, json: { write: true } })], p14.prototype, "mosaicRule", void 0), e([y({ type: x, json: { write: true } })], p14.prototype, "pixelSize", void 0), e([y({ json: { write: true } })], p14.prototype, "raster", void 0), p14 = e([a3("esri.rest.support.BaseImageMeasureParameters")], p14);

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var l9;
var u5 = l9 = class extends p14 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e4, r3, t6) {
    null != e4 && (r3.geometryType = v2(e4), r3[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new l9(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ types: n, json: { name: "fromGeometry", read: true, write: true } })], u5.prototype, "geometry", void 0), e([r("geometry")], u5.prototype, "writeGeometry", null), e([y({ type: a11.apiValues, json: { write: a11.write } })], u5.prototype, "measureOperation", null), e([y({ json: { read: true } })], u5.prototype, "is3D", void 0), e([y({ type: String, json: { read: le.read, write: le.write } })], u5.prototype, "linearUnit", void 0), e([y({ type: String, json: { read: ce.read, write: ce.write } })], u5.prototype, "areaUnit", void 0), u5 = l9 = e([a3("esri.rest.support.ImageAreaParameters")], u5);
var y6 = u5;

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var y7;
var c11 = y7 = class extends p14 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e4, r3, t6) {
    null != e4 && (r3.geometryType = v2(e4), r3[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new y7(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ type: x, json: { read: true, write: true } })], c11.prototype, "fromGeometry", void 0), e([r("fromGeometry")], c11.prototype, "writeFromGeometry", null), e([y({ type: x, json: { read: true, write: true } })], c11.prototype, "toGeometry", void 0), e([y({ type: a11.apiValues, json: { write: a11.write } })], c11.prototype, "measureOperation", null), e([y({ json: { read: true } })], c11.prototype, "is3D", void 0), e([y({ type: String, json: { read: le.read, write: le.write } })], c11.prototype, "linearUnit", void 0), e([y({ type: String, json: { read: oe.read, write: oe.write } })], c11.prototype, "angularUnit", void 0), c11 = y7 = e([a3("esri.rest.support.ImageDistanceParameters")], c11);
var u6 = c11;

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y8;
var l10 = y8 = class extends p14 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e4, r3, t6) {
    null != e4 && (r3.geometryType = v2(e4), r3[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y8(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ type: x, json: { read: true } })], l10.prototype, "fromGeometry", void 0), e([r("fromGeometry")], l10.prototype, "writeFromGeometry", null), e([y({ type: x, json: { read: true, write: true } })], l10.prototype, "toGeometry", void 0), e([y({ type: a11.apiValues, json: { write: a11.write } })], l10.prototype, "measureOperation", null), e([y({ json: { read: true } })], l10.prototype, "operationType", void 0), e([y({ type: String, json: { read: le.read, write: le.write } })], l10.prototype, "linearUnit", void 0), l10 = y8 = e([a3("esri.rest.support.ImageHeightParameters")], l10);
var c12 = l10;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var y9;
var g4 = y9 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(e4, t6, r3) {
    null != e4 && (t6.geometryType = v2(e4), t6[r3] = JSON.stringify(e4.toJSON()));
  }
  set mosaicRule(e4) {
    let t6 = e4;
    t6 && t6.mosaicMethod && (t6 = j6.fromJSON({ ...t6.toJSON(), mosaicMethod: t6.mosaicMethod, mosaicOperation: t6.mosaicOperation })), this._set("mosaicRule", t6);
  }
  writeMosaicRule(e4, t6, r3) {
    null != e4 && (t6[r3] = JSON.stringify(e4.toJSON()));
  }
  get renderingRule() {
    return t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._get("rasterFunction");
  }
  set renderingRule(e4) {
    t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._set("rasterFunction", e4);
  }
  get renderingRules() {
    return t(s.getLogger(this), "renderingRules", { replacement: "rasterFunctions", version: "4.27", warnOnce: true }), this._get("rasterFunctions");
  }
  set renderingRules(e4) {
    t(s.getLogger(this), "renderingRules", { replacement: "rasterFunctions", version: "4.27", warnOnce: true }), this._set("rasterFunctions", e4);
  }
  set rasterFunction(e4) {
    let t6 = e4;
    t6 && t6.rasterFunction && (t6 = N.fromJSON({ ...t6.toJSON(), rasterFunction: t6.rasterFunction, rasterFunctionArguments: t6.rasterFunctionArguments })), this._set("rasterFunction", t6);
  }
  writeRasterFunction(e4, t6, r3) {
    null != e4 && (t6[r3] = JSON.stringify(e4.toJSON())), e4.rasterFunctionDefinition && (t6[r3] = JSON.stringify(e4.rasterFunctionDefinition));
  }
  writeRasterFunctions(e4, t6, r3) {
    null != e4 && (t6[r3] = JSON.stringify(e4.map((e5) => e5.rasterFunctionDefinition || e5.toJSON())));
  }
  writePixelSize(e4, t6, r3) {
    null != e4 && (t6[r3] = JSON.stringify(e4));
  }
  writeTimeExtent(e4, t6, r3) {
    if (null != e4) {
      const o3 = null != e4.start ? e4.start.getTime() : null, i6 = null != e4.end ? e4.end.getTime() : null;
      t6[r3] = null != o3 ? null != i6 ? `${o3},${i6}` : `${o3}` : null;
    }
  }
  clone() {
    return new y9(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
e([y({ json: { write: true } })], g4.prototype, "geometry", void 0), e([r("geometry")], g4.prototype, "writeGeometry", null), e([y({ type: j6, json: { write: true } })], g4.prototype, "mosaicRule", null), e([r("mosaicRule")], g4.prototype, "writeMosaicRule", null), e([y({ type: N })], g4.prototype, "renderingRule", null), e([y({ type: [N] })], g4.prototype, "renderingRules", null), e([y({ type: N, json: { write: true, name: "renderingRule" } })], g4.prototype, "rasterFunction", null), e([r("rasterFunction")], g4.prototype, "writeRasterFunction", null), e([y({ type: [N], json: { write: true, name: "renderingRules" } })], g4.prototype, "rasterFunctions", void 0), e([r("rasterFunctions")], g4.prototype, "writeRasterFunctions", null), e([y({ type: x, json: { write: true } })], g4.prototype, "pixelSize", void 0), e([r("pixelSize")], g4.prototype, "writePixelSize", null), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "returnCatalogItems", void 0), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "returnPixelValues", void 0), e([y({ type: Number, json: { write: true } })], g4.prototype, "maxItemCount", void 0), e([y({ type: c, json: { write: { target: "time" } } })], g4.prototype, "timeExtent", void 0), e([r("timeExtent")], g4.prototype, "writeTimeExtent", null), e([y({ json: { write: true } })], g4.prototype, "raster", void 0), e([y({ json: { write: true } })], g4.prototype, "viewId", void 0), e([y({ type: Boolean, json: { write: true } })], g4.prototype, "processAsMultidimensional", void 0), g4 = y9 = e([a3("esri.rest.support.ImageIdentifyParameters")], g4);
var d6 = g4;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m6;
var c13 = m6 = class extends l {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r3, e4, o3) {
    e4.geometries = { geometryType: "esriGeometryPoint", geometries: r3.map((r4) => r4.toJSON()) };
  }
  clone() {
    var _a;
    return new m6({ geometries: ((_a = this.geometries) == null ? void 0 : _a.map((r3) => r3.clone())) ?? [], rasterId: this.rasterId });
  }
};
e([y({ type: [x], json: { write: true } })], c13.prototype, "geometries", void 0), e([r("geometries")], c13.prototype, "writeGeometry", null), e([y({ type: T, json: { write: true } })], c13.prototype, "rasterId", void 0), c13 = m6 = e([a3("esri.rest.support.ImagePixelLocationParameters")], c13);
var a12 = c13;

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c14;
var u7 = c14 = class extends p14 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e4, r3, t6) {
    null != e4 && (r3.geometryType = v2(e4), r3[t6] = e4.toJSON());
  }
  get measureOperation() {
    const { is3D: e4, geometry: r3 } = this;
    return "point" === r3.type ? e4 ? "point-3D" : "point" : e4 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c14(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
e([y({ types: n, json: { name: "fromGeometry", read: p } })], u7.prototype, "geometry", void 0), e([r("geometry")], u7.prototype, "writeGeometry", null), e([y({ type: a11.apiValues, json: { read: a11.read, write: a11.write } })], u7.prototype, "measureOperation", null), e([y({ json: { read: true } })], u7.prototype, "is3D", void 0), u7 = c14 = e([a3("esri.rest.support.ImagePointParameters")], u7);
var y10 = u7;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d7;
var j8 = d7 = class extends l {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t6, e4, o3) {
    null != t6 && (e4.geometryType = v2(t6), e4[o3] = t6.toJSON());
  }
  set locations(t6) {
    if (t6 == null ? void 0 : t6.length) {
      const e4 = new u({ spatialReference: t6[0].spatialReference });
      e4.points = t6.map((t7) => [t7.x, t7.y]), this._set("locations", t6), this.geometry = e4;
    }
  }
  clone() {
    return new d7(a({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
e([y({ types: n, json: { read: p } })], j8.prototype, "geometry", void 0), e([r("geometry")], j8.prototype, "writeGeometry", null), e([y()], j8.prototype, "locations", null), e([y({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], j8.prototype, "interpolation", void 0), e([y({ type: j6, json: { write: true } })], j8.prototype, "mosaicRule", void 0), e([y({ type: [String], json: { write: true } })], j8.prototype, "outFields", void 0), e([y({ type: x, json: { write: true } })], j8.prototype, "pixelSize", void 0), e([y({ type: String, json: { write: true } })], j8.prototype, "raster", void 0), e([y({ type: Boolean, json: { write: true } })], j8.prototype, "returnFirstValueOnly", void 0), e([y({ type: Number, json: { write: true } })], j8.prototype, "sampleDistance", void 0), e([y({ type: Number, json: { write: true } })], j8.prototype, "sampleCount", void 0), e([y({ type: Number, json: { write: true } })], j8.prototype, "sliceId", void 0), e([y({ type: c, json: { read: { source: "time" }, write: { target: "time" } } })], j8.prototype, "timeExtent", void 0), j8 = d7 = e([a3("esri.rest.support.ImageSampleParameters")], j8);
var h5 = j8;

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Fe = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var De = j(a2, { min: 0, max: 255 });
function Pe(e4) {
  if (!e4)
    return null;
  const t6 = JSON.stringify(e4).match(/"rasterFunction":"(.*?")/gi), r3 = t6 == null ? void 0 : t6.map((e5) => e5.replace('"rasterFunction":"', "").replace('"', ""));
  return r3 ? r3.join("/") : null;
}
var je = (d8) => {
  let y11 = class extends d8 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this._rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new y4({ layer: this }));
    }
    readServiceSupportsMosaicRule(e4, t6) {
      return this._isMosaicRuleSupported(t6);
    }
    get _rasterFunctionNamesIndex() {
      const e4 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t6) => {
        e4.set(t6.name.toLowerCase().replaceAll(/ /gi, "_"), t6.name);
      }), e4;
    }
    readBandIds(e4, t6) {
      if (Array.isArray(e4) && e4.length > 0 && e4.every((e5) => "number" == typeof e5))
        return e4;
    }
    readCapabilities(e4, t6) {
      return this._readCapabilities(t6);
    }
    writeCompressionQuality(e4, t6, r3) {
      null != e4 && "lerc" !== this.format && (t6[r3] = e4);
    }
    writeCompressionTolerance(e4, t6, r3) {
      "lerc" === this.format && null != e4 && (t6[r3] = e4);
    }
    readDefaultMosaicRule(e4, t6) {
      return this._serviceSupportsMosaicRule ? j6.fromJSON(t6) : null;
    }
    get fieldsIndex() {
      return this.fields ? new r2(this.fields) : null;
    }
    set format(e4) {
      e4 && Fe.has(e4.toLowerCase()) && this._set("format", e4.toLowerCase());
    }
    readFormat(e4, t6) {
      return "esriImageServiceDataTypeVector-UV" === t6.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t6.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e4, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e4 : 0;
    }
    readMaxScale(e4, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e4 : 0;
    }
    set mosaicRule(e4) {
      let t6 = e4;
      t6 && t6.mosaicMethod && (t6 = j6.fromJSON({ ...t6.toJSON(), mosaicMethod: t6.mosaicMethod, mosaicOperation: t6.mosaicOperation })), this._set("mosaicRule", t6);
    }
    readMosaicRule(e4, t6) {
      const r3 = e4 || t6.mosaicRule;
      return r3 ? j6.fromJSON(r3) : this._isMosaicRuleSupported(t6) ? j6.fromJSON(t6) : null;
    }
    writeMosaicRule(e4, t6, r3) {
      let i6 = this.mosaicRule;
      const s10 = this.definitionExpression;
      i6 ? s10 && s10 !== i6.where && (i6 = i6.clone(), i6.where = s10) : s10 && (i6 = new j6({ where: s10 })), this._isValidCustomizedMosaicRule(i6) && (t6[r3] = i6.toJSON());
    }
    writeNoData(e4, t6, r3) {
      null != e4 && "number" == typeof e4 && (t6[r3] = De(e4));
    }
    readObjectIdField(e4, t6) {
      if (!e4) {
        const r3 = t6.fields.filter((e5) => "esriFieldTypeOID" === e5.type || "oid" === e5.type);
        e4 = r3 && r3[0] && r3[0].name;
      }
      return e4;
    }
    get parsedUrl() {
      return L(this.url);
    }
    readSourceType(e4, t6) {
      return this._isMosaicDataset(t6) ? "mosaic-dataset" : "raster-dataset";
    }
    set renderer(e4) {
      this.loaded && (e4 = this._configRenderer(e4)), this._set("renderer", e4);
    }
    readRenderer(e4, t6, r3) {
      var _a, _b;
      const i6 = (_b = (_a = t6 == null ? void 0 : t6.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, n9 = c4(i6, r3);
      return null == n9 ? null : ("vector-field" === n9.type && t6.symbolTileSize && !i6.symbolTileSize && (n9.symbolTileSize = t6.symbolTileSize), p6(n9) || s.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n9);
    }
    writeRenderer(e4, t6, r3) {
      t6.layerDefinition = t6.layerDefinition || {}, t6.layerDefinition.drawingInfo = t6.layerDefinition.drawingInfo || {}, t6.layerDefinition.drawingInfo.renderer = e4.toJSON(), "vector-field" === e4.type && (t6.symbolTileSize = e4.symbolTileSize);
    }
    get rasterFields() {
      var _a;
      const e4 = this._rasterAttributeTableFieldPrefix || "Raster.", t6 = new y2({ name: "Raster.ItemPixelValue", alias: "Item Pixel Value", domain: null, editable: false, length: 50, type: "string" }), r3 = new y2({ name: "Raster.ServicePixelValue", alias: "Service Pixel Value", domain: null, editable: false, length: 50, type: "string" }), i6 = new y2({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Service Pixel Value", domain: null, editable: false, length: 50, type: "string" });
      let s10 = this.fields ? a(this.fields) : [];
      s10.push(r3), ((_a = this.capabilities) == null ? void 0 : _a.operations.supportsQuery) && this.fields && this.fields.length > 0 && s10.push(t6), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some((e5) => "none" === e5.name.toLowerCase()) && s10.push(i6), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter((e5) => "none" !== e5.name.toLowerCase()).forEach((e5) => {
        s10.push(new y2({ name: "Raster.ServicePixelValue." + e5.name, alias: e5.name, domain: null, editable: false, length: 50, type: "string" }));
      }), this._isVectorDataSet() && (s10.push(new y2({ name: "Raster.Magnitude", alias: "Magnitude", domain: null, editable: false, type: "double" })), s10.push(new y2({ name: "Raster.Direction", alias: "Direction", domain: null, editable: false, type: "double" })));
      const { attributeTable: n9 } = this.rasterInfo ?? {};
      if (null != n9) {
        const t7 = n9.fields.filter((e5) => "esriFieldTypeOID" !== e5.type && "value" !== e5.name.toLowerCase()).map((t8) => {
          const r4 = a(t8);
          return r4.name = e4 + t8.name, r4;
        });
        s10 = s10.concat(t7);
      }
      return s10;
    }
    get renderingRule() {
      return t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._get("rasterFunction");
    }
    set renderingRule(e4) {
      t(s.getLogger(this), "renderingRule", { replacement: "rasterFunction", version: "4.27", warnOnce: true }), this._set("rasterFunction", e4);
    }
    set rasterFunction(e4) {
      let t6 = e4;
      t6 && t6.rasterFunction && (t6 = N.fromJSON({ ...t6.toJSON(), rasterFunction: t6.rasterFunction, rasterFunctionArguments: t6.rasterFunctionArguments })), this._set("rasterFunction", t6);
    }
    readRasterFunction(e4, t6) {
      const r3 = t6.rasterFunctionInfos;
      return t6.renderingRule || r3 && r3.length && "None" !== r3[0].name ? this._isRFTJson(t6.renderingRule) ? N.fromJSON({ rasterFunctionDefinition: t6.renderingRule }) : N.fromJSON(t6.renderingRule || { rasterFunctionInfos: t6.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e4, t6) {
      const r3 = e4 || t6.extent.spatialReference;
      return r3 ? f2.fromJSON(r3) : null;
    }
    readPixelType(e4) {
      return n5.fromJSON(e4) || e4;
    }
    writePixelType(e4, t6, r3) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t6[r3] = n5.toJSON(e4));
    }
    readVersion(e4, t6) {
      let r3 = t6.currentVersion;
      return r3 || (r3 = t6.hasOwnProperty("fields") || t6.hasOwnProperty("timeInfo") ? 10 : 9.3), r3;
    }
    applyFilter(e4) {
      let t6 = e4;
      return this.pixelFilter && (t6 = this._clonePixelData(e4), this.pixelFilter(t6)), t6;
    }
    async applyRenderer(e4, t6) {
      let r3 = e4;
      const { renderer: i6, symbolizer: s10, pixelFilter: n9, bandIds: o3 } = this;
      if (!this._isPicture() && i6 && s10 && !n9) {
        const n10 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(i6.toJSON()), a13 = this._rasterJobHandler.instance;
        if (a13) {
          n10 && (s10.bind(), await a13.updateSymbolizer(s10, t6), this._cachedRendererJson = i6.toJSON());
          const l11 = await a13.symbolize({ bandIds: o3, ...e4 }, t6);
          r3 = { extent: e4.extent, pixelBlock: l11 };
        } else
          r3 = { extent: e4.extent, pixelBlock: s10.symbolize({ bandIds: o3, ...e4 }) };
      }
      return r3;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async computeAngles(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeAngles)
        throw new s2("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return e4 = v(l8, e4).clone(), S3(this.url, e4, this._getRequestOptions(t6));
    }
    async computePixelSpaceLocations(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputePixelLocation)
        throw new s2("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return e4 = v(a12, e4).clone(), d5(this.url, e4, this._getRequestOptions(t6));
    }
    async computeHistograms(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeHistograms)
        throw new s2("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e4 = v(h2, e4).clone(), this._applyMosaicAndRenderingRules(e4), R2(this.url, e4, this._getRequestOptions(t6));
    }
    async computeStatisticsHistograms(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeStatisticsHistograms)
        throw new s2("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e4 = v(h2, e4).clone(), this._applyMosaicAndRenderingRules(e4), N3(this.url, e4, this._getRequestOptions(t6));
    }
    async measureHeight(e4, t6) {
      const r3 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!("base-and-top" === e4.operationType ? r3.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e4.operationType ? r3.mensuration.supportsHeightFromBaseAndTopShadow : r3.mensuration.supportsHeightFromTopAndTopShadow))
        throw new s2("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e4 = v(c12, e4).clone(), this._applyMosaicAndRenderingRules(e4), h4(this.url, e4, this._getRequestOptions(t6));
    }
    async measureAreaAndPerimeter(e4, t6) {
      const r3 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r3.mensuration.supportsAreaAndPerimeter && (!e4.is3D || r3.mensuration.supports3D)))
        throw new s2("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e4 = v(y6, e4).clone(), this._applyMosaicAndRenderingRules(e4), j7(this.url, e4, this._getRequestOptions(t6));
    }
    async measureDistanceAndAngle(e4, t6) {
      const r3 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r3.mensuration.supportsDistanceAndAngle && (!e4.is3D || r3.mensuration.supports3D)))
        throw new s2("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e4 = v(u6, e4).clone(), this._applyMosaicAndRenderingRules(e4), I2(this.url, e4, this._getRequestOptions(t6));
    }
    async measurePointOrCentroid(e4, t6) {
      const r3 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r3.mensuration.supportsPointOrCentroid && (!e4.is3D || r3.mensuration.supports3D)))
        throw new s2("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e4 = v(y10, e4).clone(), this._applyMosaicAndRenderingRules(e4), w3(this.url, e4, this._getRequestOptions(t6));
    }
    getField(e4) {
      const { fieldsIndex: t6 } = this;
      return null != t6 ? t6.get(e4) : void 0;
    }
    getFieldDomain(e4, t6) {
      const r3 = this.getField(e4);
      return r3 ? r3.domain : null;
    }
    async fetchImage(e4, t6, r3, i6 = {}) {
      if (null == e4 || null == t6 || null == r3)
        throw new s2("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      if (this.renderer || this.symbolizer) {
        const e5 = await this._generateRasterInfo(this.rasterFunction, { signal: i6.signal });
        e5 && (this.rasterInfo = e5);
      }
      const s10 = this.getExportImageServiceParameters(e4, t6, r3, i6.timeExtent);
      if (null == s10) {
        if (i6.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e5 = document.createElement("canvas");
          if (e5.width = t6, e5.height = r3, i6.returnImageBitmap) {
            return { imageBitmap: await t3(e5, `${je2(this.parsedUrl)}/exportImage`, i6.signal) };
          }
          return { imageOrCanvasElement: e5 };
        }
        const { bandIds: s11, rasterInfo: n10 } = this, o4 = ((s11 == null ? void 0 : s11.length) || n10.bandCount) ?? 0, a13 = t6 * r3, l12 = n10.pixelType, u8 = [];
        for (let e5 = 0; e5 < o4; e5++)
          u8.push(u2.createEmptyBand(l12, a13));
        return { pixelData: { pixelBlock: new u2({ width: t6, height: r3, pixels: u8, mask: new Uint8Array(a13), pixelType: l12 }), extent: e4 } };
      }
      const n9 = !!i6.requestAsImageElement && !this.pixelFilter, o3 = n9 && !!i6.returnImageBitmap, l11 = { imageServiceParameters: s10, imageProps: { extent: e4, width: t6, height: r3, format: this.format }, requestAsImageElement: n9, returnImageBitmap: o3, signal: i6.signal };
      return this._requestArrayBuffer(l11);
    }
    fetchKeyProperties(e4) {
      return j2(je2(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => e5.data);
    }
    fetchRasterAttributeTable(e4) {
      return this.version < 10.1 ? Promise.reject(new s2("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : j2(je2(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => d.fromJSON(e5.data));
    }
    getCatalogItemRasterInfo(e4, t6) {
      const r3 = { ...t6, query: this._getQueryParams() };
      return n7(je2(this.parsedUrl), e4, r3);
    }
    async getCatalogItemICSInfo(e4, t6) {
      var _a, _b, _c;
      const { data: r3 } = await j2(je2(this.parsedUrl) + "/" + e4 + "/info/ics", { query: this._getQueryParams(), ...t6 }), i6 = r3 && r3.ics;
      if (!i6)
        return;
      let s10 = null;
      try {
        s10 = (await j2(je2(this.parsedUrl) + "/" + e4 + "/info", { query: this._getQueryParams(), ...t6 })).data.extent;
      } catch {
      }
      if (!s10 || !s10.spatialReference)
        return { ics: i6, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const o3 = this.version >= 10.7 ? j2(je2(this.parsedUrl) + "/" + e4 + "/info/icstopixel", { query: this._getQueryParams(), ...t6 }).then((e5) => e5.data).catch(() => ({})) : {}, a13 = s10.spatialReference, l11 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [s10] }), inSR: a13.wkid || JSON.stringify(a13), outSR: "0:" + e4 }, u8 = j2(je2(this.parsedUrl) + "/project", { query: this._getQueryParams(l11), ...t6 }).then((e5) => e5.data).catch(() => ({})), p15 = 5, c15 = (s10.xmin + s10.xmax) / 2, m7 = (s10.ymax - s10.ymin) / (p15 + 1), d9 = s10.ymin + m7, h6 = [];
      for (let n9 = 0; n9 < p15; n9++)
        h6.push({ x: c15, y: d9 + m7 * n9 });
      const f7 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h6 }), inSR: a13.wkid || JSON.stringify(a13), outSR: "0:" + e4 }, y12 = j2(je2(this.parsedUrl) + "/project", { query: this._getQueryParams(f7), ...t6 }).then((e5) => e5.data).catch(() => ({})), g5 = await Promise.all([o3, u8, y12]);
      let R3 = g5[0].ipxf;
      if (null == R3) {
        const e5 = (_a = i6.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e5 == null ? void 0 : e5.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e5 == null ? void 0 : e5.coefficients) == null ? void 0 : _c.length) && (R3 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e5.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const b6 = M.fromJSON(g5[1] && g5[1].geometries && g5[1].geometries[0]);
      b6 && (b6.spatialReference = new f2({ wkid: 0, imageCoordinateSystem: i6 }));
      const v5 = g5[2].geometries ? g5[2].geometries.filter((e5) => null != e5 && null != e5.x && null != e5.y && "NaN" !== e5.x && "NaN" !== e5.y) : [], S4 = v5.length;
      if (S4 < 3)
        return { ics: i6, icsToPixelTransform: R3, icsExtent: b6, northDirection: null };
      let x3 = 0, I4 = 0, w4 = 0, _ = 0;
      for (let n9 = 0; n9 < S4; n9++)
        x3 += v5[n9].x, I4 += v5[n9].y, w4 += v5[n9].x * v5[n9].x, _ += v5[n9].x * v5[n9].y;
      const F2 = (S4 * _ - x3 * I4) / (S4 * w4 - x3 * x3);
      let D = 0;
      const P2 = v5[p15 - 1].x > v5[0].x, j9 = v5[p15 - 1].y > v5[0].y;
      return F2 === 1 / 0 ? D = j9 ? 90 : 270 : 0 === F2 ? D = P2 ? 0 : 180 : F2 > 0 ? D = P2 ? 180 * Math.atan(F2) / Math.PI : 180 * Math.atan(F2) / Math.PI + 180 : F2 < 0 && (D = j9 ? 180 + 180 * Math.atan(F2) / Math.PI : 360 + 180 * Math.atan(F2) / Math.PI), { ics: i6, icsToPixelTransform: R3, icsExtent: b6, northDirection: D };
    }
    async generateRasterInfo(e4, t6) {
      var _a;
      if (e4 = v(N, e4), this.serviceRasterInfo && (!e4 || "none" === ((_a = e4.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e4)))
        return this.serviceRasterInfo;
      const r3 = Pe(e4);
      if (!r3)
        throw new s2("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[r3])
        return this._functionRasterInfos[r3];
      const i6 = { ...t6, query: this._getQueryParams() }, s10 = f5(je2(this.parsedUrl), e4, i6);
      this._functionRasterInfos[r3] = s10;
      try {
        return await s10;
      } catch (n9) {
        throw this._functionRasterInfos[r3] = null, n9;
      }
    }
    getExportImageServiceParameters(e4, t6, r3, i6) {
      var _a;
      e4 = e4.clone().shiftCentralMeridian();
      const s10 = G2(e4.spatialReference, je2(this.parsedUrl));
      this.pixelType !== this.serviceRasterInfo.pixelType && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n9 = this.exportImageServiceParameters.toJSON(), { bandIds: o3, noData: a13 } = n9;
      let { renderingRule: l11 } = n9;
      const u8 = (_a = this.rasterFunction) == null ? void 0 : _a.rasterFunctionDefinition, p15 = !this.renderer || "raster-stretch" === this.renderer.type;
      if ((o3 == null ? void 0 : o3.length) && this._hasRasterFunction(this.rasterFunction) && !u8 && p15) {
        const e5 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: o3 } };
        if ("Stretch" === l11.rasterFunction)
          e5.rasterFunctionArguments.Raster = l11.rasterFunctionArguments.Raster, l11.rasterFunctionArguments.Raster = e5;
        else if ("Colormap" === l11.rasterFunction) {
          const t7 = l11.rasterFunctionArguments.Raster;
          "Stretch" === (t7 == null ? void 0 : t7.rasterFunction) ? (e5.rasterFunctionArguments.Raster = t7.rasterFunctionArguments.Raster, t7.rasterFunctionArguments.Raster = e5) : (e5.rasterFunctionArguments.Raster = t7, l11.rasterFunctionArguments.Raster = e5);
        } else
          e5.rasterFunctionArguments.Raster = l11, l11 = e5;
        n9.bandIds = void 0;
      } else
        n9.bandIds = o3 == null ? void 0 : o3.join(",");
      a13 instanceof Array && a13.length > 0 && (n9.noData = a13.join(","));
      const c15 = this._processMultidimensionalIntersection(null, i6, this.exportImageServiceParameters.mosaicRule);
      if (c15.isOutSide)
        return null;
      n9.mosaicRule = null != c15.mosaicRule ? JSON.stringify(c15.mosaicRule) : null, i6 = c15.timeExtent, n9.renderingRule = this._getRenderingRuleString(N.fromJSON(l11));
      const m7 = {};
      if (null != i6) {
        const { start: e5, end: t7 } = i6.toJSON();
        e5 && t7 && e5 === t7 ? m7.time = "" + e5 : null == e5 && null == t7 || (m7.time = `${e5 ?? "null"},${t7 ?? "null"}`);
      }
      return { bbox: e4.xmin + "," + e4.ymin + "," + e4.xmax + "," + e4.ymax, bboxSR: s10, imageSR: s10, size: t6 + "," + r3, ...n9, ...m7 };
    }
    async getSamples(e4, t6) {
      const r3 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(r3 == null ? void 0 : r3.operations.supportsGetSamples))
        throw new s2("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e4 = v(h5, e4).clone();
      const { raster: i6 } = this;
      return i6 && null == e4.raster && (e4.raster = i6), J(this.url, e4, this._getRequestOptions(t6));
    }
    async identify(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsIdentify)
        throw new s2("imagery-layer:identify", "identify operation is not supported on the input image service");
      e4 = v(d6, e4).clone();
      const r3 = this._processMultidimensionalIntersection(e4.geometry, e4.timeExtent, e4.mosaicRule || this.mosaicRule);
      if (r3.isOutSide)
        throw new s2("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e4.timeExtent = r3.timeExtent, e4.mosaicRule = r3.mosaicRule;
      const { raster: i6, rasterFunction: s10 } = this;
      return s10 && null == e4.rasterFunction && (e4.rasterFunction = s10), i6 && null == e4.raster && (e4.raster = i6), O2(this.url, e4, this._getRequestOptions(t6));
    }
    createQuery() {
      const e4 = new b2();
      return e4.outFields = ["*"], e4.returnGeometry = true, e4.where = this.definitionExpression || "1=1", e4;
    }
    async queryRasters(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s6(this.url, e4, t6);
    }
    async queryObjectIds(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s5(this.url, e4, t6);
    }
    async queryRasterCount(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), n2(this.url, e4, t6);
    }
    async queryVisibleRasters(e4, t6) {
      var _a, _b, _c, _d;
      if (!e4)
        throw new s2("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: r3, returnDomainValues: i6, returnTopmostRaster: s10, showNoDataRecords: n9 } = t6 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let o3 = false, l11 = null, u8 = null;
      const p15 = "raster.servicepixelvalue", c15 = this._rasterFunctionNamesIndex;
      if (null != e4.outFields && (o3 = e4.outFields.some((e5) => !e5.toLowerCase().includes(p15)), this.version >= 10.4)) {
        const t7 = e4.outFields.filter((e5) => e5.toLowerCase().includes(p15) && e5.length > p15.length).map((e5) => {
          const t8 = e5.slice(p15.length + 1);
          return [this._updateRenderingRulesFunctionName(t8, c15), t8];
        });
        l11 = t7.map((e5) => new N({ functionName: e5[0] })), u8 = t7.map((e5) => e5[1]);
        const { rasterFunction: r4 } = this;
        0 === l11.length ? (r4 == null ? void 0 : r4.functionName) ? (l11.push(r4), u8.push(r4.functionName)) : l11 = null : (r4 == null ? void 0 : r4.functionName) && !l11.some((e5) => e5.functionName === r4.functionName) && (l11.push(r4), u8.push(r4.functionName));
      }
      const m7 = null == e4.outSpatialReference || e4.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: d9 } = this;
      let h6 = e4.timeExtent || this.timeExtent;
      if (d9) {
        const { isOutside: t7, intersection: r4 } = m2(d9, { geometry: e4.geometry, timeExtent: e4.timeExtent, multidimensionalDefinition: (_a = this.exportImageServiceParameters.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition });
        if (t7)
          throw new s2("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        r4 && null != r4.timeExtent && (h6 = r4.timeExtent);
      }
      const f7 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, h6), y12 = this._getQueryParams({ geometry: e4.geometry, timeExtent: h6, mosaicRule: f7, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l11, pixelSize: r3, returnCatalogItems: o3, returnGeometry: m7, raster: this.raster, maxItemCount: s10 ? 1 : null });
      delete y12.f;
      const g5 = new d6(y12);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const r4 = await O2(this.url, g5, { signal: t6 == null ? void 0 : t6.signal, query: { ...this.customParameters } }), s11 = e4.outFields, a13 = null != r4.value && r4.value.toLowerCase().includes("nodata");
        if (!(o3 && !m7 && ((_b = r4 == null ? void 0 : r4.catalogItems) == null ? void 0 : _b.features.length) && (n9 || !a13)))
          return this._processVisibleRastersResponse(r4, { returnDomainValues: i6, templateRRFunctionNames: u8, showNoDataRecords: n9, templateFields: s11 });
        const l12 = this.objectIdField || "ObjectId", p16 = ((_c = r4.catalogItems) == null ? void 0 : _c.features) ?? [], c16 = p16.map((e5) => {
          var _a2;
          return (_a2 = e5.attributes) == null ? void 0 : _a2[l12];
        }), d10 = new b2({ objectIds: c16, returnGeometry: true, outSpatialReference: e4.outSpatialReference, outFields: [l12] }), h7 = await this.queryRasters(d10);
        return ((_d = h7 == null ? void 0 : h7.features) == null ? void 0 : _d.length) && h7.features.forEach((t7) => {
          p16.forEach((r5) => {
            r5.attributes[l12] === t7.attributes[l12] && (r5.geometry = new j3(t7.geometry), null != e4.outSpatialReference && (r5.geometry.spatialReference = e4.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(r4, { returnDomainValues: i6, templateRRFunctionNames: u8, showNoDataRecords: n9, templateFields: s11 });
      } catch {
        throw new s2("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e4, t6) {
      const r3 = j2(je2(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e4 }), signal: t6 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.statistics;
      }), i6 = j2(je2(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e4 }), signal: t6 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.histograms;
      }), s10 = await Promise.all([r3, i6]);
      return s10[0] && s10[0].forEach((e5) => {
        e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
      }), { statistics: s10[0] || null, histograms: s10[1] || null };
    }
    async createFlowMesh(e4, t6) {
      const r3 = this._rasterJobHandler.instance;
      return r3 ? r3.createFlowMesh(e4, t6) : s9(e4.meshType, e4.simulationSettings, e4.flowData, null != t6.signal ? t6.signal : new AbortController().signal);
    }
    getMultidimensionalSubsetVariables(e4) {
      const t6 = e4 ?? this.serviceRasterInfo.multidimensionalInfo;
      return g(this.multidimensionalSubset, t6);
    }
    async _fetchService(e4) {
      await this._fetchServiceInfo(e4), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t6 = this.sourceJSON, r3 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : m3(je2(this.parsedUrl), t6, { signal: e4, query: this._getQueryParams() }).then((e5) => (this._set("serviceRasterInfo", e5), this._set("multidimensionalInfo", e5.multidimensionalInfo), e5)), i6 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e4 }) : null, s10 = this._getRasterFunctionInfos();
      return Promise.all([r3, i6, s10]).then((e5) => {
        e5[1] ? this._set("rasterInfo", e5[1]) : this._set("rasterInfo", e5[0]), e5[2] && this._set("rasterFunctionInfos", e5[2]), this.renderer && !this._isSupportedRenderer(this.renderer) && (this._set("renderer", null), s.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("renderer", this._configRenderer(this.renderer)), this.addHandles([l2(() => this.rasterFunction, (e6) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e6).then((e7) => {
            e7 && (this.rasterInfo = e7);
          });
        })]);
        const { serviceRasterInfo: t7 } = this;
        null != t7.multidimensionalInfo && this._updateMultidimensionalDefinition(t7);
      });
    }
    _combineMosaicRuleWithTimeExtent(e4, t6) {
      var _a;
      const r3 = this.timeInfo, { multidimensionalInfo: i6 } = this.serviceRasterInfo;
      if (null == e4 || null == i6 || null == t6 || null == (r3 == null ? void 0 : r3.startField))
        return e4;
      const { startField: s10 } = r3, n9 = i6.variables.some((e5) => e5.dimensions.some((e6) => e6.name === s10)) ? s10 : "StdTime";
      if (e4 = e4.clone(), "mosaic-dataset" === this.sourceType)
        return e4.multidimensionalDefinition = (_a = e4.multidimensionalDefinition) == null ? void 0 : _a.filter((e5) => e5.dimensionName !== n9), this._cleanupMultidimensionalDefinition(e4);
      e4.multidimensionalDefinition = e4.multidimensionalDefinition || [];
      const o3 = e4.multidimensionalDefinition.filter((e5) => e5.dimensionName === n9), a13 = null != t6.start ? t6.start.getTime() : null, l11 = null != t6.end ? t6.end.getTime() : null, u8 = null == a13 || null == l11 || a13 === l11, p15 = u8 ? [a13 || l11] : [[a13, l11]], c15 = this.version >= 10.8;
      if (o3.length)
        o3.forEach((e5) => {
          e5.dimensionName === n9 && (c15 ? (e5.dimensionName = null, e5.isSlice = false, e5.values = []) : (e5.isSlice = u8, e5.values = p15));
        });
      else if (!c15) {
        const t7 = e4.multidimensionalDefinition.filter((e5) => null != e5.variableName && null == e5.dimensionName);
        t7.length ? t7.forEach((e5) => {
          e5.dimensionName = n9, e5.isSlice = u8, e5.values = p15;
        }) : e4.multidimensionalDefinition.push(new p5({ variableName: "", dimensionName: n9, isSlice: u8, values: p15 }));
      }
      return this._cleanupMultidimensionalDefinition(e4);
    }
    _cleanupMultidimensionalDefinition(e4) {
      return null == e4 ? null : (e4.multidimensionalDefinition && (e4.multidimensionalDefinition = e4.multidimensionalDefinition.filter((e5) => !(!e5.variableName && !e5.dimensionName)), 0 === e4.multidimensionalDefinition.length && (e4.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e4.multidimensionalDefinition ? null : e4);
    }
    async _prepareForQuery(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsQuery)
        throw new s2("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e4 = null != e4 ? v(b2, e4) : this.createQuery(), t6 = this._getRequestOptions(t6), this.raster && (t6.query = { ...t6.query, raster: this.raster }), { query: e4, requestOptions: t6 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise)
        return this._rasterJobHandler.connectionPromise;
      const e4 = new t4();
      this._rasterJobHandler.connectionPromise = e4.initialize().then(() => {
        this._rasterJobHandler.instance = e4;
      }, () => {
      }), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e4) {
      const { rasterInfo: t6, rasterFunction: r3 } = this;
      return "unique-value" === e4.type && this._hasRasterFunction(r3) && 1 === (t6 == null ? void 0 : t6.bandCount) && ["u8", "s8"].includes(t6.pixelType) || null != t6 && null != e4 && S(t6).includes(e4.type);
    }
    async _fetchCapabilities(e4) {
      return this.capabilities || await this._fetchServiceInfo(e4), this.capabilities;
    }
    async _fetchServiceInfo(e4) {
      var _a;
      let t6 = this.sourceJSON;
      if (!t6) {
        const { data: r3, ssl: i6 } = await j2(je2(this.parsedUrl), { query: this._getQueryParams(), signal: e4 });
        t6 = r3, this.sourceJSON = t6, i6 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t6.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e5) => e5.trim()).indexOf("tilesonly")) > -1)
        throw new s2("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t6, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e4) {
      var _a;
      return e4.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e4.serviceSourceType : ((_a = e4.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e4) {
      var _a;
      if (!e4)
        return false;
      const t6 = this._isMosaicDataset(e4), r3 = e4.currentVersion >= 10.71 && e4.hasMultidimensions && !(((_a = e4.fields) == null ? void 0 : _a.length) > 1);
      return t6 || r3;
    }
    _isVectorFieldResampleFunction(e4) {
      if (null == e4)
        return false;
      const { functionName: t6, functionArguments: r3 } = e4, i6 = "resample" === (t6 == null ? void 0 : t6.toLowerCase()), s10 = (r3 == null ? void 0 : r3.ResampleType) || (r3 == null ? void 0 : r3.resampleType);
      return i6 && (7 === s10 || 10 === s10);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e4) {
      var _a, _b;
      const t6 = this._isPicture(), { rasterInfo: r3 } = this;
      if (!t6 && !this.pixelFilter || this._isVectorDataSet()) {
        if (!this.bandIds && r3.bandCount >= 3) {
          const e5 = q(r3);
          !e5 || 3 === r3.bandCount && 0 === e5[0] && 1 === e5[1] && 2 === e5[2] || (this.bandIds = e5);
        }
        e4 || (e4 = k2(r3, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName }));
        const t7 = Q(e4.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = t7, this.symbolizer.rasterInfo = r3) : this.symbolizer = new L2({ rendererJSON: t7, rasterInfo: r3 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e4;
    }
    _clonePixelData(e4) {
      return null == e4 ? e4 : { extent: e4.extent && e4.extent.clone(), pixelBlock: null != e4.pixelBlock ? e4.pixelBlock.clone() : null };
    }
    _getQueryParams(e4) {
      e4 && null != e4.renderingRule && "string" != typeof e4.renderingRule && (e4.renderingRule = this._getRenderingRuleString(e4.renderingRule));
      const { raster: t6, viewId: r3 } = this;
      return { raster: t6, viewId: r3, f: "json", ...e4, ...this.customParameters };
    }
    _getRequestOptions(e4) {
      return { ...e4, query: { ...e4 == null ? void 0 : e4.query, ...this.customParameters } };
    }
    _decodePixelBlock(e4, t6, r3) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e4, options: t6 }) : j5(e4, t6, r3);
    }
    async _getRasterFunctionInfos(e4) {
      var _a;
      const t6 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded)
        return t6;
      if (t6 && this.version >= 10.3) {
        if (1 === t6.length && "none" === t6[0].name.toLowerCase())
          return t6;
        const r3 = await j2(je2(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e4 });
        return (_a = r3.data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e4) {
      return !this.pixelFilter && (!e4 || e4.includes("png"));
    }
    async _requestArrayBuffer(e4) {
      const { imageProps: t6, requestAsImageElement: r3, returnImageBitmap: i6, signal: s10 } = e4;
      if (r3 && this._canRequestImageElement(t6.format)) {
        const r4 = `${je2(this.parsedUrl)}/exportImage`, { data: o4 } = await j2(r4, { responseType: i6 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e4.imageServiceParameters }), signal: s10 });
        if (o4 instanceof Blob) {
          return { imageBitmap: await t3(o4, r4, s10), params: t6 };
        }
        return { imageOrCanvasElement: o4, params: t6 };
      }
      const o3 = this._initJobHandler(), l11 = j2(je2(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e4.imageServiceParameters }), signal: s10 }), u8 = (await Promise.all([l11, o3]))[0].data, p15 = t6.format || "jpgpng";
      let c15 = p15;
      if ("bsq" !== c15 && "bip" !== c15 && (c15 = P(u8)), !c15)
        throw new s2("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u8)));
      const m7 = { signal: s10 }, d9 = "gif" === p15 || "bmp" === p15 || p15.includes("png") && ("png" === c15 || "jpg" === c15) ? j5(u8, { useCanvas: true, ...t6 }, m7) : this._decodePixelBlock(u8, { width: t6.width, height: t6.height, planes: null, pixelType: null, noDataValue: null, format: p15 }, m7);
      return { pixelData: { pixelBlock: await d9, extent: t6.extent }, params: t6 };
    }
    _generateRasterInfo(e4, t6) {
      return this.generateRasterInfo(e4, t6).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e4) {
      var _a;
      return e4 && JSON.stringify(e4.toJSON()) !== JSON.stringify((_a = this.defaultMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e4) {
      var _a;
      if (this._isValidCustomizedMosaicRule(this.mosaicRule))
        return;
      let t6 = d3(e4, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t6 && t6.length > 0) {
        this.mosaicRule = this.mosaicRule || new j6();
        const e5 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== ((_a = this.rasterFunction.functionName) == null ? void 0 : _a.toLowerCase()) && t6.forEach((e6) => e6.variableName = ""), t6 = t6.filter(({ variableName: e6, dimensionName: t7 }) => e6 && "*" !== e6 || t7), !(e5 == null ? void 0 : e5.length) && t6.length && (this.mosaicRule.multidimensionalDefinition = t6);
      }
    }
    _processVisibleRastersResponse(e4, r3) {
      r3 = r3 || {};
      const i6 = e4.value, { templateRRFunctionNames: s10, showNoDataRecords: n9, returnDomainValues: o3, templateFields: a13 } = r3, l11 = e4.processedValues;
      let u8 = e4.catalogItems && e4.catalogItems.features, p15 = e4.properties && e4.properties.Values && e4.properties.Values.map((e5) => e5.replaceAll(/ /gi, ", ")) || [];
      const c15 = this.objectIdField || "ObjectId", m7 = "string" == typeof i6 && i6.toLowerCase().includes("nodata"), d9 = [];
      if (i6 && !u8 && !m7) {
        const e5 = {};
        e5[c15] = 0;
        p15 = [i6], u8 = [new h(this.fullExtent, null, e5)];
      }
      if (!u8)
        return [];
      let h6, f7, y12;
      this._updateResponseFieldNames(u8, a13), m7 && !n9 && (u8 = []);
      for (let t6 = 0; t6 < u8.length; t6++) {
        if (h6 = u8[t6], null != i6) {
          if (f7 = p15[t6], y12 = this.rasterFunction && l11 && l11.length > 0 && s10 && s10.length > 0 && s10.includes(this.rasterFunction.functionName) ? l11[s10.indexOf(this.rasterFunction.functionName)] : i6, "nodata" === f7.toLowerCase() && !n9)
            continue;
          const e5 = "Raster.ItemPixelValue", r4 = "Raster.ServicePixelValue";
          h6.attributes[e5] = f7, h6.attributes[r4] = y12, this._updateFeatureWithMagDirValues(h6, f7);
          const o4 = this.fields && this.fields.length > 0;
          let a14 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? o4 ? f7 : i6 : y12;
          this.rasterFunction || (a14 = o4 ? f7 : i6), this._updateFeatureWithRasterAttributeTableValues(h6, a14);
        }
        if (h6.sourceLayer = h6.layer = this, o3 && this._updateFeatureWithDomainValues(h6), s10 && l11 && s10.length === l11.length)
          for (let e5 = 0; e5 < s10.length; e5++) {
            const t7 = "Raster.ServicePixelValue." + s10[e5];
            h6.attributes[t7] = l11[e5];
          }
        d9.push(u8[t6]);
      }
      return d9;
    }
    _processMultidimensionalIntersection(e4, t6, r3) {
      const { multidimensionalSubset: i6 } = this;
      if (!i6)
        return { isOutSide: false, timeExtent: t6, mosaicRule: r3 = this._combineMosaicRuleWithTimeExtent(r3, t6) };
      if (i6) {
        const { isOutside: r4, intersection: s10 } = m2(i6, { geometry: e4, timeExtent: t6 });
        if (r4)
          return { isOutSide: true, timeExtent: null, mosaicRule: null };
        s10 && null != s10.timeExtent && (t6 = s10.timeExtent);
      }
      if (null != (r3 = this._combineMosaicRuleWithTimeExtent(r3, t6)) && r3.multidimensionalDefinition) {
        const { isOutside: e5 } = m2(i6, { multidimensionalDefinition: r3.multidimensionalDefinition });
        if (e5)
          return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t6, mosaicRule: r3 };
    }
    _updateFeatureWithRasterAttributeTableValues(e4, t6) {
      const r3 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == r3)
        return;
      const { features: i6, fields: s10 } = r3, n9 = s10.map((e5) => e5.name).filter((e5) => "value" === e5.toLowerCase()), o3 = n9 && n9[0];
      if (!o3)
        return;
      const a13 = i6.filter((e5) => e5.attributes[o3] === (null != t6 ? parseInt(t6, 10) : null));
      a13 && a13[0] && s10.forEach((t7) => {
        const r4 = this._rasterAttributeTableFieldPrefix + t7.name;
        e4.attributes[r4] = a13[0].attributes[t7.name];
      });
    }
    _updateFeatureWithMagDirValues(e4, t6) {
      if (!this._isVectorDataSet())
        return;
      const r3 = t6.split(/,\s*/).map((e5) => parseFloat(e5)), i6 = r3.map((e5) => [e5]), s10 = r3.map((e5) => ({ minValue: e5, maxValue: e5, noDataValue: null })), n9 = new u2({ height: 1, width: 1, pixelType: "f32", pixels: i6, statistics: s10 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n9, extent: new M(0, 0, 0, 0, this.spatialReference) });
      const o3 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n9.pixels[0][0], n9.pixels[1][0]] : l4([n9.pixels[0][0], n9.pixels[1][0]]);
      e4.attributes["Raster.Magnitude"] = o3[0], e4.attributes["Raster.Direction"] = o3[1];
    }
    _updateFeatureWithDomainValues(e4) {
      const t6 = this.fields && this.fields.filter((e5) => e5.domain && "coded-value" === e5.domain.type);
      null != t6 && t6.forEach((t7) => {
        const r3 = e4.attributes[t7.name];
        if (null != r3) {
          const i6 = t7.domain.codedValues.find((e5) => e5.code === r3);
          i6 && (e4.attributes[t7.name] = i6.name);
        }
      });
    }
    _updateResponseFieldNames(e4, t6) {
      if (!t6 || t6.length < 1)
        return;
      const r3 = this.fieldsIndex;
      null != r3 && e4.forEach((e5) => {
        var _a;
        if (e5 && e5.attributes)
          for (const i6 of t6) {
            const t7 = (_a = r3.get(i6)) == null ? void 0 : _a.name;
            t7 && t7 !== i6 && (e5.attributes[i6] = e5.attributes[t7], delete e5.attributes[t7]);
          }
      });
    }
    _getRenderingRuleString(e4) {
      if (e4) {
        let t6 = e4.toJSON();
        return t6 = t6.rasterFunctionDefinition ?? t6, (t6.thumbnail || t6.thumbnailEx) && (t6.thumbnail = t6.thumbnailEx = null), JSON.stringify(t6);
      }
      return null;
    }
    _hasRasterFunction(e4) {
      return null != e4 && null != e4.functionName && "none" !== e4.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e4, t6) {
      if (!e4 || e4.length < 1)
        return;
      if ("Raw" === e4)
        return e4.replace("Raw", "None");
      const r3 = e4.toLowerCase().replaceAll(/ /gi, "_");
      return t6.has(r3) ? t6.get(r3) : e4;
    }
    _isRFTJson(e4) {
      return e4 && e4.name && e4.arguments && e4.function && e4.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e4) {
      const { raster: t6, mosaicRule: r3, rasterFunction: i6 } = this;
      i6 && e4 instanceof h2 && null == e4.rasterFunction && (e4.rasterFunction = i6), r3 && null == e4.mosaicRule && (e4.mosaicRule = r3), t6 && null == e4.raster && (e4.raster = t6);
    }
    _readCapabilities(e4) {
      const t6 = e4.capabilities ? e4.capabilities.toLowerCase().split(",").map((e5) => e5.trim()) : ["image", "catalog"], { currentVersion: r3, advancedQueryCapabilities: i6, maxRecordCount: s10 } = e4, n9 = t6.includes("image"), o3 = "esriImageServiceDataTypeElevation" === e4.serviceDataType, a13 = !!(e4.spatialReference || e4.extent && e4.extent.spatialReference), l11 = t6.includes("edit"), u8 = t6.includes("mensuration") && a13, p15 = null == e4.mensurationCapabilities ? [] : e4.mensurationCapabilities.toLowerCase().split(",").map((e5) => e5.trim()), c15 = u8 && p15.includes("basic");
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n9, supportsExportImage: n9, supportsIdentify: n9, supportsMeasure: u8, supportsDownload: t6.includes("download"), supportsQuery: t6.includes("catalog") && e4.fields && e4.fields.length > 0, supportsGetSamples: r3 >= 10.2 && n9, supportsProject: r3 >= 10.3 && n9, supportsComputeStatisticsHistograms: r3 >= 10.4 && n9, supportsQueryBoundary: r3 >= 10.6 && n9, supportsCalculateVolume: r3 >= 10.7 && o3, supportsComputePixelLocation: r3 >= 10.7 && t6.includes("catalog"), supportsComputeAngles: r3 >= 10.91, supportsAdd: l11, supportsDelete: l11, supportsEditing: l11, supportsUpdate: l11, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: s10, maxRecordCountFactor: void 0, supportsStatistics: !!(i6 == null ? void 0 : i6.supportsStatistics), supportsOrderBy: !!(i6 == null ? void 0 : i6.supportsOrderBy), supportsDistinct: !!(i6 == null ? void 0 : i6.supportsDistinct), supportsPagination: !!(i6 == null ? void 0 : i6.supportsPagination), supportsStandardizedQueriesOnly: !!(i6 == null ? void 0 : i6.useStandardizedQueries), supportsPercentileStatistics: !!(i6 == null ? void 0 : i6.supportsPercentileStatistics), supportsCentroid: !!(i6 == null ? void 0 : i6.supportsReturningGeometryCentroid), supportsDistance: !!(i6 == null ? void 0 : i6.supportsQueryWithDistance), supportsExtent: !!(i6 == null ? void 0 : i6.supportsReturningQueryExtent), supportsGeometryProperties: !!(i6 == null ? void 0 : i6.supportsReturningGeometryProperties), supportsHavingClause: !!(i6 == null ? void 0 : i6.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(i6 == null ? void 0 : i6.supportsDefaultSR), supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0 }, mensuration: { supportsDistanceAndAngle: c15, supportsAreaAndPerimeter: c15, supportsPointOrCentroid: c15, supportsHeightFromBaseAndTop: u8 && p15.includes("base-top height"), supportsHeightFromBaseAndTopShadow: u8 && p15.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: u8 && p15.includes("top-top shadow height"), supports3D: u8 && p15.includes("3d") } };
    }
  };
  function je2(e4) {
    return (e4 == null ? void 0 : e4.path) ?? "";
  }
  return e([y()], y11.prototype, "_functionRasterInfos", void 0), e([y()], y11.prototype, "_rasterJobHandler", void 0), e([y()], y11.prototype, "_cachedRendererJson", void 0), e([y({ readOnly: true })], y11.prototype, "_serviceSupportsMosaicRule", void 0), e([o("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], y11.prototype, "readServiceSupportsMosaicRule", null), e([y()], y11.prototype, "_rasterAttributeTableFieldPrefix", void 0), e([y({ readOnly: true })], y11.prototype, "_rasterFunctionNamesIndex", null), e([y()], y11.prototype, "adjustAspectRatio", void 0), e([y({ type: [T], json: { write: true } })], y11.prototype, "bandIds", void 0), e([o("bandIds")], y11.prototype, "readBandIds", null), e([y({ readOnly: true, json: { read: false } })], y11.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], y11.prototype, "readCapabilities", null), e([y({ type: Number })], y11.prototype, "compressionQuality", void 0), e([r("compressionQuality")], y11.prototype, "writeCompressionQuality", null), e([y({ type: Number })], y11.prototype, "compressionTolerance", void 0), e([r("compressionTolerance")], y11.prototype, "writeCompressionTolerance", null), e([y({ json: { read: { source: "copyrightText" } } })], y11.prototype, "copyright", void 0), e([y({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], y11.prototype, "defaultMosaicRule", void 0), e([o("defaultMosaicRule", ["defaultMosaicMethod"])], y11.prototype, "readDefaultMosaicRule", null), e([y({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], y11.prototype, "definitionExpression", void 0), e([y({ readOnly: true, constructOnly: true })], y11.prototype, "exportImageServiceParameters", void 0), e([y()], y11.prototype, "rasterInfo", void 0), e([y({ readOnly: true, type: [y2] })], y11.prototype, "fields", void 0), e([y({ readOnly: true })], y11.prototype, "fieldsIndex", null), e([y({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"], json: { write: true } })], y11.prototype, "format", null), e([o("service", "format", ["serviceDataType"])], y11.prototype, "readFormat", null), e([y({ type: M })], y11.prototype, "fullExtent", void 0), e([y({ readOnly: true })], y11.prototype, "hasMultidimensions", void 0), e([y({ json: { read: { source: "maxImageHeight" } } })], y11.prototype, "imageMaxHeight", void 0), e([y({ json: { read: { source: "maxImageWidth" } } })], y11.prototype, "imageMaxWidth", void 0), e([y({ type: String, json: { type: a6.jsonValues, read: a6.read, write: a6.write } })], y11.prototype, "interpolation", void 0), e([y()], y11.prototype, "minScale", void 0), e([o("service", "minScale")], y11.prototype, "readMinScale", null), e([y()], y11.prototype, "maxScale", void 0), e([o("service", "maxScale")], y11.prototype, "readMaxScale", null), e([y({ type: j6 })], y11.prototype, "mosaicRule", null), e([o("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], y11.prototype, "readMosaicRule", null), e([r("mosaicRule")], y11.prototype, "writeMosaicRule", null), e([y()], y11.prototype, "multidimensionalInfo", void 0), e([y({ type: c5, json: { write: true } })], y11.prototype, "multidimensionalSubset", void 0), e([y({ json: { type: T } })], y11.prototype, "noData", void 0), e([r("noData")], y11.prototype, "writeNoData", null), e([y({ type: String, json: { type: i2.jsonValues, read: i2.read, write: i2.write } })], y11.prototype, "noDataInterpretation", void 0), e([y({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], y11.prototype, "objectIdField", void 0), e([o("objectIdField")], y11.prototype, "readObjectIdField", null), e([y({})], y11.prototype, "geometryType", void 0), e([y({})], y11.prototype, "typeIdField", void 0), e([y({})], y11.prototype, "types", void 0), e([y({ readOnly: true })], y11.prototype, "parsedUrl", null), e([y({ type: Function })], y11.prototype, "pixelFilter", void 0), e([y()], y11.prototype, "raster", void 0), e([y({ readOnly: true })], y11.prototype, "sourceType", void 0), e([o("sourceType", ["serviceSourceType", "fields"])], y11.prototype, "readSourceType", null), e([y()], y11.prototype, "viewId", void 0), e([y({ types: l5, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: d2, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], y11.prototype, "renderer", null), e([o("renderer")], y11.prototype, "readRenderer", null), e([r("renderer")], y11.prototype, "writeRenderer", null), e([y()], y11.prototype, "symbolizer", void 0), e([y(u3)], y11.prototype, "opacity", void 0), e([y({ readOnly: true })], y11.prototype, "rasterFields", null), e([y({ constructOnly: true })], y11.prototype, "rasterFunctionInfos", void 0), e([y({ type: N })], y11.prototype, "renderingRule", null), e([y({ type: N, json: { name: "renderingRule" } })], y11.prototype, "rasterFunction", null), e([o("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], y11.prototype, "readRasterFunction", null), e([y()], y11.prototype, "serviceDataType", void 0), e([y({ readOnly: true, type: f2 })], y11.prototype, "spatialReference", void 0), e([o("spatialReference", ["spatialReference", "extent"])], y11.prototype, "readSpatialReference", null), e([y({ json: { type: n5.jsonValues } })], y11.prototype, "pixelType", void 0), e([o("pixelType")], y11.prototype, "readPixelType", null), e([r("pixelType")], y11.prototype, "writePixelType", null), e([y({ constructOnly: true, type: m })], y11.prototype, "serviceRasterInfo", void 0), e([y()], y11.prototype, "sourceJSON", void 0), e([y(f4)], y11.prototype, "url", void 0), e([y({ readOnly: true })], y11.prototype, "version", void 0), e([o("version", ["currentVersion", "fields", "timeInfo"])], y11.prototype, "readVersion", null), y11 = e([a3("esri.layers.mixins.ArcGISImageService")], y11), y11;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var I3 = class extends a4(a5(t2(c3(j4(je(p2(o2(l3(O(b4)))))))))) {
  constructor(...e4) {
    super(...e4), this.legendEnabled = true, this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery";
  }
  normalizeCtorArgs(e4, r3) {
    return "string" == typeof e4 ? { url: e4, ...r3 } : e4;
  }
  load(e4) {
    const r3 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(f).then(() => this._fetchService(r3))), Promise.resolve(this);
  }
  writeOperationalLayerType(e4, r3, t6) {
    var _a;
    const o3 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r3[t6] = o3 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  createPopupTemplate(e4) {
    const r3 = this.rasterFields, t6 = this.title, o3 = /* @__PURE__ */ new Set();
    let i6 = false, s10 = false;
    this.capabilities && (i6 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, s10 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a13 = /* @__PURE__ */ new Set();
    i6 && a13.add("raster.itempixelvalue");
    for (const p15 of r3) {
      const e5 = p15.name.toLowerCase();
      a13.has(e5) || e5.includes("raster.servicepixelvalue.") || o3.add(p15.name);
    }
    return s10 && o3.add("raster.magnitude").add("raster.direction"), p3({ fields: r3, title: t6 }, { ...e4, visibleFieldNames: o3 });
  }
  queryFeatures(e4, r3) {
    return this.queryRasters(e4, r3).then((e5) => {
      if (e5 == null ? void 0 : e5.features)
        for (const r4 of e5.features)
          r4.layer = r4.sourceLayer = this;
      return e5;
    });
  }
  queryFeatureCount(e4, r3) {
    return this.queryRasterCount(e4, r3);
  }
  redraw() {
    this.emit("redraw");
  }
  serviceSupportsSpatialReference(e4) {
    return e2(this, e4);
  }
};
e([y(c2)], I3.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide"] })], I3.prototype, "listMode", void 0), e([y({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], I3.prototype, "isReference", void 0), e([y({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], I3.prototype, "operationalLayerType", void 0), e([r("web-map", "operationalLayerType")], I3.prototype, "writeOperationalLayerType", null), e([y(p4)], I3.prototype, "popupEnabled", void 0), e([y({ type: k, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], I3.prototype, "popupTemplate", void 0), e([y({ readOnly: true })], I3.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, json: { read: false } })], I3.prototype, "type", void 0), I3 = e([a3("esri.layers.ImageryLayer")], I3);
var L3 = I3;
export {
  L3 as default
};
//# sourceMappingURL=ImageryLayer-53IYO3H3.js.map
