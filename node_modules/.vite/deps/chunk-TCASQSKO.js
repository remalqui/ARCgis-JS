import {
  i
} from "./chunk-5HAVROZG.js";
import {
  M,
  f as f2,
  p as p2
} from "./chunk-3GSONYPC.js";
import {
  f,
  g,
  p2 as p,
  r,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  s
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h(h7, a6, s6 = false) {
  let { hasM: t4, hasZ: e4 } = h7;
  Array.isArray(a6) ? 4 !== a6.length || t4 || e4 ? 3 === a6.length && s6 && !t4 ? (e4 = true, t4 = false) : 3 === a6.length && t4 && e4 && (t4 = false, e4 = false) : (t4 = true, e4 = true) : (e4 = !e4 && a6.hasZ && (!t4 || a6.hasM), t4 = !t4 && a6.hasM && (!e4 || a6.hasZ)), h7.hasZ = e4, h7.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Multipoint.js
var h2;
function l(t4) {
  return (s6, e4) => null == s6 ? e4 : null == e4 ? s6 : t4(s6, e4);
}
function c(t4) {
  return t4 && ("esri.geometry.SpatialReference" === t4.declaredClass || null != t4.wkid);
}
var m = h2 = class extends p {
  constructor(...t4) {
    super(...t4), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t4, s6) {
    if (!t4 && !s6)
      return {};
    const e4 = {};
    Array.isArray(t4) ? (e4.points = t4, e4.spatialReference = s6) : c(t4) ? e4.spatialReference = t4 : (t4.points && (e4.points = t4.points), t4.spatialReference && (e4.spatialReference = t4.spatialReference), t4.hasZ && (e4.hasZ = t4.hasZ), t4.hasM && (e4.hasM = t4.hasM));
    const i5 = e4.points && e4.points[0];
    return i5 && (void 0 === e4.hasZ && void 0 === e4.hasM ? (e4.hasZ = i5.length > 2, e4.hasM = false) : void 0 === e4.hasZ ? e4.hasZ = i5.length > 3 : void 0 === e4.hasM && (e4.hasM = i5.length > 3)), e4;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t4 = this.points;
    if (!t4.length)
      return null;
    const s6 = new M(), e4 = this.hasZ, i5 = this.hasM, r5 = e4 ? 3 : 2, n2 = t4[0], a6 = l(Math.min), p4 = l(Math.max);
    let h7, c6, m6, u6, [f8, y4] = n2, [d4, g3] = n2;
    for (let o5 = 0, l6 = t4.length; o5 < l6; o5++) {
      const s7 = t4[o5], [n3, l7] = s7;
      if (f8 = a6(f8, n3), y4 = a6(y4, l7), d4 = p4(d4, n3), g3 = p4(g3, l7), e4 && s7.length > 2) {
        const t5 = s7[2];
        h7 = a6(h7, t5), m6 = p4(m6, t5);
      }
      if (i5 && s7.length > r5) {
        const t5 = s7[r5];
        c6 = a6(c6, t5), u6 = p4(u6, t5);
      }
    }
    return s6.xmin = f8, s6.ymin = y4, s6.xmax = d4, s6.ymax = g3, s6.spatialReference = this.spatialReference, e4 ? (s6.zmin = h7, s6.zmax = m6) : (s6.zmin = void 0, s6.zmax = void 0), i5 ? (s6.mmin = c6, s6.mmax = u6) : (s6.mmin = void 0, s6.mmax = void 0), s6;
  }
  writePoints(t4, e4) {
    e4.points = a(this.points);
  }
  addPoint(t4) {
    return h(this, t4), Array.isArray(t4) ? this.points.push(t4) : this.points.push(t4.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t4 = { points: a(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t4.hasZ = true), this.hasM && (t4.hasM = true), new h2(t4);
  }
  getPoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s6 = this.points[t4], e4 = { x: s6[0], y: s6[1], spatialReference: this.spatialReference };
    let i5 = 2;
    return this.hasZ && (e4.z = s6[2], i5 = 3), this.hasM && (e4.m = s6[i5]), new x(e4);
  }
  removePoint(t4) {
    if (!this._validateInputs(t4))
      return null;
    const s6 = new x(this.points.splice(t4, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s6;
  }
  setPoint(t4, s6) {
    return this._validateInputs(t4) ? (h(this, s6), Array.isArray(s6) || (s6 = s6.toArray()), this.points[t4] = s6, this.notifyChange("points"), this) : this;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
  _validateInputs(t4) {
    return null != t4 && t4 >= 0 && t4 < this.points.length;
  }
};
e([y({ readOnly: true })], m.prototype, "cache", null), e([y()], m.prototype, "extent", null), e([y({ type: [[Number]], json: { write: { isRequired: true } } })], m.prototype, "points", void 0), e([r("points")], m.prototype, "writePoints", null), m = h2 = e([a2("esri.geometry.Multipoint")], m), m.prototype.toJSON.isDefaultToJSON = true;
var u = m;

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function t(n2) {
  return void 0 !== n2.xmin && void 0 !== n2.ymin && void 0 !== n2.xmax && void 0 !== n2.ymax;
}
function i2(n2) {
  return void 0 !== n2.points;
}
function o(n2) {
  return void 0 !== n2.x && void 0 !== n2.y;
}
function e2(n2) {
  return void 0 !== n2.paths;
}
function r2(n2) {
  return void 0 !== n2.rings;
}
function u2(n2) {
  function t4(t5, i5) {
    return null == t5 ? i5 : null == i5 ? t5 : n2(t5, i5);
  }
  return t4;
}
var l2 = u2(Math.min);
var h3 = u2(Math.max);
function a3(n2, u6) {
  return e2(u6) ? x2(n2, u6.paths, false, false) : r2(u6) ? x2(n2, u6.rings, false, false) : i2(u6) ? g2(n2, u6.points, false, false, false, false) : t(u6) ? s2(n2, u6) : (o(u6) && (n2[0] = u6.x, n2[1] = u6.y, n2[2] = u6.x, n2[3] = u6.y), n2);
}
function c2(t4) {
  let i5, o5, e4, r5;
  for (t4.reset(), i5 = e4 = 1 / 0, o5 = r5 = -1 / 0; t4.nextPath(); ) {
    const n2 = f3(t4);
    i5 = Math.min(n2[0], i5), e4 = Math.min(n2[1], e4), o5 = Math.max(n2[2], o5), r5 = Math.max(n2[3], r5);
  }
  return i([i5, e4, o5, r5]);
}
function f3(t4) {
  let i5, o5, e4, r5;
  for (i5 = e4 = 1 / 0, o5 = r5 = -1 / 0; t4.nextPoint(); )
    i5 = Math.min(t4.x, i5), e4 = Math.min(t4.y, e4), o5 = Math.max(t4.x, o5), r5 = Math.max(t4.y, r5);
  return i([i5, e4, o5, r5]);
}
function m2(n2, u6) {
  return e2(u6) ? x2(n2, u6.paths, true, false) : r2(u6) ? x2(n2, u6.rings, true, false) : i2(u6) ? g2(n2, u6.points, true, false, true, false) : t(u6) ? s2(n2, u6, true, false, true, false) : (o(u6) && (n2[0] = u6.x, n2[1] = u6.y, n2[2] = u6.z, n2[3] = u6.x, n2[4] = u6.y, n2[5] = u6.z), n2);
}
function x2(n2, t4, i5, o5) {
  const e4 = i5 ? 3 : 2;
  if (!t4.length || !t4[0].length)
    return null;
  let r5, u6, a6, c6, [f8, m6] = t4[0][0], [x5, s6] = t4[0][0];
  for (let g3 = 0; g3 < t4.length; g3++) {
    const n3 = t4[g3];
    for (let t5 = 0; t5 < n3.length; t5++) {
      const g4 = n3[t5], [y4, d4] = g4;
      if (f8 = l2(f8, y4), m6 = l2(m6, d4), x5 = h3(x5, y4), s6 = h3(s6, d4), i5 && g4.length > 2) {
        const n4 = g4[2];
        r5 = l2(r5, n4), u6 = h3(u6, n4);
      }
      if (o5 && g4.length > e4) {
        const n4 = g4[e4];
        a6 = l2(r5, n4), c6 = h3(u6, n4);
      }
    }
  }
  return i5 ? o5 ? (n2[0] = f8, n2[1] = m6, n2[2] = r5, n2[3] = a6, n2[4] = x5, n2[5] = s6, n2[6] = u6, n2[7] = c6, n2.length = 8, n2) : (n2[0] = f8, n2[1] = m6, n2[2] = r5, n2[3] = x5, n2[4] = s6, n2[5] = u6, n2.length = 6, n2) : o5 ? (n2[0] = f8, n2[1] = m6, n2[2] = a6, n2[3] = x5, n2[4] = s6, n2[5] = c6, n2.length = 6, n2) : (n2[0] = f8, n2[1] = m6, n2[2] = x5, n2[3] = s6, n2.length = 4, n2);
}
function s2(n2, t4, i5, o5, e4, r5) {
  const u6 = t4.xmin, l6 = t4.xmax, h7 = t4.ymin, a6 = t4.ymax;
  let c6 = t4.zmin, f8 = t4.zmax, m6 = t4.mmin, x5 = t4.mmax;
  return e4 ? (c6 = c6 || 0, f8 = f8 || 0, r5 ? (m6 = m6 || 0, x5 = x5 || 0, n2[0] = u6, n2[1] = h7, n2[2] = c6, n2[3] = m6, n2[4] = l6, n2[5] = a6, n2[6] = f8, n2[7] = x5, n2) : (n2[0] = u6, n2[1] = h7, n2[2] = c6, n2[3] = l6, n2[4] = a6, n2[5] = f8, n2)) : r5 ? (m6 = m6 || 0, x5 = x5 || 0, n2[0] = u6, n2[1] = h7, n2[2] = m6, n2[3] = l6, n2[4] = a6, n2[5] = x5, n2) : (n2[0] = u6, n2[1] = h7, n2[2] = l6, n2[3] = a6, n2);
}
function g2(n2, t4, i5, o5, e4, r5) {
  const u6 = i5 ? 3 : 2, a6 = o5 && r5, c6 = i5 && e4;
  if (!t4.length || !t4[0].length)
    return null;
  let f8, m6, x5, s6, [g3, y4] = t4[0], [d4, M3] = t4[0];
  for (let v2 = 0; v2 < t4.length; v2++) {
    const n3 = t4[v2], [i6, o6] = n3;
    if (g3 = l2(g3, i6), y4 = l2(y4, o6), d4 = h3(d4, i6), M3 = h3(M3, o6), c6 && n3.length > 2) {
      const t5 = n3[2];
      f8 = l2(f8, t5), m6 = h3(m6, t5);
    }
    if (a6 && n3.length > u6) {
      const t5 = n3[u6];
      x5 = l2(f8, t5), s6 = h3(m6, t5);
    }
  }
  return e4 ? (f8 = f8 || 0, m6 = m6 || 0, r5 ? (x5 = x5 || 0, s6 = s6 || 0, n2[0] = g3, n2[1] = y4, n2[2] = f8, n2[3] = x5, n2[4] = d4, n2[5] = M3, n2[6] = m6, n2[7] = s6, n2) : (n2[0] = g3, n2[1] = y4, n2[2] = f8, n2[3] = d4, n2[4] = M3, n2[5] = m6, n2)) : r5 ? (x5 = x5 || 0, s6 = s6 || 0, n2[0] = g3, n2[1] = y4, n2[2] = x5, n2[3] = d4, n2[4] = M3, n2[5] = s6, n2) : (n2[0] = g3, n2[1] = y4, n2[2] = d4, n2[3] = M3, n2);
}

// node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t2(t4) {
  const n2 = [];
  for (t4.reset(); t4.nextPath(); ) {
    const e4 = [];
    for (; t4.nextPoint(); )
      e4.push([t4.x, t4.y]);
    n2.push(e4);
  }
  return t4.reset(), n2;
}
function n(t4) {
  const n2 = [];
  for (; t4.nextPoint(); )
    n2.push([t4.x, t4.y]);
  return t4.seekPathStart(), n2;
}

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function r3(t4, n2) {
  const e4 = n2[0] - t4[0], r5 = n2[1] - t4[1];
  if (t4.length > 2 && n2.length > 2) {
    const i5 = t4[2] - n2[2];
    return Math.sqrt(e4 * e4 + r5 * r5 + i5 * i5);
  }
  return Math.sqrt(e4 * e4 + r5 * r5);
}
function i3(t4, n2, e4) {
  const r5 = t4[0] + e4 * (n2[0] - t4[0]), i5 = t4[1] + e4 * (n2[1] - t4[1]);
  return t4.length > 2 && n2.length > 2 ? [r5, i5, t4[2] + e4 * (n2[2] - t4[2])] : [r5, i5];
}
function o2(t4, n2, e4, r5) {
  const [i5, o5] = n2, [s6, f8] = e4[r5], [l6, u6] = e4[r5 + 1], c6 = l6 - s6, h7 = u6 - f8, a6 = c6 * c6 + h7 * h7, p4 = (i5 - s6) * c6 + (o5 - f8) * h7, y4 = Math.min(1, Math.max(0, p4 / a6));
  return t4[0] = s6 + c6 * y4, t4[1] = f8 + h7 * y4, t4;
}
function s3(t4, n2, e4) {
  let r5, i5, o5, s6, l6 = false, u6 = 1 / 0;
  for (e4.reset(); e4.nextPath(); )
    if (e4.nextPoint())
      for (r5 = e4.x, i5 = e4.y; e4.nextPoint(); )
        o5 = e4.x, s6 = e4.y, i5 > n2 != s6 > n2 && t4 < (o5 - r5) * (n2 - i5) / (s6 - i5) + r5 && (l6 = !l6), u6 = Math.min(u6, f4(t4, n2, r5, i5, o5, s6)), r5 = o5, i5 = s6;
  return 0 === u6 ? 0 : (l6 ? 1 : -1) * Math.sqrt(u6);
}
function f4(t4, n2, e4, r5, i5, o5) {
  let s6 = e4, f8 = r5, l6 = i5 - s6, u6 = o5 - f8;
  if (0 !== l6 || 0 !== u6) {
    const e5 = ((t4 - s6) * l6 + (n2 - f8) * u6) / (l6 * l6 + u6 * u6);
    e5 > 1 ? (s6 = i5, f8 = o5) : e5 > 0 && (s6 += l6 * e5, f8 += u6 * e5);
  }
  return l6 = t4 - s6, u6 = n2 - f8, l6 * l6 + u6 * u6;
}
function l3(t4, n2) {
  return i3(t4, n2, 0.5);
}
function h4(t4, n2, e4) {
  const r5 = t4.length;
  let i5 = 0, o5 = 0, s6 = 0;
  for (let f8 = 0; f8 < r5; f8++) {
    const l6 = t4[f8], u6 = t4[(f8 + 1) % r5];
    let c6 = 2;
    i5 += l6[0] * u6[1] - u6[0] * l6[1], l6.length > 2 && u6.length > 2 && e4 && (o5 += l6[0] * u6[2] - u6[0] * l6[2], c6 = 3), l6.length > c6 && u6.length > c6 && n2 && (s6 += l6[0] * u6[c6] - u6[0] * l6[c6]);
  }
  return i5 <= 0 && o5 <= 0 && s6 <= 0;
}
function a4(n2) {
  const e4 = n2.length;
  return e4 > 2 && s(n2[0], n2[e4 - 1]);
}
function p3(t4) {
  if ("rings" in t4 && (y2(t4), t4.rings.length > 0 && !h4(t4.rings[0], t4.hasM ?? false, t4.hasZ ?? false)))
    for (const n2 of t4.rings)
      n2.reverse();
}
function y2(t4) {
  if ("rings" in t4)
    for (const n2 of t4.rings)
      a4(n2) || n2.push(n2[0].slice());
}
function M2(t4) {
  if (!t4 || t4.length < 3)
    return 0;
  let n2 = 0;
  const e4 = t4.length - 1;
  for (let r5 = 0; r5 < e4; r5++)
    n2 += (t4[r5][0] - t4[r5 + 1][0]) * (t4[r5][1] + t4[r5 + 1][1]);
  return n2 += (t4[e4][0] - t4[0][0]) * (t4[e4][1] + t4[0][1]), -0.5 * n2;
}
function P(t4) {
  if (!t4 || t4.numPoints < 3)
    return 0;
  let n2, e4, r5 = 0;
  if (t4.seekPathStart(), !t4.nextPoint())
    return 0;
  n2 = t4.x, e4 = t4.y;
  const i5 = n2, o5 = e4;
  for (; t4.nextPoint(); )
    r5 += (n2 - t4.x) * (e4 + t4.y), n2 = t4.x, e4 = t4.y;
  return r5 += (n2 - i5) * (e4 + o5), -0.5 * r5;
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function l4(t4) {
  return t4 ? t4.hasZ ? [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2, t4.zmax - t4.zmin / 2] : [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2] : null;
}
function o3(t4) {
  return t4 ? u3(t4.rings, t4.hasZ ?? false) : null;
}
function u3(t4, n2) {
  if (!t4 || !t4.length)
    return null;
  const e4 = [], r5 = [], l6 = n2 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o5 = 0, u6 = t4.length; o5 < u6; o5++) {
    const e5 = s4(t4[o5], n2, l6);
    e5 && r5.push(e5);
  }
  if (r5.sort((t5, e5) => {
    let r6 = t5[2] - e5[2];
    return 0 === r6 && n2 && (r6 = t5[4] - e5[4]), r6;
  }), r5.length && (e4[0] = r5[0][0], e4[1] = r5[0][1], n2 && (e4[2] = r5[0][3]), (e4[0] < l6[0] || e4[0] > l6[1] || e4[1] < l6[2] || e4[1] > l6[3] || n2 && (e4[2] < l6[4] || e4[2] > l6[5])) && (e4.length = 0)), !e4.length) {
    const r6 = t4[0] && t4[0].length ? I(t4[0], n2) : null;
    if (!r6)
      return null;
    e4[0] = r6[0], e4[1] = r6[1], n2 && r6.length > 2 && (e4[2] = r6[2]);
  }
  return e4;
}
function s4(t4, n2, e4) {
  let r5 = 0, l6 = 0, o5 = 0, u6 = 0, s6 = 0;
  const I2 = t4.length ? t4[0][0] : 0, i5 = t4.length ? t4[0][1] : 0, h7 = t4.length && n2 ? t4[0][2] : 0;
  for (let N2 = 0; N2 < t4.length; N2++) {
    const c7 = t4[N2], f8 = t4[(N2 + 1) % t4.length], [m6, x5, g3] = c7, P2 = m6 - I2, T = x5 - i5, [a6, E, y4] = f8, b = a6 - I2, F = E - i5, V = P2 * F - b * T;
    if (u6 += V, r5 += (P2 + b) * V, l6 += (T + F) * V, n2 && c7.length > 2 && f8.length > 2) {
      const t5 = g3 - h7, n3 = y4 - h7, e5 = P2 * n3 - b * t5;
      o5 += (t5 + n3) * e5, s6 += e5;
    }
    m6 < e4[0] && (e4[0] = m6), m6 > e4[1] && (e4[1] = m6), x5 < e4[2] && (e4[2] = x5), x5 > e4[3] && (e4[3] = x5), n2 && (g3 < e4[4] && (e4[4] = g3), g3 > e4[5] && (e4[5] = g3));
  }
  if (u6 > 0 && (u6 *= -1), s6 > 0 && (s6 *= -1), !u6)
    return null;
  u6 *= 0.5, s6 *= 0.5;
  const c6 = [r5 / (6 * u6) + I2, l6 / (6 * u6) + i5, u6];
  return n2 && (e4[4] === e4[5] || 0 === s6 ? (c6[3] = (e4[4] + e4[5]) / 2, c6[4] = 0) : (c6[3] = o5 / (6 * s6) + h7, c6[4] = s6)), c6;
}
function I(t4, r5) {
  const l6 = r5 ? [0, 0, 0] : [0, 0], o5 = r5 ? [0, 0, 0] : [0, 0];
  let u6 = 0, s6 = 0, I2 = 0, i5 = 0;
  for (let h7 = 0, c6 = t4.length; h7 < c6 - 1; h7++) {
    const c7 = t4[h7], N2 = t4[h7 + 1];
    if (c7 && N2) {
      l6[0] = c7[0], l6[1] = c7[1], o5[0] = N2[0], o5[1] = N2[1], r5 && c7.length > 2 && N2.length > 2 && (l6[2] = c7[2], o5[2] = N2[2]);
      const t5 = r3(l6, o5);
      if (t5) {
        u6 += t5;
        const n2 = l3(c7, N2);
        s6 += t5 * n2[0], I2 += t5 * n2[1], r5 && n2.length > 2 && (i5 += t5 * n2[2]);
      }
    }
  }
  return u6 > 0 ? r5 ? [s6 / u6, I2 / u6, i5 / u6] : [s6 / u6, I2 / u6] : t4.length ? t4[0] : null;
}
function i4(n2) {
  const { hasZ: e4, numPaths: r5 } = n2;
  if (0 === r5)
    return null;
  const l6 = [], o5 = [], u6 = e4 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n2.reset(); n2.nextPath(); ) {
    const e5 = s4(n(n2), n2.hasZ, u6);
    e5 && o5.push(e5);
  }
  if (o5.sort((t4, n3) => {
    let r6 = t4[2] - n3[2];
    return 0 === r6 && e4 && (r6 = t4[4] - n3[4]), r6;
  }), o5.length && (l6[0] = o5[0][0], l6[1] = o5[0][1], e4 && (l6[2] = o5[0][3]), (l6[0] < u6[0] || l6[0] > u6[1] || l6[1] < u6[2] || l6[1] > u6[3] || e4 && (l6[2] < u6[4] || l6[2] > u6[5])) && (l6.length = 0)), !l6.length) {
    n2.reset(), n2.nextPath();
    const t4 = n2.numPoints ? h5(n2) : null;
    if (!t4)
      return null;
    l6[0] = t4[0], l6[1] = t4[1], e4 && t4.length > 2 && (l6[2] = t4[2]);
  }
  return l6;
}
function h5(t4) {
  const { hasZ: r5 } = t4, l6 = r5 ? [0, 0, 0] : [0, 0], o5 = r5 ? [0, 0, 0] : [0, 0];
  let u6 = 0, s6 = 0, I2 = 0, i5 = 0;
  if (t4.nextPoint()) {
    let h7 = t4.x, c6 = t4.y, N2 = t4.z;
    for (; t4.nextPoint(); ) {
      const f8 = t4.x, m6 = t4.y, x5 = t4.z;
      l6[0] = h7, l6[1] = c6, o5[0] = f8, o5[1] = m6, r5 && (l6[2] = N2, o5[2] = x5);
      const g3 = r3(l6, o5);
      if (g3) {
        u6 += g3;
        const t5 = l3(l6, o5);
        s6 += g3 * t5[0], I2 += g3 * t5[1], r5 && t5.length > 2 && (i5 += g3 * t5[2]);
      }
      h7 = f8, c6 = m6, N2 = x5;
    }
  }
  return u6 > 0 ? r5 ? [s6 / u6, I2 / u6, i5 / u6] : [s6 / u6, I2 / u6] : t4.numPoints ? (t4.seekPathStart(), t4.nextPoint(), [t4.x, t4.y]) : null;
}
var c3 = 1e-6;
function N(t4) {
  let n2 = 0;
  for (t4.reset(); t4.nextPath(); )
    n2 += P(t4);
  if (n2 < c3) {
    const n3 = i4(t4);
    return n3 ? [n3[0], n3[1]] : null;
  }
  const e4 = [0, 0];
  if (t4.reset(), !t4.nextPath() || !t4.nextPoint())
    return null;
  const l6 = [t4.x, t4.y];
  for (t4.reset(); t4.nextPath(); )
    m3(e4, l6, t4);
  return e4[0] *= 1 / n2, e4[1] *= 1 / n2, e4[0] += l6[0], e4[1] += l6[1], e4;
}
var f5 = 1 / 3;
function m3(t4, n2, e4) {
  if (!t4 || !e4 || e4.numPoints < 3)
    return null;
  e4.nextPoint();
  const l6 = e4.x, o5 = e4.y;
  e4.nextPoint();
  let u6, s6 = e4.x - l6, I2 = e4.y - o5, i5 = 0, h7 = 0;
  for (; e4.nextPoint(); )
    i5 = e4.x - l6, h7 = e4.y - o5, u6 = 0.5 * f5 * (i5 * I2 - h7 * s6), t4[0] += u6 * (s6 + i5), t4[1] += u6 * (I2 + h7), s6 = i5, I2 = h7;
  const c6 = P(e4), N2 = [l6, o5];
  return N2[0] -= n2[0], N2[1] -= n2[1], N2[0] *= c6, N2[1] *= c6, t4[0] += N2[0], t4[1] += N2[1], t4;
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n2) {
  return void 0 !== n2.xmin && void 0 !== n2.ymin && void 0 !== n2.xmax && void 0 !== n2.ymax;
}
function u4(n2) {
  return void 0 !== n2.points;
}
function m4(n2) {
  return void 0 !== n2.x && void 0 !== n2.y;
}
function o4(n2) {
  return void 0 !== n2.paths;
}
function r4(n2) {
  return void 0 !== n2.rings;
}
var x3 = [];
function a5(n2, i5, t4, u6) {
  return { xmin: n2, ymin: i5, xmax: t4, ymax: u6 };
}
function c4(n2, i5, t4, u6, m6, o5) {
  return { xmin: n2, ymin: i5, zmin: t4, xmax: u6, ymax: m6, zmax: o5 };
}
function s5(n2, i5, t4, u6, m6, o5) {
  return { xmin: n2, ymin: i5, mmin: t4, xmax: u6, ymax: m6, mmax: o5 };
}
function e3(n2, i5, t4, u6, m6, o5, r5, x5) {
  return { xmin: n2, ymin: i5, zmin: t4, mmin: u6, xmax: m6, ymax: o5, zmax: r5, mmax: x5 };
}
function f6(n2, i5 = false, t4 = false) {
  return i5 ? t4 ? e3(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5], n2[6], n2[7]) : c4(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : t4 ? s5(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : a5(n2[0], n2[1], n2[2], n2[3]);
}
function l5(n2) {
  return n2 ? t3(n2) ? n2 : m4(n2) ? d2(n2) : r4(n2) ? v(n2) : o4(n2) ? h6(n2) : u4(n2) ? y3(n2) : null : null;
}
function y3(i5) {
  const { hasZ: t4, hasM: u6, points: m6 } = i5;
  return f6(g2(x3, m6, t4 ?? false, u6 ?? false), t4, u6);
}
function d2(n2) {
  const { x: i5, y: t4, z: u6, m: m6 } = n2, o5 = null != m6;
  return null != u6 ? o5 ? e3(i5, t4, u6, m6, i5, t4, u6, m6) : c4(i5, t4, u6, i5, t4, u6) : o5 ? s5(i5, t4, m6, i5, t4, m6) : a5(i5, t4, i5, t4);
}
function v(n2) {
  const { hasZ: t4, hasM: u6, rings: m6 } = n2, o5 = x2(x3, m6, t4 ?? false, u6 ?? false);
  return o5 ? f6(o5, t4, u6) : null;
}
function h6(n2) {
  const { hasZ: t4, hasM: u6, paths: m6 } = n2, o5 = x2(x3, m6, t4 ?? false, u6 ?? false);
  return o5 ? f6(o5, t4, u6) : null;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var d3;
function R(t4) {
  return !Array.isArray(t4[0]);
}
var x4 = d3 = class extends p {
  static fromExtent(t4) {
    const e4 = t4.clone().normalize(), r5 = t4.spatialReference;
    let s6 = false, n2 = false;
    for (const o5 of e4)
      o5.hasZ && (s6 = true), o5.hasM && (n2 = true);
    const i5 = { rings: e4.map((t5) => {
      const e5 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s6 && t5.hasZ) {
        const r6 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < e5.length; t6++)
          e5[t6].push(r6);
      }
      if (n2 && t5.hasM) {
        const r6 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < e5.length; t6++)
          e5[t6].push(r6);
      }
      return e5;
    }), spatialReference: r5 };
    return s6 && (i5.hasZ = true), n2 && (i5.hasM = true), new d3(i5);
  }
  constructor(...t4) {
    super(...t4), this.rings = [], this.type = "polygon";
  }
  normalizeCtorArgs(t4, e4) {
    let r5, s6, n2 = null, i5 = null;
    return t4 && !Array.isArray(t4) ? (n2 = t4.rings ?? null, e4 || (t4.spatialReference ? e4 = t4.spatialReference : t4.rings || (e4 = t4)), r5 = t4.hasZ, s6 = t4.hasM) : n2 = t4, n2 = n2 || [], e4 = e4 || f.WGS84, n2.length && n2[0] && null != n2[0][0] && "number" == typeof n2[0][0] && (n2 = [n2]), i5 = n2[0] && n2[0][0], i5 && (void 0 === r5 && void 0 === s6 ? (r5 = i5.length > 2, s6 = i5.length > 3) : void 0 === r5 ? r5 = s6 ? i5.length > 3 : i5.length > 2 : void 0 === s6 && (s6 = r5 ? i5.length > 3 : i5.length > 2)), { rings: n2, spatialReference: e4, hasZ: r5, hasM: s6 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t4 = o3(this);
    if (!t4 || isNaN(t4[0]) || isNaN(t4[1]) || this.hasZ && isNaN(t4[2]))
      return null;
    const e4 = new x();
    return e4.x = t4[0], e4.y = t4[1], e4.spatialReference = this.spatialReference, this.hasZ && (e4.z = t4[2]), e4;
  }
  get extent() {
    const { spatialReference: t4 } = this, e4 = v(this);
    if (!e4)
      return null;
    const r5 = new M(e4);
    return r5.spatialReference = t4, r5;
  }
  get isSelfIntersecting() {
    return p2(this.rings);
  }
  writeRings(t4, e4) {
    e4.rings = a(this.rings);
  }
  addRing(t4) {
    if (!t4)
      return;
    const e4 = this.rings, r5 = e4.length;
    if (R(t4)) {
      const s6 = [];
      for (let e5 = 0, r6 = t4.length; e5 < r6; e5++)
        s6[e5] = t4[e5].toArray();
      e4[r5] = s6;
    } else
      e4[r5] = t4.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new d3();
    return t4.spatialReference = this.spatialReference, t4.rings = a(this.rings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4)
      return true;
    if (null == t4)
      return false;
    const r5 = this.spatialReference, s6 = t4.spatialReference;
    if (null != r5 != (null != s6))
      return false;
    if (null != r5 && null != s6 && !r5.equals(s6))
      return false;
    if (this.rings.length !== t4.rings.length)
      return false;
    const n2 = ([t5, e4, r6, s7], [n3, i5, o5, a6]) => t5 === n3 && e4 === i5 && (null == r6 && null == o5 || r6 === o5) && (null == s7 && null == a6 || s7 === a6);
    for (let i5 = 0; i5 < this.rings.length; i5++) {
      const r6 = this.rings[i5], s7 = t4.rings[i5];
      if (!s(r6, s7, n2))
        return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4)
      return false;
    const e4 = g(t4, this.spatialReference);
    return f2(this, null != e4 ? e4 : t4);
  }
  isClockwise(t4) {
    let e4;
    return e4 = R(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4, h4(e4, this.hasM, this.hasZ);
  }
  getPoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const r5 = this.rings[t4][e4], s6 = this.hasZ, n2 = this.hasM;
    return s6 && !n2 ? new x(r5[0], r5[1], r5[2], void 0, this.spatialReference) : n2 && !s6 ? new x(r5[0], r5[1], void 0, r5[2], this.spatialReference) : s6 && n2 ? new x(r5[0], r5[1], r5[2], r5[3], this.spatialReference) : new x(r5[0], r5[1], this.spatialReference);
  }
  insertPoint(t4, e4, r5) {
    return this._validateInputs(t4, e4, true) ? (h(this, r5), Array.isArray(r5) || (r5 = r5.toArray()), this.rings[t4].splice(e4, 0, r5), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const r5 = new x(this.rings[t4].splice(e4, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), r5;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e4 = this.rings.splice(t4, 1)[0], r5 = this.spatialReference, s6 = e4.map((t5) => new x(t5, r5));
    return this.notifyChange("rings"), s6;
  }
  setPoint(t4, e4, r5) {
    return this._validateInputs(t4, e4) ? (h(this, r5), Array.isArray(r5) || (r5 = r5.toArray()), this.rings[t4][e4] = r5, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, e4, r5 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length)
      return false;
    if (null != e4) {
      const s6 = this.rings[t4];
      if (r5 && (e4 < 0 || e4 > s6.length))
        return false;
      if (!r5 && (e4 < 0 || e4 >= s6.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], x4.prototype, "cache", null), e([y({ readOnly: true })], x4.prototype, "centroid", null), e([y({ readOnly: true })], x4.prototype, "extent", null), e([y({ readOnly: true })], x4.prototype, "isSelfIntersecting", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], x4.prototype, "rings", void 0), e([r("rings")], x4.prototype, "writeRings", null), x4 = d3 = e([a2("esri.geometry.Polygon")], x4), x4.prototype.toJSON.isDefaultToJSON = true;
var j = x4;

// node_modules/@arcgis/core/geometry/Polyline.js
var c5;
function u5(t4) {
  return !Array.isArray(t4[0]);
}
var f7 = c5 = class extends p {
  constructor(...t4) {
    super(...t4), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t4, e4) {
    let s6, r5, i5 = null, a6 = null;
    return t4 && !Array.isArray(t4) ? (i5 = t4.paths ?? null, e4 || (t4.spatialReference ? e4 = t4.spatialReference : t4.paths || (e4 = t4)), s6 = t4.hasZ, r5 = t4.hasM) : i5 = t4, i5 = i5 || [], e4 = e4 || f.WGS84, i5.length && i5[0] && null != i5[0][0] && "number" == typeof i5[0][0] && (i5 = [i5]), a6 = i5[0] && i5[0][0], a6 && (void 0 === s6 && void 0 === r5 ? (s6 = a6.length > 2, r5 = false) : void 0 === s6 ? s6 = !r5 && a6.length > 3 : void 0 === r5 && (r5 = !s6 && a6.length > 3)), { paths: i5, spatialReference: e4, hasZ: s6, hasM: r5 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t4 } = this, e4 = h6(this);
    if (!e4)
      return null;
    const s6 = new M(e4);
    return s6.spatialReference = t4, s6;
  }
  writePaths(t4, s6) {
    s6.paths = a(this.paths);
  }
  addPath(t4) {
    if (!t4)
      return;
    const e4 = this.paths, s6 = e4.length;
    if (u5(t4)) {
      const r5 = [];
      for (let e5 = 0, s7 = t4.length; e5 < s7; e5++)
        r5[e5] = t4[e5].toArray();
      e4[s6] = r5;
    } else
      e4[s6] = t4.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t4 = new c5();
    return t4.spatialReference = this.spatialReference, t4.paths = a(this.paths), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  getPoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const s6 = this.paths[t4][e4], r5 = this.hasZ, i5 = this.hasM;
    return r5 && !i5 ? new x(s6[0], s6[1], s6[2], void 0, this.spatialReference) : i5 && !r5 ? new x(s6[0], s6[1], void 0, s6[2], this.spatialReference) : r5 && i5 ? new x(s6[0], s6[1], s6[2], s6[3], this.spatialReference) : new x(s6[0], s6[1], this.spatialReference);
  }
  insertPoint(t4, e4, s6) {
    return this._validateInputs(t4, e4, true) ? (h(this, s6), Array.isArray(s6) || (s6 = s6.toArray()), this.paths[t4].splice(e4, 0, s6), this.notifyChange("paths"), this) : this;
  }
  removePath(t4) {
    if (!this._validateInputs(t4, null))
      return null;
    const e4 = this.paths.splice(t4, 1)[0], s6 = this.spatialReference, r5 = e4.map((t5) => new x(t5, s6));
    return this.notifyChange("paths"), r5;
  }
  removePoint(t4, e4) {
    if (!this._validateInputs(t4, e4))
      return null;
    const s6 = new x(this.paths[t4].splice(e4, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s6;
  }
  setPoint(t4, e4, s6) {
    return this._validateInputs(t4, e4) ? (h(this, s6), Array.isArray(s6) || (s6 = s6.toArray()), this.paths[t4][e4] = s6, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t4, e4, s6 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.paths.length)
      return false;
    if (null != e4) {
      const r5 = this.paths[t4];
      if (s6 && (e4 < 0 || e4 > r5.length))
        return false;
      if (!s6 && (e4 < 0 || e4 >= r5.length))
        return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
e([y({ readOnly: true })], f7.prototype, "cache", null), e([y({ readOnly: true })], f7.prototype, "extent", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], f7.prototype, "paths", void 0), e([r("paths")], f7.prototype, "writePaths", null), f7 = c5 = e([a2("esri.geometry.Polyline")], f7), f7.prototype.toJSON.isDefaultToJSON = true;
var m5 = f7;

export {
  u,
  t2 as t,
  n,
  o2 as o,
  s3 as s,
  h4 as h,
  p3 as p,
  y2 as y,
  M2 as M,
  l4 as l,
  o3 as o2,
  s4 as s2,
  i4 as i,
  N,
  a3 as a,
  c2 as c,
  f3 as f,
  m2 as m,
  g2 as g,
  l5 as l2,
  v,
  j,
  m5 as m2
};
//# sourceMappingURL=chunk-TCASQSKO.js.map
