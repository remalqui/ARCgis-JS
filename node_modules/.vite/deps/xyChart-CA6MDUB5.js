import {
  n,
  o
} from "./chunk-XR4ENMV2.js";
import {
  B,
  D,
  I,
  U as U2,
  V,
  _,
  g,
  k
} from "./chunk-LRWFHHXB.js";
import {
  l as l2
} from "./chunk-EX2LTU3A.js";
import {
  s
} from "./chunk-VGD6ZKBY.js";
import {
  $,
  A,
  De,
  F,
  Fe,
  G,
  It,
  Je,
  K,
  Kt,
  Me,
  Ne,
  P,
  Qe,
  R,
  Re,
  U,
  Ut,
  W,
  Xt,
  Y,
  Ye,
  Yt,
  Z,
  ae,
  e,
  ft,
  it,
  l,
  m,
  mt,
  ne,
  ot,
  pt,
  re,
  ti,
  tt,
  v,
  y,
  z
} from "./chunk-7WSXGFCK.js";
import {
  t
} from "./chunk-PD5Q7TDW.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/widgets/Feature/FeatureMedia/xyChart.js
function $2(t2) {
  return "object" == typeof t2 && "length" in t2 ? t2 : Array.from(t2);
}
function tt2(t2) {
  this._context = t2;
}
function et(t2) {
  return new tt2(t2);
}
function it2(t2) {
  return t2[0];
}
function st(t2) {
  return t2[1];
}
function at(t2, e2) {
  var i = k(true), s2 = null, a = et, o2 = null, n2 = V(r);
  function r(r2) {
    var l3, h, c, d = (r2 = $2(r2)).length, u = false;
    for (null == s2 && (o2 = a(c = n2())), l3 = 0; l3 <= d; ++l3)
      !(l3 < d && i(h = r2[l3], l3, r2)) === u && ((u = !u) ? o2.lineStart() : o2.lineEnd()), u && o2.point(+t2(h, l3, r2), +e2(h, l3, r2));
    if (c)
      return o2 = null, c + "" || null;
  }
  return t2 = "function" == typeof t2 ? t2 : void 0 === t2 ? it2 : k(t2), e2 = "function" == typeof e2 ? e2 : void 0 === e2 ? st : k(e2), r.x = function(e3) {
    return arguments.length ? (t2 = "function" == typeof e3 ? e3 : k(+e3), r) : t2;
  }, r.y = function(t3) {
    return arguments.length ? (e2 = "function" == typeof t3 ? t3 : k(+t3), r) : e2;
  }, r.defined = function(t3) {
    return arguments.length ? (i = "function" == typeof t3 ? t3 : k(!!t3), r) : i;
  }, r.curve = function(t3) {
    return arguments.length ? (a = t3, null != s2 && (o2 = a(s2)), r) : a;
  }, r.context = function(t3) {
    return arguments.length ? (null == t3 ? s2 = o2 = null : o2 = a(s2 = t3), r) : s2;
  }, r;
}
function ot2(t2, e2, i) {
  var s2 = null, a = k(true), o2 = null, n2 = et, r = null, l3 = V(h);
  function h(h2) {
    var c2, d, u, g2, p, m2 = (h2 = $2(h2)).length, _2 = false, x = new Array(m2), b = new Array(m2);
    for (null == o2 && (r = n2(p = l3())), c2 = 0; c2 <= m2; ++c2) {
      if (!(c2 < m2 && a(g2 = h2[c2], c2, h2)) === _2)
        if (_2 = !_2)
          d = c2, r.areaStart(), r.lineStart();
        else {
          for (r.lineEnd(), r.lineStart(), u = c2 - 1; u >= d; --u)
            r.point(x[u], b[u]);
          r.lineEnd(), r.areaEnd();
        }
      _2 && (x[c2] = +t2(g2, c2, h2), b[c2] = +e2(g2, c2, h2), r.point(s2 ? +s2(g2, c2, h2) : x[c2], i ? +i(g2, c2, h2) : b[c2]));
    }
    if (p)
      return r = null, p + "" || null;
  }
  function c() {
    return at().defined(a).curve(n2).context(o2);
  }
  return t2 = "function" == typeof t2 ? t2 : void 0 === t2 ? it2 : k(+t2), e2 = "function" == typeof e2 ? e2 : k(void 0 === e2 ? 0 : +e2), i = "function" == typeof i ? i : void 0 === i ? st : k(+i), h.x = function(e3) {
    return arguments.length ? (t2 = "function" == typeof e3 ? e3 : k(+e3), s2 = null, h) : t2;
  }, h.x0 = function(e3) {
    return arguments.length ? (t2 = "function" == typeof e3 ? e3 : k(+e3), h) : t2;
  }, h.x1 = function(t3) {
    return arguments.length ? (s2 = null == t3 ? null : "function" == typeof t3 ? t3 : k(+t3), h) : s2;
  }, h.y = function(t3) {
    return arguments.length ? (e2 = "function" == typeof t3 ? t3 : k(+t3), i = null, h) : e2;
  }, h.y0 = function(t3) {
    return arguments.length ? (e2 = "function" == typeof t3 ? t3 : k(+t3), h) : e2;
  }, h.y1 = function(t3) {
    return arguments.length ? (i = null == t3 ? null : "function" == typeof t3 ? t3 : k(+t3), h) : i;
  }, h.lineX0 = h.lineY0 = function() {
    return c().x(t2).y(e2);
  }, h.lineY1 = function() {
    return c().x(t2).y(i);
  }, h.lineX1 = function() {
    return c().x(s2).y(e2);
  }, h.defined = function(t3) {
    return arguments.length ? (a = "function" == typeof t3 ? t3 : k(!!t3), h) : a;
  }, h.curve = function(t3) {
    return arguments.length ? (n2 = t3, null != o2 && (r = n2(o2)), h) : n2;
  }, h.context = function(t3) {
    return arguments.length ? (null == t3 ? o2 = r = null : r = n2(o2 = t3), h) : o2;
  }, h;
}
tt2.prototype = { areaStart: function() {
  this._line = 0;
}, areaEnd: function() {
  this._line = NaN;
}, lineStart: function() {
  this._point = 0;
}, lineEnd: function() {
  (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
}, point: function(t2, e2) {
  switch (t2 = +t2, e2 = +e2, this._point) {
    case 0:
      this._point = 1, this._line ? this._context.lineTo(t2, e2) : this._context.moveTo(t2, e2);
      break;
    case 1:
      this._point = 2;
    default:
      this._context.lineTo(t2, e2);
  }
} };
var nt = class extends ti {
  setupDefaultRules() {
    super.setupDefaultRules();
    const t2 = this._root.interfaceColors, l3 = this._root.language, h = this.rule.bind(this);
    h("XYChart").setAll({ colors: s.new(this._root, {}), paddingLeft: 20, paddingRight: 20, paddingTop: 16, paddingBottom: 16, panX: false, panY: false, wheelStep: 0.25, arrangeTooltips: true, pinchZoomX: false, pinchZoomY: false }), h("XYSeries").setAll({ legendLabelText: "{name}" }), h("XYChart", ["scrollbar", "chart"]).setAll({ paddingBottom: 0, paddingLeft: 0, paddingTop: 0, paddingRight: 0, colors: s.new(this._root, { saturation: 0 }) });
    {
      const e2 = h("Graphics", ["scrollbar", "overlay"]);
      e2.setAll({ fillOpacity: 0.5 }), l2(e2, "fill", t2, "background");
    }
    h("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({ cornerRadiusTR: 0, cornerRadiusTL: 0, cornerRadiusBR: 0, cornerRadiusBL: 0, fillOpacity: 0, focusable: true }), h("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 }), h("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({ cornerRadiusTL: 0, cornerRadiusBL: 0, cornerRadiusTR: 0, cornerRadiusBR: 0 }), h("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({ cornerRadiusBL: 40, cornerRadiusBR: 40, cornerRadiusTL: 40, cornerRadiusTR: 40 }), h("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({ strokeOpacity: 0, inside: true }), h("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({ strokeOpacity: 0, inside: true, minGridDistance: 5 }), h("AxisLabel", ["xy", "scrollbar", "x"]).setAll({ opacity: 0.5, centerY: z, minPosition: 0.01, maxPosition: 0.99, fontSize: "0.8em" }), h("AxisLabel", ["category"]).setAll({ text: "{category}", populateText: true }), h("AxisLabel", ["x"]).setAll({ centerY: 0 }), h("AxisLabel", ["x", "inside"]).setAll({ centerY: z }), h("AxisLabel", ["x", "inside", "opposite"]).setAll({ centerY: 0 }), h("AxisLabel", ["x", "opposite"]).setAll({ centerY: z }), h("AxisLabel", ["y"]).setAll({ centerX: z }), h("AxisLabel", ["y", "inside"]).setAll({ centerX: 0 }), h("AxisLabel", ["y", "inside", "opposite"]).setAll({ centerX: z }), h("AxisLabel", ["y", "opposite"]).setAll({ centerX: 0 }), h("AxisLabel", ["xy", "scrollbar", "y"]).setAll({ visible: false }), h("Grid", ["xy", "scrollbar", "y"]).setAll({ visible: false }), h("Grid", ["xy", "scrollbar", "x"]).setAll({ opacity: 0.5 }), h("XYCursor").setAll({ behavior: "none", layer: 30, exportable: false, snapToSeriesBy: "xy", moveThreshold: 1 });
    {
      const e2 = h("Grid", ["cursor", "x"]);
      e2.setAll({ strokeOpacity: 0.8, strokeDasharray: [2, 2], ariaLabel: l3.translate("Use left and right arrows to move selection") }), l2(e2, "stroke", t2, "alternativeBackground");
    }
    {
      const e2 = h("Grid", ["cursor", "y"]);
      e2.setAll({ strokeOpacity: 0.8, strokeDasharray: [2, 2], ariaLabel: l3.translate("Use up and down arrows to move selection") }), l2(e2, "stroke", t2, "alternativeBackground");
    }
    {
      const e2 = h("Graphics", ["cursor", "selection"]);
      e2.setAll({ fillOpacity: 0.15 }), l2(e2, "fill", t2, "alternativeBackground");
    }
    h("Axis").setAll({ start: 0, end: 1, minZoomCount: 1, maxZoomCount: 1 / 0, maxZoomFactor: 1e3, maxDeviation: 0.1, snapTooltip: true, tooltipLocation: 0.5, panX: true, panY: true, zoomX: true, zoomY: true, fixAxisSize: true }), h("AxisLabel").setAll({ location: 0.5, multiLocation: 0, centerX: G, centerY: G, paddingTop: 3, paddingBottom: 3, paddingLeft: 5, paddingRight: 5 }), h("Container", ["axis", "header"]).setAll({ layer: 30 }), h("Rectangle", ["axis", "header", "background"]).setAll({ crisp: true });
    {
      const e2 = h("AxisRenderer");
      e2.setAll({ crisp: true, strokeOpacity: 0 }), l2(e2, "stroke", t2, "grid");
    }
    h("AxisRendererX").setAll({ minGridDistance: 120, opposite: false, inversed: false, cellStartLocation: 0, cellEndLocation: 1, width: z }), h("AxisRendererY").setAll({ minGridDistance: 40, opposite: false, inversed: false, cellStartLocation: 0, cellEndLocation: 1, height: z });
    {
      const e2 = h("Rectangle", ["axis", "thumb"]);
      e2.setAll({ fillOpacity: 0 }), l2(e2, "fill", t2, "alternativeBackground"), e2.states.create("hover", { fillOpacity: 0.1 });
    }
    h("Rectangle", ["axis", "thumb", "x"]).setAll({ cursorOverStyle: "ew-resize" }), h("Rectangle", ["axis", "thumb", "y"]).setAll({ cursorOverStyle: "ns-resize" });
    {
      const e2 = h("Grid");
      e2.setAll({ location: 0, strokeOpacity: 0.15, crisp: true }), l2(e2, "stroke", t2, "grid");
    }
    h("Grid", ["base"]).setAll({ strokeOpacity: 0.3 });
    {
      const e2 = h("Graphics", ["axis", "fill"]);
      e2.setAll({ visible: false, isMeasured: false, position: "absolute", fillOpacity: 0.05 }), l2(e2, "fill", t2, "alternativeBackground");
    }
    h("Graphics", ["axis", "fill", "range"]).setAll({ isMeasured: true }), h("Graphics", ["series", "fill", "range"]).setAll({ visible: false, isMeasured: true }), h("Grid", ["series", "range"]).setAll({ visible: false }), h("AxisTick", ["series", "range"]).setAll({ visible: false }), h("AxisLabel", ["series", "range"]).setAll({ visible: false });
    {
      const e2 = h("AxisTick");
      e2.setAll({ location: 0.5, multiLocation: 0, strokeOpacity: 1, isMeasured: false, position: "absolute", visible: false }), l2(e2, "stroke", t2, "grid");
    }
    h("CategoryAxis").setAll({ startLocation: 0, endLocation: 1, fillRule: (t3, e2) => {
      const i = t3.get("axisFill");
      i && (l(e2) && e2 % 2 != 0 ? i.setPrivate("visible", false) : i.setPrivate("visible", true));
    } });
    const c = [{ timeUnit: "millisecond", count: 1 }, { timeUnit: "millisecond", count: 5 }, { timeUnit: "millisecond", count: 10 }, { timeUnit: "millisecond", count: 50 }, { timeUnit: "millisecond", count: 100 }, { timeUnit: "millisecond", count: 500 }, { timeUnit: "second", count: 1 }, { timeUnit: "second", count: 5 }, { timeUnit: "second", count: 10 }, { timeUnit: "second", count: 30 }, { timeUnit: "minute", count: 1 }, { timeUnit: "minute", count: 5 }, { timeUnit: "minute", count: 10 }, { timeUnit: "minute", count: 15 }, { timeUnit: "minute", count: 30 }, { timeUnit: "hour", count: 1 }, { timeUnit: "hour", count: 3 }, { timeUnit: "hour", count: 6 }, { timeUnit: "hour", count: 12 }, { timeUnit: "day", count: 1 }, { timeUnit: "day", count: 2 }, { timeUnit: "day", count: 3 }, { timeUnit: "day", count: 4 }, { timeUnit: "day", count: 5 }, { timeUnit: "week", count: 1 }, { timeUnit: "month", count: 1 }, { timeUnit: "month", count: 2 }, { timeUnit: "month", count: 3 }, { timeUnit: "month", count: 6 }, { timeUnit: "year", count: 1 }, { timeUnit: "year", count: 2 }, { timeUnit: "year", count: 5 }, { timeUnit: "year", count: 10 }, { timeUnit: "year", count: 50 }, { timeUnit: "year", count: 100 }, { timeUnit: "year", count: 200 }, { timeUnit: "year", count: 500 }, { timeUnit: "year", count: 1e3 }, { timeUnit: "year", count: 2e3 }, { timeUnit: "year", count: 5e3 }, { timeUnit: "year", count: 1e4 }, { timeUnit: "year", count: 1e5 }], d = { millisecond: l3.translate("_date_millisecond"), second: l3.translate("_date_second"), minute: l3.translate("_date_minute"), hour: l3.translate("_date_hour"), day: l3.translate("_date_day"), week: l3.translate("_date_day"), month: l3.translate("_date_month"), year: l3.translate("_date_year") }, u = { millisecond: l3.translate("_date_millisecond"), second: l3.translate("_date_second"), minute: l3.translate("_date_minute"), hour: l3.translate("_date_day"), day: l3.translate("_date_day"), week: l3.translate("_date_day"), month: l3.translate("_date_month") + " " + l3.translate("_date_year"), year: l3.translate("_date_year") }, g2 = { millisecond: l3.translate("_date_millisecond_full"), second: l3.translate("_date_second_full"), minute: l3.translate("_date_minute_full"), hour: l3.translate("_date_hour_full"), day: l3.translate("_date_day_full"), week: l3.translate("_date_week_full"), month: l3.translate("_date_month_full"), year: l3.translate("_date_year") };
    h("CategoryDateAxis").setAll({ markUnitChange: true, gridIntervals: P(c), dateFormats: $(d), periodChangeDateFormats: $(u) }), h("DateAxis").setAll({ maxZoomFactor: null, strictMinMax: true, startLocation: 0, endLocation: 1, markUnitChange: true, groupData: false, groupCount: 500, gridIntervals: P(c), dateFormats: $(d), periodChangeDateFormats: $(u), tooltipDateFormats: g2, groupIntervals: [{ timeUnit: "millisecond", count: 1 }, { timeUnit: "millisecond", count: 10 }, { timeUnit: "millisecond", count: 100 }, { timeUnit: "second", count: 1 }, { timeUnit: "second", count: 10 }, { timeUnit: "minute", count: 1 }, { timeUnit: "minute", count: 10 }, { timeUnit: "hour", count: 1 }, { timeUnit: "day", count: 1 }, { timeUnit: "week", count: 1 }, { timeUnit: "month", count: 1 }, { timeUnit: "year", count: 1 }], fillRule: (t3) => {
      const e2 = t3.get("axisFill");
      if (e2) {
        const i = t3.component, s2 = t3.get("value"), a = t3.get("endValue"), o2 = i.intervalDuration(), n2 = i.getPrivate("baseInterval"), r = i.getPrivate("gridInterval", n2);
        let l4 = i.getPrivate("min", 0);
        if (l4 = I(new Date(l4), r.timeUnit, r.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), null != s2 && null != a) {
          const t4 = Math.round(Math.round((s2 - l4) / o2)) / 2;
          t4 == Math.round(t4) ? e2.setPrivate("visible", true) : e2.setPrivate("visible", false);
        }
      }
    } }), h("GaplessDateAxis").setAll({ fillRule: (t3) => {
      const e2 = t3.get("axisFill");
      if (e2) {
        const i = t3.get("index");
        let a = false;
        l(i) && i % 2 != 0 || (a = true), e2.setPrivate("visible", a);
      }
    } }), h("ValueAxis").setAll({ baseValue: 0, logarithmic: false, strictMinMax: false, autoZoom: true, fillRule: (t3) => {
      const e2 = t3.get("axisFill");
      if (e2) {
        const i = t3.component, a = t3.get("value"), o2 = i.getPrivate("step");
        l(a) && l(o2) && (re(a / o2 / 2, 5) == Math.round(a / o2 / 2) ? e2.setPrivate("visible", false) : e2.setPrivate("visible", true));
      }
    } }), h("DurationAxis").setAll({ baseUnit: "second" }), h("XYSeries").setAll({ maskBullets: true, stackToNegative: true, locationX: 0.5, locationY: 0.5, snapTooltip: false, openValueXGrouped: "open", openValueYGrouped: "open", valueXGrouped: "close", valueYGrouped: "close", seriesTooltipTarget: "series" }), h("BaseColumnSeries").setAll({ adjustBulletPosition: true }), h("ColumnSeries").setAll({ clustered: true }), h("RoundedRectangle", ["series", "column"]).setAll({ position: "absolute", isMeasured: false, width: U(70), height: U(70), strokeWidth: 1, strokeOpacity: 1, cornerRadiusBL: 0, cornerRadiusTL: 0, cornerRadiusBR: 0, cornerRadiusTR: 0, fillOpacity: 1, role: "figure" }), h("LineSeries").setAll({ connect: true, autoGapCount: 1.1, stackToNegative: false }), h("Graphics", ["series", "stroke"]).setAll({ position: "absolute", strokeWidth: 1, strokeOpacity: 1, isMeasured: false }), h("Graphics", ["series", "fill"]).setAll({ visible: false, fillOpacity: 0, position: "absolute", strokeWidth: 0, strokeOpacity: 0, isMeasured: false }), h("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({ draw: (t3, e2) => {
      const i = e2.parent;
      if (i) {
        const e3 = i.height(), s2 = i.width();
        t3.moveTo(0, e3 / 2), t3.lineTo(s2, e3 / 2);
      }
    } });
    {
      const e2 = h("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
      l2(e2, "stroke", t2, "disabled");
    }
    h("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({ draw: (t3, e2) => {
      const i = e2.parent;
      if (i) {
        const e3 = i.height(), s2 = i.width();
        t3.moveTo(0, 0), t3.lineTo(s2, 0), t3.lineTo(s2, e3), t3.lineTo(0, e3), t3.lineTo(0, 0);
      }
    } });
    {
      const e2 = h("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
      l2(e2, "stroke", t2, "disabled");
    }
    h("SmoothedXYLineSeries").setAll({ tension: 0.5 }), h("SmoothedXLineSeries").setAll({ tension: 0.5 }), h("SmoothedYLineSeries").setAll({ tension: 0.5 }), h("Candlestick").setAll({ position: "absolute", isMeasured: false, width: U(50), height: U(50), strokeWidth: 1, strokeOpacity: 1, cornerRadiusBL: 0, cornerRadiusTL: 0, cornerRadiusBR: 0, cornerRadiusTR: 0, fillOpacity: 1, role: "figure" }), h("OHLC").setAll({ width: U(80), height: U(80) }), h("CandlestickSeries").setAll({ lowValueXGrouped: "low", lowValueYGrouped: "low", highValueXGrouped: "high", highValueYGrouped: "high", openValueXGrouped: "open", openValueYGrouped: "open", valueXGrouped: "close", valueYGrouped: "close" });
    {
      const e2 = h("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
      l2(e2, "fill", t2, "positive"), l2(e2, "stroke", t2, "positive");
    }
    {
      const e2 = h("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
      l2(e2, "fill", t2, "negative"), l2(e2, "stroke", t2, "negative");
    }
    h("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 }), h("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
    {
      const e2 = h("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
      l2(e2, "fill", t2, "positive"), l2(e2, "stroke", t2, "positive");
    }
    {
      const e2 = h("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
      l2(e2, "fill", t2, "negative"), l2(e2, "stroke", t2, "negative");
    }
  }
};
var rt = class extends U2 {
  constructor() {
    super(...arguments), Object.defineProperty(this, "xAxes", { enumerable: true, configurable: true, writable: true, value: new F() }), Object.defineProperty(this, "yAxes", { enumerable: true, configurable: true, writable: true, value: new F() }), Object.defineProperty(this, "topAxesContainer", { enumerable: true, configurable: true, writable: true, value: this.chartContainer.children.push(Je.new(this._root, { width: z, layout: this._root.verticalLayout })) }), Object.defineProperty(this, "yAxesAndPlotContainer", { enumerable: true, configurable: true, writable: true, value: this.chartContainer.children.push(Je.new(this._root, { width: z, height: z, layout: this._root.horizontalLayout })) }), Object.defineProperty(this, "bottomAxesContainer", { enumerable: true, configurable: true, writable: true, value: this.chartContainer.children.push(Je.new(this._root, { width: z, layout: this._root.verticalLayout })) }), Object.defineProperty(this, "leftAxesContainer", { enumerable: true, configurable: true, writable: true, value: this.yAxesAndPlotContainer.children.push(Je.new(this._root, { height: z, layout: this._root.horizontalLayout })) }), Object.defineProperty(this, "plotsContainer", { enumerable: true, configurable: true, writable: true, value: this.yAxesAndPlotContainer.children.push(Je.new(this._root, { width: z, height: z, maskContent: false })) }), Object.defineProperty(this, "plotContainer", { enumerable: true, configurable: true, writable: true, value: this.plotsContainer.children.push(Je.new(this._root, { width: z, height: z })) }), Object.defineProperty(this, "topPlotContainer", { enumerable: true, configurable: true, writable: true, value: this.plotsContainer.children.push(Je.new(this._root, { width: z, height: z })) }), Object.defineProperty(this, "gridContainer", { enumerable: true, configurable: true, writable: true, value: this.plotContainer.children.push(Je.new(this._root, { width: z, height: z, isMeasured: false })) }), Object.defineProperty(this, "topGridContainer", { enumerable: true, configurable: true, writable: true, value: Je.new(this._root, { width: z, height: z, isMeasured: false }) }), Object.defineProperty(this, "rightAxesContainer", { enumerable: true, configurable: true, writable: true, value: this.yAxesAndPlotContainer.children.push(Je.new(this._root, { height: z, layout: this._root.horizontalLayout })) }), Object.defineProperty(this, "axisHeadersContainer", { enumerable: true, configurable: true, writable: true, value: this.plotContainer.children.push(Je.new(this._root, {})) }), Object.defineProperty(this, "zoomOutButton", { enumerable: true, configurable: true, writable: true, value: this.topPlotContainer.children.push(o.new(this._root, { themeTags: ["zoom"], icon: Re.new(this._root, { themeTags: ["button", "icon"] }) })) }), Object.defineProperty(this, "_movePoint", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0 } }), Object.defineProperty(this, "_wheelDp", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_otherCharts", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_movePoints", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "_downStartX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_downEndX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_downStartY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_downEndY", { enumerable: true, configurable: true, writable: true, value: void 0 });
  }
  _afterNew() {
    this._defaultThemes.push(nt.new(this._root)), super._afterNew(), this._disposers.push(this.xAxes), this._disposers.push(this.yAxes);
    const t2 = this._root;
    let e2 = this._root.verticalLayout;
    const i = this.zoomOutButton;
    i.events.on("click", () => {
      this.zoomOut();
    }), i.set("opacity", 0), i.states.lookup("default").set("opacity", 1), this.chartContainer.set("layout", e2);
    const s2 = this.plotContainer;
    s2.children.push(this.seriesContainer), this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer)), this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer)), s2.children.push(this.topGridContainer), s2.children.push(this.bulletsContainer), s2.set("interactive", true), s2.set("interactiveChildren", false), s2.set("background", Fe.new(t2, { themeTags: ["xy", "background"], fill: Xt.fromHex(0), fillOpacity: 0 })), this._disposers.push(s2.events.on("pointerdown", (t3) => {
      this._handlePlotDown(t3.originalEvent);
    })), this._disposers.push(s2.events.on("globalpointerup", (t3) => {
      this._handlePlotUp(t3.originalEvent);
    })), this._disposers.push(s2.events.on("globalpointermove", (t3) => {
      this._handlePlotMove(t3.originalEvent);
    })), this._maskGrid(), this._setUpTouch();
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) && this._setUpTouch();
  }
  _setUpTouch() {
    this.plotContainer._display.cancelTouch || (this.plotContainer._display.cancelTouch = !!(this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")));
  }
  _maskGrid() {
    this.gridContainer.set("maskContent", true), this.topGridContainer.set("maskContent", true);
  }
  _removeSeries(t2) {
    const e2 = t2.get("xAxis");
    e2 && (v(e2.series, t2), e2.markDirtyExtremes());
    const i = t2.get("yAxis");
    i && (v(i.series, t2), i.markDirtyExtremes());
    const s2 = this.get("cursor");
    if (s2) {
      const e3 = s2.get("snapToSeries");
      e3 && v(e3, t2);
    }
    super._removeSeries(t2);
  }
  handleWheel(t2) {
    const e2 = this.get("wheelX"), i = this.get("wheelY"), s2 = this.plotContainer, a = t2.originalEvent;
    if (!pt(a, this))
      return;
    a.preventDefault();
    const o2 = s2.toLocal(this._root.documentPointToRoot({ x: a.clientX, y: a.clientY })), n2 = this.get("wheelStep", 0.2), r = a.deltaY / 100, l3 = a.deltaX / 100, h = this.get("wheelZoomPositionX"), c = this.get("wheelZoomPositionY");
    "zoomX" !== e2 && "zoomXY" !== e2 || 0 == l3 || this.xAxes.each((t3) => {
      if (t3.get("zoomX")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), a2 = t3.fixPosition(o2.x / s2.width());
        null != h && (a2 = h);
        let r2 = e3 - n2 * (i2 - e3) * l3 * a2, c2 = i2 + n2 * (i2 - e3) * l3 * (1 - a2);
        1 / (c2 - r2) < t3.getPrivate("maxZoomFactor", 1 / 0) / t3.get("minZoomCount", 1) && this._handleWheelAnimation(t3.zoom(r2, c2));
      }
    }), "zoomX" !== i && "zoomXY" !== i || 0 == r || this.xAxes.each((t3) => {
      if (t3.get("zoomX")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), a2 = t3.fixPosition(o2.x / s2.width());
        null != h && (a2 = h);
        let l4 = e3 - n2 * (i2 - e3) * r * a2, c2 = i2 + n2 * (i2 - e3) * r * (1 - a2);
        1 / (c2 - l4) < t3.getPrivate("maxZoomFactor", 1 / 0) / t3.get("minZoomCount", 1) && this._handleWheelAnimation(t3.zoom(l4, c2));
      }
    }), "zoomY" !== e2 && "zoomXY" !== e2 || 0 == l3 || this.yAxes.each((t3) => {
      if (t3.get("zoomY")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), a2 = t3.fixPosition(o2.y / s2.height());
        null != c && (a2 = c);
        let r2 = e3 - n2 * (i2 - e3) * l3 * a2, h2 = i2 + n2 * (i2 - e3) * l3 * (1 - a2);
        1 / (h2 - r2) < t3.getPrivate("maxZoomFactor", 1 / 0) / t3.get("minZoomCount", 1) && this._handleWheelAnimation(t3.zoom(r2, h2));
      }
    }), "zoomY" !== i && "zoomXY" !== i || 0 == r || this.yAxes.each((t3) => {
      if (t3.get("zoomY")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), a2 = t3.fixPosition(o2.y / s2.height());
        null != c && (a2 = c);
        let l4 = e3 - n2 * (i2 - e3) * r * a2, h2 = i2 + n2 * (i2 - e3) * r * (1 - a2);
        1 / (h2 - l4) < t3.getPrivate("maxZoomFactor", 1 / 0) / t3.get("minZoomCount", 1) && this._handleWheelAnimation(t3.zoom(l4, h2));
      }
    }), "panX" !== e2 && "panXY" !== e2 || 0 == l3 || this.xAxes.each((t3) => {
      if (t3.get("panX")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), s3 = this._getWheelSign(t3) * n2 * (i2 - e3) * l3, a2 = e3 + s3, o3 = i2 + s3, r2 = this._fixWheel(a2, o3);
        a2 = r2[0], o3 = r2[1], this._handleWheelAnimation(t3.zoom(a2, o3));
      }
    }), "panX" !== i && "panXY" !== i || 0 == r || this.xAxes.each((t3) => {
      if (t3.get("panX")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), s3 = this._getWheelSign(t3) * n2 * (i2 - e3) * r, a2 = e3 + s3, o3 = i2 + s3, l4 = this._fixWheel(a2, o3);
        a2 = l4[0], o3 = l4[1], this._handleWheelAnimation(t3.zoom(a2, o3));
      }
    }), "panY" !== e2 && "panXY" !== e2 || 0 == l3 || this.yAxes.each((t3) => {
      if (t3.get("panY")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), s3 = this._getWheelSign(t3) * n2 * (i2 - e3) * l3, a2 = e3 + s3, o3 = i2 + s3, r2 = this._fixWheel(a2, o3);
        a2 = r2[0], o3 = r2[1], this._handleWheelAnimation(t3.zoom(a2, o3));
      }
    }), "panY" !== i && "panXY" !== i || 0 == r || this.yAxes.each((t3) => {
      if (t3.get("panY")) {
        let e3 = t3.get("start"), i2 = t3.get("end"), s3 = this._getWheelSign(t3) * n2 * (i2 - e3) * r, a2 = e3 - s3, o3 = i2 - s3, l4 = this._fixWheel(a2, o3);
        a2 = l4[0], o3 = l4[1], this._handleWheelAnimation(t3.zoom(a2, o3));
      }
    });
  }
  _handleSetWheel() {
    const t2 = this.get("wheelX"), e2 = this.get("wheelY"), i = this.plotContainer;
    "none" !== t2 || "none" !== e2 ? (this._wheelDp = i.events.on("wheel", (t3) => {
      this.handleWheel(t3);
    }), this._disposers.push(this._wheelDp)) : this._wheelDp && this._wheelDp.dispose();
  }
  _getWheelSign(t2) {
    let e2 = 1;
    return t2.get("renderer").get("inversed") && (e2 = -1), e2;
  }
  _fixWheel(t2, e2) {
    const i = e2 - t2;
    return t2 < 0 && (e2 = (t2 = 0) + i), e2 > 1 && (t2 = (e2 = 1) - i), [t2, e2];
  }
  _handlePlotDown(t2) {
    if (2 == t2.button)
      return;
    const e2 = this.plotContainer;
    let i = e2.toLocal(this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY }));
    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
      if (t2.pointerId && Y(e2._downPoints).length > 0) {
        const t3 = this.xAxes.getIndex(0), e3 = this.yAxes.getIndex(0);
        t3 && (this._downStartX = t3.get("start", 0), this._downEndX = t3.get("end", 1)), e3 && (this._downStartY = e3.get("start", 0), this._downEndY = e3.get("end", 1));
      }
    }
    if ((this.get("panX") || this.get("panY")) && i.x >= 0 && i.y >= 0 && i.x <= e2.width() && i.y <= this.height()) {
      this._downPoint = { x: t2.clientX, y: t2.clientY };
      const e3 = this.get("panX"), i2 = this.get("panY");
      e3 && this.xAxes.each((t3) => {
        t3._panStart = t3.get("start"), t3._panEnd = t3.get("end");
      }), i2 && this.yAxes.each((t3) => {
        t3._panStart = t3.get("start"), t3._panEnd = t3.get("end");
      });
      const s2 = "panstarted";
      this.events.isEnabled(s2) && this.events.dispatch(s2, { type: s2, target: this, originalEvent: t2 });
    }
  }
  _handleWheelAnimation(t2) {
    t2 ? t2.events.on("stopped", () => {
      this._dispatchWheelAnimation();
    }) : this._dispatchWheelAnimation();
  }
  _dispatchWheelAnimation() {
    const t2 = "wheelended";
    this.events.isEnabled(t2) && this.events.dispatch(t2, { type: t2, target: this });
  }
  _handlePlotUp(t2) {
    const e2 = this._downPoint;
    if (e2 && (this.get("panX") || this.get("panY"))) {
      let i = this.plotContainer.toLocal(this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY }));
      if (i.x == e2.x && i.y == e2.y) {
        const e3 = "pancancelled";
        this.events.isEnabled(e3) && this.events.dispatch(e3, { type: e3, target: this, originalEvent: t2 });
      }
      const s2 = "panended";
      this.events.isEnabled(s2) && this.events.dispatch(s2, { type: s2, target: this, originalEvent: t2 });
    }
    this._downPoint = void 0, this.xAxes.each((t3) => {
      t3._isPanning = false;
    }), this.yAxes.each((t3) => {
      t3._isPanning = false;
    });
  }
  _handlePlotMove(t2) {
    const e2 = this.plotContainer;
    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
      const i2 = t2.pointerId;
      if (i2 && (this._movePoints[i2] = this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY }), Y(e2._downPoints).length > 1))
        return void this._handlePinch();
    }
    let i = this._downPoint;
    if (i) {
      i = e2.toLocal(this._root.documentPointToRoot(i));
      let s2 = e2.toLocal(this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY }));
      const a = this.get("panX"), o2 = this.get("panY");
      if (a) {
        let t3 = this.get("scrollbarX");
        t3 && t3.events.disableType("rangechanged"), this.xAxes.each((t4) => {
          if (t4.get("panX")) {
            t4._isPanning = true;
            let a2 = t4._panStart, o3 = t4._panEnd, n2 = (o3 - a2) * (i.x - s2.x) / e2.width();
            t4.get("renderer").get("inversed") && (n2 *= -1);
            let r = a2 + n2, l3 = o3 + n2;
            l3 - r < 1 + 2 * t4.get("maxDeviation", 1) && (t4.set("start", r), t4.set("end", l3));
          }
        }), t3 && t3.events.enableType("rangechanged");
      }
      if (o2) {
        let t3 = this.get("scrollbarY");
        t3 && t3.events.disableType("rangechanged"), this.yAxes.each((t4) => {
          if (t4.get("panY")) {
            t4._isPanning = true;
            let a2 = t4._panStart, o3 = t4._panEnd, n2 = (o3 - a2) * (i.y - s2.y) / e2.height();
            t4.get("renderer").get("inversed") && (n2 *= -1);
            let r = a2 - n2, l3 = o3 - n2;
            l3 - r < 1 + 2 * t4.get("maxDeviation", 1) && (t4.set("start", r), t4.set("end", l3));
          }
        }), t3 && t3.events.enableType("rangechanged");
      }
    }
  }
  _handlePinch() {
    const t2 = this.plotContainer;
    let e2 = 0, i = [], s2 = [];
    if (Z(t2._downPoints, (t3, a) => {
      i[e2] = a;
      let o2 = this._movePoints[t3];
      o2 && (s2[e2] = o2), e2++;
    }), i.length > 1 && s2.length > 1) {
      const e3 = t2.width(), a = t2.height();
      let o2 = i[0], n2 = i[1], r = s2[0], l3 = s2[1];
      if (o2 && n2 && r && l3) {
        if (r = t2.toLocal(r), l3 = t2.toLocal(l3), o2 = t2.toLocal(o2), n2 = t2.toLocal(n2), this.get("pinchZoomX")) {
          const t3 = this._downStartX, i2 = this._downEndX;
          if (null != t3 && null != i2) {
            o2.x > n2.x && ([o2, n2] = [n2, o2], [r, l3] = [l3, r]);
            let s3 = t3 + o2.x / e3 * (i2 - t3), a2 = t3 + n2.x / e3 * (i2 - t3), h = t3 + r.x / e3 * (i2 - t3), c = t3 + l3.x / e3 * (i2 - t3), d = Math.max(1e-3, a2 - s3) / Math.max(1e-3, c - h), u = t3 * d + s3 - h * d, g2 = i2 * d + a2 - c * d;
            this.xAxes.each((t4) => {
              let e4 = t4.fixPosition(u), i3 = t4.fixPosition(g2);
              t4.zoom(e4, i3, 0);
            });
          }
        }
        if (this.get("pinchZoomY")) {
          const t3 = this._downStartY, e4 = this._downEndY;
          if (null != t3 && null != e4) {
            o2.y < n2.y && ([o2, n2] = [n2, o2], [r, l3] = [l3, r]);
            let i2 = t3 + (1 - o2.y / a) * (e4 - t3), s3 = t3 + (1 - n2.y / a) * (e4 - t3), h = t3 + (1 - r.y / a) * (e4 - t3), c = t3 + (1 - l3.y / a) * (e4 - t3), d = Math.max(1e-3, s3 - i2) / Math.max(1e-3, c - h), u = t3 * d + i2 - h * d, g2 = e4 * d + s3 - c * d;
            this.yAxes.each((t4) => {
              let e5 = t4.fixPosition(u), i3 = t4.fixPosition(g2);
              t4.zoom(e5, i3, 0);
            });
          }
        }
      }
    }
  }
  _handleCursorPosition() {
    const t2 = this.get("cursor");
    if (t2) {
      const e2 = t2.getPrivate("point");
      let i = t2.get("snapToSeries");
      if (t2._downPoint && (i = void 0), i && e2) {
        const s2 = t2.get("snapToSeriesBy"), a = [];
        m(i, (t3) => {
          if (!t3.isHidden() && !t3.isHiding())
            if ("x!" != s2 && "y!" != s2) {
              const e3 = t3.startIndex(), i2 = t3.endIndex();
              for (let s3 = e3; s3 < i2; s3++) {
                const e4 = t3.dataItems[s3];
                e4 && !e4.isHidden() && a.push(e4);
              }
            } else {
              const e3 = t3.get("tooltipDataItem");
              e3 && a.push(e3);
            }
        });
        let o2, n2 = 1 / 0;
        if (m(a, (t3) => {
          const i2 = t3.get("point");
          if (i2) {
            let a2 = 0;
            a2 = "x" == s2 || "x!" == s2 ? Math.abs(e2.x - i2.x) : "y" == s2 || "y!" == s2 ? Math.abs(e2.y - i2.y) : Math.hypot(e2.x - i2.x, e2.y - i2.y), a2 < n2 && (n2 = a2, o2 = t3);
          }
        }), m(i, (t3) => {
          const e3 = t3.get("tooltip");
          e3 && e3._setDataItem(void 0);
        }), o2) {
          let e3 = o2.component;
          e3.showDataItemTooltip(o2);
          const i2 = o2.get("point");
          i2 && t2.handleMove(e3.toGlobal({ x: i2.x - e3.x(), y: i2.y - e3.y() }), true);
        }
      }
    }
  }
  _updateCursor() {
    let t2 = this.get("cursor");
    t2 && t2.handleMove();
  }
  _addCursor(t2) {
    this.plotContainer.children.push(t2);
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.series.each((t2) => {
      this._colorize(t2);
    }), (this.isDirty("wheelX") || this.isDirty("wheelY")) && this._handleSetWheel(), this.isDirty("cursor")) {
      const t2 = this._prevSettings.cursor, e2 = this.get("cursor");
      e2 !== t2 && (this._disposeProperty("cursor"), t2 && t2.dispose(), e2 && (e2._setChart(this), this._addCursor(e2), this._pushPropertyDisposer("cursor", e2.events.on("selectended", () => {
        this._handleCursorSelectEnd();
      }))), this._prevSettings.cursor = e2);
    }
    if (this.isDirty("scrollbarX")) {
      const t2 = this._prevSettings.scrollbarX, e2 = this.get("scrollbarX");
      e2 !== t2 && (this._disposeProperty("scrollbarX"), t2 && t2.dispose(), e2 && (e2.parent || this.topAxesContainer.children.push(e2), this._pushPropertyDisposer("scrollbarX", e2.events.on("rangechanged", (t3) => {
        this._handleScrollbar(this.xAxes, t3.start, t3.end, t3.grip);
      })), e2.setPrivate("positionTextFunction", (t3) => {
        const e3 = this.xAxes.getIndex(0);
        return e3 && e3.getTooltipText(t3) || "";
      })), this._prevSettings.scrollbarX = e2);
    }
    if (this.isDirty("scrollbarY")) {
      const t2 = this._prevSettings.scrollbarY, e2 = this.get("scrollbarY");
      e2 !== t2 && (this._disposeProperty("scrollbarY"), t2 && t2.dispose(), e2 && (e2.parent || this.rightAxesContainer.children.push(e2), this._pushPropertyDisposer("scrollbarY", e2.events.on("rangechanged", (t3) => {
        this._handleScrollbar(this.yAxes, t3.start, t3.end, t3.grip);
      })), e2.setPrivate("positionTextFunction", (t3) => {
        const e3 = this.yAxes.getIndex(0);
        return e3 && e3.getTooltipText(t3) || "";
      })), this._prevSettings.scrollbarY = e2);
    }
    this._handleZoomOut();
  }
  _processSeries(t2) {
    super._processSeries(t2), this._colorize(t2);
  }
  _colorize(t2) {
    const e2 = this.get("colors");
    if (e2 && null == t2.get("fill")) {
      const i = e2.next();
      t2._setSoft("stroke", i), t2._setSoft("fill", i);
    }
  }
  _handleCursorSelectEnd() {
    const t2 = this.get("cursor"), e2 = t2.get("behavior"), i = t2.getPrivate("downPositionX", 0), s2 = t2.getPrivate("downPositionY", 0), a = t2.getPrivate("positionX", 0.5), o2 = t2.getPrivate("positionY", 0.5);
    this.xAxes.each((t3) => {
      if ("zoomX" === e2 || "zoomXY" === e2) {
        let e3 = t3.toAxisPosition(i), s3 = t3.toAxisPosition(a);
        t3.zoom(e3, s3);
      }
      t3.setPrivate("updateScrollbar", true);
    }), this.yAxes.each((t3) => {
      if ("zoomY" === e2 || "zoomXY" === e2) {
        let e3 = t3.toAxisPosition(s2), i2 = t3.toAxisPosition(o2);
        t3.zoom(e3, i2);
      }
      t3.setPrivate("updateScrollbar", true);
    });
  }
  _handleScrollbar(t2, e2, i, s2) {
    t2.each((t3) => {
      let a = t3.fixPosition(e2), o2 = t3.fixPosition(i), n2 = t3.zoom(a, o2, void 0, s2);
      const r = "updateScrollbar";
      t3.setPrivateRaw(r, false), n2 ? n2.events.on("stopped", () => {
        t3.setPrivateRaw(r, true);
      }) : t3.setPrivateRaw(r, true);
    });
  }
  _processAxis(t2, e2) {
    return t2.events.onAll((t3) => {
      if ("clear" === t3.type)
        m(t3.oldValues, (t4) => {
          this._removeAxis(t4);
        });
      else if ("push" === t3.type)
        e2.children.push(t3.newValue), t3.newValue.processChart(this);
      else if ("setIndex" === t3.type)
        e2.children.setIndex(t3.index, t3.newValue), t3.newValue.processChart(this);
      else if ("insertIndex" === t3.type)
        e2.children.insertIndex(t3.index, t3.newValue), t3.newValue.processChart(this);
      else if ("removeIndex" === t3.type)
        this._removeAxis(t3.oldValue);
      else {
        if ("moveIndex" !== t3.type)
          throw new Error("Unknown IListEvent type");
        e2.children.moveValue(t3.value, t3.newIndex), t3.value.processChart(this);
      }
    });
  }
  _removeAxis(t2) {
    if (!t2.isDisposed()) {
      const e2 = t2.parent;
      e2 && e2.children.removeValue(t2);
      const i = t2.gridContainer, s2 = i.parent;
      s2 && s2.children.removeValue(i);
      const a = t2.topGridContainer, o2 = a.parent;
      o2 && o2.children.removeValue(a);
    }
  }
  _updateChartLayout() {
    const t2 = this.leftAxesContainer.width(), e2 = this.rightAxesContainer.width(), i = this.bottomAxesContainer;
    i.set("paddingLeft", t2), i.set("paddingRight", e2);
    const s2 = this.topAxesContainer;
    s2.set("paddingLeft", t2), s2.set("paddingRight", e2);
  }
  processAxis(t2) {
  }
  _handleAxisSelection(t2, e2) {
    let i = t2.fixPosition(t2.get("start", 0)), s2 = t2.fixPosition(t2.get("end", 1));
    if (i > s2 && ([i, s2] = [s2, i]), -1 != this.xAxes.indexOf(t2)) {
      if (e2 || t2.getPrivate("updateScrollbar")) {
        let t3 = this.get("scrollbarX");
        !t3 || t3.getPrivate("isBusy") && !e2 || (t3.setRaw("start", i), t3.setRaw("end", s2), t3.updateGrips());
      }
    } else if (-1 != this.yAxes.indexOf(t2) && (e2 || t2.getPrivate("updateScrollbar"))) {
      let t3 = this.get("scrollbarY");
      !t3 || t3.getPrivate("isBusy") && !e2 || (t3.setRaw("start", i), t3.setRaw("end", s2), t3.updateGrips());
    }
    this._handleZoomOut();
  }
  _handleZoomOut() {
    let t2 = this.zoomOutButton;
    if (t2 && t2.parent) {
      let e2 = false;
      this.xAxes.each((t3) => {
        0 == t3.get("start") && 1 == t3.get("end") || (e2 = true);
      }), this.yAxes.each((t3) => {
        0 == t3.get("start") && 1 == t3.get("end") || (e2 = true);
      }), e2 ? t2.isHidden() && t2.show() : t2.hide();
    }
  }
  inPlot(t2) {
    const e2 = this.plotContainer, i = this.getPrivate("otherCharts", this._otherCharts), s2 = e2.toGlobal(t2);
    if (t2.x >= -0.5 && t2.y >= -0.5 && t2.x <= e2.width() + 0.5 && t2.y <= e2.height() + 0.5)
      return true;
    if (i)
      for (let a = i.length - 1; a >= 0; a--) {
        const t3 = i[a];
        if (t3 != this) {
          const e3 = t3.plotContainer, i2 = this._root.rootPointToDocument(s2), a2 = t3._root.documentPointToRoot(i2), o2 = e3.toLocal(a2);
          if (o2.x >= -0.1 && o2.y >= -0.1 && o2.x <= e3.width() + 0.1 && o2.y <= e3.height() + 0.1)
            return true;
        }
      }
    return false;
  }
  arrangeTooltips() {
    const t2 = this.plotContainer, e2 = t2.width(), i = t2.height(), a = this.height();
    let o2 = t2._display.toGlobal({ x: 0, y: 0 }), n2 = t2._display.toGlobal({ x: e2, y: i });
    const r = [];
    let l3, h, c = 0, d = 1 / 0, u = this._movePoint, g2 = this.get("maxTooltipDistance"), p = this.get("maxTooltipDistanceBy", "xy");
    l(g2) && this.series.each((t3) => {
      if (!t3.isHidden()) {
        const e3 = t3.get("tooltip");
        if (e3) {
          let i2 = e3.get("pointTo");
          if (i2) {
            let e4 = Math.hypot(u.x - i2.x, u.y - i2.y);
            "x" == p ? e4 = Math.abs(u.x - i2.x) : "y" == p && (e4 = Math.abs(u.y - i2.y)), e4 < d && (d = e4, l3 = t3, h = i2);
          }
        }
      }
    });
    const m2 = [];
    if (this.series.each((t3) => {
      const e3 = t3.get("tooltip");
      if (e3) {
        let i2 = false, s2 = e3.get("pointTo");
        if (s2) {
          if (g2 >= 0) {
            let s3 = e3.get("pointTo");
            if (s3 && t3 != l3) {
              let t4 = Math.hypot(h.x - s3.x, h.y - s3.y);
              "x" == p ? t4 = Math.abs(h.x - s3.x) : "y" == p && (t4 = Math.abs(h.y - s3.y)), t4 > g2 && (i2 = true);
            }
          } else
            -1 == g2 && t3 != l3 && (i2 = true);
          this.inPlot(this._tooltipToLocal(s2)) && e3.dataItem ? i2 || (c += s2.y) : i2 = true, i2 || t3.isHidden() || t3.isHiding() ? e3.hide(0) : (e3.show(), r.push(e3), m2.push(t3));
        }
      }
    }), this.setPrivate("tooltipSeries", m2), this.get("arrangeTooltips")) {
      const t3 = this._root.tooltipContainer, e3 = r.length;
      if (c / e3 > i / 2 + o2.y) {
        r.sort((t4, e5) => De(e5.get("pointTo").y, t4.get("pointTo").y));
        let e4 = n2.y;
        if (m(r, (i2) => {
          let s2 = i2.height(), a2 = i2.get("centerY");
          a2 instanceof K && (s2 *= a2.value), s2 += i2.get("marginBottom", 0), i2.set("bounds", { left: o2.x, top: o2.y, right: n2.x, bottom: e4 }), i2.setPrivate("customData", { left: o2.x, top: o2.y, right: n2.x, bottom: e4 }), e4 = Math.min(e4 - s2, i2._fy - s2), i2.parent == t3 && t3.children.moveValue(i2, 0);
        }), e4 < 0) {
          r.reverse();
          let t4 = e4;
          m(r, (i2) => {
            let s2 = i2.get("bounds");
            if (s2) {
              let a2 = s2.top - e4, o3 = s2.bottom - e4;
              a2 < t4 && (a2 = t4, o3 = a2 + i2.height()), i2.set("bounds", { left: s2.left, top: a2, right: s2.right, bottom: o3 }), t4 = s2.bottom - e4 + i2.get("marginBottom", 0);
            }
          });
        }
      } else {
        r.reverse(), r.sort((t4, e5) => De(t4.get("pointTo").y, e5.get("pointTo").y));
        let e4 = 0;
        if (m(r, (i2) => {
          let s2 = i2.height(), r2 = i2.get("centerY");
          r2 instanceof K && (s2 *= r2.value), s2 += i2.get("marginBottom", 0), i2.set("bounds", { left: o2.x, top: e4, right: n2.x, bottom: Math.max(o2.y + a, e4 + s2) }), i2.parent == t3 && t3.children.moveValue(i2, 0), e4 = Math.max(e4 + s2, i2._fy + s2);
        }), e4 > a) {
          r.reverse();
          let t4 = a;
          m(r, (i2) => {
            let s2 = i2.get("bounds");
            if (s2) {
              let o3 = s2.top - (a - e4), n3 = s2.bottom - (a - e4);
              n3 > t4 && (n3 = t4, o3 = n3 - i2.height()), i2.set("bounds", { left: s2.left, top: o3, right: s2.right, bottom: n3 }), t4 = n3 - i2.height() - i2.get("marginBottom", 0);
            }
          });
        }
      }
    }
  }
  _tooltipToLocal(t2) {
    return this.plotContainer.toLocal(t2);
  }
  zoomOut() {
    this.xAxes.each((t2) => {
      t2.setPrivate("updateScrollbar", true), t2.zoom(0, 1);
    }), this.yAxes.each((t2) => {
      t2.setPrivate("updateScrollbar", true), t2.zoom(0, 1);
    });
  }
};
Object.defineProperty(rt, "className", { enumerable: true, configurable: true, writable: true, value: "XYChart" }), Object.defineProperty(rt, "classNames", { enumerable: true, configurable: true, writable: true, value: U2.classNames.concat([rt.className]) });
var lt = class extends Re {
  _beforeChanged() {
    super._beforeChanged(), (this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = true);
  }
};
Object.defineProperty(lt, "className", { enumerable: true, configurable: true, writable: true, value: "Grid" }), Object.defineProperty(lt, "classNames", { enumerable: true, configurable: true, writable: true, value: Re.classNames.concat([lt.className]) });
var ht = class extends Je {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lineX", { enumerable: true, configurable: true, writable: true, value: this.children.push(lt.new(this._root, { themeTags: ["x"] })) }), Object.defineProperty(this, "lineY", { enumerable: true, configurable: true, writable: true, value: this.children.push(lt.new(this._root, { themeTags: ["y"] })) }), Object.defineProperty(this, "selection", { enumerable: true, configurable: true, writable: true, value: this.children.push(Re.new(this._root, { themeTags: ["selection", "cursor"], layer: 30 })) }), Object.defineProperty(this, "_movePoint", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_lastPoint", { enumerable: true, configurable: true, writable: true, value: { x: 0, y: 0 } }), Object.defineProperty(this, "_tooltipX", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_tooltipY", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "chart", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_toX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_toY", { enumerable: true, configurable: true, writable: true, value: void 0 });
  }
  _afterNew() {
    this._settings.themeTags = Kt(this._settings.themeTags, ["xy", "cursor"]), super._afterNew(), this.setAll({ width: z, height: z, isMeasured: true, position: "absolute" }), this.states.create("hidden", { visible: true, opacity: 0 }), this._drawLines(), this.setPrivateRaw("visible", false), this._disposers.push(this.setTimeout(() => {
      this.setPrivate("visible", true);
    }, 500)), this._disposers.push(this.lineX.events.on("positionchanged", () => {
      this._handleXLine();
    })), this._disposers.push(this.lineY.events.on("positionchanged", () => {
      this._handleYLine();
    })), this._disposers.push(this.lineX.events.on("focus", (t2) => this._handleLineFocus(t2.target))), this._disposers.push(this.lineX.events.on("blur", (t2) => this._handleLineBlur(t2.target))), this._disposers.push(this.lineY.events.on("focus", (t2) => this._handleLineFocus(t2.target))), this._disposers.push(this.lineY.events.on("blur", (t2) => this._handleLineBlur(t2.target))), it("keyboardevents") && this._disposers.push(tt(document, "keydown", (t2) => {
      this._handleLineMove(t2.keyCode);
    }));
  }
  _setUpTouch() {
    const t2 = this.chart;
    t2 && (t2.plotContainer._display.cancelTouch = "none" != this.get("behavior"));
  }
  _handleXLine() {
    let t2 = this.lineX.x(), e2 = true;
    (t2 < 0 || t2 > this.width()) && (e2 = false), this.lineX.setPrivate("visible", e2);
  }
  _handleYLine() {
    let t2 = this.lineY.y(), e2 = true;
    (t2 < 0 || t2 > this.height()) && (e2 = false), this.lineY.setPrivate("visible", e2);
  }
  _handleLineMove(t2) {
    let e2 = "", i = 0, s2 = 0.1;
    const a = this.chart;
    this._root.focused(this.lineX) ? (a && a.xAxes.length && (s2 = a.xAxes.getIndex(0).getCellWidthPosition()), i = this.getPrivate("positionX", 0), e2 = "positionX", 37 == t2 ? i -= s2 : 39 == t2 && (i += s2)) : this._root.focused(this.lineY) && (a && a.yAxes.length && (s2 = a.yAxes.getIndex(0).getCellWidthPosition()), i = this.getPrivate("positionY", 0), e2 = "positionY", 38 == t2 ? i -= s2 : 40 == t2 && (i += s2)), i < 0 ? i = 0 : i > 1 && (i = 1), "" != e2 && this.set(e2, i);
  }
  _handleLineFocus(t2) {
    this.setAll({ positionX: this.getPrivate("positionX"), positionY: this.getPrivate("positionY"), alwaysShow: true });
  }
  _handleLineBlur(t2) {
    this.setAll({ positionX: void 0, positionY: void 0, alwaysShow: false });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("xAxis")) {
      this._tooltipX = false;
      const t2 = this.get("xAxis");
      if (t2) {
        const e2 = t2.get("tooltip");
        e2 && (this._tooltipX = true, this._disposers.push(e2.on("pointTo", () => {
          this._updateXLine(e2);
        })));
      }
    }
    if (this.isDirty("yAxis")) {
      this._tooltipY = false;
      const t2 = this.get("yAxis");
      if (t2) {
        const e2 = t2.get("tooltip");
        e2 && (this._tooltipY = true, this._disposers.push(e2.on("pointTo", () => {
          this._updateYLine(e2);
        })));
      }
    }
  }
  _handleSyncWith() {
    const t2 = this.chart;
    if (t2) {
      const e2 = this.get("syncWith"), i = [];
      e2 && m(e2, (t3) => {
        const e3 = t3.chart;
        e3 && i.push(e3);
      }), t2._otherCharts = i;
    }
  }
  _updateChildren() {
    if (super._updateChildren(), this._handleSyncWith(), this.isDirty("positionX") || this.isDirty("positionY")) {
      const t2 = this.get("positionX"), e2 = this.get("positionY");
      null == t2 && null == e2 ? this.hide(0) : (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
    }
  }
  _updateXLine(t2) {
    let e2 = re(this._display.toLocal(t2.get("pointTo", { x: 0, y: 0 })).x, 2);
    this._toX != e2 && (this.lineX.animate({ key: "x", to: e2, duration: t2.get("animationDuration", 0), easing: t2.get("animationEasing") }), this._toX = e2);
  }
  _updateYLine(t2) {
    let e2 = re(this._display.toLocal(t2.get("pointTo", { x: 0, y: 0 })).y, 2);
    this._toY != e2 && (this.lineY.animate({ key: "y", to: e2, duration: t2.get("animationDuration", 0), easing: t2.get("animationEasing") }), this._toY = e2);
  }
  _drawLines() {
    this.lineX.set("draw", (t2) => {
      t2.moveTo(0, 0), t2.lineTo(0, this.height());
    }), this.lineY.set("draw", (t2) => {
      t2.moveTo(0, 0), t2.lineTo(this.width(), 0);
    });
  }
  _setChart(t2) {
    this.chart = t2, this._handleSyncWith();
    const e2 = t2.plotContainer;
    this.events.on("boundschanged", () => {
      this._disposers.push(this.setTimeout(() => {
        this.get("alwaysShow") && (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
      }, 50));
    }), it("touchevents") && (this._disposers.push(e2.events.on("click", (t3) => {
      ot(t3.originalEvent) && this._handleMove(t3.originalEvent);
    })), this._setUpTouch()), this._disposers.push(e2.events.on("pointerdown", (t3) => {
      this._handleCursorDown(t3.originalEvent);
    })), this._disposers.push(e2.events.on("globalpointerup", (t3) => {
      this._handleCursorUp(t3.originalEvent), t3.native || this.isHidden() || this._handleMove(t3.originalEvent);
    })), this._disposers.push(e2.events.on("globalpointermove", (t3) => {
      (this.get("syncWith") || 0 != Y(e2._downPoints).length || t3.native || !this.isHidden()) && this._handleMove(t3.originalEvent);
    }));
    const i = this.parent;
    i && i.children.moveValue(this.selection);
  }
  _inPlot(t2) {
    const e2 = this.chart;
    return !!e2 && e2.inPlot(t2);
  }
  _handleCursorDown(t2) {
    if (2 == t2.button)
      return;
    const e2 = this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY });
    let i = this._display.toLocal(e2);
    const s2 = this.chart;
    if (this.selection.set("draw", () => {
    }), s2 && this._inPlot(i)) {
      if (this._downPoint = i, "none" != this.get("behavior")) {
        this.selection.show();
        const t4 = "selectstarted";
        this.events.isEnabled(t4) && this.events.dispatch(t4, { type: t4, target: this });
      }
      let t3 = this._getPosition(i).x, e3 = this._getPosition(i).y;
      this.setPrivate("downPositionX", t3), this.setPrivate("downPositionY", e3);
    }
  }
  _handleCursorUp(t2) {
    if (this._downPoint) {
      const e2 = this.get("behavior", "none");
      if ("none" != e2) {
        "z" === e2.charAt(0) && this.selection.hide();
        const i = this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY });
        let s2 = this._display.toLocal(i);
        const a = this._downPoint, o2 = this.get("moveThreshold", 1);
        if (s2 && a) {
          let t3 = false;
          if ("zoomX" !== e2 && "zoomXY" !== e2 && "selectX" !== e2 && "selectXY" !== e2 || Math.abs(s2.x - a.x) > o2 && (t3 = true), "zoomY" !== e2 && "zoomXY" !== e2 && "selectY" !== e2 && "selectXY" !== e2 || Math.abs(s2.y - a.y) > o2 && (t3 = true), t3) {
            const t4 = "selectended";
            this.events.isEnabled(t4) && this.events.dispatch(t4, { type: t4, target: this });
          }
        }
      }
    }
    this._downPoint = void 0;
  }
  _handleMove(t2) {
    if (this.getPrivate("visible")) {
      const e2 = this.chart;
      if (e2 && Y(e2.plotContainer._downPoints).length > 1)
        return void this.set("forceHidden", true);
      this.set("forceHidden", false);
      const i = this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY }), s2 = this._lastPoint;
      if (Math.round(s2.x) === Math.round(i.x) && Math.round(s2.y) === Math.round(i.y))
        return;
      this._lastPoint = i, this.setPrivate("lastPoint", i), this.handleMove({ x: i.x, y: i.y });
    }
  }
  _getPosition(t2) {
    return { x: t2.x / this.width(), y: t2.y / this.height() };
  }
  handleMove(t2, e2) {
    t2 || (t2 = this._movePoint);
    const i = this.get("alwaysShow");
    if (!t2)
      return void this.hide(0);
    this._movePoint = t2;
    let a = this._display.toLocal(t2), o2 = this.chart;
    if (o2 && this._inPlot(a)) {
      if (o2._movePoint = t2, this.isHidden()) {
        this.show();
        "z" == this.get("behavior", "").charAt(0) && this.selection.set("draw", () => {
        });
      }
      let n2 = a.x, r = a.y, l3 = this._getPosition(a);
      this.setPrivate("point", a);
      let h = this.get("snapToSeries");
      this._downPoint && (h = void 0);
      let c = this.get("positionX"), d = l3.x;
      l(c) && (d = c);
      let u = this.get("positionY"), g2 = l3.y;
      l(u) && (g2 = u), this.setPrivate("positionX", d), this.setPrivate("positionY", g2);
      const p = this._getPoint(d, g2);
      if (n2 = p.x, r = p.y, o2.xAxes.each((t3) => {
        t3._handleCursorPosition(d, h), i && t3.handleCursorShow();
      }), o2.yAxes.each((t3) => {
        t3._handleCursorPosition(g2, h), i && t3.handleCursorShow();
      }), !e2) {
        o2._handleCursorPosition();
        const t3 = "cursormoved";
        this.events.isEnabled(t3) && this.events.dispatch(t3, { type: t3, target: this });
      }
      this._updateLines(n2, r), o2.arrangeTooltips();
    } else if (!this._downPoint && !i) {
      this.hide(0);
      const t3 = "cursorhidden";
      this.events.isEnabled(t3) && this.events.dispatch(t3, { type: t3, target: this });
    }
    this._downPoint && "none" != this.get("behavior") && this._updateSelection(a);
  }
  _getPoint(t2, e2) {
    return { x: this.width() * t2, y: this.height() * e2 };
  }
  _updateLines(t2, e2) {
    this._tooltipX || this.lineX.set("x", t2), this._tooltipY || this.lineY.set("y", e2), this._drawLines();
  }
  _updateSelection(t2) {
    const e2 = this.selection, i = this.get("behavior"), s2 = this.width(), a = this.height();
    t2.x < 0 && (t2.x = 0), t2.x > s2 && (t2.x = s2), t2.y < 0 && (t2.y = 0), t2.y > a && (t2.y = a), e2.set("draw", (e3) => {
      const o2 = this._downPoint;
      o2 && ("zoomXY" === i || "selectXY" === i ? (e3.moveTo(o2.x, o2.y), e3.lineTo(o2.x, t2.y), e3.lineTo(t2.x, t2.y), e3.lineTo(t2.x, o2.y), e3.lineTo(o2.x, o2.y)) : "zoomX" === i || "selectX" === i ? (e3.moveTo(o2.x, 0), e3.lineTo(o2.x, a), e3.lineTo(t2.x, a), e3.lineTo(t2.x, 0), e3.lineTo(o2.x, 0)) : "zoomY" !== i && "selectY" !== i || (e3.moveTo(0, o2.y), e3.lineTo(s2, o2.y), e3.lineTo(s2, t2.y), e3.lineTo(0, t2.y), e3.lineTo(0, o2.y)));
    });
  }
  _onHide() {
    if (this.isHidden()) {
      let t2 = this.chart;
      t2 && (t2.xAxes.each((t3) => {
        t3.handleCursorHide();
      }), t2.yAxes.each((t3) => {
        t3.handleCursorHide();
      }), t2.series.each((t3) => {
        t3.handleCursorHide();
      }));
    }
    super._onHide();
  }
  _onShow() {
    if (!this.isHidden()) {
      let t2 = this.chart;
      t2 && (t2.xAxes.each((t3) => {
        t3.handleCursorShow();
      }), t2.yAxes.each((t3) => {
        t3.handleCursorShow();
      }));
    }
    super._onShow();
  }
  _dispose() {
    super._dispose(), this.selection.dispose();
  }
};
function ct(t2, e2) {
  return null == t2 ? e2 : null == e2 ? t2 : e2 < t2 ? e2 : t2;
}
function dt(t2, e2) {
  return null == t2 ? e2 : null == e2 ? t2 : e2 > t2 ? e2 : t2;
}
Object.defineProperty(ht, "className", { enumerable: true, configurable: true, writable: true, value: "XYCursor" }), Object.defineProperty(ht, "classNames", { enumerable: true, configurable: true, writable: true, value: Je.classNames.concat([ht.className]) });
var ut = class extends D {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_xField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_yField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_xOpenField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_yOpenField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_xLowField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_xHighField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_yLowField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_yHighField", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_axesDirty", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_stackDirty", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_selectionProcessed", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_dataSets", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "_mainContainerMask", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_x", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_y", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "mainContainer", { enumerable: true, configurable: true, writable: true, value: this.children.push(Je.new(this._root, {})) }), Object.defineProperty(this, "axisRanges", { enumerable: true, configurable: true, writable: true, value: new R() }), Object.defineProperty(this, "_skipped", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_couldStackTo", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "_reallyStackedTo", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "_stackedSeries", { enumerable: true, configurable: true, writable: true, value: {} }), Object.defineProperty(this, "_aLocationX0", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_aLocationX1", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_aLocationY0", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_aLocationY1", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_showBullets", { enumerable: true, configurable: true, writable: true, value: true }), Object.defineProperty(this, "valueXFields", { enumerable: true, configurable: true, writable: true, value: ["valueX", "openValueX", "lowValueX", "highValueX"] }), Object.defineProperty(this, "valueYFields", { enumerable: true, configurable: true, writable: true, value: ["valueY", "openValueY", "lowValueY", "highValueY"] }), Object.defineProperty(this, "_valueXFields", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_valueYFields", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_valueXShowFields", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_valueYShowFields", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "__valueXShowFields", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "__valueYShowFields", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_emptyDataItem", { enumerable: true, configurable: true, writable: true, value: new g(this, void 0, {}) }), Object.defineProperty(this, "_dataSetId", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_tooltipFieldX", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_tooltipFieldY", { enumerable: true, configurable: true, writable: true, value: void 0 });
  }
  _afterNew() {
    this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY"), this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY"), this._setRawDefault("vcx", 1), this._setRawDefault("vcy", 1), this._setRawDefault("valueXShow", "valueXWorking"), this._setRawDefault("valueYShow", "valueYWorking"), this._setRawDefault("openValueXShow", "openValueXWorking"), this._setRawDefault("openValueYShow", "openValueYWorking"), this._setRawDefault("lowValueXShow", "lowValueXWorking"), this._setRawDefault("lowValueYShow", "lowValueYWorking"), this._setRawDefault("highValueXShow", "highValueXWorking"), this._setRawDefault("highValueYShow", "highValueYWorking"), this._setRawDefault("lowValueXGrouped", "low"), this._setRawDefault("lowValueYGrouped", "low"), this._setRawDefault("highValueXGrouped", "high"), this._setRawDefault("highValueYGrouped", "high"), super._afterNew(), this._settings.xAxis.series.push(this), this._settings.yAxis.series.push(this), this.set("maskContent", true), this._disposers.push(this.axisRanges.events.onAll((t3) => {
      if ("clear" === t3.type)
        m(t3.oldValues, (t4) => {
          this._removeAxisRange(t4);
        });
      else if ("push" === t3.type)
        this._processAxisRange(t3.newValue);
      else if ("setIndex" === t3.type)
        this._processAxisRange(t3.newValue);
      else if ("insertIndex" === t3.type)
        this._processAxisRange(t3.newValue);
      else if ("removeIndex" === t3.type)
        this._removeAxisRange(t3.oldValue);
      else {
        if ("moveIndex" !== t3.type)
          throw new Error("Unknown IStreamEvent type");
        this._processAxisRange(t3.value);
      }
    }));
    const t2 = this.get("xAxis"), e2 = this.get("yAxis");
    this._disposers.push(t2.events.on("positionchanged", () => {
      this._fixPosition();
    })), this._disposers.push(e2.events.on("positionchanged", () => {
      this._fixPosition();
    })), this.get("baseAxis") || (e2.isType("CategoryAxis") || e2.isType("DateAxis") ? this.set("baseAxis", e2) : this.set("baseAxis", t2)), this.states.create("hidden", { opacity: 1, visible: false }), this._makeFieldNames();
  }
  _processAxisRange(t2) {
    const e2 = Je.new(this._root, {});
    t2.container = e2, this.children.push(e2), t2.series = this;
    const i = t2.axisDataItem;
    i.setRaw("isRange", true);
    const s2 = i.component;
    if (s2) {
      s2._processAxisRange(i, ["range", "series"]);
      const t3 = i.get("bullet");
      if (t3) {
        const e3 = t3.get("sprite");
        e3 && e3.setPrivate("visible", false);
      }
      const a = i.get("axisFill");
      a && e2.set("mask", a), s2._seriesAxisRanges.push(i);
    }
  }
  _removeAxisRange(t2) {
    const e2 = t2.axisDataItem, i = e2.component;
    i.disposeDataItem(e2), v(i._seriesAxisRanges, e2);
    const s2 = t2.container;
    s2 && s2.dispose();
  }
  _updateFields() {
    super._updateFields(), this._valueXFields = [], this._valueYFields = [], this._valueXShowFields = [], this._valueYShowFields = [], this.__valueXShowFields = [], this.__valueYShowFields = [], this.valueXFields && m(this.valueXFields, (t2) => {
      if (this.get(t2 + "Field")) {
        this._valueXFields.push(t2);
        let e2 = this.get(t2 + "Show");
        this.__valueXShowFields.push(e2), -1 != e2.indexOf("Working") ? this._valueXShowFields.push(e2.split("Working")[0]) : this._valueXShowFields.push(e2);
      }
    }), this.valueYFields && m(this.valueYFields, (t2) => {
      if (this.get(t2 + "Field")) {
        this._valueYFields.push(t2);
        let e2 = this.get(t2 + "Show");
        this.__valueYShowFields.push(e2), -1 != e2.indexOf("Working") ? this._valueYShowFields.push(e2.split("Working")[0]) : this._valueYShowFields.push(e2);
      }
    });
  }
  _dispose() {
    super._dispose();
    const t2 = this.chart;
    t2 && t2.series.removeValue(this), y(this.get("xAxis").series, this), y(this.get("yAxis").series, this);
  }
  _min(t2, e2) {
    let i = ct(this.getPrivate(t2), e2);
    this.setPrivate(t2, i);
  }
  _max(t2, e2) {
    let i = dt(this.getPrivate(t2), e2);
    this.setPrivate(t2, i);
  }
  _shouldMakeBullet(t2) {
    const e2 = this.get("xAxis"), i = this.get("yAxis"), s2 = this.get("baseAxis");
    if (!e2.inited || !i.inited)
      return false;
    const a = this.get("minBulletDistance", 0);
    if (a > 0) {
      let t3 = this.startIndex(), o2 = this.endIndex() - t3;
      if (e2 == s2) {
        if (e2.get("renderer").axisLength() / o2 < a / 5)
          return false;
      } else if (i == s2 && i.get("renderer").axisLength() / o2 < a / 5)
        return false;
    }
    return null != t2.get(this._xField) && null != t2.get(this._yField);
  }
  _makeFieldNames() {
    const t2 = this.get("xAxis"), e2 = this.get("yAxis"), i = t2.getPrivate("name"), s2 = It(i), a = e2.getPrivate("name"), o2 = It(a), n2 = t2.get("renderer").getPrivate("letter"), r = e2.get("renderer").getPrivate("letter"), l3 = "open", h = "low", c = "high", d = "Show";
    "ValueAxis" === t2.className ? (this._xField = this.get(i + n2 + d), this._xOpenField = this.get(l3 + s2 + n2 + d), this._xLowField = this.get(h + s2 + n2 + d), this._xHighField = this.get(c + s2 + n2 + d)) : (this._xField = i + n2, this._xOpenField = l3 + s2 + n2, this._xLowField = h + s2 + n2, this._xHighField = c + s2 + n2), "ValueAxis" === e2.className ? (this._yField = this.get(a + r + d), this._yOpenField = this.get(l3 + o2 + r + d), this._yLowField = this.get(h + o2 + r + d), this._yHighField = this.get(c + o2 + r + d)) : (this._yField = a + r, this._yOpenField = l3 + o2 + r, this._yLowField = h + o2 + r, this._yHighField = c + o2 + r);
  }
  _fixVC() {
    const t2 = this.get("xAxis"), e2 = this.get("yAxis"), i = this.get("baseAxis"), s2 = this.states.lookup("hidden"), a = this.get("sequencedInterpolation");
    if (s2) {
      let o2 = 0;
      a && (o2 = 0.999999999999), t2 === i ? s2.set("vcy", o2) : (e2 === i || s2.set("vcy", o2), s2.set("vcx", o2));
    }
  }
  _handleMaskBullets() {
    this.isDirty("maskBullets") && this.bulletsContainer.set("maskContent", this.get("maskBullets"));
  }
  _fixPosition() {
    const t2 = this.get("xAxis"), e2 = this.get("yAxis");
    this.set("x", t2.x() - mt(t2.get("centerX", 0), t2.width()) - t2.parent.get("paddingLeft", 0)), this.set("y", e2.y() - mt(e2.get("centerY", 0), e2.height()) - e2.parent.get("paddingTop", 0)), this.bulletsContainer.set("y", this.y()), this.bulletsContainer.set("x", this.x());
  }
  _prepareChildren() {
    super._prepareChildren(), (this.isDirty("valueYShow") || this.isDirty("valueXShow")) && (this._updateFields(), this._makeFieldNames(), this._valuesDirty = true), this.set("width", this.get("xAxis").width()), this.set("height", this.get("yAxis").height()), this._handleMaskBullets();
    const t2 = this.get("xAxis"), e2 = this.get("yAxis"), i = this.get("baseAxis");
    let s2;
    switch (this.get("tooltipPositionX")) {
      case "open":
        s2 = this._xOpenField;
        break;
      case "low":
        s2 = this._xLowField;
        break;
      case "high":
        s2 = this._xHighField;
        break;
      default:
        s2 = this._xField;
    }
    this._tooltipFieldX = s2;
    let a;
    switch (this.get("tooltipPositionY")) {
      case "open":
        a = this._yOpenField;
        break;
      case "low":
        a = this._yLowField;
        break;
      case "high":
        a = this._yHighField;
        break;
      default:
        a = this._yField;
    }
    this._tooltipFieldY = a, this.isDirty("baseAxis") && this._fixVC(), this._fixPosition();
    const o2 = this.get("stacked");
    if (this.isDirty("stacked") && (o2 ? this._valuesDirty && !this._dataProcessed || this._stack() : this._unstack()), this._valuesDirty && !this._dataProcessed && (this._dataProcessed = true, o2 && this._stack(), m(this.dataItems, (i2) => {
      m(this._valueXShowFields, (t3) => {
        let e3 = i2.get(t3);
        null != e3 && (o2 && (e3 += this.getStackedXValue(i2, t3)), this._min("minX", e3), this._max("maxX", e3));
      }), m(this._valueYShowFields, (t3) => {
        let e3 = i2.get(t3);
        null != e3 && (o2 && (e3 += this.getStackedYValue(i2, t3)), this._min("minY", e3), this._max("maxY", e3));
      }), t2.processSeriesDataItem(i2, this._valueXFields), e2.processSeriesDataItem(i2, this._valueYFields);
    }), t2._seriesValuesDirty = true, e2._seriesValuesDirty = true, this.get("ignoreMinMax") || ((this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) && t2.markDirtyExtremes(), (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) && e2.markDirtyExtremes()), this._markStakedDirtyStack(), this.get("tooltipDataItem") || this.updateLegendValue(void 0)), (this.isDirty("vcx") || this.isDirty("vcy")) && this._markStakedDirtyStack(), this._dataGrouped || (t2._groupSeriesData(this), e2._groupSeriesData(this), this._dataGrouped = true), this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty) {
      let s3 = this.startIndex(), a2 = this.endIndex(), o3 = this.get("minBulletDistance", 0);
      if (o3 > 0 && i && (i.get("renderer").axisLength() / (a2 - s3) > o3 ? this._showBullets = true : this._showBullets = false), (this._psi != s3 || this._pei != a2 || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
        this._selectionProcessed = true;
        const o4 = this.get("vcx", 1), n2 = this.get("vcy", 1), r = this.get("stacked", false), l3 = this.getPrivate("outOfSelection");
        if (i === t2)
          if (e2._calculateTotals(), this.setPrivateRaw("selectionMinY", void 0), this.setPrivateRaw("selectionMaxY", void 0), l3)
            e2.markDirtySelectionExtremes();
          else
            for (let t3 = s3; t3 < a2; t3++)
              this.processYSelectionDataItem(this.dataItems[t3], n2, r);
        else if (i === e2)
          if (t2._calculateTotals(), this.setPrivateRaw("selectionMinX", void 0), this.setPrivateRaw("selectionMaxX", void 0), l3)
            e2.markDirtySelectionExtremes();
          else
            for (let t3 = s3; t3 < a2; t3++)
              this.processXSelectionDataItem(this.dataItems[t3], o4, r);
        if (i === t2) {
          if ("valueYWorking" !== this.get("valueYShow")) {
            const t3 = this.getPrivate("selectionMinY");
            null != t3 && (this.setPrivateRaw("minY", t3), e2.markDirtyExtremes());
            const i2 = this.getPrivate("selectionMaxY");
            null != i2 && (this.setPrivateRaw("maxY", i2), e2.markDirtyExtremes());
          }
        } else if (i === e2 && "valueXWorking" !== this.get("valueXShow")) {
          const i2 = this.getPrivate("selectionMinX");
          null != i2 && (this.setPrivateRaw("minX", i2), e2.markDirtyExtremes());
          const s4 = this.getPrivate("selectionMaxX");
          null != s4 && (this.setPrivateRaw("maxX", s4), t2.markDirtyExtremes());
        }
        (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) && t2.markDirtySelectionExtremes(), (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) && e2.markDirtySelectionExtremes();
      }
    }
  }
  _makeRangeMask() {
    if (this.axisRanges.length > 0) {
      let t2 = this._mainContainerMask;
      null == t2 && (t2 = this.children.push(Re.new(this._root, {})), this._mainContainerMask = t2, t2.set("draw", (e2, i) => {
        const s2 = this.parent;
        if (s2) {
          const t3 = this._root.container.width(), a = this._root.container.height();
          e2.moveTo(-t3, -a), e2.lineTo(-t3, 2 * a), e2.lineTo(2 * t3, 2 * a), e2.lineTo(2 * t3, -a), e2.lineTo(-t3, -a), this.axisRanges.each((t4) => {
            const a2 = t4.axisDataItem.get("axisFill");
            if (s2 && a2) {
              let t5 = a2.get("draw");
              t5 && t5(e2, i);
            }
          });
        }
        this.mainContainer._display.mask = t2._display;
      })), t2.markDirty(), t2._markDirtyKey("fill");
    } else
      this.mainContainer._display.mask = null;
  }
  _updateChildren() {
    super._updateChildren(), this._x = this.x(), this._y = this.y(), this._makeRangeMask();
  }
  _stack() {
    const t2 = this.chart;
    if (t2) {
      const e2 = t2.series.indexOf(this);
      if (this._couldStackTo = [], e2 > 0) {
        let i;
        for (let s2 = e2 - 1; s2 >= 0 && (i = t2.series.getIndex(s2), i.get("xAxis") !== this.get("xAxis") || i.get("yAxis") !== this.get("yAxis") || i.className !== this.className || (this._couldStackTo.push(i), i.get("stacked"))); s2--)
          ;
      }
      this._stackDataItems();
    }
  }
  _unstack() {
    Z(this._reallyStackedTo, (t2, e2) => {
      delete e2._stackedSeries[this.uid];
    }), this._reallyStackedTo = {}, m(this.dataItems, (t2) => {
      t2.setRaw("stackToItemY", void 0), t2.setRaw("stackToItemX", void 0);
    });
  }
  _stackDataItems() {
    const t2 = this.get("baseAxis"), e2 = this.get("xAxis"), i = this.get("yAxis");
    let a, o2;
    t2 === e2 ? (a = "valueY", o2 = "stackToItemY") : t2 === i && (a = "valueX", o2 = "stackToItemX");
    let n2 = this._couldStackTo.length, r = 0;
    const l3 = this.get("stackToNegative");
    this._reallyStackedTo = {}, m(this.dataItems, (t3) => {
      for (let e3 = 0; e3 < n2; e3++) {
        let i2 = this._couldStackTo[e3], n3 = i2.dataItems[r], h = t3.get(a);
        if (n3) {
          let e4 = n3.get(a);
          if (l3) {
            if (!l(h))
              break;
            if (l(e4)) {
              if (h >= 0 && e4 >= 0) {
                t3.setRaw(o2, n3), this._reallyStackedTo[i2.uid] = i2, i2._stackedSeries[this.uid] = this;
                break;
              }
              if (h < 0 && e4 < 0) {
                t3.setRaw(o2, n3), this._reallyStackedTo[i2.uid] = i2, i2._stackedSeries[this.uid] = this;
                break;
              }
            }
          } else if (l(h) && l(e4)) {
            t3.setRaw(o2, n3), this._reallyStackedTo[i2.uid] = i2, i2._stackedSeries[this.uid] = this;
            break;
          }
        }
      }
      r++;
    });
  }
  processXSelectionDataItem(t2, e2, i) {
    m(this.__valueXShowFields, (s2) => {
      let a = t2.get(s2);
      null != a && (i && (a += this.getStackedXValueWorking(t2, s2)), this._min("selectionMinX", a), this._max("selectionMaxX", a * e2));
    });
  }
  processYSelectionDataItem(t2, e2, i) {
    m(this.__valueYShowFields, (s2) => {
      let a = t2.get(s2);
      null != a && (i && (a += this.getStackedYValueWorking(t2, s2)), this._min("selectionMinY", a), this._max("selectionMaxY", a * e2));
    });
  }
  getStackedYValueWorking(t2, e2) {
    const i = t2.get("stackToItemY");
    if (i) {
      const t3 = i.component;
      return i.get(e2, 0) * t3.get("vcy", 1) + this.getStackedYValueWorking(i, e2);
    }
    return 0;
  }
  getStackedXValueWorking(t2, e2) {
    const i = t2.get("stackToItemX");
    if (i) {
      const t3 = i.component;
      return i.get(e2, 0) * t3.get("vcx", 1) + this.getStackedXValueWorking(i, e2);
    }
    return 0;
  }
  getStackedYValue(t2, e2) {
    const i = t2.get("stackToItemY");
    return i ? i.get(e2, 0) + this.getStackedYValue(i, e2) : 0;
  }
  getStackedXValue(t2, e2) {
    const i = t2.get("stackToItemX");
    return i ? i.get(e2, 0) + this.getStackedXValue(i, e2) : 0;
  }
  createLegendMarker(t2) {
    this.updateLegendMarker();
  }
  _markDirtyAxes() {
    this._axesDirty = true, this.markDirty();
  }
  _markDataSetDirty() {
    this._afterDataChange(), this._valuesDirty = true, this._dataProcessed = false, this._aggregatesCalculated = false, this.markDirty();
  }
  _clearDirty() {
    super._clearDirty(), this._axesDirty = false, this._selectionProcessed = false, this._stackDirty = false, this._dataProcessed = false;
  }
  _positionBullet(t2) {
    let e2 = t2.get("sprite");
    if (e2) {
      let i = e2.dataItem, s2 = t2.get("locationX", i.get("locationX", 0.5)), a = t2.get("locationY", i.get("locationY", 0.5)), o2 = this.get("xAxis"), n2 = this.get("yAxis");
      const r = o2.getDataItemPositionX(i, this._xField, s2, this.get("vcx", 1)), l3 = n2.getDataItemPositionY(i, this._yField, a, this.get("vcy", 1));
      let h = this.getPoint(r, l3), c = i.get("left", h.x), d = i.get("right", h.x), u = i.get("top", h.y), g2 = i.get("bottom", h.y);
      if (this._shouldShowBullet(r, l3)) {
        t2.getPrivate("hidden") ? e2.setPrivate("visible", false) : e2.setPrivate("visible", true);
        let i2 = d - c, o3 = g2 - u;
        e2.isType("Label") && (e2.setPrivate("maxWidth", Math.abs(i2)), e2.setPrivate("maxHeight", Math.abs(o3)));
        let n3 = c + i2 * s2, r2 = g2 - o3 * a;
        e2.set("x", n3), e2.set("y", r2);
      } else
        e2.setPrivate("visible", false);
    }
  }
  _shouldShowBullet(t2, e2) {
    return this._showBullets;
  }
  setDataSet(t2) {
    if (this._dataSets[t2]) {
      this._handleDataSetChange(), this._dataItems = this._dataSets[t2], this._markDataSetDirty(), this._dataSetId = t2;
      const e2 = "datasetchanged";
      this.events.isEnabled(e2) && this.events.dispatch(e2, { type: e2, target: this, id: t2 });
    }
  }
  _handleDataSetChange() {
    this.bullets.length > 0 && m(this._dataItems, (t2) => {
      let e2 = t2.bullets;
      e2 && m(e2, (t3) => {
        if (t3) {
          let e3 = t3.get("sprite");
          e3 && e3.setPrivate("visible", false);
        }
      });
    }), this._selectionProcessed = false;
  }
  show(t2) {
    const e2 = Object.create(null, { show: { get: () => super.show } });
    return t(this, void 0, void 0, function* () {
      this._fixVC();
      let i = [];
      i.push(e2.show.call(this, t2).then(() => {
        this._isShowing = false;
        let t3 = this.get("xAxis"), e3 = this.get("yAxis"), i2 = this.get("baseAxis");
        e3 !== i2 && e3.markDirtySelectionExtremes(), t3 !== i2 && t3.markDirtySelectionExtremes();
      })), i.push(this.bulletsContainer.show(t2)), i.push(this._sequencedShowHide(true, t2)), yield Promise.all(i);
    });
  }
  hide(t2) {
    const e2 = Object.create(null, { hide: { get: () => super.hide } });
    return t(this, void 0, void 0, function* () {
      this._fixVC();
      let i = [];
      i.push(e2.hide.call(this, t2).then(() => {
        this._isHiding = false;
      })), i.push(this.bulletsContainer.hide(t2)), i.push(this._sequencedShowHide(false, t2)), yield Promise.all(i);
    });
  }
  showDataItem(t2, e2) {
    const i = Object.create(null, { showDataItem: { get: () => super.showDataItem } });
    return t(this, void 0, void 0, function* () {
      const a = [i.showDataItem.call(this, t2, e2)];
      l(e2) || (e2 = this.get("stateAnimationDuration", 0));
      const o2 = this.get("stateAnimationEasing");
      m(this._valueFields, (i2) => {
        a.push(t2.animate({ key: i2 + "Working", to: t2.get(i2), duration: e2, easing: o2 }).waitForStop());
      }), yield Promise.all(a);
    });
  }
  hideDataItem(t2, e2) {
    const i = Object.create(null, { hideDataItem: { get: () => super.hideDataItem } });
    return t(this, void 0, void 0, function* () {
      const a = [i.hideDataItem.call(this, t2, e2)], o2 = this.states.create("hidden", {});
      l(e2) || (e2 = o2.get("stateAnimationDuration", this.get("stateAnimationDuration", 0)));
      const n2 = o2.get("stateAnimationEasing", this.get("stateAnimationEasing")), r = this.get("xAxis"), l3 = this.get("yAxis"), h = this.get("baseAxis"), c = this.get("stacked");
      if (h !== r && h || m(this._valueYFields, (i2) => {
        let o3 = l3.getPrivate("min"), r2 = l3.baseValue();
        l(o3) && o3 > r2 && (r2 = o3), c && (r2 = 0), null != t2.get(i2) && a.push(t2.animate({ key: i2 + "Working", to: r2, duration: e2, easing: n2 }).waitForStop());
      }), h === l3 || !h) {
        let i2 = r.getPrivate("min"), o3 = r.baseValue();
        l(i2) && i2 > o3 && (o3 = i2), c && (o3 = 0), m(this._valueXFields, (i3) => {
          null != t2.get(i3) && a.push(t2.animate({ key: i3 + "Working", to: o3, duration: e2, easing: n2 }).waitForStop());
        });
      }
      yield Promise.all(a);
    });
  }
  _markDirtyStack() {
    this._stackDirty = true, this.markDirty(), this._markStakedDirtyStack();
  }
  _markStakedDirtyStack() {
    const t2 = this._stackedSeries;
    t2 && Z(t2, (t3, e2) => {
      e2._stackDirty || e2._markDirtyStack();
    });
  }
  _afterChanged() {
    super._afterChanged(), this._skipped && (this._markDirtyAxes(), this._skipped = false);
  }
  showDataItemTooltip(t2) {
    this.updateLegendMarker(t2), this.updateLegendValue(t2);
    const e2 = this.get("tooltip");
    if (e2) {
      if (this.isHidden())
        this.hideTooltip();
      else if (e2._setDataItem(t2), t2) {
        let i = this.get("locationX", 0), s2 = this.get("locationY", 1), a = t2.get("locationX", i), o2 = t2.get("locationY", s2);
        const n2 = this.get("xAxis"), r = this.get("yAxis"), l3 = this.get("vcx", 1), h = this.get("vcy", 1), c = n2.getDataItemPositionX(t2, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * a, l3), d = r.getDataItemPositionY(t2, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * o2, h), u = this.getPoint(c, d);
        let g2 = true;
        if (m(this._valueFields, (e3) => {
          null == t2.get(e3) && (g2 = false);
        }), g2) {
          const i2 = this.chart;
          i2 && i2.inPlot(u) ? (e2.label.text.markDirtyText(), e2.set("tooltipTarget", this._getTooltipTarget(t2)), e2.set("pointTo", this._display.toGlobal({ x: u.x, y: u.y }))) : e2._setDataItem(void 0);
        } else
          e2._setDataItem(void 0);
      }
    }
  }
  hideTooltip() {
    const t2 = this.get("tooltip");
    return t2 && t2.set("tooltipTarget", this), super.hideTooltip();
  }
  _getTooltipTarget(t2) {
    if ("bullet" == this.get("seriesTooltipTarget")) {
      const e2 = t2.bullets;
      if (e2 && e2.length > 0) {
        const t3 = e2[0].get("sprite");
        if (t3)
          return t3;
      }
    }
    return this;
  }
  updateLegendValue(t2) {
    const e2 = this.get("legendDataItem");
    if (e2) {
      const i = e2.get("label");
      if (i) {
        let e3 = "";
        t2 ? (i._setDataItem(t2), e3 = this.get("legendLabelText", i.get("text", this.get("name", "")))) : (i._setDataItem(this._emptyDataItem), e3 = this.get("legendRangeLabelText", this.get("legendLabelText", i.get("text", this.get("name", ""))))), i.set("text", e3);
      }
      const s2 = e2.get("valueLabel");
      if (s2) {
        let e3 = "";
        t2 ? (s2._setDataItem(t2), e3 = this.get("legendValueText", s2.get("text", ""))) : (s2._setDataItem(this._emptyDataItem), e3 = this.get("legendRangeValueText", s2.get("text", ""))), s2.set("text", e3);
      }
    }
  }
  _getItemReaderLabel() {
    let t2 = "X: {" + this._xField;
    return this.get("xAxis").isType("DateAxis") && (t2 += ".formatDate()"), t2 += "}; Y: {" + this._yField, this.get("yAxis").isType("DateAxis") && (t2 += ".formatDate()"), t2 += "}", t2;
  }
  getPoint(t2, e2) {
    let i = this.get("xAxis").get("renderer").positionToCoordinate(t2), s2 = this.get("yAxis").get("renderer").positionToCoordinate(e2), a = 999999999;
    return s2 < -a && (s2 = -a), s2 > a && (s2 = a), i < -a && (i = -a), i > a && (i = a), { x: i, y: s2 };
  }
  _shouldInclude(t2) {
    return true;
  }
  handleCursorHide() {
    this.hideTooltip(), this.updateLegendValue(void 0), this.updateLegendMarker(void 0);
  }
  _afterDataChange() {
    super._afterDataChange(), this.get("xAxis")._markDirtyKey("start"), this.get("yAxis")._markDirtyKey("start"), this.resetExtremes();
  }
  resetExtremes() {
    this.setPrivate("selectionMinX", void 0), this.setPrivate("selectionMaxX", void 0), this.setPrivate("selectionMinY", void 0), this.setPrivate("selectionMaxY", void 0), this.setPrivate("minX", void 0), this.setPrivate("minY", void 0), this.setPrivate("maxX", void 0), this.setPrivate("maxY", void 0);
  }
  createAxisRange(t2) {
    return this.axisRanges.push({ axisDataItem: t2 });
  }
  get mainDataItems() {
    return this._mainDataItems;
  }
};
Object.defineProperty(ut, "className", { enumerable: true, configurable: true, writable: true, value: "XYSeries" }), Object.defineProperty(ut, "classNames", { enumerable: true, configurable: true, writable: true, value: D.classNames.concat([ut.className]) });
var gt = class _gt extends ut {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_ph", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_pw", { enumerable: true, configurable: true, writable: true, value: 0 });
  }
  _makeGraphics(t2, e2) {
    return this.makeColumn(e2, t2);
  }
  _makeFieldNames() {
    super._makeFieldNames();
    const t2 = this.get("xAxis"), e2 = this.get("yAxis"), i = "CategoryAxis", s2 = "ValueAxis";
    t2.isType(i) && (this.get("openCategoryXField") || (this._xOpenField = this._xField)), t2.isType(s2) && (this.get("openValueXField") || (this._xOpenField = this._xField)), e2.isType(i) && (this.get("openCategoryYField") || (this._yOpenField = this._yField)), e2.isType(s2) && (this.get("openValueYField") || (this._yOpenField = this._yField));
  }
  _prepareChildren() {
    super._prepareChildren();
    const t2 = this.get("xAxis"), e2 = this.get("yAxis"), i = this.dataItems.length, s2 = Math.max(0, this.startIndex() - 2), a = Math.min(this.endIndex() + 2, i - 1);
    if (t2.inited && e2.inited)
      for (let o2 = s2; o2 <= a; o2++) {
        let t3 = this.dataItems[o2];
        this._createGraphics(t3);
      }
  }
  _updateChildren() {
    const t2 = this.chart;
    t2 && (this._ph = t2.plotContainer.height(), this._pw = t2.plotContainer.width());
    const e2 = this.get("xAxis"), i = this.get("yAxis"), s2 = this.get("baseAxis"), a = this.columns.template;
    this.isDirty("fill") && null == a.get("fill") && a.set("fill", this.get("fill")), this.isDirty("stroke") && null == a.get("stroke") && a.set("stroke", this.get("stroke"));
    let o2 = 0, n2 = 0, r = 0;
    m(s2.series, (t3) => {
      if (t3 instanceof _gt) {
        const e3 = t3.get("stacked");
        e3 && 0 == r && n2++, !e3 && t3.get("clustered") && n2++;
      }
      t3 === this && (o2 = n2 - 1), r++;
    }), this.get("clustered") || (o2 = 0, n2 = 1), 0 === n2 && (n2 = 1, o2 = 0);
    const l3 = e2.get("renderer"), h = i.get("renderer"), c = "cellStartLocation", d = "cellEndLocation", u = l3.get(c, 0), g2 = l3.get(d, 1), p = h.get(c, 0), m2 = h.get(d, 1);
    if (this._aLocationX0 = u + o2 / n2 * (g2 - u), this._aLocationX1 = u + (o2 + 1) / n2 * (g2 - u), this._aLocationY0 = p + o2 / n2 * (m2 - p), this._aLocationY1 = p + (o2 + 1) / n2 * (m2 - p), e2.inited && i.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
        const t3 = this.dataItems.length;
        let e3 = Math.max(0, this.startIndex() - 2), i2 = Math.min(this.endIndex() + 2, t3 - 1);
        for (let a2 = 0; a2 < e3; a2++)
          this._toggleColumn(this.dataItems[a2], false);
        let s3 = this.dataItems[e3];
        for (let a2 = e3; a2 <= i2; a2++) {
          let t4 = this.dataItems[a2];
          if (null != t4.get("valueX") && null != t4.get("valueY")) {
            if (s3 = t4, a2 > 0 && e3 > 0)
              for (let t5 = a2 - 1; t5 >= 0; t5--) {
                let e4 = this.dataItems[t5];
                if (null != e4.get("valueX") && null != e4.get("valueY")) {
                  s3 = e4;
                  break;
                }
              }
            break;
          }
          this._toggleColumn(t4, false);
        }
        for (let a2 = e3; a2 <= i2; a2++) {
          let t4 = this.dataItems[a2];
          this._updateGraphics(t4, s3), null != t4.get("valueX") && null != t4.get("valueY") && (s3 = t4);
        }
        for (let a2 = i2 + 1; a2 < t3; a2++)
          this._toggleColumn(this.dataItems[a2], false);
      }
    } else
      this._skipped = true;
    this.updateLegendMarker(this.get("tooltipDataItem")), super._updateChildren();
  }
  _createGraphics(t2) {
    let e2 = t2.get("graphics");
    if (!e2) {
      e2 = this._makeGraphics(this.columns, t2), t2.set("graphics", e2), e2._setDataItem(t2);
      const i = t2.get("legendDataItem");
      if (i) {
        const t3 = i.get("markerRectangle");
        t3 && t3.setAll({ fill: e2.get("fill"), stroke: e2.get("stroke") });
      }
      this.axisRanges.each((e3) => {
        const i2 = e3.container, s2 = t2.get("rangeGraphics", []);
        t2.set("rangeGraphics", s2);
        const a = this._makeGraphics(e3.columns, t2);
        s2.push(a), a.setPrivate("list", e3.columns), i2.children.push(a);
      });
    }
  }
  _updateGraphics(t2, e2) {
    let i = t2.get("graphics");
    const s2 = this._xField, a = this._yField, o2 = t2.get(s2), n2 = t2.get(a);
    if (null != o2 && null != n2) {
      const o3 = this._xOpenField, n3 = this._yOpenField, r = this.get("locationX", t2.get("locationX", 0.5)), l3 = this.get("locationY", t2.get("locationY", 0.5)), h = this.get("openLocationX", t2.get("openLocationX", r)), c = this.get("openLocationY", t2.get("openLocationY", l3)), d = i.get("width"), u = i.get("height"), g2 = this.get("stacked"), p = this.get("xAxis"), m2 = this.get("yAxis"), _2 = this.get("baseAxis"), b = p.get("start"), y2 = p.get("end"), v2 = m2.get("start"), P2 = m2.get("end");
      let w, T, A2, k2, D2 = this.get("vcy", 1), C = this.get("vcx", 1), I2 = false, X = false;
      if (m2.isType("CategoryAxis") && p.isType("CategoryAxis")) {
        let e3 = this._aLocationX0 + h - 0.5, i2 = this._aLocationX1 + r - 0.5;
        if (d instanceof K) {
          let t3 = (i2 - e3) * (1 - d.value) / 2;
          e3 += t3, i2 -= t3;
        }
        if (w = p.getDataItemPositionX(t2, o3, e3, C), T = p.getDataItemPositionX(t2, s2, i2, C), e3 = this._aLocationY0 + c - 0.5, i2 = this._aLocationY1 + l3 - 0.5, u instanceof K) {
          let t3 = (i2 - e3) * (1 - u.value) / 2;
          e3 += t3, i2 -= t3;
        }
        A2 = m2.getDataItemPositionY(t2, n3, e3, D2), k2 = m2.getDataItemPositionY(t2, a, i2, D2), t2.setRaw("point", { x: w + (T - w) / 2, y: A2 + (k2 - A2) / 2 });
      } else if (p === _2) {
        let e3 = this._aLocationX0 + h - 0.5, i2 = this._aLocationX1 + r - 0.5;
        if (d instanceof K) {
          let t3 = (i2 - e3) * (1 - d.value) / 2;
          e3 += t3, i2 -= t3;
        }
        if (w = p.getDataItemPositionX(t2, o3, e3, C), T = p.getDataItemPositionX(t2, s2, i2, C), A2 = m2.getDataItemPositionY(t2, a, l3, D2), this._yOpenField !== this._yField)
          k2 = m2.getDataItemPositionY(t2, n3, c, D2);
        else if (g2) {
          let e4 = t2.get("stackToItemY");
          k2 = e4 ? m2.getDataItemPositionY(e4, a, c, e4.component.get("vcy")) : m2.basePosition();
        } else
          k2 = m2.basePosition();
        t2.setRaw("point", { x: w + (T - w) / 2, y: A2 }), X = true;
      } else if (m2 === _2) {
        let e3 = this._aLocationY0 + c - 0.5, i2 = this._aLocationY1 + l3 - 0.5;
        if (u instanceof K) {
          let t3 = (i2 - e3) * (1 - u.value) / 2;
          e3 += t3, i2 -= t3;
        }
        if (A2 = m2.getDataItemPositionY(t2, n3, e3, D2), k2 = m2.getDataItemPositionY(t2, a, i2, D2), T = p.getDataItemPositionX(t2, s2, r, C), this._xOpenField !== this._xField)
          w = p.getDataItemPositionX(t2, o3, h, C);
        else if (g2) {
          let e4 = t2.get("stackToItemX");
          w = e4 ? p.getDataItemPositionX(e4, s2, h, e4.component.get("vcx")) : p.basePosition();
        } else
          w = p.basePosition();
        I2 = true, t2.setRaw("point", { x: T, y: A2 + (k2 - A2) / 2 });
      }
      this._updateSeriesGraphics(t2, i, w, T, A2, k2, I2, X), w < b && T < b || w > y2 && T > y2 || A2 < v2 && k2 <= v2 || A2 >= P2 && k2 > P2 || e(w) || e(A2) ? this._toggleColumn(t2, false) : this._toggleColumn(t2, true);
      let Y2 = t2.get("rangeGraphics");
      Y2 && m(Y2, (e3) => {
        this._updateSeriesGraphics(t2, e3, w, T, A2, k2, I2, X);
      }), this._applyGraphicsStates(t2, e2);
    }
  }
  _updateSeriesGraphics(t2, e2, i, a, o2, n2, r, l3) {
    const h = e2.get("width"), c = e2.get("height"), d = e2.get("maxWidth"), u = e2.get("maxHeight"), g2 = this.getPoint(i, o2), p = this.getPoint(a, n2), m2 = t2.get("point");
    if (m2) {
      const t3 = this.getPoint(m2.x, m2.y);
      m2.x = t3.x + this._x, m2.y = t3.y + this._y;
    }
    if (i = g2.x, a = p.x, o2 = g2.y, n2 = p.y, l(h)) {
      const t3 = (a - i - h) / 2;
      i += t3, a -= t3;
    }
    if (l(d) && d < Math.abs(a - i)) {
      const t3 = (a - i - d) / 2;
      i += t3, a -= t3;
    }
    if (l(c)) {
      const t3 = (n2 - o2 - c) / 2;
      o2 += t3, n2 -= t3;
    }
    if (l(u) && u < Math.abs(n2 - o2)) {
      const t3 = (n2 - o2 - u) / 2;
      o2 += t3, n2 -= t3;
    }
    this.get("adjustBulletPosition") && (r && (a = Math.min(Math.max(0, a), this._pw), i = Math.min(Math.max(0, i), this._pw)), l3 && (o2 = Math.min(Math.max(0, o2), this._ph), n2 = Math.min(Math.max(0, n2), this._ph))), t2.setRaw("left", i), t2.setRaw("right", a), t2.setRaw("top", o2), t2.setRaw("bottom", n2), e2.setPrivate("width", a - i), e2.setPrivate("height", n2 - o2), e2.set("x", i), e2.set("y", n2 - (n2 - o2));
  }
  _handleDataSetChange() {
    super._handleDataSetChange(), m(this._dataItems, (t2) => {
      this._toggleColumn(t2, false);
    });
  }
  _applyGraphicsStates(t2, e2) {
    const i = t2.get("graphics"), a = i.states.lookup("dropFromOpen"), o2 = i.states.lookup("riseFromOpen"), n2 = i.states.lookup("dropFromPrevious"), r = i.states.lookup("riseFromPrevious");
    if (a || n2 || o2 || r) {
      const i2 = this.get("xAxis"), l3 = this.get("yAxis"), h = this.get("baseAxis");
      let c, d, u;
      h === i2 && l3.isType("ValueAxis") ? (c = t2.get(this._yOpenField), d = t2.get(this._yField), u = e2.get(this._yField)) : h === l3 && i2.isType("ValueAxis") && (c = t2.get(this._xOpenField), d = t2.get(this._xField), u = e2.get(this._xField)), l(c) && l(d) && (d < c ? a && a.apply() : o2 && o2.apply(), l(u) && (d < u ? n2 && n2.apply() : r && r.apply()));
    }
  }
  disposeDataItem(t2) {
    super.disposeDataItem(t2);
    const e2 = t2.get("graphics");
    e2 && (this.columns.removeValue(e2), e2.dispose());
    const i = t2.get("rangeGraphics");
    i && m(i, (t3) => {
      const e3 = t3.getPrivate("list");
      e3 && e3.removeValue(t3), t3.dispose();
    });
  }
  hideDataItem(t2, e2) {
    const i = Object.create(null, { hideDataItem: { get: () => super.hideDataItem } });
    return t(this, void 0, void 0, function* () {
      const s2 = [i.hideDataItem.call(this, t2, e2)], a = t2.get("graphics");
      a && s2.push(a.hide(e2));
      const o2 = t2.get("rangeGraphics");
      o2 && m(o2, (t3) => {
        s2.push(t3.hide(e2));
      }), yield Promise.all(s2);
    });
  }
  _toggleColumn(t2, e2) {
    const i = t2.get("graphics");
    i && i.setPrivate("visible", e2);
    const s2 = t2.get("rangeGraphics");
    s2 && m(s2, (t3) => {
      t3.setPrivate("visible", e2);
    });
    const a = t2.bullets;
    a && m(a, (t3) => {
      t3.setPrivate("hidden", !e2);
    });
  }
  showDataItem(t2, e2) {
    const i = Object.create(null, { showDataItem: { get: () => super.showDataItem } });
    return t(this, void 0, void 0, function* () {
      const s2 = [i.showDataItem.call(this, t2, e2)], a = t2.get("graphics");
      a && s2.push(a.show(e2));
      const o2 = t2.get("rangeGraphics");
      o2 && m(o2, (t3) => {
        s2.push(t3.show(e2));
      }), yield Promise.all(s2);
    });
  }
  updateLegendMarker(t2) {
    let e2 = this.get("legendDataItem");
    if (this.get("useLastColorForLegendMarker") && !t2) {
      const e3 = this.dataItems[this.endIndex() - 1];
      e3 && (t2 = e3);
    }
    if (e2) {
      let i = this.columns.template;
      if (t2) {
        let e3 = t2.get("graphics");
        e3 && (i = e3);
      }
      const s2 = e2.get("markerRectangle");
      s2 && (e2.get("itemContainer").get("disabled") || m(Ne, (t3) => {
        s2.set(t3, i.get(t3, this.get(t3)));
      }));
    }
  }
  _getTooltipTarget(t2) {
    if ("bullet" == this.get("seriesTooltipTarget"))
      return super._getTooltipTarget(t2);
    let e2 = t2.get("graphics");
    return e2 || this;
  }
};
Object.defineProperty(gt, "className", { enumerable: true, configurable: true, writable: true, value: "BaseColumnSeries" }), Object.defineProperty(gt, "classNames", { enumerable: true, configurable: true, writable: true, value: ut.classNames.concat([gt.className]) });
var pt2 = class extends _ {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_series", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "_isPanning", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "labelsContainer", { enumerable: true, configurable: true, writable: true, value: this.children.push(Je.new(this._root, {})) }), Object.defineProperty(this, "gridContainer", { enumerable: true, configurable: true, writable: true, value: Je.new(this._root, { width: z, height: z }) }), Object.defineProperty(this, "topGridContainer", { enumerable: true, configurable: true, writable: true, value: Je.new(this._root, { width: z, height: z }) }), Object.defineProperty(this, "bulletsContainer", { enumerable: true, configurable: true, writable: true, value: this.children.push(Je.new(this._root, { isMeasured: false, width: z, height: z, position: "absolute" })) }), Object.defineProperty(this, "chart", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_rangesDirty", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_panStart", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_panEnd", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_sAnimation", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_eAnimation", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_skipSync", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "axisRanges", { enumerable: true, configurable: true, writable: true, value: new R() }), Object.defineProperty(this, "_seriesAxisRanges", { enumerable: true, configurable: true, writable: true, value: [] }), Object.defineProperty(this, "ghostLabel", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_cursorPosition", { enumerable: true, configurable: true, writable: true, value: -1 }), Object.defineProperty(this, "_snapToSeries", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_seriesValuesDirty", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "axisHeader", { enumerable: true, configurable: true, writable: true, value: this.children.push(Je.new(this._root, { themeTags: ["axis", "header"], position: "absolute", background: Fe.new(this._root, { themeTags: ["header", "background"], fill: this._root.interfaceColors.get("background") }) })) }), Object.defineProperty(this, "_bullets", { enumerable: true, configurable: true, writable: true, value: {} });
  }
  _dispose() {
    this.gridContainer.dispose(), this.topGridContainer.dispose(), this.bulletsContainer.dispose(), this.labelsContainer.dispose(), this.axisHeader.dispose(), super._dispose();
  }
  _afterNew() {
    super._afterNew(), this.setPrivate("updateScrollbar", true), this._disposers.push(this.axisRanges.events.onAll((t3) => {
      if ("clear" === t3.type)
        m(t3.oldValues, (t4) => {
          this.disposeDataItem(t4);
        });
      else if ("push" === t3.type)
        this._processAxisRange(t3.newValue, ["range"]);
      else if ("setIndex" === t3.type)
        this._processAxisRange(t3.newValue, ["range"]);
      else if ("insertIndex" === t3.type)
        this._processAxisRange(t3.newValue, ["range"]);
      else if ("removeIndex" === t3.type)
        this.disposeDataItem(t3.oldValue);
      else {
        if ("moveIndex" !== t3.type)
          throw new Error("Unknown IStreamEvent type");
        this._processAxisRange(t3.value, ["range"]);
      }
    }));
    const t2 = this.get("renderer");
    t2 && (t2.axis = this, t2.processAxis()), this.children.push(t2), this.ghostLabel = t2.makeLabel(new g(this, void 0, {}), []), this.ghostLabel.adapters.disable("text"), this.ghostLabel.setAll({ opacity: 0, tooltipText: void 0, tooltipHTML: void 0, interactive: false }), this.ghostLabel.events.disable();
  }
  _updateFinals(t2, e2) {
  }
  zoom(t2, e2, i, a) {
    if (this._updateFinals(t2, e2), this.get("start") !== t2 || this.get("end") != e2) {
      let o2 = this._sAnimation, n2 = this._eAnimation, r = this.get("maxDeviation", 0.5) * Math.min(1, e2 - t2);
      t2 < -r && (t2 = -r), e2 > 1 + r && (e2 = 1 + r), t2 > e2 && ([t2, e2] = [e2, t2]), l(i) || (i = this.get("interpolationDuration", 0)), a || (a = "end");
      let l3 = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100)), h = l3;
      1 === e2 && 0 !== t2 && (a = t2 < this.get("start") ? "start" : "end"), 0 === t2 && 1 !== e2 && (a = e2 > this.get("end") ? "end" : "start");
      let c = this.get("minZoomCount"), d = this.get("maxZoomCount");
      l(c) && (l3 = h / c);
      let u = 1;
      if (l(d) && (u = h / d), "start" === a ? (d > 0 && 1 / (e2 - t2) < u && (e2 = t2 + 1 / u), 1 / (e2 - t2) > l3 && (e2 = t2 + 1 / l3), e2 > 1 && e2 - t2 < 1 / l3 && (t2 = e2 - 1 / l3)) : (d > 0 && 1 / (e2 - t2) < u && (t2 = e2 - 1 / u), 1 / (e2 - t2) > l3 && (t2 = e2 - 1 / l3), t2 < 0 && e2 - t2 < 1 / l3 && (e2 = t2 + 1 / l3)), 1 / (e2 - t2) > l3 && (e2 = t2 + 1 / l3), 1 / (e2 - t2) > l3 && (t2 = e2 - 1 / l3), null != d && null != c && t2 == this.get("start") && e2 == this.get("end")) {
        const t3 = this.chart;
        t3 && t3._handleAxisSelection(this, true);
      }
      if ((o2 && o2.playing && o2.to == t2 || this.get("start") == t2) && (n2 && n2.playing && n2.to == e2 || this.get("end") == e2))
        return;
      if (i > 0) {
        let s2, a2, o3 = this.get("interpolationEasing");
        if (this.get("start") != t2 && (s2 = this.animate({ key: "start", to: t2, duration: i, easing: o3 })), this.get("end") != e2 && (a2 = this.animate({ key: "end", to: e2, duration: i, easing: o3 })), this._sAnimation = s2, this._eAnimation = a2, s2)
          return s2;
        if (a2)
          return a2;
      } else
        this.set("start", t2), this.set("end", e2), this._root.events.once("frameended", () => {
          this._markDirtyKey("start"), this._root._markDirty();
        });
    } else
      this._sAnimation && this._sAnimation.stop(), this._eAnimation && this._eAnimation.stop();
  }
  get series() {
    return this._series;
  }
  _processAxisRange(t2, e2) {
    t2.setRaw("isRange", true), this._createAssets(t2, e2), this._rangesDirty = true, this._prepareDataItem(t2);
    const i = t2.get("above"), s2 = this.topGridContainer, a = t2.get("grid");
    i && a && s2.children.moveValue(a);
    const o2 = t2.get("axisFill");
    i && o2 && s2.children.moveValue(o2);
  }
  _prepareDataItem(t2, e2) {
  }
  markDirtyExtremes() {
  }
  markDirtySelectionExtremes() {
  }
  _calculateTotals() {
  }
  _updateAxisRanges() {
    this._bullets = {}, this.axisRanges.each((t2) => {
      this._prepareDataItem(t2);
    }), m(this._seriesAxisRanges, (t2) => {
      this._prepareDataItem(t2);
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.get("fixAxisSize") ? this.ghostLabel.set("visible", true) : this.ghostLabel.set("visible", false), this.isDirty("start") || this.isDirty("end")) {
      this.chart._updateCursor();
      let t3 = this.get("start", 0), e2 = this.get("end", 1), i = this.get("maxDeviation", 0.5) * Math.min(1, e2 - t3);
      if (t3 < -i) {
        let s2 = t3 + i;
        t3 = -i, this.setRaw("start", t3), this.isDirty("end") && this.setRaw("end", e2 - s2);
      }
      if (e2 > 1 + i) {
        let s2 = e2 - 1 - i;
        e2 = 1 + i, this.setRaw("end", e2), this.isDirty("start") && this.setRaw("start", t3 - s2);
      }
    }
    const t2 = this.get("renderer");
    if (t2._start = this.get("start"), t2._end = this.get("end"), t2._inversed = t2.get("inversed", false), t2._axisLength = t2.axisLength() / (t2._end - t2._start), t2._updateLC(), this.isDirty("tooltip")) {
      const e2 = this.get("tooltip");
      if (e2) {
        const i = t2.get("themeTags");
        e2.addTag("axis"), e2.addTag(this.className.toLowerCase()), e2._applyThemes(), i && (e2.set("themeTags", Kt(e2.get("themeTags"), i)), e2.label._applyThemes());
      }
    }
  }
  _updateTooltipBounds() {
    const t2 = this.get("tooltip");
    t2 && this.get("renderer").updateTooltipBounds(t2);
  }
  _updateBounds() {
    super._updateBounds(), this._updateTooltipBounds();
  }
  processChart(t2) {
    this.chart = t2;
    this.get("renderer").chart = t2, t2.gridContainer.children.push(this.gridContainer), t2.topGridContainer.children.push(this.topGridContainer), t2.axisHeadersContainer.children.push(this.axisHeader), this.on("start", () => {
      t2._handleAxisSelection(this);
    }), this.on("end", () => {
      t2._handleAxisSelection(this);
    }), t2.plotContainer.onPrivate("width", () => {
      this.markDirtySize();
    }), t2.plotContainer.onPrivate("height", () => {
      this.markDirtySize();
    }), t2.processAxis(this);
  }
  hideDataItem(t2) {
    return this._toggleDataItem(t2, false), super.hideDataItem(t2);
  }
  showDataItem(t2) {
    return this._toggleDataItem(t2, true), super.showDataItem(t2);
  }
  _toggleDataItem(t2, e2) {
    const i = t2.get("label");
    i && i.setPrivate("visible", e2);
    const s2 = t2.get("grid");
    s2 && s2.setPrivate("visible", e2);
    const a = t2.get("tick");
    a && a.setPrivate("visible", e2);
    const o2 = t2.get("axisFill");
    o2 && o2.setPrivate("visible", e2);
    const n2 = t2.get("bullet");
    if (n2) {
      const t3 = n2.get("sprite");
      t3 && t3.setPrivate("visible", e2);
    }
  }
  _createAssets(t2, e2) {
    const i = this.get("renderer");
    t2.get("label") || i.makeLabel(t2, e2), t2.get("grid") || i.makeGrid(t2, e2), t2.get("tick") || i.makeTick(t2, e2), t2.get("axisFill") || i.makeAxisFill(t2, e2), this._processBullet(t2);
  }
  _processBullet(t2) {
    let e2 = t2.get("bullet"), i = this.get("bullet");
    if (e2 || !i || t2.get("isRange") || (e2 = i(this._root, this, t2)), e2) {
      e2.axis = this;
      const i2 = e2.get("sprite");
      i2 && (i2._setDataItem(t2), t2.setRaw("bullet", e2), i2.parent || this.bulletsContainer.children.push(i2));
    }
  }
  _afterChanged() {
    super._afterChanged();
    const t2 = this.chart;
    t2 && (t2._updateChartLayout(), t2.axisHeadersContainer.markDirtySize()), this.get("renderer")._updatePositions();
  }
  disposeDataItem(t2) {
    super.disposeDataItem(t2);
    const e2 = this.get("renderer"), i = t2.get("label");
    i && (e2.labels.removeValue(i), i.dispose());
    const s2 = t2.get("tick");
    s2 && (e2.ticks.removeValue(s2), s2.dispose());
    const a = t2.get("grid");
    a && (e2.grid.removeValue(a), a.dispose());
    const o2 = t2.get("axisFill");
    o2 && (e2.axisFills.removeValue(o2), o2.dispose());
    const n2 = t2.get("bullet");
    n2 && n2.dispose();
  }
  _updateGhost() {
    this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
    const t2 = this.ghostLabel;
    if (!t2.isHidden()) {
      const e3 = t2.localBounds(), i2 = e3.right - e3.left;
      let s2 = t2.get("text");
      m(this.dataItems, (t3) => {
        const e4 = t3.get("label");
        if (e4 && !e4.isHidden()) {
          const t4 = e4.localBounds();
          t4.right - t4.left > i2 && (s2 = e4.text._getText());
        }
      }), t2.set("text", s2);
    }
    let e2 = this.get("start", 0), i = this.get("end", 1);
    this.get("renderer").updateLabel(t2, e2 + 0.5 * (i - e2));
  }
  _handleCursorPosition(t2, e2) {
    t2 = this.get("renderer").toAxisPosition(t2), this._cursorPosition = t2, this._snapToSeries = e2, this.updateTooltip();
  }
  updateTooltip() {
    const t2 = this._snapToSeries;
    let e2 = this._cursorPosition;
    const i = this.get("tooltip"), a = this.get("renderer");
    l(e2) && (m(this.series, (i2) => {
      if (i2.get("baseAxis") === this) {
        const s2 = this.getSeriesItem(i2, e2, this.get("tooltipLocation"));
        i2.setRaw("tooltipDataItem", s2), t2 && -1 != t2.indexOf(i2) ? (i2.updateLegendMarker(s2), i2.updateLegendValue(s2)) : i2.showDataItemTooltip(s2);
      }
    }), i && (a.updateTooltipBounds(i), this.get("snapTooltip") && (e2 = this.roundAxisPosition(e2, this.get("tooltipLocation", 0.5))), e(e2) ? i.hide(0) : (this.setPrivateRaw("tooltipPosition", e2), this._updateTooltipText(i, e2), a.positionTooltip(i, e2), e2 < this.get("start") || e2 > this.get("end") ? i.hide(0) : i.show(0))));
  }
  _updateTooltipText(t2, e2) {
    t2.label.set("text", this.getTooltipText(e2));
  }
  roundAxisPosition(t2, e2) {
    return t2;
  }
  handleCursorShow() {
    let t2 = this.get("tooltip");
    t2 && t2.show();
  }
  handleCursorHide() {
    let t2 = this.get("tooltip");
    t2 && t2.hide();
  }
  processSeriesDataItem(t2, e2) {
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = false, this._rangesDirty = false;
  }
  coordinateToPosition(t2) {
    const e2 = this.get("renderer");
    return e2.toAxisPosition(t2 / e2.axisLength());
  }
  toAxisPosition(t2) {
    return this.get("renderer").toAxisPosition(t2);
  }
  fixPosition(t2) {
    return this.get("renderer").fixPosition(t2);
  }
  shouldGap(t2, e2, i, s2) {
    return false;
  }
  createAxisRange(t2) {
    return this.axisRanges.push(t2);
  }
  _groupSeriesData(t2) {
  }
  getCellWidthPosition() {
    return 0.05;
  }
};
Object.defineProperty(pt2, "className", { enumerable: true, configurable: true, writable: true, value: "Axis" }), Object.defineProperty(pt2, "classNames", { enumerable: true, configurable: true, writable: true, value: _.classNames.concat([pt2.className]) });
var mt2 = class _mt extends pt2 {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_itemMap", { enumerable: true, configurable: true, writable: true, value: {} });
  }
  _afterNew() {
    this._settings.themeTags = Kt(this._settings.themeTags, ["axis"]), this.fields.push("category"), this.setPrivateRaw("name", "category"), this.addTag("category"), super._afterNew();
  }
  _prepareChildren() {
    super._prepareChildren();
    const t2 = this.dataItems.length;
    let e2 = 0;
    this._valuesDirty && (this._itemMap = {}, m(this.dataItems, (t3) => {
      t3.setRaw("index", e2), this._itemMap[t3.get("category")] = t3, e2++;
    }), this.setPrivateRaw("maxZoomFactor", t2)), this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * t2), 0)), this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * t2), t2)), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && this.dataItems.length > 0 && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges());
  }
  _handleRangeChange() {
    m(this.series, (t2) => {
      let e2 = this.dataItems[this.startIndex()].get("category"), i = this.dataItems[this.endIndex() - 1].get("category"), s2 = t2.get("baseAxis"), a = t2.get("xAxis"), o2 = t2.get("yAxis");
      if (a instanceof _mt && o2 instanceof _mt)
        t2._markDirtyAxes();
      else if (s2 === this) {
        let n2, r, l3 = o2;
        if (a === s2 ? (t2.get("categoryXField") && (n2 = "categoryX"), t2.get("openCategoryXField") && (r = "openCategoryX")) : o2 === s2 && (t2.get("categoryYField") && (n2 = "categoryY"), t2.get("openCategoryYField") && (r = "openCategoryY"), l3 = a), "ValueAxis" == l3.className && (n2 || r)) {
          let s3, a2;
          for (let i2 = 0, c = t2.dataItems.length; i2 < c; i2++) {
            let a3 = t2.dataItems[i2];
            if (n2 && a3.get(n2) === e2) {
              s3 = a3;
              break;
            }
            if (r && a3.get(r) === e2) {
              s3 = a3;
              break;
            }
          }
          for (let e3 = t2.dataItems.length - 1; e3 >= 0; e3--) {
            let s4 = t2.dataItems[e3];
            if (n2 && s4.get(n2) === i) {
              a2 = s4;
              break;
            }
            if (r && s4.get(r) === i) {
              a2 = s4;
              break;
            }
          }
          let o3 = 0, l4 = t2.dataItems.length;
          s3 && (o3 = t2.dataItems.indexOf(s3)), a2 && (l4 = t2.dataItems.indexOf(a2) + 1), t2.setPrivate("startIndex", o3), t2.setPrivate("endIndex", l4);
          let h = false;
          for (let e3 = o3; e3 < l4; e3++) {
            const i2 = t2.dataItems[e3];
            if (m(t2.__valueXShowFields, (t3) => {
              null != i2.get(t3) && (h = true);
            }), m(t2.__valueYShowFields, (t3) => {
              null != i2.get(t3) && (h = true);
            }), h)
              break;
          }
          t2.setPrivate("outOfSelection", !h);
        }
        t2._markDirtyAxes();
      }
    });
  }
  _prepareAxisItems() {
    const t2 = this.get("renderer"), e2 = this.dataItems.length;
    let i = this.startIndex();
    i > 0 && i--;
    let s2 = this.endIndex();
    s2 < e2 && s2++;
    let a = t2.axisLength() / Math.max(t2.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), o2 = Math.max(1, Math.min(e2, Math.ceil((s2 - i) / a)));
    i = Math.floor(i / o2) * o2, this._frequency = o2;
    for (let r = 0; r < e2; r++)
      this.dataItems[r].hide();
    let n2 = this.dataItems[i].get("index", 0);
    for (let r = i; r < s2; r += o2) {
      let t3 = this.dataItems[r];
      this._createAssets(t3, []), t3.isHidden() && t3.show(), this._prepareDataItem(t3, n2, o2), n2++;
    }
    this._updateGhost();
  }
  _prepareDataItem(t2, e2, i) {
    let a = this.get("renderer"), o2 = t2.get("categoryLocation", 0), n2 = t2.get("endCategoryLocation", 1), r = t2.get("index");
    l(r) || (r = this.categoryToIndex(t2.get("category")));
    let l3, h = this.indexToPosition(r, o2), c = t2.get("endCategory");
    c ? (l3 = this.categoryToIndex(c), l(l3) || (l3 = r)) : l3 = r;
    let d, u, g2 = this.indexToPosition(l3, n2);
    d = t2.get("isRange") ? l3 : r + this._frequency - 1, u = this.indexToPosition(d, n2), a.updateLabel(t2.get("label"), h, g2, i), a.updateGrid(t2.get("grid"), h, g2), a.updateTick(t2.get("tick"), h, g2, i), a.updateFill(t2.get("axisFill"), h, u), this._processBullet(t2), a.updateBullet(t2.get("bullet"), h, g2);
    const p = this.get("fillRule");
    p && p(t2, e2);
  }
  startIndex() {
    let t2 = this.dataItems.length;
    return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), t2 - 1);
  }
  endIndex() {
    let t2 = this.dataItems.length;
    return Math.max(1, Math.min(this.getPrivate("endIndex", t2), t2));
  }
  baseValue() {
  }
  basePosition() {
    return 0;
  }
  getX(t2) {
    let e2 = this._itemMap[t2];
    return e2 ? this._settings.renderer.positionToCoordinate(this.indexToPosition(e2.get("index", 0))) : NaN;
  }
  getY(t2) {
    let e2 = this._itemMap[t2];
    return e2 ? this._settings.renderer.positionToCoordinate(this.indexToPosition(e2.get("index", 0))) : NaN;
  }
  getDataItemPositionX(t2, e2, i, s2) {
    const a = t2.get(e2), o2 = this._itemMap[a];
    return o2 ? this.indexToPosition(o2.get("index", 0), i) : NaN;
  }
  getDataItemCoordinateX(t2, e2, i, s2) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(t2, e2, i, s2));
  }
  getDataItemPositionY(t2, e2, i, s2) {
    const a = t2.get(e2), o2 = this._itemMap[a];
    return o2 ? this.indexToPosition(o2.get("index", 0), i) : NaN;
  }
  getDataItemCoordinateY(t2, e2, i, s2) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(t2, e2, i, s2));
  }
  indexToPosition(t2, e2) {
    l(e2) || (e2 = 0.5);
    let i = this.dataItems.length, a = this.get("startLocation", 0);
    i -= a, i -= 1 - this.get("endLocation", 1);
    let o2 = (t2 + e2 - a) / i, n2 = this.dataItems[t2];
    return n2 && (o2 += n2.get("deltaPosition", 0)), o2;
  }
  categoryToIndex(t2) {
    let e2 = this._itemMap[t2];
    return e2 ? e2.get("index") : NaN;
  }
  dataItemToPosition(t2) {
    return this.indexToPosition(t2.get("index"));
  }
  roundAxisPosition(t2, e2) {
    return t2 += (0.5 - e2) / this.dataItems.length, this.indexToPosition(this.axisPositionToIndex(t2), e2);
  }
  axisPositionToIndex(t2) {
    let e2 = this.dataItems.length;
    return ne(Math.floor(t2 * e2), 0, e2 - 1);
  }
  getTooltipText(t2) {
    const e2 = this.dataItems[this.axisPositionToIndex(t2)];
    if (e2) {
      const t3 = e2.get("label");
      if (t3)
        return Ye(t3, this.get("tooltipText", ""));
    }
  }
  _updateTooltipText(t2, e2) {
    t2._setDataItem(this.dataItems[this.axisPositionToIndex(e2)]), t2.label.text.markDirtyText();
  }
  getSeriesItem(t2, e2) {
    if (this.dataItems.length > 0) {
      let i = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), s2 = this.axisPositionToIndex(e2), a = t2.dataItems[s2], o2 = this.dataItems[s2], n2 = o2.get("category");
      if (a && o2 && a.get(i) === n2)
        return a;
      for (let e3 = 0, r = t2.dataItems.length; e3 < r; e3++) {
        let s3 = t2.dataItems[e3];
        if (s3.get(i) === n2)
          return s3;
      }
    }
  }
  zoomToIndexes(t2, e2, i) {
    let s2 = this.dataItems.length;
    this.zoom(t2 / s2, e2 / s2, i);
  }
  zoomToCategories(t2, e2, i) {
    this.zoomToIndexes(this.categoryToIndex(t2), this.categoryToIndex(e2) + 1, i);
  }
  getCellWidthPosition() {
    return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
  }
};
Object.defineProperty(mt2, "className", { enumerable: true, configurable: true, writable: true, value: "CategoryAxis" }), Object.defineProperty(mt2, "classNames", { enumerable: true, configurable: true, writable: true, value: pt2.classNames.concat([mt2.className]) });
var _t = class extends pt2 {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dirtyExtremes", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_dirtySelectionExtremes", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_deltaMinMax", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_minReal", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_maxReal", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_baseValue", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_syncDp", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_minLogAdjusted", { enumerable: true, configurable: true, writable: true, value: 1 });
  }
  markDirtyExtremes() {
    this._dirtyExtremes = true, this.markDirty();
  }
  markDirtySelectionExtremes() {
    this._dirtySelectionExtremes = true, this.markDirty();
  }
  _afterNew() {
    this._settings.themeTags = Kt(this._settings.themeTags, ["axis"]), this.setPrivateRaw("name", "value"), this.addTag("value"), super._afterNew();
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("syncWithAxis")) {
      this._prevSettings.syncWithAxis && this._syncDp && this._syncDp.dispose();
      let t2 = this.get("syncWithAxis");
      t2 && (this._syncDp = new A([t2.onPrivate("selectionMinFinal", () => {
        this._dirtySelectionExtremes = true;
      }), t2.onPrivate("selectionMaxFinal", () => {
        this._dirtySelectionExtremes = true;
      })]));
    }
    (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) && (this._getMinMax(), this.ghostLabel.set("text", ""), this._dirtyExtremes = false), this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", true) && (this._getSelectionMinMax(), this._dirtySelectionExtremes = false), this._groupData(), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges()), this._baseValue = this.baseValue();
  }
  _groupData() {
  }
  _formatText(t2) {
    const e2 = this.get("numberFormat"), i = this.getNumberFormatter();
    let s2 = "";
    return s2 = e2 ? i.format(t2, e2) : i.format(t2, void 0, this.getPrivate("stepDecimalPlaces")), s2;
  }
  _prepareAxisItems() {
    const t2 = this.getPrivate("min"), e2 = this.getPrivate("max");
    if (l(t2) && l(e2)) {
      const e3 = this.get("logarithmic"), i = this.getPrivate("step"), s2 = this.getPrivate("selectionMin"), a = this.getPrivate("selectionMax") + i;
      let o2 = s2 - i, r = 0, l3 = 1, h = t2;
      if (e3) {
        if (o2 = this._minLogAdjusted, o2 < s2)
          for (; o2 < s2; )
            o2 += i;
        h = o2, h <= 0 && (h = 1, i < 1 && (h = i)), l3 = Math.log(a - i) * Math.LOG10E - Math.log(h) * Math.LOG10E, l3 > 2 && (o2 = Math.pow(10, Math.log(h) * Math.LOG10E - 5));
      }
      let c = -1 / 0;
      for (; o2 < a; ) {
        let t3;
        this.dataItems.length < r + 1 ? (t3 = new g(this, void 0, {}), this._dataItems.push(t3), this.processDataItem(t3)) : t3 = this.dataItems[r], this._createAssets(t3, []), t3.isHidden() && t3.show(), t3.setRaw("value", o2);
        const s3 = t3.get("label");
        if (s3 && s3.set("text", this._formatText(o2)), this._prepareDataItem(t3), e3 && l3 > 2 ? o2 = Math.pow(10, Math.log(h) * Math.LOG10E + r - 5) : o2 += i, c == o2)
          break;
        let a2 = Math.pow(10, Math.floor(Math.log(Math.abs(i)) * Math.LOG10E));
        if (a2 < 1) {
          let t4 = Math.round(Math.abs(Math.log(Math.abs(a2)) * Math.LOG10E)) + 2;
          o2 = re(o2, t4);
        }
        r++, c = o2;
      }
      for (let t3 = r; t3 < this.dataItems.length; t3++)
        this.dataItems[t3].hide();
      m(this.series, (t3) => {
        t3.inited && t3._markDirtyAxes();
      }), this._updateGhost();
    }
  }
  _prepareDataItem(t2, e2) {
    let i = this.get("renderer"), a = t2.get("value"), o2 = t2.get("endValue"), n2 = this.valueToPosition(a), r = n2, l3 = this.valueToPosition(a + this.getPrivate("step"));
    l(o2) && (r = this.valueToPosition(o2), l3 = r), t2.get("isRange") && null == o2 && (l3 = n2), i.updateLabel(t2.get("label"), n2, r, e2);
    const h = t2.get("grid");
    if (i.updateGrid(h, n2, r), h && (a == this.get("baseValue", 0) ? (h.addTag("base"), h._applyThemes()) : h.hasTag("base") && (h.removeTag("base"), h._applyThemes())), i.updateTick(t2.get("tick"), n2, r, e2), i.updateFill(t2.get("axisFill"), n2, l3), this._processBullet(t2), i.updateBullet(t2.get("bullet"), n2, r), !t2.get("isRange")) {
      const e3 = this.get("fillRule");
      e3 && e3(t2);
    }
  }
  _handleRangeChange() {
    let t2 = this.positionToValue(this.get("start", 0)), e2 = this.positionToValue(this.get("end", 1));
    const i = this.get("renderer").gridCount();
    let s2 = this._adjustMinMax(t2, e2, i, true), a = ft(s2.step);
    this.setPrivateRaw("stepDecimalPlaces", a), t2 = re(t2, a), e2 = re(e2, a), s2 = this._adjustMinMax(t2, e2, i, true);
    let o2 = s2.step;
    t2 = s2.min, e2 = s2.max, this.getPrivate("selectionMin") === t2 && this.getPrivate("selectionMax") === e2 && this.getPrivate("step") === o2 || (this.setPrivateRaw("selectionMin", t2), this.setPrivateRaw("selectionMax", e2), this.setPrivateRaw("step", o2));
  }
  positionToValue(t2) {
    const e2 = this.getPrivate("min"), i = this.getPrivate("max");
    return this.get("logarithmic") ? Math.pow(Math.E, (t2 * (Math.log(i) * Math.LOG10E - Math.log(e2) * Math.LOG10E) + Math.log(e2) * Math.LOG10E) / Math.LOG10E) : t2 * (i - e2) + e2;
  }
  valueToPosition(t2) {
    const e2 = this.getPrivate("min"), i = this.getPrivate("max");
    if (this.get("logarithmic")) {
      if (t2 <= 0) {
        let e3 = this.get("treatZeroAs");
        l(e3) && (t2 = e3);
      }
      return (Math.log(t2) * Math.LOG10E - Math.log(e2) * Math.LOG10E) / (Math.log(i) * Math.LOG10E - Math.log(e2) * Math.LOG10E);
    }
    return (t2 - e2) / (i - e2);
  }
  valueToFinalPosition(t2) {
    const e2 = this.getPrivate("minFinal"), i = this.getPrivate("maxFinal");
    if (this.get("logarithmic")) {
      if (t2 <= 0) {
        let e3 = this.get("treatZeroAs");
        l(e3) && (t2 = e3);
      }
      return (Math.log(t2) * Math.LOG10E - Math.log(e2) * Math.LOG10E) / (Math.log(i) * Math.LOG10E - Math.log(e2) * Math.LOG10E);
    }
    return (t2 - e2) / (i - e2);
  }
  getX(t2, e2, i) {
    t2 = i + (t2 - i) * e2;
    const s2 = this.valueToPosition(t2);
    return this._settings.renderer.positionToCoordinate(s2);
  }
  getY(t2, e2, i) {
    t2 = i + (t2 - i) * e2;
    const s2 = this.valueToPosition(t2);
    return this._settings.renderer.positionToCoordinate(s2);
  }
  getDataItemCoordinateX(t2, e2, i, s2) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(t2, e2, i, s2));
  }
  getDataItemPositionX(t2, e2, i, s2) {
    let a = t2.get(e2);
    if (t2.get("stackToItemX")) {
      a = a * s2 + t2.component.getStackedXValueWorking(t2, e2);
    } else
      a = this._baseValue + (a - this._baseValue) * s2;
    return this.valueToPosition(a);
  }
  getDataItemCoordinateY(t2, e2, i, s2) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(t2, e2, i, s2));
  }
  getDataItemPositionY(t2, e2, i, s2) {
    let a = t2.get(e2);
    if (t2.get("stackToItemY")) {
      a = a * s2 + t2.component.getStackedYValueWorking(t2, e2);
    } else
      a = this._baseValue + (a - this._baseValue) * s2;
    return this.valueToPosition(a);
  }
  basePosition() {
    return this.valueToPosition(this.baseValue());
  }
  baseValue() {
    const t2 = Math.min(this.getPrivate("minFinal", -1 / 0), this.getPrivate("selectionMin", -1 / 0)), e2 = Math.max(this.getPrivate("maxFinal", 1 / 0), this.getPrivate("selectionMax", 1 / 0));
    let i = this.get("baseValue", 0);
    return i < t2 && (i = t2), i > e2 && (i = e2), i;
  }
  cellEndValue(t2) {
    return t2;
  }
  fixSmallStep(t2) {
    return 1 + t2 === 1 ? (t2 *= 2, this.fixSmallStep(t2)) : t2;
  }
  _fixMin(t2) {
    return t2;
  }
  _fixMax(t2) {
    return t2;
  }
  _calculateTotals() {
    if (this.get("calculateTotals")) {
      let t2 = this.series[0];
      if (t2) {
        let e2 = t2.startIndex();
        if (t2.dataItems.length > 0) {
          e2 > 0 && e2--;
          let i, s2, a = t2.endIndex();
          a < t2.dataItems.length && a++, t2.get("yAxis") == this ? (i = "valueY", s2 = "vcy") : t2.get("xAxis") == this && (i = "valueX", s2 = "vcx");
          let o2 = i + "Working";
          if (i)
            for (let t3 = e2; t3 < a; t3++) {
              let e3 = 0, a2 = 0;
              m(this.series, (i2) => {
                if (!i2.get("excludeFromTotal")) {
                  let n2 = i2.dataItems[t3];
                  if (n2) {
                    let t4 = n2.get(o2) * i2.get(s2);
                    e(t4) || (e3 += t4, a2 += Math.abs(t4));
                  }
                }
              }), m(this.series, (n2) => {
                if (!n2.get("excludeFromTotal")) {
                  let r = n2.dataItems[t3];
                  if (r) {
                    let t4 = r.get(o2) * n2.get(s2);
                    e(t4) || (r.set(i + "Total", a2), r.set(i + "Sum", e3), r.set(i + "TotalPercent", t4 / a2 * 100));
                  }
                }
              });
            }
        }
      }
    }
  }
  _getSelectionMinMax() {
    const t2 = this.getPrivate("minFinal"), e2 = this.getPrivate("maxFinal"), i = this.get("min"), a = this.get("max");
    let o2 = this.get("extraMin", 0), r = this.get("extraMax", 0);
    this.get("logarithmic") && (null == this.get("extraMin") && (o2 = 0.1), null == this.get("extraMax") && (r = 0.2));
    const l3 = this.get("renderer").gridCount(), h = this.get("strictMinMaxSelection"), c = this.get("strictMinMax");
    if (l(t2) && l(e2)) {
      let d = e2, u = t2;
      if (m(this.series, (t3) => {
        if (!t3.get("ignoreMinMax")) {
          let e3, i2;
          const a2 = t3.getPrivate("outOfSelection");
          t3.get("xAxis") === this ? a2 || (e3 = t3.getPrivate("selectionMinX", t3.getPrivate("minX")), i2 = t3.getPrivate("selectionMaxX", t3.getPrivate("maxX"))) : t3.get("yAxis") === this && (a2 || (e3 = t3.getPrivate("selectionMinY", t3.getPrivate("minY")), i2 = t3.getPrivate("selectionMaxY", t3.getPrivate("maxY")))), t3.isHidden() || t3.isShowing() || (l(e3) && (d = Math.min(d, e3)), l(i2) && (u = Math.max(u, i2)));
        }
      }), this.axisRanges.each((t3) => {
        if (t3.get("affectsMinMax")) {
          let e3 = t3.get("value");
          null != e3 && (d = Math.min(d, e3), u = Math.max(u, e3)), e3 = t3.get("endValue"), null != e3 && (d = Math.min(d, e3), u = Math.max(u, e3));
        }
      }), d > u && ([d, u] = [u, d]), l(i) ? d = c ? i : t2 : c && l(this._minReal) && (d = this._minReal), l(a) ? u = c ? a : e2 : c && l(this._maxReal) && (u = this._maxReal), d === u) {
        d -= this._deltaMinMax, u += this._deltaMinMax;
        let t3 = this._adjustMinMax(d, u, l3, c);
        d = t3.min, u = t3.max;
      }
      let g2 = d, p = u;
      d -= (u - d) * o2, u += (u - d) * r;
      let m2 = this._adjustMinMax(d, u, l3);
      d = m2.min, u = m2.max, d = ne(d, t2, e2), u = ne(u, t2, e2), m2 = this._adjustMinMax(d, u, l3, true), c || (d = m2.min, u = m2.max);
      const _2 = this.get("syncWithAxis");
      _2 && (m2 = this._syncAxes(d, u, m2.step, _2.getPrivate("selectionMinFinal", _2.getPrivate("minFinal", 0)), _2.getPrivate("selectionMaxFinal", _2.getPrivate("maxFinal", 1)), _2.getPrivate("selectionStepFinal", _2.getPrivate("step", 1))), d = m2.min, u = m2.max), c && (l(i) && (d = Math.max(d, i)), l(a) && (u = Math.min(u, a))), h && (d = g2 - (u - d) * o2, u = p + (u - d) * r), this.get("logarithmic") && (d <= 0 && (d = g2 * (1 - Math.min(o2, 0.99))), d < t2 && (d = t2), u > e2 && (u = e2));
      let b = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2), f = re(this.valueToFinalPosition(d), b), y2 = re(this.valueToFinalPosition(u), b);
      this.setPrivateRaw("selectionMinFinal", d), this.setPrivateRaw("selectionMaxFinal", u), this.setPrivateRaw("selectionStepFinal", m2.step), this.zoom(f, y2);
    }
  }
  _getMinMax() {
    let t2 = this.get("min"), e2 = this.get("max"), i = 1 / 0, a = -1 / 0, o2 = this.get("extraMin", 0), r = this.get("extraMax", 0);
    this.get("logarithmic") && (null == this.get("extraMin") && (o2 = 0.1), null == this.get("extraMax") && (r = 0.2));
    let l3 = 1 / 0;
    if (m(this.series, (t3) => {
      if (!t3.get("ignoreMinMax")) {
        let e3, o3;
        if (t3.get("xAxis") === this ? (e3 = t3.getPrivate("minX"), o3 = t3.getPrivate("maxX")) : t3.get("yAxis") === this && (e3 = t3.getPrivate("minY"), o3 = t3.getPrivate("maxY")), l(e3) && l(o3)) {
          i = Math.min(i, e3), a = Math.max(a, o3);
          let t4 = o3 - e3;
          t4 <= 0 && (t4 = Math.abs(o3 / 100)), t4 < l3 && (l3 = t4);
        }
      }
    }), this.axisRanges.each((t3) => {
      if (t3.get("affectsMinMax")) {
        let e3 = t3.get("value");
        null != e3 && (i = Math.min(i, e3), a = Math.max(a, e3)), e3 = t3.get("endValue"), null != e3 && (i = Math.min(i, e3), a = Math.max(a, e3));
      }
    }), this.get("logarithmic")) {
      let t3 = this.get("treatZeroAs");
      l(t3) && i <= 0 && (i = t3);
    }
    if (0 === i && 0 === a && (a = 0.9, i = -0.9), l(t2) && (i = t2), l(e2) && (a = e2), i === 1 / 0 || a === -1 / 0)
      return this.setPrivate("minFinal", void 0), void this.setPrivate("maxFinal", void 0);
    const h = i, c = a;
    let d = this.adapters.fold("min", i), u = this.adapters.fold("max", a);
    l(d) && (i = d), l(u) && (a = u), i = this._fixMin(i), a = this._fixMax(a), a - i <= 1 / Math.pow(10, 15) && (a - i != 0 ? this._deltaMinMax = (a - i) / 2 : this._getDelta(a), i -= this._deltaMinMax, a += this._deltaMinMax), i -= (a - i) * o2, a += (a - i) * r, this.get("logarithmic") && (i < 0 && h >= 0 && (i = 0), a > 0 && c <= 0 && (a = 0)), this._minReal = i, this._maxReal = a;
    let g2 = this.get("strictMinMax"), p = this.get("strictMinMaxSelection", false);
    p && (g2 = p);
    let m2 = g2;
    l(e2) && (m2 = true);
    let _2 = this.get("renderer").gridCount(), b = this._adjustMinMax(i, a, _2, m2);
    i = b.min, a = b.max, b = this._adjustMinMax(i, a, _2, true), i = b.min, a = b.max, g2 && (i = l(t2) ? t2 : this._minReal, a = l(e2) ? e2 : this._maxReal, a - i <= 1e-8 && (i -= this._deltaMinMax, a += this._deltaMinMax), i -= (a - i) * o2, a += (a - i) * r), d = this.adapters.fold("min", i), u = this.adapters.fold("max", a), l(d) && (i = d), l(u) && (a = u), l3 == 1 / 0 && (l3 = a - i);
    let f = Math.round(Math.abs(Math.log(Math.abs(a - i)) * Math.LOG10E)) + 5;
    i = re(i, f), a = re(a, f);
    const y2 = this.get("syncWithAxis");
    if (y2 && (b = this._syncAxes(i, a, b.step, y2.getPrivate("minFinal", y2.getPrivate("min", 0)), y2.getPrivate("maxFinal", y2.getPrivate("max", 1)), y2.getPrivate("step", 1)), i = b.min, a = b.max), this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((a - i) / l3 * this.get("maxZoomFactor", 100)))), this._fixZoomFactor(), this.get("logarithmic") && (this._minLogAdjusted = i, i = this._minReal, a = this._maxReal, i <= 0 && (i = h * (1 - Math.min(o2, 0.99)))), l(i) && l(a) && (this.getPrivate("minFinal") !== i || this.getPrivate("maxFinal") !== a)) {
      this.setPrivate("minFinal", i), this.setPrivate("maxFinal", a), this._saveMinMax(i, a);
      const t3 = this.get("interpolationDuration", 0), e3 = this.get("interpolationEasing");
      this.animatePrivate({ key: "min", to: i, duration: t3, easing: e3 }), this.animatePrivate({ key: "max", to: a, duration: t3, easing: e3 });
    }
  }
  _fixZoomFactor() {
  }
  _getDelta(t2) {
    let e2 = Math.log(Math.abs(t2)) * Math.LOG10E, i = Math.pow(10, Math.floor(e2));
    i /= 10, this._deltaMinMax = i;
  }
  _saveMinMax(t2, e2) {
  }
  _adjustMinMax(t2, e2, i, a) {
    i <= 1 && (i = 1), i = Math.round(i);
    let o2 = t2, r = e2, l3 = e2 - t2;
    0 === l3 && (l3 = Math.abs(e2));
    let h = Math.log(Math.abs(l3)) * Math.LOG10E, c = Math.pow(10, Math.floor(h));
    c /= 10;
    let d = c;
    a && (d = 0), a ? (t2 = Math.floor(t2 / c) * c, e2 = Math.ceil(e2 / c) * c) : (t2 = Math.ceil(t2 / c) * c - d, e2 = Math.floor(e2 / c) * c + d), t2 < 0 && o2 >= 0 && (t2 = 0), e2 > 0 && r <= 0 && (e2 = 0), h = Math.log(Math.abs(l3)) * Math.LOG10E, c = Math.pow(10, Math.floor(h)), c /= 100;
    let u = Math.ceil(l3 / i / c) * c, g2 = Math.pow(10, Math.floor(Math.log(Math.abs(u)) * Math.LOG10E)), p = Math.ceil(u / g2);
    p > 5 ? p = 10 : p <= 5 && p > 2 && (p = 5), u = Math.ceil(u / (g2 * p)) * g2 * p;
    let m2 = this.get("maxPrecision");
    if (l(m2)) {
      let t3 = ae(u, m2);
      m2 < Number.MAX_VALUE && u !== t3 && (u = t3);
    }
    let _2 = 0;
    g2 < 1 && (_2 = Math.round(Math.abs(Math.log(Math.abs(g2)) * Math.LOG10E)) + 1, u = re(u, _2));
    let x, b = Math.floor(t2 / u);
    return t2 = re(u * b, _2), x = a ? Math.floor(e2 / u) : Math.ceil(e2 / u), x === b && x++, (e2 = re(u * x, _2)) < r && (e2 += u), t2 > o2 && (t2 -= u), u = this.fixSmallStep(u), { min: t2, max: e2, step: u };
  }
  getTooltipText(t2) {
    const e2 = this.get("tooltipNumberFormat", this.get("numberFormat")), i = this.getNumberFormatter(), s2 = this.get("extraTooltipPrecision", 0), a = this.getPrivate("stepDecimalPlaces", 0) + s2, o2 = re(this.positionToValue(t2), a);
    return e2 ? i.format(o2, e2) : i.format(o2, void 0, a);
  }
  getSeriesItem(t2, e2) {
    let i, s2, a = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), o2 = this.positionToValue(e2);
    if (m(t2.dataItems, (t3, e3) => {
      const n2 = Math.abs(t3.get(a) - o2);
      (void 0 === i || n2 < s2) && (i = e3, s2 = n2);
    }), null != i)
      return t2.dataItems[i];
  }
  zoomToValues(t2, e2, i) {
    const s2 = this.getPrivate("minFinal", 0), a = this.getPrivate("maxFinal", 0);
    null != this.getPrivate("min") && null != this.getPrivate("max") && this.zoom((t2 - s2) / (a - s2), (e2 - s2) / (a - s2), i);
  }
  _syncAxes(t2, e2, i, a, o2, n2) {
    if (this.get("syncWithAxis")) {
      let r = Math.round(o2 - a) / n2, l3 = Math.round((e2 - t2) / i), h = this.get("renderer").gridCount();
      if (l(r) && l(l3)) {
        let s2 = false, a2 = 0, o3 = 0.01 * (e2 - t2), n3 = t2, l4 = e2, c = i;
        for (; 1 != s2; )
          if (s2 = this._checkSync(n3, l4, c, r), a2++, a2 > 500 && (s2 = true), s2)
            t2 = n3, e2 = l4, i = c;
          else {
            a2 / 3 == Math.round(a2 / 3) ? (n3 = t2 - o3 * a2, t2 >= 0 && n3 < 0 && (n3 = 0)) : (l4 = e2 + o3 * a2, l4 <= 0 && l4 > 0 && (l4 = 0));
            let i2 = this._adjustMinMax(n3, l4, h, true);
            n3 = i2.min, l4 = i2.max, c = i2.step;
          }
      }
    }
    return { min: t2, max: e2, step: i };
  }
  _checkSync(t2, e2, i, s2) {
    let a = (e2 - t2) / i;
    for (let o2 = 1; o2 < s2; o2++)
      if (re(a / o2, 1) == s2 || a * o2 == s2)
        return true;
    return false;
  }
  getCellWidthPosition() {
    let t2 = this.getPrivate("selectionMax", this.getPrivate("max")), e2 = this.getPrivate("selectionMin", this.getPrivate("min"));
    return l(t2) && l(e2) ? this.getPrivate("step", 1) / (t2 - e2) : 0.05;
  }
};
Object.defineProperty(_t, "className", { enumerable: true, configurable: true, writable: true, value: "ValueAxis" }), Object.defineProperty(_t, "classNames", { enumerable: true, configurable: true, writable: true, value: pt2.classNames.concat([_t.className]) });
var xt = class extends Qe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", { enumerable: true, configurable: true, writable: true, value: [] });
  }
};
Object.defineProperty(xt, "className", { enumerable: true, configurable: true, writable: true, value: "AxisLabel" }), Object.defineProperty(xt, "classNames", { enumerable: true, configurable: true, writable: true, value: Qe.classNames.concat([xt.className]) });
var bt = class extends B {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", { enumerable: true, configurable: true, writable: true, value: [] });
  }
};
Object.defineProperty(bt, "className", { enumerable: true, configurable: true, writable: true, value: "AxisTick" }), Object.defineProperty(bt, "classNames", { enumerable: true, configurable: true, writable: true, value: B.classNames.concat([bt.className]) });
var ft2 = class extends Re {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_axisLength", { enumerable: true, configurable: true, writable: true, value: 100 }), Object.defineProperty(this, "_start", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_end", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_inversed", { enumerable: true, configurable: true, writable: true, value: false }), Object.defineProperty(this, "_minSize", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "chart", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_lc", { enumerable: true, configurable: true, writable: true, value: 1 }), Object.defineProperty(this, "_ls", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_thumbDownPoint", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_downStart", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_downEnd", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "ticks", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => bt._new(this._root, { themeTags: Kt(this.ticks.template.get("themeTags", []), this.get("themeTags", [])) }, [this.ticks.template])) }), Object.defineProperty(this, "grid", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => lt._new(this._root, { themeTags: Kt(this.grid.template.get("themeTags", []), this.get("themeTags", [])) }, [this.grid.template])) }), Object.defineProperty(this, "axisFills", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => Re._new(this._root, { themeTags: Kt(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", [])) }, [this.axisFills.template])) }), Object.defineProperty(this, "labels", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => xt._new(this._root, { themeTags: Kt(this.labels.template.get("themeTags", []), this.get("themeTags", [])) }, [this.labels.template])) }), Object.defineProperty(this, "axis", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "thumb", { enumerable: true, configurable: true, writable: true, value: void 0 });
  }
  makeTick(t2, e2) {
    const i = this.ticks.make();
    return i._setDataItem(t2), t2.setRaw("tick", i), i.set("themeTags", Kt(i.get("themeTags"), e2)), this.axis.labelsContainer.children.push(i), this.ticks.push(i), i;
  }
  makeGrid(t2, e2) {
    const i = this.grid.make();
    return i._setDataItem(t2), t2.setRaw("grid", i), i.set("themeTags", Kt(i.get("themeTags"), e2)), this.axis.gridContainer.children.push(i), this.grid.push(i), i;
  }
  makeAxisFill(t2, e2) {
    const i = this.axisFills.make();
    return i._setDataItem(t2), i.set("themeTags", Kt(i.get("themeTags"), e2)), this.axis.gridContainer.children.push(i), t2.setRaw("axisFill", i), this.axisFills.push(i), i;
  }
  makeLabel(t2, e2) {
    const i = this.labels.make();
    return i.set("themeTags", Kt(i.get("themeTags"), e2)), this.axis.labelsContainer.children.moveValue(i, 0), i._setDataItem(t2), t2.setRaw("label", i), this.labels.push(i), i;
  }
  axisLength() {
    return 0;
  }
  gridCount() {
    return this.axisLength() / this.get("minGridDistance", 50);
  }
  _updatePositions() {
  }
  _afterNew() {
    super._afterNew(), this.set("isMeasured", false);
    const t2 = this.thumb;
    t2 && (this._disposers.push(t2.events.on("pointerdown", (t3) => {
      this._handleThumbDown(t3.originalEvent);
    })), this._disposers.push(t2.events.on("globalpointerup", (t3) => {
      this._handleThumbUp(t3.originalEvent);
    })), this._disposers.push(t2.events.on("globalpointermove", (t3) => {
      this._handleThumbMove(t3.originalEvent);
    })));
  }
  _changed() {
    if (super._changed(), this.isDirty("pan")) {
      const t2 = this.thumb;
      if (t2) {
        const e2 = this.axis.labelsContainer, i = this.get("pan");
        "zoom" == i ? e2.children.push(t2) : "none" == i && e2.children.removeValue(t2);
      }
    }
  }
  _handleThumbDown(t2) {
    this._thumbDownPoint = this.toLocal(this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY }));
    const e2 = this.axis;
    this._downStart = e2.get("start"), this._downEnd = e2.get("end");
  }
  _handleThumbUp(t2) {
    this._thumbDownPoint = void 0;
  }
  _handleThumbMove(t2) {
    const e2 = this._thumbDownPoint;
    if (e2) {
      const i = this.toLocal(this._root.documentPointToRoot({ x: t2.clientX, y: t2.clientY })), s2 = this._downStart, a = this._downEnd, o2 = this._getPan(i, e2) * Math.min(1, a - s2) / 2;
      this.axis.setAll({ start: s2 - o2, end: a + o2 });
    }
  }
  _getPan(t2, e2) {
    return 0;
  }
  positionToCoordinate(t2) {
    return this._inversed ? (this._end - t2) * this._axisLength : (t2 - this._start) * this._axisLength;
  }
  updateTooltipBounds(t2) {
  }
  _updateSize() {
    this.markDirty(), this._clear = true;
  }
  toAxisPosition(t2) {
    const e2 = this._start || 0, i = this._end || 1;
    return t2 *= i - e2, t2 = this.get("inversed") ? i - t2 : e2 + t2;
  }
  fixPosition(t2) {
    return this.get("inversed") ? 1 - t2 : t2;
  }
  _updateLC() {
  }
  toggleVisibility(t2, e2, i, s2) {
    let a = this.axis;
    const o2 = a.get("start", 0), n2 = a.get("end", 1);
    e2 < o2 + (n2 - o2) * (i - 1e-4) || e2 > o2 + (n2 - o2) * (s2 + 1e-4) ? t2.setPrivate("visible", false) : t2.setPrivate("visible", true);
  }
  _positionTooltip(t2, e2) {
    const i = this.chart;
    i && (i.inPlot(e2) ? t2.set("pointTo", this._display.toGlobal(e2)) : t2.hide());
  }
  processAxis() {
  }
};
Object.defineProperty(ft2, "className", { enumerable: true, configurable: true, writable: true, value: "AxisRenderer" }), Object.defineProperty(ft2, "classNames", { enumerable: true, configurable: true, writable: true, value: Re.classNames.concat([ft2.className]) });
var yt = class extends ft2 {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", { enumerable: true, configurable: true, writable: true, value: Fe.new(this._root, { width: z, isMeasured: false, themeTags: ["axis", "x", "thumb"] }) });
  }
  _afterNew() {
    this._settings.themeTags = Kt(this._settings.themeTags, ["renderer", "x"]), super._afterNew(), this.setPrivateRaw("letter", "X");
    const t2 = this.grid.template;
    t2.set("height", z), t2.set("width", 0), t2.set("draw", (t3, e2) => {
      t3.moveTo(0, 0), t3.lineTo(0, e2.height());
    }), this.set("draw", (t3, e2) => {
      t3.moveTo(0, 0), t3.lineTo(e2.width(), 0);
    });
  }
  _changed() {
    super._changed();
    const t2 = this.axis;
    t2.ghostLabel.setPrivate("visible", !this.get("inside")), t2.ghostLabel.set("x", -1e3);
    const e2 = "opposite", i = "inside";
    if (this.isDirty(e2) || this.isDirty(i)) {
      const s2 = this.chart, a = t2.children;
      if (this.get(i) ? t2.addTag(i) : t2.removeTag(i), s2) {
        if (this.get(e2)) {
          const i2 = s2.topAxesContainer.children;
          -1 == i2.indexOf(t2) && i2.insertIndex(0, t2), t2.addTag(e2), a.moveValue(this);
        } else {
          const i2 = s2.bottomAxesContainer.children;
          -1 == i2.indexOf(t2) && i2.moveValue(t2), t2.removeTag(e2), a.moveValue(this, 0);
        }
        t2.ghostLabel._applyThemes(), this.labels.each((t3) => {
          t3._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      t2.markDirtySize();
    }
    this.thumb.setPrivate("height", t2.labelsContainer.height());
  }
  _getPan(t2, e2) {
    return (e2.x - t2.x) / this.width();
  }
  toAxisPosition(t2) {
    const e2 = this._start || 0, i = this._end || 1;
    return t2 = (t2 -= this._ls) * (i - e2) / this._lc, t2 = this.get("inversed") ? i - t2 : e2 + t2;
  }
  _updateLC() {
    const t2 = this.axis, e2 = t2.parent;
    if (e2) {
      const i = e2.innerWidth();
      this._lc = this.axisLength() / i, this._ls = (t2.x() - e2.get("paddingLeft", 0)) / i;
    }
  }
  _updatePositions() {
    const t2 = this.axis, e2 = t2.x() - mt(t2.get("centerX", 0), t2.width()) - t2.parent.get("paddingLeft", 0);
    t2.gridContainer.set("x", e2), t2.topGridContainer.set("x", e2), t2.bulletsContainer.set("y", this.y());
    const i = t2.chart;
    if (i) {
      const e3 = i.plotContainer, s2 = t2.axisHeader;
      let a = t2.get("marginLeft", 0), o2 = t2.x() - a;
      const n2 = t2.parent;
      n2 && (o2 -= n2.get("paddingLeft", 0)), s2.children.length > 0 ? (a = t2.axisHeader.width(), t2.set("marginLeft", a + 1)) : s2.set("width", a), s2.setAll({ x: o2, y: -1, height: e3.height() + 2 });
    }
  }
  processAxis() {
    super.processAxis();
    const t2 = this.axis;
    t2.set("width", z);
    const i = this._root.verticalLayout;
    t2.set("layout", i), t2.labelsContainer.set("width", z), t2.axisHeader.setAll({ layout: i });
  }
  axisLength() {
    return this.axis.width();
  }
  positionToPoint(t2) {
    return { x: this.positionToCoordinate(t2), y: 0 };
  }
  updateTick(t2, i, a, o2) {
    if (t2) {
      l(i) || (i = 0);
      let n2 = 0.5;
      n2 = l(o2) && o2 > 1 ? t2.get("multiLocation", n2) : t2.get("location", n2), l(a) && a != i && (i += (a - i) * n2), t2.set("x", this.positionToCoordinate(i));
      let r = t2.get("length", 0);
      const l3 = t2.get("inside", this.get("inside", false));
      this.get("opposite") ? (t2.set("y", z), l3 || (r *= -1)) : (t2.set("y", 0), l3 && (r *= -1)), t2.set("draw", (t3) => {
        t3.moveTo(0, 0), t3.lineTo(0, r);
      }), this.toggleVisibility(t2, i, t2.get("minPosition", 0), t2.get("maxPosition", 1));
    }
  }
  updateLabel(t2, i, a, o2) {
    if (t2) {
      let n2 = 0.5;
      n2 = l(o2) && o2 > 1 ? t2.get("multiLocation", n2) : t2.get("location", n2), l(i) || (i = 0);
      const r = t2.get("inside", this.get("inside", false));
      this.get("opposite") ? r ? (t2.set("position", "absolute"), t2.set("y", 0)) : (t2.set("position", "relative"), t2.set("y", z)) : r ? (t2.set("y", 0), t2.set("position", "absolute")) : (t2.set("y", void 0), t2.set("position", "relative")), l(a) && a != i && (i += (a - i) * n2), t2.set("x", this.positionToCoordinate(i)), this.toggleVisibility(t2, i, t2.get("minPosition", 0), t2.get("maxPosition", 1));
    }
  }
  updateGrid(t2, e2, i) {
    if (t2) {
      l(e2) || (e2 = 0);
      let a = t2.get("location", 0.5);
      l(i) && i != e2 && (e2 += (i - e2) * a), t2.set("x", this.positionToCoordinate(e2)), this.toggleVisibility(t2, e2, 0, 1);
    }
  }
  updateBullet(t2, e2, i) {
    if (t2) {
      const a = t2.get("sprite");
      if (a) {
        l(e2) || (e2 = 0);
        let o2 = t2.get("location", 0.5);
        l(i) && i != e2 && (e2 += (i - e2) * o2);
        let n2 = this.axis.roundAxisPosition(e2, o2), r = this.axis._bullets[n2], l3 = -1;
        if (this.get("opposite") && (l3 = 1), t2.get("stacked"))
          if (r) {
            let t3 = r.get("sprite");
            t3 && a.set("y", t3.y() + t3.height() * l3);
          } else
            a.set("y", 0);
        this.axis._bullets[n2] = t2, a.set("x", this.positionToCoordinate(e2)), this.toggleVisibility(a, e2, 0, 1);
      }
    }
  }
  updateFill(t2, e2, i) {
    if (t2) {
      l(e2) || (e2 = 0), l(i) || (i = 1);
      let a = this.positionToCoordinate(e2), o2 = this.positionToCoordinate(i);
      this.fillDrawMethod(t2, a, o2);
    }
  }
  fillDrawMethod(t2, e2, i) {
    t2.set("draw", (t3) => {
      const s2 = this.axis.gridContainer.height(), a = this.width();
      i < e2 && ([i, e2] = [e2, i]), e2 > a || i < 0 || (t3.moveTo(e2, 0), t3.lineTo(i, 0), t3.lineTo(i, s2), t3.lineTo(e2, s2), t3.lineTo(e2, 0));
    });
  }
  positionTooltip(t2, e2) {
    this._positionTooltip(t2, { x: this.positionToCoordinate(e2), y: 0 });
  }
  updateTooltipBounds(t2) {
    const e2 = this.get("inside"), i = 1e5;
    let s2 = this._display.toGlobal({ x: 0, y: 0 }), a = s2.x, o2 = 0, n2 = this.axisLength(), r = i, l3 = "up";
    this.get("opposite") ? e2 ? (l3 = "up", o2 = s2.y, r = i) : (l3 = "down", o2 = s2.y - i, r = i) : e2 ? (l3 = "down", o2 = s2.y - i, r = i) : (l3 = "up", o2 = s2.y, r = i);
    const h = { left: a, right: a + n2, top: o2, bottom: o2 + r }, c = t2.get("bounds");
    Ut(h, c) || (t2.set("bounds", h), t2.set("pointerOrientation", l3));
  }
};
Object.defineProperty(yt, "className", { enumerable: true, configurable: true, writable: true, value: "AxisRendererX" }), Object.defineProperty(yt, "classNames", { enumerable: true, configurable: true, writable: true, value: ft2.classNames.concat([yt.className]) });
var vt = class extends ft2 {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_downY", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "thumb", { enumerable: true, configurable: true, writable: true, value: Fe.new(this._root, { height: z, isMeasured: false, themeTags: ["axis", "y", "thumb"] }) });
  }
  _afterNew() {
    this._settings.themeTags = Kt(this._settings.themeTags, ["renderer", "y"]), this._settings.opposite && this._settings.themeTags.push("opposite"), super._afterNew(), this.setPrivateRaw("letter", "Y");
    const t2 = this.grid.template;
    t2.set("width", z), t2.set("height", 0), t2.set("draw", (t3, e2) => {
      t3.moveTo(0, 0), t3.lineTo(e2.width(), 0);
    }), this.set("draw", (t3, e2) => {
      t3.moveTo(0, 0), t3.lineTo(0, e2.height());
    });
  }
  _getPan(t2, e2) {
    return (t2.y - e2.y) / this.height();
  }
  _changed() {
    super._changed();
    const t2 = this.axis;
    t2.ghostLabel.setPrivate("visible", !this.get("inside")), t2.ghostLabel.set("y", -1e3);
    const e2 = this.thumb, i = "opposite", s2 = "inside", a = this.chart;
    if (this.isDirty(i) || this.isDirty(s2)) {
      const e3 = t2.children;
      if (this.get(s2) ? t2.addTag(s2) : t2.removeTag(s2), a) {
        if (this.get(i)) {
          const s3 = a.rightAxesContainer.children;
          -1 == s3.indexOf(t2) && s3.moveValue(t2, 0), t2.addTag(i), e3.moveValue(this, 0);
        } else {
          const s3 = a.leftAxesContainer.children;
          -1 == s3.indexOf(t2) && s3.moveValue(t2), t2.removeTag(i), e3.moveValue(this);
        }
        t2.ghostLabel._applyThemes(), this.labels.each((t3) => {
          t3._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      t2.markDirtySize();
    }
    const o2 = t2.labelsContainer.width();
    a && (this.get(i) ? e2.set("centerX", 0) : e2.set("centerX", o2)), e2.setPrivate("width", o2);
  }
  processAxis() {
    super.processAxis();
    const t2 = this.axis;
    null == t2.get("height") && t2.set("height", z);
    const i = this._root.horizontalLayout;
    t2.set("layout", i), t2.labelsContainer.set("height", z), t2.axisHeader.set("layout", i);
  }
  _updatePositions() {
    const t2 = this.axis, e2 = t2.y() - mt(t2.get("centerY", 0), t2.height());
    t2.gridContainer.set("y", e2), t2.topGridContainer.set("y", e2), t2.bulletsContainer.set("x", this.x());
    const i = t2.chart;
    if (i) {
      const e3 = i.plotContainer, s2 = t2.axisHeader;
      let a = t2.get("marginTop", 0);
      s2.children.length > 0 ? (a = t2.axisHeader.height(), t2.set("marginTop", a + 1)) : s2.set("height", a), s2.setAll({ y: t2.y() - a, x: -1, width: e3.width() + 2 });
    }
  }
  axisLength() {
    return this.axis.innerHeight();
  }
  positionToPoint(t2) {
    return { x: 0, y: this.positionToCoordinate(t2) };
  }
  updateLabel(t2, e2, i, a) {
    if (t2) {
      l(e2) || (e2 = 0);
      let o2 = 0.5;
      o2 = l(a) && a > 1 ? t2.get("multiLocation", o2) : t2.get("location", o2);
      const n2 = this.get("opposite"), r = t2.get("inside", this.get("inside", false));
      n2 ? (t2.set("x", 0), r ? t2.set("position", "absolute") : t2.set("position", "relative")) : r ? (t2.set("x", 0), t2.set("position", "absolute")) : (t2.set("x", void 0), t2.set("position", "relative")), l(i) && i != e2 && (e2 += (i - e2) * o2), t2.set("y", this.positionToCoordinate(e2)), this.toggleVisibility(t2, e2, t2.get("minPosition", 0), t2.get("maxPosition", 1));
    }
  }
  updateGrid(t2, e2, i) {
    if (t2) {
      l(e2) || (e2 = 0);
      let a = t2.get("location", 0.5);
      l(i) && i != e2 && (e2 += (i - e2) * a), t2.set("y", this.positionToCoordinate(e2)), this.toggleVisibility(t2, e2, 0, 1);
    }
  }
  updateTick(t2, e2, i, a) {
    if (t2) {
      l(e2) || (e2 = 0);
      let o2 = 0.5;
      o2 = l(a) && a > 1 ? t2.get("multiLocation", o2) : t2.get("location", o2), l(i) && i != e2 && (e2 += (i - e2) * o2), t2.set("y", this.positionToCoordinate(e2));
      let n2 = t2.get("length", 0);
      const r = t2.get("inside", this.get("inside", false));
      this.get("opposite") ? (t2.set("x", 0), r && (n2 *= -1)) : r || (n2 *= -1), t2.set("draw", (t3) => {
        t3.moveTo(0, 0), t3.lineTo(n2, 0);
      }), this.toggleVisibility(t2, e2, t2.get("minPosition", 0), t2.get("maxPosition", 1));
    }
  }
  updateBullet(t2, e2, i) {
    if (t2) {
      const a = t2.get("sprite");
      if (a) {
        l(e2) || (e2 = 0);
        let o2 = t2.get("location", 0.5);
        l(i) && i != e2 && (e2 += (i - e2) * o2);
        let n2 = this.axis.roundAxisPosition(e2, o2), r = this.axis._bullets[n2], l3 = 1;
        if (this.get("opposite") && (l3 = -1), t2.get("stacked"))
          if (r) {
            let t3 = r.get("sprite");
            t3 && a.set("x", t3.x() + t3.width() * l3);
          } else
            a.set("x", 0);
        this.axis._bullets[n2] = t2, a.set("y", this.positionToCoordinate(e2)), this.toggleVisibility(a, e2, 0, 1);
      }
    }
  }
  updateFill(t2, e2, i) {
    if (t2) {
      l(e2) || (e2 = 0), l(i) || (i = 1);
      let a = this.positionToCoordinate(e2), o2 = this.positionToCoordinate(i);
      this.fillDrawMethod(t2, a, o2);
    }
  }
  fillDrawMethod(t2, e2, i) {
    t2.set("draw", (t3) => {
      const s2 = this.axis.gridContainer.width(), a = this.height();
      i < e2 && ([i, e2] = [e2, i]), e2 > a || i < 0 || (t3.moveTo(0, e2), t3.lineTo(s2, e2), t3.lineTo(s2, i), t3.lineTo(0, i), t3.lineTo(0, e2));
    });
  }
  positionToCoordinate(t2) {
    return this._inversed ? (t2 - this._start) * this._axisLength : (this._end - t2) * this._axisLength;
  }
  positionTooltip(t2, e2) {
    this._positionTooltip(t2, { x: 0, y: this.positionToCoordinate(e2) });
  }
  updateTooltipBounds(t2) {
    const e2 = this.get("inside"), i = 1e5;
    let s2 = this._display.toGlobal({ x: 0, y: 0 }), a = s2.y, o2 = 0, n2 = this.axisLength(), r = i, l3 = "right";
    this.get("opposite") ? e2 ? (l3 = "right", o2 = s2.x - i, r = i) : (l3 = "left", o2 = s2.x, r = i) : e2 ? (l3 = "left", o2 = s2.x, r = i) : (l3 = "right", o2 = s2.x - i, r = i);
    const h = { left: o2, right: o2 + r, top: a, bottom: a + n2 }, c = t2.get("bounds");
    Ut(h, c) || (t2.set("bounds", h), t2.set("pointerOrientation", l3));
  }
  _updateLC() {
    const t2 = this.axis, e2 = t2.parent;
    if (e2) {
      const i = e2.innerHeight();
      this._lc = this.axisLength() / i, this._ls = t2.y() / i;
    }
  }
  toAxisPosition(t2) {
    const e2 = this._start || 0, i = this._end || 1;
    return t2 = (t2 -= this._ls) * (i - e2) / this._lc, t2 = this.get("inversed") ? e2 + t2 : i - t2;
  }
  fixPosition(t2) {
    return this.get("inversed") ? t2 : 1 - t2;
  }
};
Object.defineProperty(vt, "className", { enumerable: true, configurable: true, writable: true, value: "AxisRendererY" }), Object.defineProperty(vt, "classNames", { enumerable: true, configurable: true, writable: true, value: ft2.classNames.concat([vt.className]) });
var Pt = class extends gt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => n._new(this._root, { position: "absolute", themeTags: Kt(this.columns.template.get("themeTags", []), ["series", "column"]) }, [this.columns.template])) });
  }
  makeColumn(t2, e2) {
    const i = this.mainContainer.children.push(e2.make());
    return i._setDataItem(t2), e2.push(i), i;
  }
  _processAxisRange(t2) {
    super._processAxisRange(t2), t2.columns = new W(Me.new({}), () => n._new(this._root, { position: "absolute", themeTags: Kt(t2.columns.template.get("themeTags", []), ["series", "column"]) }, [this.columns.template, t2.columns.template]));
  }
};
Object.defineProperty(Pt, "className", { enumerable: true, configurable: true, writable: true, value: "ColumnSeries" }), Object.defineProperty(Pt, "classNames", { enumerable: true, configurable: true, writable: true, value: gt.classNames.concat([Pt.className]) });
var wt = class extends ut {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_endIndex", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_strokeGenerator", { enumerable: true, configurable: true, writable: true, value: at() }), Object.defineProperty(this, "_fillGenerator", { enumerable: true, configurable: true, writable: true, value: ot2() }), Object.defineProperty(this, "_legendStroke", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_legendFill", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "strokes", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => Re._new(this._root, { themeTags: Kt(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"]) }, [this.strokes.template])) }), Object.defineProperty(this, "fills", { enumerable: true, configurable: true, writable: true, value: new W(Me.new({}), () => Re._new(this._root, { themeTags: Kt(this.strokes.template.get("themeTags", []), ["line", "series", "fill"]) }, [this.fills.template])) }), Object.defineProperty(this, "_fillTemplate", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_strokeTemplate", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "_previousPoint", { enumerable: true, configurable: true, writable: true, value: [0, 0, 0, 0] }), Object.defineProperty(this, "_dindex", { enumerable: true, configurable: true, writable: true, value: 0 }), Object.defineProperty(this, "_sindex", { enumerable: true, configurable: true, writable: true, value: 0 });
  }
  _afterNew() {
    this._fillGenerator.y0(function(t2) {
      return t2[3];
    }), this._fillGenerator.x0(function(t2) {
      return t2[2];
    }), this._fillGenerator.y1(function(t2) {
      return t2[1];
    }), this._fillGenerator.x1(function(t2) {
      return t2[0];
    }), super._afterNew();
  }
  makeStroke(t2) {
    const e2 = this.mainContainer.children.push(t2.make());
    return t2.push(e2), e2;
  }
  makeFill(t2) {
    const e2 = this.mainContainer.children.push(t2.make());
    return t2.push(e2), e2;
  }
  _updateChildren() {
    this._strokeTemplate = void 0, this._fillTemplate = void 0;
    let t2 = this.get("xAxis"), e2 = this.get("yAxis");
    if (this.isDirty("stroke")) {
      const t3 = this.get("stroke");
      this.strokes.template.set("stroke", t3);
      const e3 = this._legendStroke;
      e3 && e3.states.lookup("default").set("stroke", t3);
    }
    if (this.isDirty("fill")) {
      const t3 = this.get("fill");
      this.fills.template.set("fill", t3);
      const e3 = this._legendFill;
      e3 && e3.states.lookup("default").set("fill", t3);
    }
    if (this.isDirty("curveFactory")) {
      const t3 = this.get("curveFactory");
      t3 && (this._strokeGenerator.curve(t3), this._fillGenerator.curve(t3));
    }
    if (t2.inited && e2.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
        this.fills.each((t4) => {
          t4.setPrivate("visible", false);
        }), this.strokes.each((t4) => {
          t4.setPrivate("visible", false);
        }), this.axisRanges.each((t4) => {
          let e4 = t4.fills;
          e4 && e4.each((t5) => {
            t5.setPrivate("visible", false);
          });
          let i2 = t4.strokes;
          i2 && i2.each((t5) => {
            t5.setPrivate("visible", false);
          });
        });
        let t3 = this.startIndex(), e3 = this.strokes.template.get("templateField"), i = this.fills.template.get("templateField"), a = true, o2 = true;
        e3 && (a = false), i && (o2 = false);
        for (let l3 = t3 - 1; l3 >= 0; l3--) {
          let n3 = this.dataItems[l3], r2 = true, h = n3.dataContext;
          if (e3 && h[e3] && (a = true), i && h[i] && (o2 = true), m(this._valueFields, (t4) => {
            l(n3.get(t4)) || (r2 = false);
          }), r2 && a && o2) {
            t3 = l3;
            break;
          }
        }
        let n2 = this.dataItems.length, r = this.endIndex();
        if (r < n2) {
          r++;
          for (let t4 = r; t4 < n2; t4++) {
            let e4 = this.dataItems[t4], i2 = true;
            if (m(this._valueFields, (t5) => {
              l(e4.get(t5)) || (i2 = false);
            }), i2) {
              r = t4 + 1;
              break;
            }
          }
        }
        if (t3 > 0 && t3--, this._endIndex = r, this._clearGraphics(), this._sindex = 0, this._dindex = t3, 1 == this.dataItems.length)
          this._startSegment(0);
        else
          for (; this._dindex < r - 1; )
            this._startSegment(this._dindex), this._sindex++;
      }
    } else
      this._skipped = true;
    super._updateChildren();
  }
  _clearGraphics() {
    this.strokes.clear(), this.fills.clear();
  }
  _startSegment(t2) {
    let e2 = this._endIndex, i = e2;
    const s2 = this.get("autoGapCount"), a = this.get("connect"), o2 = this.makeFill(this.fills), n2 = this._fillTemplate, r = this.fills.template;
    n2 && n2 != r && (o2.template = n2), o2.setPrivate("visible", true);
    const l3 = this.makeStroke(this.strokes), h = this._strokeTemplate;
    h && h != this.strokes.template && (l3.template = h), l3.setPrivate("visible", true);
    let c = this.get("xAxis"), d = this.get("yAxis"), u = this.get("baseAxis"), g2 = this.get("vcx", 1), p = this.get("vcy", 1), m2 = this._xField, _2 = this._yField, x = this._xOpenField, b = this._yOpenField;
    const f = this.get("openValueXField"), y2 = this.get("openValueYField");
    f || (x = this._xField), y2 || (b = this._yField);
    const v2 = this.get("stacked"), P2 = c.basePosition(), w = d.basePosition();
    let T;
    T = u === d ? this._yField : this._xField;
    const A2 = [];
    let k2 = [];
    A2.push(k2);
    const D2 = this.strokes.template.get("templateField"), M = this.fills.template.get("templateField");
    let C = this.get("locationX", 0.5), I2 = this.get("locationY", 0.5), X = this.get("openLocationX", C), Y2 = this.get("openLocationY", I2);
    const O = this.get("minDistance", 0);
    let S, F2 = this.fills.template.get("visible");
    this.axisRanges.length > 0 && (F2 = true);
    let L = false;
    (v2 || f || y2) && (L = true);
    const j = { points: k2, segments: A2, stacked: v2, getOpen: L, basePosX: P2, basePosY: w, fillVisible: F2, xField: m2, yField: _2, xOpenField: x, yOpenField: b, vcx: g2, vcy: p, baseAxis: u, xAxis: c, yAxis: d, locationX: C, locationY: I2, openLocationX: X, openLocationY: Y2, minDistance: O };
    for (S = t2; S < i; S++) {
      this._dindex = S;
      const e3 = this._dataItems[S];
      let n3 = e3.get(m2), r2 = e3.get(_2);
      if (null == n3 || null == r2 ? a || (k2 = [], A2.push(k2), j.points = k2) : this._getPoints(e3, j), D2) {
        let s3 = e3.dataContext[D2];
        if (s3) {
          if (s3 instanceof Me || (s3 = Me.new(s3)), this._strokeTemplate = s3, S > t2) {
            i = S;
            break;
          }
          l3.template = s3;
        }
      }
      if (M) {
        let s3 = e3.dataContext[M];
        if (s3) {
          if (s3 instanceof Me || (s3 = Me.new(s3)), this._fillTemplate = s3, S > t2) {
            i = S;
            break;
          }
          o2.template = s3;
        }
      }
      if (!a) {
        let t3 = this.dataItems[S + 1];
        t3 && u.shouldGap(e3, t3, s2, T) && (k2 = [], A2.push(k2), j.points = k2);
      }
    }
    o2.setRaw("userData", [t2, S]), l3.setRaw("userData", [t2, S]), S === e2 && this._endLine(k2, A2[0][0]), l3 && this._drawStroke(l3, A2), o2 && this._drawFill(o2, A2), this.axisRanges.each((e3) => {
      const i2 = e3.container, s3 = e3.fills, a2 = this.makeFill(s3);
      i2 && i2.children.push(a2), a2.setPrivate("visible", true), this._drawFill(a2, A2);
      const o3 = e3.strokes, n3 = this.makeStroke(o3);
      i2 && i2.children.push(n3), n3.setPrivate("visible", true), this._drawStroke(n3, A2), a2.setRaw("userData", [t2, S]), n3.setRaw("userData", [t2, S]);
    });
  }
  _getPoints(t2, e2) {
    let i = e2.points, s2 = t2.get("locationX", e2.locationX), a = t2.get("locationY", e2.locationY), o2 = e2.xAxis.getDataItemPositionX(t2, e2.xField, s2, e2.vcx), n2 = e2.yAxis.getDataItemPositionY(t2, e2.yField, a, e2.vcy);
    if (this._shouldInclude(o2)) {
      const s3 = this.getPoint(o2, n2), a2 = [s3.x, s3.y];
      if (s3.x += this._x, s3.y += this._y, t2.set("point", s3), e2.fillVisible) {
        let i2 = o2, s4 = n2;
        if (e2.baseAxis === e2.xAxis ? s4 = e2.basePosY : e2.baseAxis === e2.yAxis && (i2 = e2.basePosX), e2.getOpen) {
          let a3 = t2.get(e2.xOpenField), o3 = t2.get(e2.yOpenField);
          if (null != a3 && null != o3) {
            let a4 = t2.get("openLocationX", e2.openLocationX), o4 = t2.get("openLocationY", e2.openLocationY);
            if (e2.stacked) {
              let n3 = t2.get("stackToItemX"), r2 = t2.get("stackToItemY");
              n3 ? (i2 = e2.xAxis.getDataItemPositionX(n3, e2.xField, a4, n3.component.get("vcx")), e(i2) && (i2 = e2.basePosX)) : i2 = e2.yAxis === e2.baseAxis ? e2.basePosX : e2.xAxis.getDataItemPositionX(t2, e2.xOpenField, a4, e2.vcx), r2 ? (s4 = e2.yAxis.getDataItemPositionY(r2, e2.yField, o4, r2.component.get("vcy")), e(s4) && (s4 = e2.basePosY)) : s4 = e2.xAxis === e2.baseAxis ? e2.basePosY : e2.yAxis.getDataItemPositionY(t2, e2.yOpenField, o4, e2.vcy);
            } else
              i2 = e2.xAxis.getDataItemPositionX(t2, e2.xOpenField, a4, e2.vcx), s4 = e2.yAxis.getDataItemPositionY(t2, e2.yOpenField, o4, e2.vcy);
          }
        }
        let r = this.getPoint(i2, s4);
        a2[2] = r.x, a2[3] = r.y;
      }
      if (e2.minDistance > 0) {
        const t3 = a2[0], s4 = a2[1], o3 = a2[2], n3 = a2[3], r = this._previousPoint, l3 = r[0], h = r[1], c = r[2], d = r[3];
        (Math.hypot(t3 - l3, s4 - h) > e2.minDistance || o3 && n3 && Math.hypot(o3 - c, n3 - d) > e2.minDistance) && (i.push(a2), this._previousPoint = a2);
      } else
        i.push(a2);
    }
  }
  _endLine(t2, e2) {
  }
  _drawStroke(t2, e2) {
    t2.get("visible") && !t2.get("forceHidden") && t2.set("draw", (t3) => {
      m(e2, (e3) => {
        this._strokeGenerator.context(t3), this._strokeGenerator(e3);
      });
    });
  }
  _drawFill(t2, e2) {
    t2.get("visible") && !t2.get("forceHidden") && t2.set("draw", (t3) => {
      m(e2, (e3) => {
        this._fillGenerator.context(t3), this._fillGenerator(e3);
      });
    });
  }
  _processAxisRange(t2) {
    super._processAxisRange(t2), t2.fills = new W(Me.new({}), () => Re._new(this._root, { themeTags: Kt(t2.fills.template.get("themeTags", []), ["line", "series", "fill"]) }, [this.fills.template, t2.fills.template])), t2.strokes = new W(Me.new({}), () => Re._new(this._root, { themeTags: Kt(t2.strokes.template.get("themeTags", []), ["line", "series", "stroke"]) }, [this.strokes.template, t2.strokes.template]));
  }
  createLegendMarker(t2) {
    const e2 = this.get("legendDataItem");
    if (e2) {
      const t3 = e2.get("marker"), i = e2.get("markerRectangle");
      i && i.setPrivate("visible", false), t3.set("background", Fe.new(t3._root, { fillOpacity: 0, fill: Yt(0) }));
      const s2 = t3.children.push(Re._new(t3._root, { themeTags: ["line", "series", "legend", "marker", "stroke"], interactive: false }, [this.strokes.template]));
      this._legendStroke = s2;
      const a = t3.children.push(Re._new(t3._root, { themeTags: ["line", "series", "legend", "marker", "fill"] }, [this.fills.template]));
      this._legendFill = a;
      const o2 = this._root.interfaceColors.get("disabled");
      if (s2.states.create("disabled", { fill: o2, stroke: o2 }), a.states.create("disabled", { fill: o2, stroke: o2 }), this.bullets.length > 0) {
        const e3 = this.bullets.getIndex(0);
        if (e3) {
          const i2 = e3(t3._root, this, new g(this, {}, {}));
          if (i2) {
            const e4 = i2.get("sprite");
            e4 instanceof Re && e4.states.create("disabled", { fill: o2, stroke: o2 }), e4 && (e4.set("tooltipText", void 0), e4.set("tooltipHTML", void 0), t3.children.push(e4), e4.setAll({ x: t3.width() / 2, y: t3.height() / 2 }));
          }
        }
      }
    }
  }
};
Object.defineProperty(wt, "className", { enumerable: true, configurable: true, writable: true, value: "LineSeries" }), Object.defineProperty(wt, "classNames", { enumerable: true, configurable: true, writable: true, value: ut.classNames.concat([wt.className]) });
export {
  yt as AxisRendererXAm5,
  vt as AxisRendererYAm5,
  mt2 as CategoryAxisAm5,
  Pt as ColumnSeriesAm5,
  wt as LineSeriesAm5,
  _t as ValueAxisAm5,
  rt as XYChartAm5,
  ht as XYCursorAm5
};
//# sourceMappingURL=xyChart-CA6MDUB5.js.map
