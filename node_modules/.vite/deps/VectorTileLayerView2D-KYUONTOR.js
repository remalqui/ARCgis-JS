import {
  i as i4
} from "./chunk-Y2JGNMOW.js";
import {
  r as r4
} from "./chunk-7YWQQHOF.js";
import {
  d as d2,
  f as f4
} from "./chunk-KPMUAI6T.js";
import "./chunk-TBMS67KR.js";
import {
  i as i3
} from "./chunk-FZIEP3HG.js";
import "./chunk-N5CR6S5Y.js";
import {
  e as e8
} from "./chunk-JUYJSPTR.js";
import {
  c as c2,
  u
} from "./chunk-PEYWLFGJ.js";
import {
  T as T2,
  e2 as e7
} from "./chunk-NE5U5H4D.js";
import {
  c,
  e as e5,
  t as t4
} from "./chunk-AER5JAFS.js";
import {
  l as l5
} from "./chunk-WXCIKTAW.js";
import {
  E as E2,
  I as I2
} from "./chunk-FKEHFW5J.js";
import {
  a as a4,
  i as i2,
  l as l4,
  n as n3,
  r as r2
} from "./chunk-7HZ72XIE.js";
import "./chunk-2735WBYK.js";
import "./chunk-Y7HVH6RU.js";
import "./chunk-NVZXNBIH.js";
import "./chunk-CN3PB7HS.js";
import {
  t as t3
} from "./chunk-XYJMHUDA.js";
import "./chunk-CSLWFQJE.js";
import "./chunk-3VTULECI.js";
import "./chunk-A4HFWKMU.js";
import "./chunk-TDXHXKUI.js";
import "./chunk-PR2OEILG.js";
import "./chunk-PJP6JTP7.js";
import "./chunk-IVABPLLZ.js";
import {
  T
} from "./chunk-TBHRKIAA.js";
import "./chunk-JSMUQBPG.js";
import {
  a as a3,
  s as s2
} from "./chunk-QAWS7Y22.js";
import {
  t as t2
} from "./chunk-FF5LS3YE.js";
import {
  C as C2,
  D,
  E,
  F,
  G,
  I,
  O,
  R
} from "./chunk-BCDDCNQ2.js";
import {
  n as n2
} from "./chunk-FN5LEP6H.js";
import {
  e as e3
} from "./chunk-LREUW66K.js";
import "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-SCOBW7KR.js";
import "./chunk-AHAGGZUI.js";
import "./chunk-RADYXGQH.js";
import {
  e as e6,
  r as r3
} from "./chunk-D5NSNTGJ.js";
import "./chunk-OMDLZQUU.js";
import "./chunk-O62OS3ME.js";
import {
  f as f3
} from "./chunk-AF36K5Y6.js";
import "./chunk-5K6FTFN4.js";
import {
  y as y2
} from "./chunk-E2BBTG5C.js";
import "./chunk-5KLICR5E.js";
import "./chunk-PNA6D76Z.js";
import {
  h as h3
} from "./chunk-NDQCNJMM.js";
import {
  l as l3
} from "./chunk-R2HXL6HT.js";
import {
  e as e4
} from "./chunk-2PAQQUAG.js";
import "./chunk-QXPTMFGZ.js";
import {
  h as h4
} from "./chunk-4SARN32Z.js";
import "./chunk-QA4FMJA6.js";
import "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-VZAEQ6CY.js";
import {
  M,
  f as f2,
  h as h2,
  r
} from "./chunk-SS33L3LC.js";
import "./chunk-X4Y5OF5X.js";
import {
  j as j3
} from "./chunk-PX3FFFQ5.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-LNMNRMVX.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-KIEN3CY2.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-4RFFPIT2.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import {
  i
} from "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-4NOOGA4U.js";
import "./chunk-CWQ6Q3PH.js";
import {
  h,
  l as l2
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-74O2T7JC.js";
import {
  n
} from "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import "./chunk-3GSONYPC.js";
import {
  S2 as S
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  kt
} from "./chunk-O3CHVGVF.js";
import {
  C,
  d,
  f,
  j,
  m as m2
} from "./chunk-HNHXEGH2.js";
import {
  e as e2,
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  m
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e9 = class {
  constructor(e11, t10) {
    this._width = 0, this._height = 0, this._free = [], this._width = e11, this._height = t10, this._free.push(new t3(0, 0, e11, t10));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e11, t10) {
    if (e11 > this._width || t10 > this._height)
      return new t3();
    let i9 = null, s7 = -1;
    for (let h7 = 0; h7 < this._free.length; ++h7) {
      const w = this._free[h7];
      e11 <= w.width && t10 <= w.height && (null === i9 || w.y <= i9.y && w.x <= i9.x) && (i9 = w, s7 = h7);
    }
    return null === i9 ? new t3() : (this._free.splice(s7, 1), i9.width < i9.height ? (i9.width > e11 && this._free.push(new t3(i9.x + e11, i9.y, i9.width - e11, t10)), i9.height > t10 && this._free.push(new t3(i9.x, i9.y + t10, i9.width, i9.height - t10))) : (i9.width > e11 && this._free.push(new t3(i9.x + e11, i9.y, i9.width - e11, i9.height)), i9.height > t10 && this._free.push(new t3(i9.x, i9.y + t10, e11, i9.height - t10))), new t3(i9.x, i9.y, e11, t10));
  }
  release(h7) {
    for (let e11 = 0; e11 < this._free.length; ++e11) {
      const t10 = this._free[e11];
      if (t10.y === h7.y && t10.height === h7.height && t10.x + t10.width === h7.x)
        t10.width += h7.width;
      else if (t10.x === h7.x && t10.width === h7.width && t10.y + t10.height === h7.y)
        t10.height += h7.height;
      else if (h7.y === t10.y && h7.height === t10.height && h7.x + h7.width === t10.x)
        t10.x = h7.x, t10.width += h7.width;
      else {
        if (h7.x !== t10.x || h7.width !== t10.width || h7.y + h7.height !== t10.y)
          continue;
        t10.y = h7.y, t10.height += h7.height;
      }
      this._free.splice(e11, 1), this.release(h7);
    }
    this._free.push(h7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n4 = class {
  constructor(e11, s7, i9) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e11, this.height = s7, this._glyphSource = i9, this._binPack = new e9(e11 - 4, s7 - 4), this._glyphData.push(new Uint8Array(e11 * s7)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s7, i9) {
    const h7 = [], r9 = this._glyphSource, n7 = /* @__PURE__ */ new Set(), o6 = 1 / 256;
    for (const t10 of i9) {
      const e11 = Math.floor(t10 * o6);
      n7.add(e11);
    }
    const a7 = [];
    return n7.forEach((t10) => {
      const e11 = s7 + t10;
      if (this._rangePromises.has(e11))
        a7.push(this._rangePromises.get(e11));
      else {
        const i10 = r9.getRange(s7, t10).then(() => {
          this._rangePromises.delete(e11);
        }, () => {
          this._rangePromises.delete(e11);
        });
        this._rangePromises.set(e11, i10), a7.push(i10);
      }
    }), Promise.all(a7).then(() => {
      let n8 = this._glyphIndex[s7];
      n8 || (n8 = {}, this._glyphIndex[s7] = n8);
      for (const o7 of i9) {
        const i10 = n8[o7];
        if (i10) {
          h7[o7] = { sdf: true, rect: i10.rect, metrics: i10.metrics, page: i10.page, code: o7 };
          continue;
        }
        const a8 = r9.getGlyph(s7, o7);
        if (!a8 || !a8.metrics)
          continue;
        const c5 = a8.metrics;
        let l12;
        if (0 === c5.width)
          l12 = new t3(0, 0, 0, 0);
        else {
          const e11 = 3, s8 = c5.width + 2 * e11, i11 = c5.height + 2 * e11;
          let h8 = s8 % 4 ? 4 - s8 % 4 : 4, r10 = i11 % 4 ? 4 - i11 % 4 : 4;
          1 === h8 && (h8 = 5), 1 === r10 && (r10 = 5), l12 = this._binPack.allocate(s8 + h8, i11 + r10), l12.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e9(this.width - 4, this.height - 4), l12 = this._binPack.allocate(s8 + h8, i11 + r10));
          const n9 = this._glyphData[this._currentPage], o8 = a8.bitmap;
          let g2, _2;
          if (o8)
            for (let t10 = 0; t10 < i11; t10++) {
              g2 = s8 * t10, _2 = this.width * (l12.y + t10 + 1) + l12.x;
              for (let t11 = 0; t11 < s8; t11++)
                n9[_2 + t11 + 1] = o8[g2 + t11];
            }
        }
        n8[o7] = { rect: l12, metrics: c5, tileIDs: null, page: this._currentPage }, h7[o7] = { sdf: true, rect: l12, metrics: c5, page: this._currentPage, code: o7 }, this._dirties[this._currentPage] = true;
      }
      return h7;
    });
  }
  removeGlyphs(t10) {
    for (const e11 in this._glyphIndex) {
      const s7 = this._glyphIndex[e11];
      if (!s7)
        continue;
      let i9;
      for (const e12 in s7)
        if (i9 = s7[e12], i9.tileIDs.delete(t10), 0 === i9.tileIDs.size) {
          const t11 = this._glyphData[i9.page], h7 = i9.rect;
          let r9, n7;
          for (let e13 = 0; e13 < h7.height; e13++)
            for (r9 = this.width * (h7.y + e13) + h7.x, n7 = 0; n7 < h7.width; n7++)
              t11[r9 + n7] = 0;
          delete s7[e12], this._dirties[i9.page] = true;
        }
    }
  }
  bind(t10, e11, n7, o6 = 0) {
    if (!this._textures[n7]) {
      const e12 = new e7();
      e12.pixelFormat = G.ALPHA, e12.wrapMode = D.CLAMP_TO_EDGE, e12.width = this.width, e12.height = this.height, this._textures[n7] = new T2(t10, e12, new Uint8Array(this.width * this.height));
    }
    const a7 = this._textures[n7];
    a7.setSamplingMode(e11), this._dirties[n7] && a7.setData(this._glyphData[n7]), t10.bindTexture(a7, o6), this._dirties[n7] = false;
  }
  dispose() {
    this._binPack = null;
    for (const t10 of this._textures)
      t10 && t10.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s3 = class {
  constructor(e11) {
    if (this._metrics = [], this._bitmaps = [], e11)
      for (; e11.next(); )
        switch (e11.tag()) {
          case 1: {
            const t10 = e11.getMessage();
            for (; t10.next(); )
              switch (t10.tag()) {
                case 3: {
                  const e12 = t10.getMessage();
                  let s7, a7, r9, n7, i9, c5, g2;
                  for (; e12.next(); )
                    switch (e12.tag()) {
                      case 1:
                        s7 = e12.getUInt32();
                        break;
                      case 2:
                        a7 = e12.getBytes();
                        break;
                      case 3:
                        r9 = e12.getUInt32();
                        break;
                      case 4:
                        n7 = e12.getUInt32();
                        break;
                      case 5:
                        i9 = e12.getSInt32();
                        break;
                      case 6:
                        c5 = e12.getSInt32();
                        break;
                      case 7:
                        g2 = e12.getUInt32();
                        break;
                      default:
                        e12.skip();
                    }
                  e12.release(), s7 && (this._metrics[s7] = { width: r9, height: n7, left: i9, top: c5, advance: g2 }, this._bitmaps[s7] = a7);
                  break;
                }
                default:
                  t10.skip();
              }
            t10.release();
            break;
          }
          default:
            e11.skip();
        }
  }
  getMetrics(e11) {
    return this._metrics[e11];
  }
  getBitmap(e11) {
    return this._bitmaps[e11];
  }
};
var a5 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e11) {
    return this._ranges[e11];
  }
  addRange(e11, t10) {
    this._ranges[e11] = t10;
  }
};
var r5 = class {
  constructor(e11) {
    this._glyphInfo = {}, this._baseURL = e11;
  }
  getRange(a7, r9) {
    const n7 = this._getFontStack(a7);
    if (n7.getRange(r9))
      return Promise.resolve();
    const i9 = 256 * r9, c5 = i9 + 255;
    if (this._baseURL) {
      const g2 = this._baseURL.replace("{fontstack}", a7).replace("{range}", i9 + "-" + c5);
      return j2(g2, { responseType: "array-buffer" }).then((e11) => {
        n7.addRange(r9, new s3(new n2(new Uint8Array(e11.data), new DataView(e11.data))));
      }).catch(() => {
        n7.addRange(r9, new s3());
      });
    }
    return n7.addRange(r9, new s3()), Promise.resolve();
  }
  getGlyph(e11, t10) {
    const s7 = this._getFontStack(e11);
    if (!s7)
      return;
    const a7 = Math.floor(t10 / 256), r9 = s7.getRange(a7);
    return r9 ? { metrics: r9.getMetrics(t10), bitmap: r9.getBitmap(t10) } : void 0;
  }
  _getFontStack(e11) {
    let t10 = this._glyphInfo[e11];
    return t10 || (t10 = this._glyphInfo[e11] = new a5()), t10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r6 = "dasharray-";
var o = class _o {
  constructor(t10, e11, s7 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, (t10 <= 0 || e11 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t10, this._pageHeight = e11, s7 > 0 && (this._maxItemSize = s7), this._binPack = new e9(t10 - 4, e11 - 4);
  }
  dispose() {
    this._binPack = null, this._mosaicRects = {};
    for (const t10 of this._textures)
      t10 && t10.dispose();
    this._textures.length = 0;
  }
  getWidth(t10) {
    return t10 >= this._size.length ? -1 : this._size[t10][0];
  }
  getHeight(t10) {
    return t10 >= this._size.length ? -1 : this._size[t10][1];
  }
  getPageSize(t10) {
    return t10 >= this._size.length ? null : this._size[t10];
  }
  setSpriteSource(t10) {
    if (this.dispose(), this.pixelRatio = t10.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4);
      const t11 = Math.floor(this._pageWidth), e11 = Math.floor(this._pageHeight), s7 = new Uint32Array(t11 * e11);
      this._mosaicsData[0] = s7, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t10;
  }
  getSpriteItem(t10, i9 = false) {
    let e11, s7, h7 = this._mosaicRects[t10];
    if (h7)
      return h7;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus)
      return null;
    if (t10 && t10.startsWith(r6) ? ([e11, s7] = this._rasterizeDash(t10), i9 = true) : e11 = this._sprites.getSpriteInfo(t10), !e11 || !e11.width || !e11.height || e11.width < 0 || e11.height < 0)
      return null;
    const a7 = e11.width, o6 = e11.height, [n7, _2, g2] = this._allocateImage(a7, o6);
    return n7.width <= 0 ? null : (this._copy(n7, e11, _2, g2, i9, s7), h7 = { rect: n7, width: a7, height: o6, sdf: e11.sdf, simplePattern: false, pixelRatio: e11.pixelRatio, page: _2 }, this._mosaicRects[t10] = h7, h7);
  }
  getSpriteItems(t10) {
    const i9 = {};
    for (const e11 of t10)
      i9[e11.name] = this.getSpriteItem(e11.name, e11.repeat);
    return i9;
  }
  getMosaicItemPosition(t10, i9) {
    const e11 = this.getSpriteItem(t10, i9), s7 = e11 && e11.rect;
    if (!s7)
      return null;
    s7.width = e11.width, s7.height = e11.height;
    const h7 = e11.width, a7 = e11.height, r9 = 2;
    return { tl: [s7.x + r9, s7.y + r9], br: [s7.x + r9 + h7, s7.y + r9 + a7], page: e11.page };
  }
  bind(t10, i9, e11 = 0, r9 = 0) {
    if (e11 >= this._size.length || e11 >= this._mosaicsData.length)
      return;
    if (!this._textures[e11]) {
      const i10 = new e7();
      i10.wrapMode = D.CLAMP_TO_EDGE, i10.width = this._size[e11][0], i10.height = this._size[e11][1], this._textures[e11] = new T2(t10, i10, new Uint8Array(this._mosaicsData[e11].buffer));
    }
    const o6 = this._textures[e11];
    o6.setSamplingMode(i9), this._dirties[e11] && o6.setData(new Uint8Array(this._mosaicsData[e11].buffer)), t10.bindTexture(o6, r9), this._dirties[e11] = false;
  }
  static _copyBits(t10, i9, e11, s7, h7, a7, r9, o6, n7, _2, g2) {
    let c5 = s7 * i9 + e11, l12 = o6 * a7 + r9;
    if (g2) {
      l12 -= a7;
      for (let r10 = -1; r10 <= _2; r10++, c5 = ((r10 + _2) % _2 + s7) * i9 + e11, l12 += a7)
        for (let i10 = -1; i10 <= n7; i10++)
          h7[l12 + i10] = t10[c5 + (i10 + n7) % n7];
    } else
      for (let p4 = 0; p4 < _2; p4++) {
        for (let i10 = 0; i10 < n7; i10++)
          h7[l12 + i10] = t10[c5 + i10];
        c5 += i9, l12 += a7;
      }
  }
  _copy(t10, i9, e11, s7, h7, a7) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || e11 >= this._mosaicsData.length)
      return;
    const r9 = new Uint32Array(a7 ? a7.buffer : this._sprites.image.buffer), n7 = this._mosaicsData[e11];
    n7 && r9 || console.error("Source or target images are uninitialized!");
    const _2 = 2, g2 = a7 ? i9.width : this._sprites.width;
    _o._copyBits(r9, g2, i9.x, i9.y, n7, s7[0], t10.x + _2, t10.y + _2, i9.width, i9.height, h7), this._dirties[e11] = true;
  }
  _allocateImage(t10, s7) {
    t10 += 2, s7 += 2;
    const h7 = Math.max(t10, s7);
    if (this._maxItemSize && this._maxItemSize < h7) {
      const i9 = new t3(0, 0, t10, s7);
      return this._mosaicsData.push(new Uint32Array(t10 * s7)), this._dirties.push(true), this._size.push([t10, s7]), this._textures.push(void 0), [i9, this._mosaicsData.length - 1, [t10, s7]];
    }
    let a7 = t10 % 4 ? 4 - t10 % 4 : 4, r9 = s7 % 4 ? 4 - s7 % 4 : 4;
    1 === a7 && (a7 = 5), 1 === r9 && (r9 = 5);
    const o6 = this._binPack.allocate(t10 + a7, s7 + r9);
    return o6.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t10, s7)) : [o6, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i9) {
    const e11 = /\[(.*?)\]/, s7 = i9.match(e11);
    if (!s7)
      return null;
    const h7 = s7[1].split(",").map(Number), a7 = i9.slice(i9.lastIndexOf("-") + 1), [r9, o6, n7] = e8(h7, a7);
    return [{ x: 0, y: 0, width: o6, height: n7, sdf: true, pixelRatio: 1 }, new Uint8Array(r9.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var h5 = class {
  constructor(t10, e11, s7) {
    this._layer = t10, this._styleRepository = e11, this.devicePixelRatio = s7, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e2(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t10) {
    this._requestSprite(t10);
    const s7 = this._layer.currentStyleInfo.glyphsUrl, r9 = new r5(s7 ? kt(s7, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n4(1024, 1024, r9), this._broadcastPromise = f3("WorkerTileHandler", { client: this, schedule: t10.schedule, signal: t10.signal }).then((s8) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s8, this._layer && !this._connection.closed)) {
        const r10 = s8.broadcast("setStyle", this._layer.currentStyleInfo.style, t10);
        Promise.all(r10).catch((t11) => m2(t11));
      }
    });
  }
  _requestSprite(t10) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e11 = new AbortController();
    this._spriteSourceAbortController = e11;
    const r9 = t10 == null ? void 0 : t10.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r9 && (this._inputSignalEventListener = p(e11), r9.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i9 } = e11, o6 = { ...t10, signal: i9 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o6), this._spriteSourcePromise.then((t11) => {
      f(i9), this._spriteMosaic = new o(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t11);
    });
  }
  async updateStyle(t10) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", t10)), this._broadcastPromise;
  }
  setSpriteSource(t10) {
    const e11 = new o(1024, 1024, 250);
    return e11.setSpriteSource(t10), this._spriteMosaic = e11, this._spriteSourcePromise = Promise.resolve(t10), this._spriteSourceAbortController = null, e11;
  }
  async setStyle(t10, e11) {
    await this._broadcastPromise, this._styleRepository = t10, this._requestSprite();
    const s7 = new r5(this._layer.currentStyleInfo.glyphsUrl ? kt(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n4(1024, 1024, s7), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", e11)), this._broadcastPromise;
  }
  fetchTileData(t10, e11) {
    return this._getRefKeys(t10, e11).then((t11) => {
      const s7 = this._layer.sourceNameToSource, r9 = [];
      for (const e12 in s7)
        r9.push(e12);
      return this._getSourcesData(r9, t11, e11);
    });
  }
  parseTileData(t10, e11) {
    const s7 = t10 && t10.data;
    if (!s7)
      return Promise.resolve(null);
    const { sourceName2DataAndRefKey: r9, transferList: i9 } = s7;
    return 0 === Object.keys(r9).length ? Promise.resolve(null) : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t10.key.id, sourceName2DataAndRefKey: r9, styleLayerUIDs: t10.styleLayerUIDs }, { ...e11, transferList: i9 }));
  }
  async getSprites(t10) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t10);
  }
  getGlyphs(t10) {
    return this._glyphMosaic.getGlyphItems(t10.font, t10.codePoints);
  }
  async _getTilePayload(t10, e11, s7) {
    const i9 = e4.pool.acquire(t10.id), o6 = this._layer.sourceNameToSource[e11], { level: n7, row: l12, col: a7 } = i9;
    e4.pool.release(i9);
    try {
      return { protobuff: await o6.requestTile(n7, l12, a7, s7), sourceName: e11 };
    } catch (c5) {
      if (d(c5))
        throw c5;
      return { protobuff: null, sourceName: e11 };
    }
  }
  _getRefKeys(t10, e11) {
    const s7 = this._layer.sourceNameToSource, r9 = new Array();
    for (const i9 in s7) {
      const o6 = s7[i9].getRefKey(t10, e11);
      r9.push(o6);
    }
    return j(r9);
  }
  _getSourcesData(t10, e11, s7) {
    const r9 = [];
    for (let i9 = 0; i9 < e11.length; i9++)
      if (null == e11[i9].value || null == t10[i9])
        r9.push(null);
      else {
        const o6 = this._getTilePayload(e11[i9].value, t10[i9], s7);
        r9.push(o6);
      }
    return j(r9).then((t11) => {
      const s8 = {}, r10 = [];
      for (let i9 = 0; i9 < t11.length; i9++) {
        const o6 = t11[i9].value;
        if (o6 && (o6.protobuff && o6.protobuff.byteLength > 0)) {
          const t12 = e11[i9].value.id;
          s8[o6.sourceName] = { refKey: t12, protobuff: o6.protobuff }, r10.push(o6.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s8, transferList: r10 };
    });
  }
};
function p(t10) {
  return () => t10.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var l6 = 512;
var s4 = 1e-6;
var r7 = (e11, i9) => e11 + 1 / (1 << 2 * i9);
var o2 = class {
  constructor(i9, t10) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e3(40, (e11) => e11.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i9.acquireTile, this.releaseTile = i9.releaseTile, this.tileInfoView = i9.tileInfoView, this._container = t10;
  }
  destroy() {
    for (const [e11, i9] of this._tiles)
      i9.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e11) {
    this._updateCacheSize(e11);
    const l12 = this.tileInfoView, s7 = l12.getTileCoverage(e11.state, 0, true, "smallest"), { spans: r9, lodInfo: o6 } = s7, { level: n7 } = o6, a7 = this._tiles, c5 = /* @__PURE__ */ new Set(), h7 = /* @__PURE__ */ new Set();
    for (const { row: i9, colFrom: _2, colTo: f6 } of r9)
      for (let e12 = _2; e12 <= f6; e12++) {
        const l13 = e4.getId(n7, i9, o6.normalizeCol(e12), o6.getWorldForColumn(e12)), s8 = this._getOrAcquireTile(l13);
        c5.add(l13), s8.processed() ? this._addToContainer(s8) : h7.add(new e4(l13));
      }
    for (const [i9, t10] of a7)
      t10.isCoverage = c5.has(i9);
    for (const i9 of h7)
      this._findPlaceholdersForMissingTiles(i9, c5);
    let d4 = false;
    for (const [i9, t10] of a7)
      t10.neededForCoverage = c5.has(i9), t10.neededForCoverage || t10.isHoldingForFade && l12.intersects(s7, t10.key) && c5.add(i9), t10.isFading && (d4 = true);
    for (const [i9, t10] of this._tiles)
      c5.has(i9) || this._releaseTile(i9);
    return l3.pool.release(s7), !d4;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  _findPlaceholdersForMissingTiles(e11, i9) {
    const t10 = [];
    for (const [s7, r9] of this._tiles)
      this._addPlaceholderChild(t10, r9, e11, i9);
    const l12 = t10.reduce(r7, 0);
    Math.abs(1 - l12) < s4 || this._addPlaceholderParent(e11.id, i9);
  }
  _addPlaceholderChild(e11, i9, t10, l12) {
    i9.key.level <= t10.level || !i9.hasData() || a6(t10, i9.key) && (this._addToContainer(i9), l12.add(i9.id), e11.push(i9.key.level - t10.level));
  }
  _addPlaceholderParent(e11, i9) {
    const t10 = this._tiles;
    let l12 = e11;
    for (; ; ) {
      if (l12 = n5(l12), !l12 || i9.has(l12))
        return;
      const e12 = t10.get(l12);
      if (e12 && e12.hasData())
        return this._addToContainer(e12), void i9.add(e12.id);
    }
  }
  _getOrAcquireTile(e11) {
    let i9 = this._tiles.get(e11);
    return i9 || (i9 = this._tileCache.pop(e11), i9 || (i9 = this.acquireTile(new e4(e11))), this._tiles.set(e11, i9), i9);
  }
  _releaseTile(e11) {
    const i9 = this._tiles.get(e11);
    this.releaseTile(i9), this._removeFromContainer(i9), this._tiles.delete(e11), i9.hasData() ? this._tileCache.put(e11, i9, 1) : i9.dispose();
  }
  _addToContainer(e11) {
    let i9;
    const t10 = [], l12 = this._container;
    if (l12.contains(e11))
      return;
    const s7 = this._visibleTiles;
    for (const [r9, o6] of s7)
      this._canConnectDirectly(e11, o6) && t10.push(o6), null == i9 && this._canConnectDirectly(o6, e11) && (i9 = o6);
    if (null != i9) {
      for (const l13 of t10)
        i9.childrenTiles.delete(l13), e11.childrenTiles.add(l13), l13.parentTile = e11;
      i9.childrenTiles.add(e11), e11.parentTile = i9;
    } else
      for (const r9 of t10)
        e11.childrenTiles.add(r9), r9.parentTile = e11;
    s7.set(e11.id, e11), l12.addChild(e11);
  }
  _removeFromContainer(e11) {
    if (this._visibleTiles.delete(e11.id), this._container.removeChild(e11), null != e11.parentTile) {
      e11.parentTile.childrenTiles.delete(e11);
      for (const i9 of e11.childrenTiles)
        null != e11.parentTile && e11.parentTile.childrenTiles.add(i9);
    }
    for (const i9 of e11.childrenTiles)
      i9.parentTile = e11.parentTile;
    e11.parentTile = null, e11.childrenTiles.clear();
  }
  _canConnectDirectly(e11, i9) {
    const t10 = e11.key;
    let { level: l12, row: s7, col: r9, world: o6 } = i9.key;
    const n7 = this._visibleTiles;
    for (; l12 > 0; ) {
      if (l12--, s7 >>= 1, r9 >>= 1, t10.level === l12 && t10.row === s7 && t10.col === r9 && t10.world === o6)
        return true;
      if (n7.has(`${l12}/${s7}/${r9}/${o6}`))
        return false;
    }
    return false;
  }
  _updateCacheSize(e11) {
    const i9 = e11.state.size;
    if (i9[0] === this._viewSize[0] && i9[1] === this._viewSize[1])
      return;
    const t10 = Math.ceil(i9[0] / l6) + 1, s7 = Math.ceil(i9[1] / l6) + 1;
    this._viewSize[0] = i9[0], this._viewSize[1] = i9[1], this._tileCache.maxSize = 5 * t10 * s7;
  }
};
function n5(e11) {
  const [i9, t10, l12, s7] = e11.split("/"), r9 = parseInt(i9, 10);
  return 0 === r9 ? null : `${r9 - 1}/${parseInt(t10, 10) >> 1}/${parseInt(l12, 10) >> 1}/${parseInt(s7, 10)}`;
}
function a6(e11, i9) {
  const t10 = i9.level - e11.level;
  return e11.row === i9.row >> t10 && e11.col === i9.col >> t10 && e11.world === i9.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t5 = class {
  constructor(t10) {
    this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t10;
  }
};
var s5 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function s6(t10, e11, s7, o6, l12, i9) {
  const r9 = s7 - l12;
  if (r9 >= 0)
    return (e11 >> r9) + (o6 - (i9 << r9)) * (t10 >> r9);
  const n7 = -r9;
  return e11 - (i9 - (o6 << n7)) * (t10 >> n7) << n7;
}
var o3 = class {
  constructor(t10, e11, s7) {
    this._rows = Math.ceil(e11 / s7), this._columns = Math.ceil(t10 / s7), this._cellSize = s7, this.cells = new Array(this._rows);
    for (let o6 = 0; o6 < this._rows; o6++) {
      this.cells[o6] = new Array(this._columns);
      for (let t11 = 0; t11 < this._columns; t11++)
        this.cells[o6][t11] = [];
    }
  }
  getCell(t10, e11) {
    const s7 = Math.min(Math.max(Math.floor(e11 / this._cellSize), 0), this._rows - 1), o6 = Math.min(Math.max(Math.floor(t10 / this._cellSize), 0), this._columns - 1);
    return this.cells[s7] && this.cells[s7][o6] || null;
  }
  getCellSpan(t10, e11, s7, o6) {
    return [Math.min(Math.max(Math.floor(t10 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e11 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s7 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o6 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l7(t10, s7, o6, l12, i9, r9) {
  const n7 = s7[l12++];
  for (let a7 = 0; a7 < n7; a7++) {
    const n8 = new t5(r9);
    n8.xTile = s7[l12++], n8.yTile = s7[l12++], n8.hash = s7[l12++], n8.priority = s7[l12++];
    const a8 = s7[l12++];
    for (let t11 = 0; t11 < a8; t11++) {
      const t12 = s7[l12++], e11 = s7[l12++], i10 = s7[l12++], r10 = s7[l12++], a9 = !!s7[l12++], c6 = s7[l12++], h8 = o6[l12++], f6 = o6[l12++], u3 = s7[l12++], m5 = s7[l12++];
      n8.colliders.push({ xTile: t12, yTile: e11, dxPixels: i10, dyPixels: r10, hard: a9, partIndex: c6, width: u3, height: m5, minLod: h8, maxLod: f6 });
    }
    const c5 = t10[l12++];
    for (let e11 = 0; e11 < c5; e11++)
      n8.textVertexRanges.push([t10[l12++], t10[l12++]]);
    const h7 = t10[l12++];
    for (let e11 = 0; e11 < h7; e11++)
      n8.iconVertexRanges.push([t10[l12++], t10[l12++]]);
    i9.push(n8);
  }
  return l12;
}
function i5(t10, e11, s7) {
  for (const [o6, l12] of t10.symbols)
    r8(t10, e11, s7, l12, o6);
}
function r8(e11, s7, o6, l12, i9) {
  const r9 = e11.layerData.get(i9);
  if (r9.type === E2.SYMBOL) {
    for (const t10 of l12) {
      const s8 = t10.unique;
      let l13;
      if (t10.selectedForRendering) {
        const t11 = s8.parts[0], i10 = t11.startOpacity, r10 = t11.targetOpacity;
        e11.allSymbolsFadingOut = e11.allSymbolsFadingOut && 0 === r10;
        const n7 = o6 ? Math.floor(127 * i10) | r10 << 7 : r10 ? 255 : 0;
        l13 = n7 << 24 | n7 << 16 | n7 << 8 | n7;
      } else
        l13 = 0;
      for (const [e12, o7] of t10.iconVertexRanges)
        for (let t11 = e12; t11 < e12 + o7; t11 += 4)
          r9.iconOpacity[t11 / 4] = l13;
      if (t10.selectedForRendering) {
        const t11 = s8.parts[1], i10 = t11.startOpacity, r10 = t11.targetOpacity;
        e11.allSymbolsFadingOut = e11.allSymbolsFadingOut && 0 === r10;
        const n7 = o6 ? Math.floor(127 * i10) | r10 << 7 : r10 ? 255 : 0;
        l13 = n7 << 24 | n7 << 16 | n7 << 8 | n7;
      } else
        l13 = 0;
      for (const [e12, o7] of t10.textVertexRanges)
        for (let t11 = e12; t11 < e12 + o7; t11 += 4)
          r9.textOpacity[t11 / 4] = l13;
    }
    r9.lastOpacityUpdate = s7, r9.opacityChanged = true;
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var o4 = class {
  constructor(t10, e11) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t10;
    let r9 = 1;
    const n7 = new Uint32Array(t10);
    this.layerUIDs = [];
    const s7 = n7[r9++];
    for (let i9 = 0; i9 < s7; i9++)
      this.layerUIDs[i9] = n7[r9++];
    this.bufferDataOffset = r9, e11 && (this.layer = e11.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this.isDestroyed = true);
  }
  prepareForRendering(t10) {
    null != this._data && (this.doPrepareForRendering(t10, this._data, this.bufferDataOffset), this._data = null);
  }
};
var h6 = class extends o4 {
  constructor(t10, e11) {
    super(t10, e11), this.type = E2.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const n7 = new Uint32Array(t10);
    let s7 = this.bufferDataOffset;
    this.lineIndexStart = n7[s7++], this.lineIndexCount = n7[s7++];
    const i9 = n7[s7++];
    if (i9 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t11 = 0; t11 < i9; t11++) {
        const t12 = n7[s7++], e12 = n7[s7++], r9 = n7[s7++];
        this.patternMap.set(t12, [e12, r9]);
      }
    }
    this.bufferDataOffset = s7;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = t(this.vao);
  }
  doPrepareForRendering(t10, e11, r9) {
    const n7 = new Uint32Array(e11), o6 = new Int32Array(n7.buffer), h7 = n7[r9++], f6 = c2.createVertex(t10, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r9, h7));
    r9 += h7;
    const c5 = n7[r9++], l12 = c2.createIndex(t10, F.STATIC_DRAW, new Uint32Array(n7.buffer, 4 * r9, c5));
    r9 += c5;
    const y4 = this.layer.lineMaterial;
    this.vao = new u(t10, y4.getAttributeLocations(), y4.getLayoutInfo(), { geometry: f6 }, l12);
  }
};
var f5 = class extends o4 {
  constructor(t10, e11) {
    super(t10, e11), this.type = E2.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const n7 = new Uint32Array(t10);
    let s7 = this.bufferDataOffset;
    this.fillIndexStart = n7[s7++], this.fillIndexCount = n7[s7++], this.outlineIndexStart = n7[s7++], this.outlineIndexCount = n7[s7++];
    const i9 = n7[s7++];
    if (i9 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t11 = 0; t11 < i9; t11++) {
        const t12 = n7[s7++], e12 = n7[s7++], r9 = n7[s7++];
        this.patternMap.set(t12, [e12, r9]);
      }
    }
    this.bufferDataOffset = s7;
  }
  get memoryUsed() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.memoryEstimate) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = t(this.fillVAO), this.outlineVAO = t(this.outlineVAO);
  }
  doPrepareForRendering(t10, e11, r9) {
    const n7 = new Uint32Array(e11), o6 = new Int32Array(n7.buffer), h7 = n7[r9++], f6 = c2.createVertex(t10, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r9, h7));
    r9 += h7;
    const c5 = n7[r9++], l12 = c2.createIndex(t10, F.STATIC_DRAW, new Uint32Array(n7.buffer, 4 * r9, c5));
    r9 += c5;
    const y4 = n7[r9++], u3 = c2.createVertex(t10, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r9, y4));
    r9 += y4;
    const A = n7[r9++], d4 = c2.createIndex(t10, F.STATIC_DRAW, new Uint32Array(n7.buffer, 4 * r9, A));
    r9 += A;
    const I3 = this.layer, g2 = I3.fillMaterial, p4 = I3.outlineMaterial;
    this.fillVAO = new u(t10, g2.getAttributeLocations(), g2.getLayoutInfo(), { geometry: f6 }, l12), this.outlineVAO = new u(t10, p4.getAttributeLocations(), p4.getLayoutInfo(), { geometry: u3 }, d4);
  }
};
var c3 = class extends o4 {
  constructor(t10, e11, s7) {
    super(t10, e11), this.type = E2.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const i9 = new Uint32Array(t10), a7 = new Int32Array(t10), o6 = new Float32Array(t10);
    let h7 = this.bufferDataOffset;
    this.isIconSDF = !!i9[h7++];
    const f6 = i9[h7++];
    for (let r9 = 0; r9 < f6; r9++) {
      const t11 = i9[h7++], e12 = i9[h7++], r10 = i9[h7++];
      this.iconPerPageElementsMap.set(t11, [e12, r10]);
    }
    const c5 = i9[h7++];
    for (let r9 = 0; r9 < c5; r9++) {
      const t11 = i9[h7++], e12 = i9[h7++], r10 = i9[h7++];
      this.glyphPerPageElementsMap.set(t11, [e12, r10]);
    }
    const l12 = i9[h7++], y4 = i9[h7++];
    this.iconOpacity = new Int32Array(l12), this.textOpacity = new Int32Array(y4), h7 = l7(i9, a7, o6, h7, this.symbols, s7), this.bufferDataOffset = h7;
  }
  get memoryUsed() {
    var _a, _b, _c2;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.memoryEstimate) ?? 0) + (((_c2 = this.textVAO) == null ? void 0 : _c2.memoryEstimate) ?? 0) + m(this.iconOpacity) + m(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t10 = 0;
    for (const [e11, r9] of this.iconPerPageElementsMap)
      t10 += r9[1];
    for (const [e11, r9] of this.glyphPerPageElementsMap)
      t10 += r9[1];
    return t10 / 3;
  }
  doDestroy() {
    this.iconVAO = t(this.iconVAO), this.textVAO = t(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged)
      return;
    this.opacityChanged = false;
    const t10 = this.iconOpacity, e11 = this.iconVAO.vertexBuffers.opacity;
    t10.length > 0 && t10.byteLength === e11.byteLength && e11.setSubData(t10, 0, 0, t10.length);
    const r9 = this.textOpacity, n7 = this.textVAO.vertexBuffers.opacity;
    r9.length > 0 && r9.byteLength === n7.byteLength && n7.setSubData(r9, 0, 0, r9.length);
  }
  doPrepareForRendering(t10, e11, r9) {
    const n7 = new Uint32Array(e11), o6 = new Int32Array(n7.buffer), h7 = n7[r9++], f6 = c2.createVertex(t10, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r9, h7));
    r9 += h7;
    const c5 = n7[r9++], l12 = c2.createIndex(t10, F.STATIC_DRAW, new Uint32Array(n7.buffer, 4 * r9, c5));
    r9 += c5;
    const y4 = n7[r9++], u3 = c2.createVertex(t10, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r9, y4));
    r9 += y4;
    const A = n7[r9++], d4 = c2.createIndex(t10, F.STATIC_DRAW, new Uint32Array(n7.buffer, 4 * r9, A));
    r9 += A;
    const I3 = c2.createVertex(t10, F.STATIC_DRAW, this.iconOpacity.buffer), g2 = c2.createVertex(t10, F.STATIC_DRAW, this.textOpacity.buffer), p4 = this.layer, m5 = p4.iconMaterial, x = p4.textMaterial;
    this.iconVAO = new u(t10, m5.getAttributeLocations(), m5.getLayoutInfo(), { geometry: f6, opacity: I3 }, l12), this.textVAO = new u(t10, x.getAttributeLocations(), x.getLayoutInfo(), { geometry: u3, opacity: g2 }, d4);
  }
};
var l8 = class extends o4 {
  constructor(t10, e11) {
    super(t10, e11), this.type = E2.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const n7 = new Uint32Array(t10);
    let s7 = this.bufferDataOffset;
    this.circleIndexStart = n7[s7++], this.circleIndexCount = n7[s7++], this.bufferDataOffset = s7;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.memoryEstimate) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = t(this.vao);
  }
  doPrepareForRendering(t10, e11, r9) {
    const n7 = new Uint32Array(e11), o6 = new Int32Array(n7.buffer), h7 = n7[r9++], f6 = c2.createVertex(t10, F.STATIC_DRAW, new Int32Array(o6.buffer, 4 * r9, h7));
    r9 += h7;
    const c5 = n7[r9++], l12 = c2.createIndex(t10, F.STATIC_DRAW, new Uint32Array(n7.buffer, 4 * r9, c5));
    r9 += c5;
    const y4 = this.layer.circleMaterial;
    this.vao = new u(t10, y4.getAttributeLocations(), y4.getLayoutInfo(), { geometry: f6 }, l12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var d3 = class _d extends r4 {
  constructor(e11, t10, s7, a7, r9, i9, o6, h7 = null) {
    super(e11, t10, s7, a7, r9, i9, 4096, 4096), this.styleRepository = o6, this._memCache = h7, this.type = "vector-tile", this._referenced = 0, this._hasSymbolBuckets = false, this._memoryUsedByLayerData = 0, this.layerData = /* @__PURE__ */ new Map(), this.layerCount = 0, this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.invalidating = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this._processed = false, this._referenced = 1, this.id = e11.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e5;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e5);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e11) {
    this.changeDataImpl(e11), this.requestRender(), this.ready(), this.invalidating = false, this._processed = true;
  }
  deleteLayerData(e11) {
    var _a;
    let t10 = false;
    for (const s7 of e11)
      if (this.layerData.has(s7)) {
        const e12 = this.layerData.get(s7);
        this._memoryUsedByLayerData -= e12.memoryUsed, e12.type === E2.SYMBOL && this.symbols.has(s7) && (this.symbols.delete(s7), t10 = true), e12.destroy(), this.layerData.delete(s7), this.layerCount--;
      }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this._memoryUsedByLayerData), t10 && this.emit("symbols-changed"), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerCount > 0;
  }
  dispose() {
    "unloaded" !== this.status && (m3.delete(this), _d._destroyRenderBuckets(this.layerData), this.layerData = null, this.layerCount = 0, this._memoryUsedByLayerData = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    return 0 == --this._referenced && (this.dispose(), this.stage = null, true);
  }
  retain() {
    ++this._referenced;
  }
  get referenced() {
    return this._referenced;
  }
  get memoryUsed() {
    return this._memoryUsedByLayerData + 256;
  }
  changeDataImpl(e11) {
    var _a;
    let t10 = false;
    if (e11) {
      const { bucketsWithData: s7, emptyBuckets: a7 } = e11, r9 = this._createRenderBuckets(s7);
      if (a7 && a7.byteLength > 0) {
        const e12 = new Uint32Array(a7);
        for (const t11 of e12)
          this._deleteLayerData(t11);
      }
      for (const [e12, o6] of r9)
        this._deleteLayerData(e12), o6.type === E2.SYMBOL && (this.symbols.set(e12, o6.symbols), t10 = true), this._memoryUsedByLayerData += o6.memoryUsed, this.layerData.set(e12, o6), this.layerCount++;
      (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this.memoryUsed);
    }
    this._hasSymbolBuckets = false;
    for (const [s7, a7] of this.layerData)
      a7.type === E2.SYMBOL && (this._hasSymbolBuckets = true);
    t10 && this.emit("symbols-changed");
  }
  attachWithContext(e11) {
    this.stage = { context: e11, trashDisplayObject(e12) {
      e12.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(r9) {
    super.setTransform(r9);
    const i9 = this.resolution / (r9.resolution * r9.pixelRatio), o6 = this.width / this.rangeX * i9, h7 = this.height / this.rangeY * i9, n7 = [0, 0];
    r9.toScreen(n7, [this.x, this.y]);
    const l12 = this.transforms.tileUnitsToPixels;
    r(l12), M(l12, l12, n7), h2(l12, l12, Math.PI * r9.rotation / 180), f2(l12, l12, [o6, h7, 1]);
  }
  _createTransforms() {
    return { dvs: e6(), tileMat3: e6(), tileUnitsToPixels: e6() };
  }
  static _destroyRenderBuckets(e11) {
    if (!e11)
      return;
    const t10 = /* @__PURE__ */ new Set();
    e11.forEach((e12) => {
      t10.has(e12) || (e12.destroy(), t10.add(e12));
    }), e11.clear();
  }
  _createRenderBuckets(e11) {
    const t10 = /* @__PURE__ */ new Map(), s7 = /* @__PURE__ */ new Map();
    for (const a7 of e11) {
      const e12 = this._deserializeBucket(a7, s7);
      for (const s8 of e12.layerUIDs)
        t10.set(s8, e12);
    }
    return t10;
  }
  _deserializeBucket(e11, t10) {
    let s7 = t10.get(e11);
    if (s7)
      return s7;
    switch (new Uint32Array(e11)[0]) {
      case E2.FILL:
        s7 = new f5(e11, this.styleRepository);
        break;
      case E2.LINE:
        s7 = new h6(e11, this.styleRepository);
        break;
      case E2.SYMBOL:
        s7 = new c3(e11, this.styleRepository, this);
        break;
      case E2.CIRCLE:
        s7 = new l8(e11, this.styleRepository);
    }
    return t10.set(e11, s7), s7;
  }
  _deleteLayerData(e11) {
    if (!this.layerData.has(e11))
      return;
    const t10 = this.layerData.get(e11);
    this._memoryUsedByLayerData -= t10.memoryUsed, t10.destroy(), this.layerData.delete(e11), this.layerCount--;
  }
};
var m3 = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i6(e11, t10, n7, o6, i9, l12) {
  const { iconRotationAlignment: a7, textRotationAlignment: c5, iconTranslate: h7, iconTranslateAnchor: u3, textTranslate: d4, textTranslateAnchor: y4 } = o6;
  let x = 0;
  for (const g2 of e11.colliders) {
    const [e12, o7] = 0 === g2.partIndex ? h7 : d4, m5 = 0 === g2.partIndex ? u3 : y4, f6 = g2.minLod <= l12 && l12 <= g2.maxLod;
    x += f6 ? 0 : 1, g2.enabled = f6, g2.xScreen = g2.xTile * i9[0] + g2.yTile * i9[3] + i9[6], g2.yScreen = g2.xTile * i9[1] + g2.yTile * i9[4] + i9[7], m5 === r2.MAP ? (g2.xScreen += n7 * e12 - t10 * o7, g2.yScreen += t10 * e12 + n7 * o7) : (g2.xScreen += e12, g2.yScreen += o7), l4.VIEWPORT === (0 === g2.partIndex ? a7 : c5) ? (g2.dxScreen = g2.dxPixels, g2.dyScreen = g2.dyPixels) : (g2.dxScreen = n7 * (g2.dxPixels + g2.width / 2) - t10 * (g2.dyPixels + g2.height / 2) - g2.width / 2, g2.dyScreen = t10 * (g2.dxPixels + g2.width / 2) + n7 * (g2.dyPixels + g2.height / 2) - g2.height / 2);
  }
  e11.colliders.length > 0 && x === e11.colliders.length && (e11.unique.show = false);
}
var l9 = class {
  constructor(o6, r9, s7, i9, l12, a7) {
    this._symbols = o6, this._styleRepository = i9, this._zoom = l12, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new o3(r9, s7, t4), this._si = Math.sin(Math.PI * a7 / 180), this._co = Math.cos(Math.PI * a7 / 180);
    for (const t10 of o6)
      for (const n7 of t10.symbols)
        this._allNeededMatrices.has(n7.tile) || this._allNeededMatrices.set(n7.tile, r3(n7.tile.transforms.tileUnitsToPixels));
  }
  work(e11) {
    const t10 = this._gridIndex;
    function n7(e12) {
      const n8 = e12.xScreen + e12.dxScreen, o7 = e12.yScreen + e12.dyScreen, r9 = n8 + e12.width, s7 = o7 + e12.height, [i9, l12, a7, c5] = t10.getCellSpan(n8, o7, r9, s7);
      for (let h7 = l12; h7 <= c5; h7++)
        for (let e13 = i9; e13 <= a7; e13++) {
          const i10 = t10.cells[h7][e13];
          for (const e14 of i10) {
            const t11 = e14.xScreen + e14.dxScreen, i11 = e14.yScreen + e14.dyScreen, l13 = t11 + e14.width, a8 = i11 + e14.height;
            if (!(r9 < t11 || n8 > l13 || s7 < i11 || o7 > a8))
              return true;
          }
        }
      return false;
    }
    const o6 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t11 = this._symbols[this._currentLayerCursor], r9 = this._getProperties(t11.styleLayerUID);
      for (; this._currentSymbolCursor < t11.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o6 > e11)
          return false;
        const s7 = t11.symbols[this._currentSymbolCursor];
        if (!s7.unique.show)
          continue;
        i6(s7, this._si, this._co, r9, this._allNeededMatrices.get(s7.tile), this._zoom);
        const l12 = s7.unique;
        if (!l12.show)
          continue;
        const { iconAllowOverlap: a7, iconIgnorePlacement: c5, textAllowOverlap: h7, textIgnorePlacement: u3 } = r9;
        for (const e12 of s7.colliders) {
          if (!e12.enabled)
            continue;
          const t12 = l12.parts[e12.partIndex];
          if (!t12.show)
            continue;
          !(e12.partIndex ? h7 : a7) && n7(e12) && (e12.hard ? l12.show = false : t12.show = false);
        }
        if (l12.show)
          for (const e12 of s7.colliders) {
            if (!e12.enabled)
              continue;
            if (e12.partIndex ? u3 : c5)
              continue;
            if (!l12.parts[e12.partIndex].show)
              continue;
            const t12 = e12.xScreen + e12.dxScreen, n8 = e12.yScreen + e12.dyScreen, o7 = t12 + e12.width, r10 = n8 + e12.height, [s8, i9, a8, h8] = this._gridIndex.getCellSpan(t12, n8, o7, r10);
            for (let l13 = i9; l13 <= h8; l13++)
              for (let t13 = s8; t13 <= a8; t13++) {
                this._gridIndex.cells[l13][t13].push(e12);
              }
          }
      }
    }
    return true;
  }
  _getProperties(e11) {
    const t10 = this._styleProps.get(e11);
    if (t10)
      return t10;
    const n7 = this._zoom, s7 = this._styleRepository.getStyleLayerByUID(e11), i9 = s7.getLayoutValue("symbol-placement", n7) !== n3.POINT;
    let l12 = s7.getLayoutValue("icon-rotation-alignment", n7);
    l12 === l4.AUTO && (l12 = i9 ? l4.MAP : l4.VIEWPORT);
    let a7 = s7.getLayoutValue("text-rotation-alignment", n7);
    a7 === l4.AUTO && (a7 = i9 ? l4.MAP : l4.VIEWPORT);
    const c5 = s7.getPaintValue("icon-translate", n7), h7 = s7.getPaintValue("icon-translate-anchor", n7), u3 = s7.getPaintValue("text-translate", n7), d4 = s7.getPaintValue("text-translate-anchor", n7), y4 = { iconAllowOverlap: s7.getLayoutValue("icon-allow-overlap", n7), iconIgnorePlacement: s7.getLayoutValue("icon-ignore-placement", n7), textAllowOverlap: s7.getLayoutValue("text-allow-overlap", n7), textIgnorePlacement: s7.getLayoutValue("text-ignore-placement", n7), iconRotationAlignment: l12, textRotationAlignment: a7, iconTranslateAnchor: h7, iconTranslate: c5, textTranslateAnchor: d4, textTranslate: u3 };
    return this._styleProps.set(e11, y4), y4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t6(o6, t10) {
  if (o6.priority - t10.priority)
    return o6.priority - t10.priority;
  const e11 = o6.tile.key, i9 = t10.tile.key;
  return e11.world - i9.world ? e11.world - i9.world : e11.level - i9.level ? e11.level - i9.level : e11.row - i9.row ? e11.row - i9.row : e11.col - i9.col ? e11.col - i9.col : o6.xTile - t10.xTile ? o6.xTile - t10.xTile : o6.yTile - t10.yTile;
}
var e10 = class {
  get running() {
    return this._running;
  }
  constructor(o6, t10, e11, i9, s7, n7) {
    this._visibleTiles = o6, this._symbolRepository = t10, this._createCollisionJob = e11, this._assignTileSymbolsOpacity = i9, this._symbolLayerSorter = s7, this._isLayerVisible = n7, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o6, t10) {
    this._screenWidth === o6 && this._screenHeight === t10 || this.restart(), this._screenWidth = o6, this._screenHeight = t10;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o6) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t10 = performance.now();
      if (!this._selectionJob.work(o6))
        return false;
      if (this._selectionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t10))))
        return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t10 = performance.now();
      if (!this._collisionJob.work(o6))
        return false;
      if (this._collisionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t10))))
        return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t10 = performance.now();
      if (!this._opacityJob.work(o6))
        return false;
      if (this._opacityJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t10))))
        return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o6 = this._symbolRepository.uniqueSymbols;
    for (let t10 = 0; t10 < o6.length; t10++) {
      const e12 = o6[t10];
      for (let o7 = 0; o7 < e12.uniqueSymbols.length; o7++) {
        const t11 = e12.uniqueSymbols[o7];
        for (const o8 of t11.tileSymbols)
          o8.selectedForRendering = false;
      }
    }
    const e11 = [];
    let i9 = 0, s7 = 0;
    const n7 = this._isLayerVisible;
    function r9(r10) {
      let l13;
      const c5 = performance.now();
      for (; s7 < o6.length; s7++, i9 = 0) {
        const t10 = o6[s7], h7 = t10.styleLayerUID;
        if (!n7(h7)) {
          e11[s7] || (e11[s7] = { styleLayerUID: h7, symbols: [] });
          continue;
        }
        e11[s7] = e11[s7] || { styleLayerUID: h7, symbols: [] };
        const a7 = e11[s7];
        for (; i9 < t10.uniqueSymbols.length; i9++) {
          if (l13 = t10.uniqueSymbols[i9], i9 % 100 == 99 && performance.now() - c5 > r10)
            return false;
          let o7 = null, e12 = false, s8 = false;
          for (const t11 of l13.tileSymbols)
            if (!s8 || !e12) {
              const i10 = t11.tile;
              (!o7 || i10.isCoverage || i10.neededForCoverage && !e12) && (o7 = t11, (i10.neededForCoverage || i10.isCoverage) && (s8 = true), i10.isCoverage && (e12 = true));
            }
          if (o7.selectedForRendering = true, s8) {
            a7.symbols.push(o7), l13.show = true;
            for (const o8 of l13.parts)
              o8.show = true;
          } else
            l13.show = false;
        }
      }
      for (const o7 of e11)
        o7.symbols.sort(t6);
      return true;
    }
    const l12 = this._symbolLayerSorter;
    return { work: r9, get sortedSymbols() {
      return e11.sort(l12);
    } };
  }
  _createOpacityJob() {
    const o6 = this._assignTileSymbolsOpacity, t10 = this._visibleTiles;
    let e11 = 0;
    function s7(t11, e12) {
      const n7 = t11.symbols;
      for (const [o7, s8] of n7)
        i7(s8, e12);
      o6(t11, e12);
      for (const o7 of t11.childrenTiles)
        s7(o7, e12);
    }
    return { work(o7) {
      const i9 = performance.now();
      for (; e11 < t10.length; e11++) {
        if (performance.now() - i9 > o7)
          return false;
        const n7 = t10[e11];
        if (null != n7.parentTile)
          continue;
        s7(n7, performance.now());
      }
      return true;
    } };
  }
};
function i7(t10, e11) {
  for (const i9 of t10) {
    const t11 = i9.unique;
    for (const i10 of t11.parts) {
      const s7 = i10.targetOpacity > 0.5 ? 1 : -1;
      i10.startOpacity += s7 * ((e11 - i10.startTime) / e5), i10.startOpacity = Math.min(Math.max(i10.startOpacity, 0), 1), i10.startTime = e11, i10.targetOpacity = t11.show && i10.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var l10 = 32;
var o5 = 8;
var t7 = 64;
var i8 = class {
  constructor(e11, s7, l12) {
    this.tileCoordRange = e11, this._visibleTiles = s7, this._createUnique = l12, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  add(s7, i9) {
    this._uniqueSymbolLayerArray = null;
    let n7 = this._tiles.get(s7.id);
    n7 || (n7 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s7.id, n7));
    const r9 = /* @__PURE__ */ new Map();
    if (i9)
      for (const e11 of i9)
        n7.symbols.has(e11) && (r9.set(e11, n7.symbols.get(e11)), n7.symbols.delete(e11));
    else
      for (const [e11, l12] of s7.layerData)
        n7.symbols.has(e11) && (r9.set(e11, n7.symbols.get(e11)), n7.symbols.delete(e11));
    this._removeSymbols(r9);
    const y4 = s7.symbols, a7 = /* @__PURE__ */ new Map();
    for (const [f6, c5] of y4) {
      let s8 = c5.length;
      if (s8 >= l10) {
        let l12 = this.tileCoordRange;
        do {
          l12 /= 2, s8 /= 4;
        } while (s8 > o5 && l12 > t7);
        const i10 = new o3(this.tileCoordRange, this.tileCoordRange, l12);
        a7.set(f6, { flat: c5, index: i10 }), n7.symbols.set(f6, { flat: c5, index: i10 });
        for (const e11 of c5)
          i10.getCell(e11.xTile, e11.yTile).push(e11);
      } else
        a7.set(f6, { flat: c5 }), n7.symbols.set(f6, { flat: c5 });
    }
    this._addSymbols(s7.key, y4);
  }
  deleteStyleLayers(e11) {
    this._uniqueSymbolLayerArray = null;
    for (const [s7, l12] of this._tiles) {
      const o6 = /* @__PURE__ */ new Map();
      for (const s8 of e11)
        l12.symbols.has(s8) && (o6.set(s8, l12.symbols.get(s8)), l12.symbols.delete(s8));
      this._removeSymbols(o6), 0 === l12.symbols.size && this._tiles.delete(s7);
    }
  }
  removeTile(e11) {
    this._uniqueSymbolLayerArray = null;
    const s7 = this._tiles.get(e11.id);
    if (!s7)
      return;
    const l12 = /* @__PURE__ */ new Map();
    for (const [o6, t10] of e11.symbols)
      s7.symbols.has(o6) && (l12.set(o6, s7.symbols.get(o6)), s7.symbols.delete(o6));
    this._removeSymbols(l12), 0 === s7.symbols.size && this._tiles.delete(e11.id);
  }
  _removeSymbols(e11) {
    for (const [s7, { flat: l12 }] of e11)
      for (const e12 of l12) {
        const l13 = e12.unique, o6 = l13.tileSymbols, t10 = o6.length - 1;
        for (let s8 = 0; s8 < t10; s8++)
          if (o6[s8] === e12) {
            o6[s8] = o6[t10];
            break;
          }
        if (o6.length = t10, 0 === t10) {
          const e13 = this._uniqueSymbolsReferences.get(s7);
          e13.delete(l13), 0 === e13.size && this._uniqueSymbolsReferences.delete(s7);
        }
        e12.unique = null;
      }
  }
  _addSymbols(e11, s7) {
    if (0 === s7.size)
      return;
    const l12 = this._visibleTiles;
    for (const o6 of l12)
      o6.parentTile || o6.key.world !== e11.world || o6.key.level === e11.level && !o6.key.equals(e11) || this._matchSymbols(o6, e11, s7);
    for (const [o6, t10] of s7)
      for (const e12 of t10)
        if (null == e12.unique) {
          const s8 = this._createUnique();
          e12.unique = s8, s8.tileSymbols.push(e12);
          let l13 = this._uniqueSymbolsReferences.get(o6);
          l13 || (l13 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o6, l13)), l13.add(s8);
        }
  }
  _matchSymbols(e11, l12, o6) {
    if (e11.key.level > l12.level) {
      const s7 = e11.key.level - l12.level;
      if (e11.key.row >> s7 !== l12.row || e11.key.col >> s7 !== l12.col)
        return;
    }
    if (l12.level > e11.key.level) {
      const s7 = l12.level - e11.key.level;
      if (l12.row >> s7 !== e11.key.row || l12.col >> s7 !== e11.key.col)
        return;
    }
    if (l12.equals(e11.key)) {
      for (const s7 of e11.childrenTiles)
        this._matchSymbols(s7, l12, o6);
      return;
    }
    const t10 = /* @__PURE__ */ new Map();
    for (const [i9, n7] of o6) {
      const o7 = [];
      for (const t11 of n7) {
        const i10 = s6(this.tileCoordRange, t11.xTile, l12.level, l12.col, e11.key.level, e11.key.col), n8 = s6(this.tileCoordRange, t11.yTile, l12.level, l12.row, e11.key.level, e11.key.row);
        i10 >= 0 && i10 < this.tileCoordRange && n8 >= 0 && n8 < this.tileCoordRange && o7.push({ symbol: t11, xTransformed: i10, yTransformed: n8 });
      }
      const r9 = [], y4 = e11.key.level < l12.level ? 1 : 1 << e11.key.level - l12.level, a7 = this._tiles.get(e11.id).symbols.get(i9);
      if (a7) {
        const e12 = a7.flat;
        for (const s7 of o7) {
          let l13, o8 = false;
          const t11 = s7.xTransformed, i10 = s7.yTransformed;
          l13 = null != a7.index ? a7.index.getCell(t11, i10) : e12;
          const n8 = s7.symbol, f6 = n8.hash;
          for (const e13 of l13)
            if (f6 === e13.hash && Math.abs(t11 - e13.xTile) <= y4 && Math.abs(i10 - e13.yTile) <= y4) {
              const s8 = e13.unique;
              n8.unique = s8, s8.tileSymbols.push(n8), o8 = true;
              break;
            }
          o8 || r9.push(n8);
        }
      }
      r9.length > 0 && t10.set(i9, r9);
    }
    for (const s7 of e11.childrenTiles)
      this._matchSymbols(s7, l12, t10);
  }
  _createUniqueSymbolLayerArray() {
    const e11 = this._uniqueSymbolsReferences, s7 = new Array(e11.size);
    let l12, o6 = 0;
    for (const [t10, i9] of e11) {
      const e12 = new Array(i9.size);
      l12 = 0;
      for (const s8 of i9)
        e12[l12++] = s8;
      s7[o6] = { styleLayerUID: t10, uniqueSymbols: e12 }, o6++;
    }
    return s7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c4 = 0.5;
var n6 = 1e-6;
var _ = class extends n {
  constructor(t10, e11) {
    super(), this.styleRepository = t10, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._completed = false, this._symbolRepository = new i8(4096, e11, () => new s5()), this._symbolDeclutterer = new e10(e11, this._symbolRepository, (t11, e12, i9) => new l9(t11, e12, i9, this.styleRepository, this._zoom, this._viewState.rotation), (t11, e12) => {
      t11.allSymbolsFadingOut = true, t11.lastOpacityUpdate = e12, i5(t11, e12, true), t11.decluttered = true, t11.requestRender();
    }, (t11, e12) => this.styleRepository.getStyleLayerByUID(t11.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e12.styleLayerUID).z, (t11) => {
      const e12 = this.styleRepository.getStyleLayerByUID(t11);
      if (this._zoom + n6 < e12.minzoom || this._zoom - n6 >= e12.maxzoom)
        return false;
      const i9 = e12.getLayoutProperty("visibility");
      return !i9 || i9.getValue() !== i2.NONE;
    });
  }
  addTile(t10) {
    t10.decluttered = false, this._tileToHandle.set(t10, t10.on("symbols-changed", () => {
      this._symbolRepository.add(t10), this.restartDeclutter();
    })), this._symbolRepository.add(t10), this.restartDeclutter();
  }
  removeTile(t10) {
    const e11 = this._tileToHandle.get(t10);
    e11 && (this._symbolRepository.removeTile(t10), this.restartDeclutter(), e11.remove(), this._tileToHandle.delete(t10));
  }
  update(t10, e11) {
    return this._zoom = t10, this._viewState = { scale: e11.scale, rotation: e11.rotation, center: [e11.center[0], e11.center[1]], size: [e11.size[0], e11.size[1]] }, this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t10) => t10.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t10) {
    this._symbolRepository.deleteStyleLayers(t10);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this.emit("fade-complete");
    }, (1 + c4) * e5);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this.emit("fade-start");
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t8 = class extends r4 {
  _createTransforms() {
    return { dvs: e6(), tileMat3: e6() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y3 = 1e-6;
function p2(e11, t10) {
  if (e11) {
    const s7 = e11.getLayoutProperty("visibility");
    if (!s7 || s7.getValue() !== i2.NONE && (void 0 === e11.minzoom || e11.minzoom < t10 + y3) && (void 0 === e11.maxzoom || e11.maxzoom >= t10 - y3))
      return true;
  }
  return false;
}
var m4 = class extends i4 {
  constructor(e11) {
    super(e11), this._backgroundTiles = [], this._pointToCallbacks = /* @__PURE__ */ new Map();
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [], this._pointToCallbacks.clear();
  }
  setStyleResources(e11, t10, r9) {
    if (this._spriteMosaic = e11, this._glyphMosaic = t10, this._styleRepository = r9, null == this._symbolFader) {
      const e12 = new _(this._styleRepository, this.children);
      e12.on("fade-start", () => {
        this.emit("fade-start"), this.requestRender();
      }), e12.on("fade-complete", () => {
        this.emit("fade-complete"), this.requestRender();
      }), this._symbolFader = e12;
    }
    this._symbolFader.styleRepository = r9;
  }
  setSpriteMosaic(e11) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e11;
  }
  deleteStyleLayers(e11) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e11);
  }
  async hitTest(t10) {
    const s7 = C();
    return this._pointToCallbacks.set(t10, s7), this.requestRender(), s7.promise;
  }
  enterTileInvalidation() {
    for (const e11 of this.children)
      e11.invalidating = true;
  }
  createRenderParams(e11) {
    return { ...super.createRenderParams(e11), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e11) {
    !this.visible || e11.drawPhase !== T.MAP && e11.drawPhase !== T.DEBUG || void 0 === this._spriteMosaic || super.doRender(e11);
  }
  addChild(e11) {
    return super.addChild(e11), null != this._symbolFader ? this._symbolFader.addTile(e11) : e11.decluttered = true, this.requestRender(), e11;
  }
  removeChild(e11) {
    return null != this._symbolFader && this._symbolFader.removeTile(e11), this.requestRender(), super.removeChild(e11);
  }
  renderChildren(e11) {
    const { drawPhase: t10 } = e11;
    if (t10 !== T.DEBUG) {
      if (this._doRender(e11), this._pointToCallbacks.size > 0) {
        e11.drawPhase = T.HITTEST;
        const s7 = e11.painter.effects.hittestVTL;
        s7.bind(e11), this._doRender(e11), s7.draw(e11, this._pointToCallbacks), s7.unbind(e11), e11.drawPhase = t10;
      }
    } else
      super.renderChildren(e11);
  }
  removeAllChildren() {
    for (let e11 = 0; e11 < this.children.length; e11++) {
      const t10 = this.children[e11];
      null != this._symbolFader && this._symbolFader.removeTile(t10), t10.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e11) => e11.neededForCoverage && e11.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e11) {
    const { context: t10 } = e11, s7 = this._styleRepository;
    if (!s7)
      return;
    const r9 = s7.layers;
    let i9 = true;
    e11.drawPhase === T.HITTEST && (i9 = false), s7.backgroundBucketIds.length > 0 && (e11.renderPass = "background", this._renderBackgroundLayers(e11, s7.backgroundBucketIds)), super.renderChildren(e11), e11.drawPhase === T.MAP && this._fade(e11.displayLevel, e11.state);
    const o6 = this.children.filter((e12) => e12.visible && e12.hasData());
    if (!o6 || 0 === o6.length)
      return t10.bindVAO(), t10.setStencilTestEnabled(true), void t10.setBlendingEnabled(true);
    for (const l12 of o6)
      l12.triangleCount = 0;
    t10.setStencilWriteMask(0), t10.setColorMask(true, true, true, true), t10.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), t10.setStencilTestEnabled(true), t10.setBlendingEnabled(false), t10.setDepthTestEnabled(true), t10.setDepthWriteEnabled(true), t10.setDepthFunction(I.LEQUAL), t10.setClearDepth(1), t10.clear(t10.gl.DEPTH_BUFFER_BIT), e11.renderPass = "opaque";
    for (let l12 = r9.length - 1; l12 >= 0; l12--)
      this._renderStyleLayer(r9[l12], e11, o6);
    t10.setDepthWriteEnabled(false), t10.setBlendingEnabled(i9), t10.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e11.renderPass = "translucent";
    for (let l12 = 0; l12 < r9.length; l12++)
      this._renderStyleLayer(r9[l12], e11, o6);
    t10.bindVAO(), t10.setStencilTestEnabled(true), t10.setBlendingEnabled(true);
  }
  _fade(e11, t10) {
    null != this._symbolFader && (this._symbolFader.update(e11, t10) || this.requestRender());
  }
  _renderStyleLayer(e11, t10, s7) {
    const { painter: l12, renderPass: o6 } = t10;
    if (void 0 === e11)
      return;
    const n7 = e11.getLayoutProperty("visibility");
    if (n7 && n7.getValue() === i2.NONE)
      return;
    let a7;
    switch (e11.type) {
      case a4.BACKGROUND:
        return;
      case a4.FILL:
        if ("opaque" !== o6 && "translucent" !== t10.renderPass)
          return;
        a7 = "vtlFill";
        break;
      case a4.LINE:
        if ("translucent" !== o6)
          return;
        a7 = "vtlLine";
        break;
      case a4.CIRCLE:
        if ("translucent" !== o6)
          return;
        a7 = "vtlCircle";
        break;
      case a4.SYMBOL:
        if ("translucent" !== o6)
          return;
        a7 = "vtlSymbol";
    }
    if (s7 = e11.type === a4.SYMBOL ? s7.filter((e12) => e12.decluttered) : s7.filter((e12) => e12.neededForCoverage), "vtlSymbol" !== a7) {
      const r9 = t10.displayLevel;
      if (0 === s7.length || void 0 !== e11.minzoom && e11.minzoom >= r9 + y3 || void 0 !== e11.maxzoom && e11.maxzoom < r9 - y3)
        return;
    }
    const d4 = e11.uid;
    t10.styleLayerUID = d4, t10.styleLayer = e11;
    for (const r9 of s7)
      if (r9.layerData.has(d4)) {
        l12.renderObjects(t10, s7, a7);
        break;
      }
  }
  _renderBackgroundLayers(e11, s7) {
    const { context: r9, displayLevel: n7, painter: u3, state: y4 } = e11, m5 = this._styleRepository;
    let f6 = false;
    for (const t10 of s7) {
      if (m5.getLayerById(t10).type === a4.BACKGROUND && p2(m5.getLayerById(t10), n7)) {
        f6 = true;
        break;
      }
    }
    if (!f6)
      return;
    const _2 = this._tileInfoView.getTileCoverage(e11.state, 0, true, "smallest"), { spans: b, lodInfo: g2 } = _2, { level: T3 } = g2, E3 = i(), C3 = [];
    if (this._renderPasses) {
      const t10 = this._renderPasses[0];
      null != this._clippingInfos && (t10.brushes[0].prepareState(e11), t10.brushes[0].drawMany(e11, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let v, R2 = 0;
    for (const { row: i9, colFrom: l12, colTo: a7 } of b)
      for (let e12 = l12; e12 <= a7; e12++) {
        if (R2 < L2.length)
          v = L2[R2], v.key.set(T3, i9, g2.normalizeCol(e12), g2.getWorldForColumn(e12)), this._tileInfoView.getTileBounds(E3, v.key, false), v.x = E3[0], v.y = E3[3], v.resolution = this._tileInfoView.getTileResolution(T3);
        else {
          const s8 = new e4(T3, i9, g2.normalizeCol(e12), g2.getWorldForColumn(e12)), r10 = this._tileInfoView.getTileBounds(i(), s8), l13 = this._tileInfoView.getTileResolution(T3);
          v = new t8(s8, l13, r10[0], r10[3], 512, 512, 4096, 4096), L2.push(v);
        }
        v.setTransform(y4), C3.push(v), R2++;
      }
    r9.setStencilWriteMask(0), r9.setColorMask(true, true, true, true), r9.setStencilOp(O.KEEP, O.KEEP, O.REPLACE), r9.setStencilFunction(I.EQUAL, 0, 255);
    let S2 = true;
    e11.drawPhase === T.HITTEST && (S2 = false), r9.setStencilTestEnabled(S2);
    for (const t10 of s7) {
      const s8 = m5.getLayerById(t10);
      s8.type === a4.BACKGROUND && p2(s8, n7) && (e11.styleLayerUID = s8.uid, e11.styleLayer = s8, u3.renderObjects(e11, C3, "vtlBackground"));
    }
    l3.pool.release(_2);
  }
};

// node_modules/@arcgis/core/views/2d/layers/support/DebugOverlay.js
var u2 = { geometry: [new t2("a_PositionAndFlags", 3, C2.SHORT, 0, 6)] };
var p3 = /* @__PURE__ */ new Map();
p3.set("a_PositionAndFlags", 0);
var g = { vsPath: "debug/overlay", fsPath: "debug/overlay", attributes: p3 };
var l11 = class extends i3 {
  constructor(e11) {
    super(), this._conf = e11;
  }
  static makeFlags(e11, t10) {
    return e11 | t10 << 2;
  }
  _createTransforms() {
    return { dvs: e6() };
  }
  doRender(e11) {
    this._updateTransforms(e11), this._ensureResources(e11);
    const { context: t10 } = e11;
    t10.useProgram(this._program), this._program.setUniformMatrix3fv("u_dvsMat3", this.transforms.dvs), this._program.setUniform4fv("u_colors", this._conf.getColors(e11)), this._program.setUniform1fv("u_opacities", this._conf.getOpacities(e11));
    const { vertexData: r9, indexData: s7 } = this._conf.getMesh(e11);
    this._vertexBuffer.setData(r9), this._indexBuffer.setData(s7), t10.bindVAO(this._vertexArray), t10.setBlendingEnabled(true), t10.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), t10.setDepthTestEnabled(false), t10.setStencilTestEnabled(false), t10.setColorMask(true, true, true, true), t10.drawElements(E.TRIANGLES, s7.length, C2.UNSIGNED_INT, 0);
  }
  onDetach() {
    this._vertexArray = t(this._vertexArray);
  }
  _updateTransforms(e11) {
    r(this.transforms.dvs), M(this.transforms.dvs, this.transforms.dvs, [-1, 1]), f2(this.transforms.dvs, this.transforms.dvs, [2 / e11.state.size[0], -2 / e11.state.size[1], 1]);
  }
  _ensureResources(e11) {
    const { context: t10 } = e11;
    this._program || (this._program = e11.painter.materialManager.getProgram(g)), this._vertexBuffer || (this._vertexBuffer = c2.createVertex(t10, F.STREAM_DRAW)), this._indexBuffer || (this._indexBuffer = c2.createIndex(t10, F.STREAM_DRAW)), this._vertexArray || (this._vertexArray = new u(t10, p3, u2, { geometry: this._vertexBuffer }, this._indexBuffer));
  }
};

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t9 = class extends h3 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e11) {
    const l12 = e4.pool.acquire(e11), t10 = 0 === l12.level ? null : e4.getId(l12.level - 1, l12.row >> 1, l12.col >> 1, l12.world);
    return e4.pool.release(l12), t10;
  }
  getTileCoverage(e11, l12, s7 = true, t10) {
    const o6 = super.getTileCoverage(e11, l12, s7, t10);
    if (!o6)
      return o6;
    const i9 = 1 << o6.lodInfo.level;
    return o6.spans = o6.spans.filter((e12) => e12.row >= 0 && e12.row < i9), o6;
  }
  scaleToLevel(e11) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e11])
      return this._levelByScale[e11];
    {
      const l12 = this._fullCacheLodInfos;
      if (e11 > l12[0].scale)
        return l12[0].level;
      let s7, t10;
      for (let o6 = 0; o6 < l12.length - 1; o6++)
        if (t10 = l12[o6 + 1], e11 > t10.scale)
          return s7 = l12[o6], s7.level + (s7.scale - e11) / (s7.scale - t10.scale);
      return l12[l12.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l12) {
    let s7;
    if (0 === l12[0].level)
      s7 = l12.map((e11) => ({ level: e11.level, resolution: e11.resolution, scale: e11.scale }));
    else {
      const l13 = this.tileInfo.size[0], t10 = this.tileInfo.spatialReference;
      s7 = j3.create({ size: l13, spatialReference: t10 }).lods.map((e11) => ({ level: e11.level, resolution: e11.resolution, scale: e11.scale }));
    }
    for (let e11 = 0; e11 < s7.length; e11++)
      this._levelByScale[s7[e11].scale] = s7[e11].level;
    this._fullCacheLodInfos = s7;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var D2 = class extends f4(d2) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._collisionOverlay = null, this.fading = false, this._getCollidersMesh = (e11) => {
      const { pixelRatio: t10 } = e11.state;
      let i9 = 0;
      const s7 = [], r9 = [];
      for (const a7 of this._vectorTileContainer.children)
        if (a7.symbols)
          for (const [e12, l12] of a7.symbols)
            for (const a8 of l12)
              for (const e13 of a8.colliders) {
                const l13 = (e13.xScreen + e13.dxScreen) * t10, n7 = (e13.yScreen + e13.dyScreen) * t10, o6 = e13.width * t10, h7 = e13.height * t10, u3 = a8.unique.parts[e13.partIndex].targetOpacity > 0.5;
                if (!u3 && "all" !== this.layer.showCollisionBoxes)
                  continue;
                const c5 = 3, y4 = 1, p4 = 3, d4 = 0, _2 = u3 ? 2 : 0, f6 = u3 ? 3 : 0, g2 = l11.makeFlags(_2, f6);
                s7.push(l13, n7, g2, l13 + o6, n7, g2, l13, n7 + h7, g2, l13 + o6, n7 + h7, g2), r9.push(i9, i9 + 1, i9 + 2, i9 + 1, i9 + 3, i9 + 2), i9 += 4;
                const m5 = u3 ? c5 : y4, C3 = u3 ? p4 : d4, T3 = l11.makeFlags(m5, C3);
                s7.push(l13, n7, T3, l13 + o6, n7, T3, l13, n7 + 1, T3, l13 + o6, n7 + 1, T3), r9.push(i9, i9 + 1, i9 + 2, i9 + 1, i9 + 3, i9 + 2), i9 += 4, s7.push(l13, n7 + h7 - 1, T3, l13 + o6, n7 + h7 - 1, T3, l13, n7 + h7, T3, l13 + o6, n7 + h7, T3), r9.push(i9, i9 + 1, i9 + 2, i9 + 1, i9 + 3, i9 + 2), i9 += 4, s7.push(l13, n7, T3, l13 + 1, n7, T3, l13, n7 + h7, T3, l13 + 1, n7 + h7, T3), r9.push(i9, i9 + 1, i9 + 2, i9 + 1, i9 + 3, i9 + 2), i9 += 4, s7.push(l13 + o6 - 1, n7, T3, l13 + o6, n7, T3, l13 + o6 - 1, n7 + h7, T3, l13 + o6, n7 + h7, T3), r9.push(i9, i9 + 1, i9 + 2, i9 + 1, i9 + 3, i9 + 2), i9 += 4;
              }
      return { vertexData: new Int16Array(s7), indexData: new Uint32Array(r9) };
    }, this._getCollidersColors = () => [1, 0.5, 0, 1, 1, 0, 0, 1, 0, 1, 0.5, 1, 0, 0.5, 0, 1], this._getCollidersOpacities = () => [0.05, 0.01, 0.15, 0.2];
  }
  async hitTest(e11, i9) {
    if (!this._tileHandlerPromise)
      return null;
    await this._tileHandlerPromise;
    const s7 = await this._vectorTileContainer.hitTest(i9);
    if (!s7 || 0 === s7.length)
      return null;
    const r9 = s7[0] - 1, a7 = this._styleRepository, l12 = a7.getStyleLayerByUID(r9);
    if (!l12)
      return null;
    const n7 = a7.getStyleLayerIndex(l12.id);
    return [{ type: "graphic", mapPoint: e11, layer: this.layer, graphic: new h4({ attributes: { layerId: n7, layerName: l12.id, layerUID: r9 }, layer: this.layer, sourceLayer: this.layer }) }];
  }
  update(e11) {
    if (this._tileHandlerPromise && this._isTileHandlerReady)
      return e11.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e11.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e11.state, this._parseQueue.state = e11.state, this._tileManager.update(e11) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e11 } = this.layer.currentStyleInfo;
    this._styleRepository = new l5(e11), this._tileInfoView = new t9(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m4(this._tileInfoView), this._tileHandler = new h5(this.layer, this._styleRepository, window.devicePixelRatio || 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this._vectorTileContainer.on("fade-start", () => {
      this.fading = true, this.notifyChange("updating"), this.requestUpdate();
    }), this._vectorTileContainer.on("fade-complete", () => {
      var _a;
      (_a = this._collisionOverlay) == null ? void 0 : _a.requestRender(), this.fading = false, this.notifyChange("updating"), this.requestUpdate();
    }), l2(() => this.layer.showCollisionBoxes, (e12) => {
      "none" !== e12 ? this._collisionOverlay || (this._collisionOverlay = new l11({ getMesh: this._getCollidersMesh, getColors: this._getCollidersColors, getOpacities: this._getCollidersOpacities }), this.container.addChild(this._collisionOverlay)) : this._collisionOverlay && (this.container.removeChild(this._collisionOverlay), this._collisionOverlay = null), this.container.requestRender();
    }, h), this.layer.on("paint-change", (e12) => {
      if (e12.isDataDriven)
        this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e12 }), this.notifyChange("updating"), this.requestUpdate();
      else {
        const t10 = this._styleRepository, i9 = t10.getLayerById(e12.layer);
        if (!i9)
          return;
        const s7 = i9.type === a4.SYMBOL;
        t10.setPaintProperties(e12.layer, e12.paint), s7 && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender();
      }
    }), this.layer.on("layout-change", (e12) => {
      const t10 = this._styleRepository, i9 = t10.getLayerById(e12.layer);
      if (!i9)
        return;
      const s7 = a3(i9.layout, e12.layout);
      if (null != s7) {
        if (s2(s7, "visibility") && 1 === Q(s7))
          return t10.setLayoutProperties(e12.layer, e12.layout), i9.type === a4.SYMBOL && this._vectorTileContainer.restartDeclutter(), void this._vectorTileContainer.requestRender();
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e12 }), this.notifyChange("updating"), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e12) => {
      const t10 = this._styleRepository, i9 = t10.getLayerById(e12.layer);
      i9 && (t10.setStyleLayerVisibility(e12.layer, e12.visibility), i9.type === a4.SYMBOL && this._vectorTileContainer.restartDeclutter(), this._vectorTileContainer.requestRender());
    }), this.layer.on("style-layer-change", (e12) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e12 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e12) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e12 }), this.notifyChange("updating"), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e12) => {
      this._newSpriteSource = e12.spriteSource, this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: null });
      const t10 = this._styleRepository.layers;
      for (const i9 of t10)
        switch (i9.type) {
          case a4.SYMBOL:
            i9.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i9.id, layout: i9.layout } });
            break;
          case a4.LINE:
            i9.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i9.id, paint: i9.paint, isDataDriven: i9.isPainterDataDriven() } });
            break;
          case a4.FILL:
            i9.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i9.id, paint: i9.paint, isDataDriven: i9.isPainterDataDriven() } });
        }
      this.notifyChange("updating"), this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = l(this._vectorTileContainer), this._tileHandler = l(this._tileHandler);
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this._collisionOverlay && this._vectorTileContainer.restartDeclutter(), this.requestUpdate();
  }
  supportsSpatialReference(e11) {
    var _a;
    return S((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e11);
  }
  canResume() {
    let e11 = super.canResume();
    const { currentStyleInfo: t10 } = this.layer;
    if (e11 && (t10 == null ? void 0 : t10.layerDefinition)) {
      const i9 = this.view.scale, { minScale: s7, maxScale: r9 } = t10.layerDefinition;
      t10 && t10.layerDefinition && (s7 && s7 < i9 && (e11 = false), r9 && r9 > i9 && (e11 = false));
    }
    return e11;
  }
  isUpdating() {
    const e11 = this._vectorTileContainer.children;
    return !this._isTileHandlerReady || !this._fetchQueue || !this._parseQueue || this._fetchQueue.updating || this._parseQueue.updating || e11.length > 0 && e11.some((e12) => e12.invalidating) || this.fading;
  }
  acquireTile(e11) {
    var _a;
    const t10 = this._createVectorTile(e11);
    return (_a = this._tileHandlerPromise) == null ? void 0 : _a.then(() => {
      this._fetchQueue.push(t10.key).then((e12) => this._parseQueue.push({ key: t10.key, data: e12 })).then((e12) => {
        t10.once("attach", () => this.requestUpdate()), t10.setData(e12), this.requestUpdate(), this.notifyChange("updating");
      }).catch((e12) => {
        this.notifyChange("updating"), d(e12) || s.getLogger(this).error(e12);
      });
    }), t10;
  }
  releaseTile(e11) {
    const t10 = e11.key.id;
    this._fetchQueue.abort(t10), this._parseQueue.abort(t10), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new o2({ acquireTile: (e12) => this.acquireTile(e12), releaseTile: (e12) => this.releaseTile(e12), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo)
      return;
    const e11 = new AbortController(), t10 = this._tileHandler.start({ signal: e11.signal }).then(() => {
      this._fetchQueue = new y2({ tileInfoView: this._tileInfoView, process: (e12, t11) => this._getTileData(e12, t11), concurrency: 15 }), this._parseQueue = new y2({ tileInfoView: this._tileInfoView, process: (e12, t11) => this._parseTileData(e12, t11), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e12) => {
      this._vectorTileContainer.setStyleResources(e12, this._tileHandler.glyphMosaic, this._styleRepository), this.requestUpdate();
    }), this._tileHandlerAbortController = e11, this._tileHandlerPromise = t10;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer)
      return;
    const e11 = this._tileHandlerAbortController;
    e11 && e11.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = l(this._fetchQueue), this._parseQueue = l(this._parseQueue), this._tileManager = l(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e11, t10) {
    const i9 = await this._tileHandler.fetchTileData(e11, t10);
    return this.notifyChange("updating"), i9;
  }
  async _parseTileData(e11, t10) {
    return this._tileHandler.parseTileData(e11, t10);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e11 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e11);
    } catch (n7) {
      s.getLogger(this).error("error applying vector-tiles style update", n7.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t10 = this._styleRepository, i9 = [];
    e11.forEach((e12) => {
      if (e12.type !== I2.LAYER_REMOVED)
        return;
      const s7 = e12.data, r10 = t10.getLayerById(s7.layer);
      r10 && i9.push(r10.uid);
    });
    const r9 = [];
    let a7;
    e11.forEach((e12) => {
      const i10 = e12.type, s7 = e12.data;
      switch (i10) {
        case I2.PAINTER_CHANGED:
          t10.setPaintProperties(s7.layer, s7.paint), a7 = s7.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t10.setLayoutProperties(s7.layer, s7.layout), a7 = s7.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t10.deleteStyleLayer(s7.layer);
        case I2.LAYER_CHANGED:
          t10.setStyleLayer(s7.layer, s7.index), a7 = s7.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(this._newSpriteSource)), this._newSpriteSource = null, a7 = null;
      }
      const l13 = t10.getLayerById(a7);
      l13 && r9.push(l13.uid);
    });
    const l12 = this._vectorTileContainer.children;
    if (i9.length > 0) {
      this._vectorTileContainer.deleteStyleLayers(i9);
      for (const e12 of l12)
        e12.deleteLayerData(i9);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), r9.length > 0) {
      const e12 = [];
      for (const t11 of l12) {
        const i10 = this._fetchQueue.push(t11.key).then((e13) => this._parseQueue.push({ key: t11.key, data: e13, styleLayerUIDs: r9 })).then((e13) => t11.setData(e13));
        e12.push(i10);
      }
      await Promise.all(e12);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e11 } = this.layer.currentStyleInfo, t10 = a(e11);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this.notifyChange("updating"), this._styleRepository = new l5(t10), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s7 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, t10), await this._tileHandlerPromise;
    } catch (l12) {
      if (!d(l12))
        throw l12;
    }
    if (s7.aborted)
      return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), void this.requestUpdate();
    const r9 = await this._tileHandler.spriteMosaic;
    this._vectorTileContainer.setStyleResources(r9, this._tileHandler.glyphMosaic, this._styleRepository), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.notifyChange("updating"), this.requestUpdate();
  }
  _createVectorTile(e11) {
    const t10 = this._tileInfoView.getTileBounds(i(), e11), i9 = this._tileInfoView.getTileResolution(e11.level);
    return new d3(e11, i9, t10[0], t10[3], 512, 512, this._styleRepository);
  }
};
function Q(e11) {
  if (null == e11)
    return 0;
  switch (e11.type) {
    case "partial":
      return Object.keys(e11.diff).length;
    case "complete":
      return Math.max(Object.keys(e11.oldValue).length, Object.keys(e11.newValue).length);
    case "collection":
      return Object.keys(e11.added).length + Object.keys(e11.changed).length + Object.keys(e11.removed).length;
  }
}
e([y()], D2.prototype, "_fetchQueue", void 0), e([y()], D2.prototype, "_parseQueue", void 0), e([y()], D2.prototype, "_isTileHandlerReady", void 0), e([y()], D2.prototype, "fading", void 0), D2 = e([a2("esri.views.2d.layers.VectorTileLayerView2D")], D2);
var L = D2;
export {
  L as default
};
//# sourceMappingURL=VectorTileLayerView2D-KYUONTOR.js.map
