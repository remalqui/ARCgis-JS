import {
  s as s2,
  t as t3
} from "./chunk-KXXE4EG4.js";
import {
  t as t2
} from "./chunk-P6EIQMMQ.js";
import {
  A as A2,
  B as B2,
  C,
  D,
  E,
  F,
  H as H2,
  J,
  K,
  L,
  M as M2,
  N,
  O,
  P,
  R,
  S,
  T,
  U,
  V as V2,
  W,
  b,
  d,
  g,
  h,
  j as j2,
  k,
  m as m2,
  p as p3,
  v as v2,
  w,
  x as x2,
  y
} from "./chunk-TQF2QRC7.js";
import {
  e as e2,
  l,
  s,
  u as u2
} from "./chunk-CEAO27ON.js";
import {
  A
} from "./chunk-CIYZZPIM.js";
import {
  a as a2,
  c,
  r
} from "./chunk-SXL2EDR4.js";
import {
  Ae,
  B,
  Ne,
  Pe,
  Q,
  V,
  fe,
  je,
  ke,
  me,
  oe,
  q,
  v,
  ye,
  z
} from "./chunk-RFI4CCAC.js";
import {
  e,
  t
} from "./chunk-FJYIB7HF.js";
import {
  j as j3
} from "./chunk-7KX64CAH.js";
import {
  p as p2
} from "./chunk-T4XWQYGC.js";
import {
  j,
  m2 as m,
  u
} from "./chunk-TCASQSKO.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  H,
  p2 as p,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import {
  a2 as a
} from "./chunk-MH2LNFJK.js";

// node_modules/@arcgis/core/arcade/functions/geomasync.js
function pn(t4) {
  return 0 === a.indexOf("4.") ? j.fromExtent(t4) : new j({ spatialReference: t4.spatialReference, rings: [[[t4.xmin, t4.ymin], [t4.xmin, t4.ymax], [t4.xmax, t4.ymax], [t4.xmax, t4.ymin], [t4.xmin, t4.ymin]]] });
}
function gn(n, t4, e3) {
  if (Q(n, 2, 2, t4, e3), n[0] instanceof p && n[1] instanceof p)
    ;
  else if (n[0] instanceof p && null === n[1])
    ;
  else if (n[1] instanceof p && null === n[0])
    ;
  else if (null !== n[0] || null !== n[1])
    throw new t(t4, e.InvalidParameter, e3);
}
async function vn(n, t4) {
  if ("polygon" !== n.type && "polyline" !== n.type && "extent" !== n.type)
    return 0;
  let e3 = 1;
  if (n.spatialReference.vcsWkid || n.spatialReference.latestVcsWkid) {
    e3 = s(n.spatialReference) / H(n.spatialReference);
  }
  let r2 = 0;
  if ("polyline" === n.type)
    for (const a3 of n.paths)
      for (let n2 = 1; n2 < a3.length; n2++)
        r2 += e2(a3[n2], a3[n2 - 1], e3);
  else if ("polygon" === n.type)
    for (const a3 of n.rings) {
      for (let n2 = 1; n2 < a3.length; n2++)
        r2 += e2(a3[n2], a3[n2 - 1], e3);
      (a3[0][0] !== a3[a3.length - 1][0] || a3[0][1] !== a3[a3.length - 1][1] || void 0 !== a3[0][2] && a3[0][2] !== a3[a3.length - 1][2]) && (r2 += e2(a3[0], a3[a3.length - 1], e3));
    }
  else
    "extent" === n.type && (r2 += 2 * e2([n.xmin, n.ymin, 0], [n.xmax, n.ymin, 0], e3), r2 += 2 * e2([n.xmin, n.ymin, 0], [n.xmin, n.ymax, 0], e3), r2 *= 2, r2 += 4 * Math.abs(v(n.zmax, 0) * e3 - v(n.zmin, 0) * e3));
  const i = new m({ hasZ: false, hasM: false, spatialReference: n.spatialReference, paths: [[0, 0], [0, r2]] });
  return F(i, t4);
}
function Pn(n) {
  "async" === n.mode && (n.functions.disjoint = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null === a3[0] || null === a3[1] || A2(a3[0], a3[1])));
  }, n.functions.intersects = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null !== a3[0] && null !== a3[1] && h(a3[0], a3[1])));
  }, n.functions.touches = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null !== a3[0] && null !== a3[1] && S(a3[0], a3[1])));
  }, n.functions.crosses = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null !== a3[0] && null !== a3[1] && m2(a3[0], a3[1])));
  }, n.functions.within = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null !== a3[0] && null !== a3[1] && x2(a3[0], a3[1])));
  }, n.functions.contains = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null !== a3[0] && null !== a3[1] && p3(a3[0], a3[1])));
  }, n.functions.overlaps = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null !== a3[0] && null !== a3[1] && O(a3[0], a3[1])));
  }, n.functions.equals = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, i) => (Q(i, 2, 2, t4, e3), i[0] === i[1] || (i[0] instanceof p && i[1] instanceof p ? g(i[0], i[1]) : !(!B(i[0]) || !B(i[1])) && i[0].equals(i[1]))));
  }, n.functions.relate = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, o) => {
      if (o = Ne(o), Q(o, 3, 3, t4, e3), o[0] instanceof p && o[1] instanceof p)
        return R(o[0], o[1], oe(o[2]));
      if (o[0] instanceof p && null === o[1])
        return false;
      if (o[1] instanceof p && null === o[0])
        return false;
      if (null === o[0] && null === o[1])
        return false;
      throw new t(t4, e.InvalidParameter, e3);
    });
  }, n.functions.intersection = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, a3) => (gn(a3 = Ne(a3), t4, e3), null === a3[0] || null === a3[1] ? null : D(a3[0], a3[1])));
  }, n.functions.union = function(e3, r2) {
    return n.standardFunctionAsync(e3, r2, (n2, a3, o) => {
      const l2 = [];
      if (0 === (o = Ne(o)).length)
        throw new t(e3, e.WrongNumberOfParameters, r2);
      if (1 === o.length)
        if (z(o[0])) {
          const n3 = Ne(o[0]);
          for (let t4 = 0; t4 < n3.length; t4++)
            if (null !== n3[t4]) {
              if (!(n3[t4] instanceof p))
                throw new t(e3, e.InvalidParameter, r2);
              l2.push(n3[t4]);
            }
        } else {
          if (!q(o[0])) {
            if (o[0] instanceof p)
              return ye(c(o[0]), e3.spatialReference);
            if (null === o[0])
              return null;
            throw new t(e3, e.InvalidParameter, r2);
          }
          {
            const n3 = Ne(o[0].toArray());
            for (let t4 = 0; t4 < n3.length; t4++)
              if (null !== n3[t4]) {
                if (!(n3[t4] instanceof p))
                  throw new t(e3, e.InvalidParameter, r2);
                l2.push(n3[t4]);
              }
          }
        }
      else
        for (let t4 = 0; t4 < o.length; t4++)
          if (null !== o[t4]) {
            if (!(o[t4] instanceof p))
              throw new t(e3, e.InvalidParameter, r2);
            l2.push(o[t4]);
          }
      return 0 === l2.length ? null : b(l2);
    });
  }, n.functions.difference = function(e3, r2) {
    return n.standardFunctionAsync(e3, r2, (n2, a3, o) => (gn(o = Ne(o), e3, r2), null !== o[0] && null === o[1] ? c(o[0]) : null === o[0] ? null : E(o[0], o[1])));
  }, n.functions.symmetricdifference = function(e3, r2) {
    return n.standardFunctionAsync(e3, r2, (n2, a3, o) => (gn(o = Ne(o), e3, r2), null === o[0] && null === o[1] ? null : null === o[0] ? c(o[1]) : null === o[1] ? c(o[0]) : k(o[0], o[1])));
  }, n.functions.clip = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, o) => {
      if (o = Ne(o), Q(o, 2, 2, t4, e3), !(o[1] instanceof M) && null !== o[1])
        throw new t(t4, e.InvalidParameter, e3);
      if (null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return null === o[1] ? null : y(o[0], o[1]);
    });
  }, n.functions.cut = function(e3, r2) {
    return n.standardFunctionAsync(e3, r2, (n2, o, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 2, e3, r2), !(l2[1] instanceof m) && null !== l2[1])
        throw new t(e3, e.InvalidParameter, r2);
      if (null === l2[0])
        return [];
      if (!(l2[0] instanceof p))
        throw new t(e3, e.InvalidParameter, r2);
      return null === l2[1] ? [c(l2[0])] : w(l2[0], l2[1]);
    });
  }, n.functions.area = function(t4, r2) {
    return n.standardFunctionAsync(t4, r2, async (n2, o, l2) => {
      if (Q(l2, 1, 2, t4, r2), null === (l2 = Ne(l2))[0])
        return 0;
      if (V(l2[0])) {
        const n3 = await l2[0].sumArea(r(v(l2[1], -1)), false, t4.abortSignal);
        if (t4.abortSignal.aborted)
          throw new t(t4, e.Cancelled, r2);
        return n3;
      }
      if (z(l2[0]) || q(l2[0])) {
        const n3 = ke(l2[0], t4.spatialReference);
        return null === n3 ? 0 : W(n3, r(v(l2[1], -1)));
      }
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, r2);
      return W(l2[0], r(v(l2[1], -1)));
    });
  }, n.functions.areageodetic = function(t4, r2) {
    return n.standardFunctionAsync(t4, r2, async (n2, o, l2) => {
      if (Q(l2, 1, 2, t4, r2), null === (l2 = Ne(l2))[0])
        return 0;
      if (V(l2[0])) {
        const n3 = await l2[0].sumArea(r(v(l2[1], -1)), true, t4.abortSignal);
        if (t4.abortSignal.aborted)
          throw new t(t4, e.Cancelled, r2);
        return n3;
      }
      if (z(l2[0]) || q(l2[0])) {
        const n3 = ke(l2[0], t4.spatialReference);
        return null === n3 ? 0 : K(n3, r(v(l2[1], -1)));
      }
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, r2);
      return K(l2[0], r(v(l2[1], -1)));
    });
  }, n.functions.length = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, async (n2, o, l2) => {
      if (Q(l2, 1, 2, t4, e3), null === (l2 = Ne(l2))[0])
        return 0;
      if (V(l2[0])) {
        const n3 = await l2[0].sumLength(a2(v(l2[1], -1)), false, t4.abortSignal);
        if (t4.abortSignal.aborted)
          throw new t(t4, e.Cancelled, e3);
        return n3;
      }
      if (z(l2[0]) || q(l2[0])) {
        const n3 = je(l2[0], t4.spatialReference);
        return null === n3 ? 0 : F(n3, a2(v(l2[1], -1)));
      }
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return F(l2[0], a2(v(l2[1], -1)));
    });
  }, n.functions.length3d = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, l2) => {
      if (Q(l2, 1, 2, t4, e3), null === (l2 = Ne(l2))[0])
        return 0;
      if (z(l2[0]) || q(l2[0])) {
        const n3 = je(l2[0], t4.spatialReference);
        return null === n3 ? 0 : true === n3.hasZ ? vn(n3, a2(v(l2[1], -1))) : F(n3, a2(v(l2[1], -1)));
      }
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return true === l2[0].hasZ ? vn(l2[0], a2(v(l2[1], -1))) : F(l2[0], a2(v(l2[1], -1)));
    });
  }, n.functions.lengthgeodetic = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, async (n2, o, l2) => {
      if (Q(l2, 1, 2, t4, e3), null === (l2 = Ne(l2))[0])
        return 0;
      if (V(l2[0])) {
        const n3 = await l2[0].sumLength(a2(v(l2[1], -1)), true, t4.abortSignal);
        if (t4.abortSignal.aborted)
          throw new t(t4, e.Cancelled, e3);
        return n3;
      }
      if (z(l2[0]) || q(l2[0])) {
        const n3 = je(l2[0], t4.spatialReference);
        return null === n3 ? 0 : M2(n3, a2(v(l2[1], -1)));
      }
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return M2(l2[0], a2(v(l2[1], -1)));
    });
  }, n.functions.distance = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, l2) => {
      l2 = Ne(l2), Q(l2, 2, 3, t4, e3);
      let c2 = l2[0];
      (z(l2[0]) || q(l2[0])) && (c2 = Ae(l2[0], t4.spatialReference));
      let f = l2[1];
      if ((z(l2[1]) || q(l2[1])) && (f = Ae(l2[1], t4.spatialReference)), !(c2 instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      if (!(f instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return d(c2, f, a2(v(l2[2], -1)));
    });
  }, n.functions.distancegeodetic = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, l2) => {
      l2 = Ne(l2), Q(l2, 2, 3, t4, e3);
      const s3 = l2[0], u3 = l2[1];
      if (!(s3 instanceof x))
        throw new t(t4, e.InvalidParameter, e3);
      if (!(u3 instanceof x))
        throw new t(t4, e.InvalidParameter, e3);
      const c2 = new m({ paths: [], spatialReference: s3.spatialReference });
      return c2.addPath([s3, u3]), M2(c2, a2(v(l2[2], -1)));
    });
  }, n.functions.densify = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 3, t4, e3), null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      const s3 = fe(l2[1]);
      if (isNaN(s3))
        throw new t(t4, e.InvalidParameter, e3);
      if (s3 <= 0)
        throw new t(t4, e.InvalidParameter, e3);
      return l2[0] instanceof j || l2[0] instanceof m ? C(l2[0], s3, a2(v(l2[2], -1))) : l2[0] instanceof M ? C(pn(l2[0]), s3, a2(v(l2[2], -1))) : l2[0];
    });
  }, n.functions.densifygeodetic = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 3, t4, e3), null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      const s3 = fe(l2[1]);
      if (isNaN(s3))
        throw new t(t4, e.InvalidParameter, e3);
      if (s3 <= 0)
        throw new t(t4, e.InvalidParameter, e3);
      return l2[0] instanceof j || l2[0] instanceof m ? U(l2[0], s3, a2(v(l2[2], -1))) : l2[0] instanceof M ? U(pn(l2[0]), s3, a2(v(l2[2], -1))) : l2[0];
    });
  }, n.functions.generalize = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 4, t4, e3), null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      const s3 = fe(l2[1]);
      if (isNaN(s3))
        throw new t(t4, e.InvalidParameter, e3);
      return B2(l2[0], s3, me(v(l2[2], true)), a2(v(l2[3], -1)));
    });
  }, n.functions.buffer = function(e3, o) {
    return n.standardFunctionAsync(e3, o, (n2, l2, s3) => {
      if (s3 = Ne(s3), Q(s3, 2, 3, e3, o), null === s3[0])
        return null;
      if (!(s3[0] instanceof p))
        throw new t(e3, e.InvalidParameter, o);
      const u3 = fe(s3[1]);
      if (isNaN(u3))
        throw new t(e3, e.InvalidParameter, o);
      return 0 === u3 ? c(s3[0]) : L(s3[0], u3, a2(v(s3[2], -1)));
    });
  }, n.functions.buffergeodetic = function(e3, o) {
    return n.standardFunctionAsync(e3, o, (n2, l2, s3) => {
      if (s3 = Ne(s3), Q(s3, 2, 3, e3, o), null === s3[0])
        return null;
      if (!(s3[0] instanceof p))
        throw new t(e3, e.InvalidParameter, o);
      const u3 = fe(s3[1]);
      if (isNaN(u3))
        throw new t(e3, e.InvalidParameter, o);
      return 0 === u3 ? c(s3[0]) : P(s3[0], u3, a2(v(s3[2], -1)));
    });
  }, n.functions.offset = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, o, s3) => {
      if (s3 = Ne(s3), Q(s3, 2, 6, t4, e3), null === s3[0])
        return null;
      if (!(s3[0] instanceof j || s3[0] instanceof m))
        throw new t(t4, e.InvalidParameter, e3);
      const u3 = fe(s3[1]);
      if (isNaN(u3))
        throw new t(t4, e.InvalidParameter, e3);
      const c2 = fe(v(s3[4], 10));
      if (isNaN(c2))
        throw new t(t4, e.InvalidParameter, e3);
      const f = fe(v(s3[5], 0));
      if (isNaN(f))
        throw new t(t4, e.InvalidParameter, e3);
      return v2(s3[0], u3, a2(v(s3[2], -1)), oe(v(s3[3], "round")).toLowerCase(), c2, f);
    });
  }, n.functions.rotate = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, o) => {
      o = Ne(o), Q(o, 2, 3, t4, e3);
      let l2 = o[0];
      if (null === l2)
        return null;
      if (!(l2 instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      l2 instanceof M && (l2 = j.fromExtent(l2));
      const s3 = fe(o[1]);
      if (isNaN(s3))
        throw new t(t4, e.InvalidParameter, e3);
      const u3 = v(o[2], null);
      if (null === u3)
        return H2(l2, s3);
      if (u3 instanceof x)
        return H2(l2, s3, u3);
      throw new t(t4, e.InvalidParameter, e3);
    });
  }, n.functions.centroid = function(e3, r2) {
    return n.standardFunctionAsync(e3, r2, (n2, o, l2) => {
      if (l2 = Ne(l2), Q(l2, 1, 1, e3, r2), null === l2[0])
        return null;
      let f = l2[0];
      if ((z(l2[0]) || q(l2[0])) && (f = Ae(l2[0], e3.spatialReference)), null === f)
        return null;
      if (!(f instanceof p))
        throw new t(e3, e.InvalidParameter, r2);
      return f instanceof x ? ye(c(l2[0]), e3.spatialReference) : f instanceof j ? f.centroid : f instanceof m ? l(f) : f instanceof u ? u2(f) : f instanceof M ? f.center : null;
    });
  }, n.functions.multiparttosinglepart = function(e3, r2) {
    return n.standardFunctionAsync(e3, r2, async (n2, o, l2) => {
      l2 = Ne(l2), Q(l2, 1, 1, e3, r2);
      const s3 = [];
      if (null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(e3, e.InvalidParameter, r2);
      if (l2[0] instanceof x)
        return [ye(c(l2[0]), e3.spatialReference)];
      if (l2[0] instanceof M)
        return [ye(c(l2[0]), e3.spatialReference)];
      const u3 = await N(l2[0]);
      if (u3 instanceof j) {
        const n3 = [], t4 = [];
        for (let e4 = 0; e4 < u3.rings.length; e4++)
          if (u3.isClockwise(u3.rings[e4])) {
            const t5 = p2({ rings: [u3.rings[e4]], hasZ: true === u3.hasZ, hazM: true === u3.hasM, spatialReference: u3.spatialReference.toJSON() });
            n3.push(t5);
          } else
            t4.push({ ring: u3.rings[e4], pt: u3.getPoint(e4, 0) });
        for (let e4 = 0; e4 < t4.length; e4++)
          for (let r3 = 0; r3 < n3.length; r3++)
            if (n3[r3].contains(t4[e4].pt)) {
              n3[r3].addRing(t4[e4].ring);
              break;
            }
        return n3;
      }
      if (u3 instanceof m) {
        const n3 = [];
        for (let t4 = 0; t4 < u3.paths.length; t4++) {
          const e4 = p2({ paths: [u3.paths[t4]], hasZ: true === u3.hasZ, hazM: true === u3.hasM, spatialReference: u3.spatialReference.toJSON() });
          n3.push(e4);
        }
        return n3;
      }
      if (l2[0] instanceof u) {
        const n3 = ye(c(l2[0]), e3.spatialReference);
        for (let t4 = 0; t4 < n3.points.length; t4++)
          s3.push(n3.getPoint(t4));
        return s3;
      }
      return null;
    });
  }, n.functions.issimple = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, o) => {
      if (o = Ne(o), Q(o, 1, 1, t4, e3), null === o[0])
        return true;
      if (!(o[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return J(o[0]);
    });
  }, n.functions.simplify = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, o) => {
      if (o = Ne(o), Q(o, 1, 1, t4, e3), null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return N(o[0]);
    });
  }, n.functions.convexhull = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, (n2, r2, o) => {
      if (o = Ne(o), Q(o, 1, 1, t4, e3), null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(t4, e.InvalidParameter, e3);
      return j2(o[0]);
    });
  }, n.functions.getuser = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, async (n2, r2, i) => {
      Q(i, 0, 2, t4, e3);
      let o = v(i[1], ""), s3 = true === o;
      if (o = true === o || false === o ? "" : oe(o), 0 === i.length || i[0] instanceof t2) {
        let n3 = null;
        n3 = t4.services && t4.services.portal ? t4.services.portal : j3.getDefault(), i.length > 0 && (n3 = t3(i[0], n3));
        const e4 = await s2(n3, o, s3);
        if (e4) {
          const n4 = JSON.parse(JSON.stringify(e4));
          for (const t5 of ["lastLogin", "created", "modified"])
            void 0 !== n4[t5] && null !== n4[t5] && (n4[t5] = new Date(n4[t5]));
          return A.convertObjectToArcadeDictionary(n4, Pe(t4));
        }
        return null;
      }
      let u3 = null;
      if (V(i[0]) && (u3 = i[0]), u3) {
        if (s3 = false, o)
          return null;
        await u3.load();
        const n3 = await u3.getOwningSystemUrl();
        if (!n3) {
          if (!o) {
            const n4 = await u3.getIdentityUser();
            return n4 ? A.convertObjectToArcadeDictionary({ username: n4 }, Pe(t4)) : null;
          }
          return null;
        }
        let e4 = null;
        e4 = t4.services && t4.services.portal ? t4.services.portal : j3.getDefault(), e4 = t3(new t2(n3), e4);
        const r3 = await s2(e4, o, s3);
        if (r3) {
          const n4 = JSON.parse(JSON.stringify(r3));
          for (const t5 of ["lastLogin", "created", "modified"])
            void 0 !== n4[t5] && null !== n4[t5] && (n4[t5] = new Date(n4[t5]));
          return A.convertObjectToArcadeDictionary(n4, Pe(t4));
        }
        return null;
      }
      throw new t(t4, e.InvalidParameter, e3);
    });
  }), n.functions.nearestcoordinate = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, async (n2, r2, o) => {
      if (o = Ne(o), Q(o, 2, 2, t4, e3), !(o[0] instanceof p || null === o[0]))
        throw new t(t4, e.InvalidParameter, e3);
      if (!(o[1] instanceof x || null === o[1]))
        throw new t(t4, e.InvalidParameter, e3);
      if (null === o[0] || null === o[1])
        return null;
      const l2 = await T(o[0], o[1]);
      return null === l2 ? null : A.convertObjectToArcadeDictionary({ coordinate: l2.coordinate, distance: l2.distance }, Pe(t4), false, true);
    });
  }, n.functions.nearestvertex = function(t4, e3) {
    return n.standardFunctionAsync(t4, e3, async (n2, r2, o) => {
      if (o = Ne(o), Q(o, 2, 2, t4, e3), !(o[0] instanceof p || null === o[0]))
        throw new t(t4, e.InvalidParameter, e3);
      if (!(o[1] instanceof x || null === o[1]))
        throw new t(t4, e.InvalidParameter, e3);
      if (null === o[0] || null === o[1])
        return null;
      const l2 = await V2(o[0], o[1]);
      return null === l2 ? null : A.convertObjectToArcadeDictionary({ coordinate: l2.coordinate, distance: l2.distance }, Pe(t4), false, true);
    });
  };
}

export {
  Pn
};
//# sourceMappingURL=chunk-MPUQPE5T.js.map
