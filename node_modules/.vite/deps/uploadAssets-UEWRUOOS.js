import {
  N,
  a,
  g as g2,
  i,
  m
} from "./chunk-5U4S3W7H.js";
import {
  w
} from "./chunk-G5WJIWPP.js";
import "./chunk-OO4A3EBQ.js";
import {
  e,
  o,
  u
} from "./chunk-XR4HIGQP.js";
import {
  r
} from "./chunk-5EXFDBQJ.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  Jt,
  V
} from "./chunk-O3CHVGVF.js";
import {
  f,
  g,
  s as s3
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/uploads.js
var r2 = 1e6;
var a2 = 20 * r2;
var n = 2e9;
var i2 = 3;
async function p({ data: p2, name: c, description: l }, m2, d) {
  let f2 = null;
  try {
    const u2 = V(m2, "uploads"), h = V(u2, "info"), { data: w2 } = await j(h, { query: { f: "json" }, responseType: "json" });
    s3(d);
    const y = w(m2), j3 = w2.maxUploadFileSize * r2, g4 = y ? n : j3, q2 = y ? Math.min(a2, j3) : a2;
    if (p2.size > g4)
      throw new Error("Data too large");
    const T2 = V(u2, "register"), { data: z } = await j(T2, { query: { f: "json", itemName: c, description: l }, responseType: "json", method: "post" });
    if (s3(d), !z.success)
      throw new Error("Registration failed");
    const { itemID: E2 } = z.item;
    f2 = V(u2, E2);
    const U2 = V(f2, "uploadPart"), D2 = Math.ceil(p2.size / q2), M = new Array();
    for (let e2 = 0; e2 < D2; ++e2)
      M.push(p2.slice(e2 * q2, Math.min((e2 + 1) * q2, p2.size)));
    const P2 = M.slice().reverse(), x2 = new Array(), A2 = async () => {
      for (; 0 !== P2.length; ) {
        const o2 = M.length - P2.length, s4 = P2.pop(), r3 = new FormData();
        r3.append("f", "json"), r3.append("file", s4), r3.append("partId", `${o2}`);
        const { data: a3 } = await j(U2, { timeout: 0, body: r3, responseType: "json", method: "post" });
        if (s3(d), !a3.success)
          throw new Error("Part upload failed");
      }
    };
    for (let e2 = 0; e2 < i2 && 0 !== P2.length; ++e2)
      x2.push(A2());
    await Promise.all(x2);
    const F2 = V(f2, "commit"), { data: I2 } = await j(F2, { query: { f: "json", parts: M.map((e2, t) => t).join(",") }, responseType: "json", method: "post" });
    if (s3(d), !I2.success)
      throw new Error("Commit failed");
    return I2.item;
  } catch (u2) {
    if (null != f2) {
      const t = V(f2, "delete");
      await j(t, { query: { f: "json" }, responseType: "json", method: "post" });
    }
    throw u2;
  }
}

// node_modules/@arcgis/core/layers/graphics/sources/support/uploadAssets.js
async function g3(e2, t, s4) {
  return e2.length ? Promise.all(e2.map((e3) => T(e3, t, s4))) : [];
}
async function T(e2, { layer: s4, ongoingUploads: r3 }, a3) {
  const o2 = r3.get(e2);
  if (o2)
    return o2;
  if (!P(s4))
    throw new s2(`${s4.type}-layer:upload-failure`, "Layer does not support asset uploads.", new Error());
  if (b(e2, s4))
    return e2;
  const n2 = E(e2, s4, a3);
  r3.set(e2, n2);
  try {
    await n2;
  } finally {
    r3.delete(e2);
  }
  return e2;
}
function b(e2, t) {
  const { parsedUrl: s4 } = t;
  return null != s4 && e2.metadata.externalSources.some((e3) => m(e3, s4));
}
async function E(e2, t, s4) {
  const { metadata: a3 } = e2, { displaySource: o2 } = a3, n2 = x(o2 == null ? void 0 : o2.source, t), i3 = !!n2, u2 = a3.externalSources.length > 0, l = i3 ? $(n2, t, s4) : u2 ? F(e2, t, s4) : j2(e2, t, s4), c = await l;
  return s3(s4), e2.addExternalSources([c]), e2;
}
async function $(e2, t, s4) {
  return { source: await N2(e2, t, s4), original: true };
}
async function F(e2, s4, r3) {
  const a3 = B(s4), { externalSources: o2 } = e2.metadata, n2 = U(o2, s4);
  if (!n2)
    throw new s2(`${s4.type}-layer:upload-failure`, "Could not find an external source that is supported by the service.", new Error());
  const i3 = await N2(n2, s4, r3);
  e2.addExternalSources([{ source: i3, original: true }]);
  return { source: await q(i3, s4, a3) };
}
async function j2(e2, t, s4) {
  const r3 = D(e2, t, s4);
  return { source: await A([r3], t, s4), extent: e2.extent.clone(), original: true };
}
async function D(e2, t, s4) {
  const a3 = B(t), o2 = await e2.load(s4), n2 = await o2.toBinaryGLTF({ ignoreLocalTransform: true });
  s3(s4);
  const i3 = await n2.buffer();
  return s3(s4), { blob: new Blob([i3.data], { type: i3.type }), assetName: `${r()}.glb`, assetType: a3 };
}
function U(e2, t) {
  for (const s4 of e2) {
    const e3 = x(s4.source, t);
    if (e3)
      return e3;
  }
  return null;
}
function x(e2, t) {
  if (!e2)
    return null;
  const { infoFor3D: { supportedFormats: s4, editFormats: r3 } } = t, a3 = N(e2), o2 = new Array();
  let n2 = false;
  for (let i3 = 0; i3 < a3.length; ++i3) {
    const e3 = v(a3[i3], s4);
    if (!e3)
      return null;
    r3.includes(e3.assetType) && (n2 = true), o2.push(e3);
  }
  return n2 ? o2 : null;
}
function v(e2, t) {
  const s4 = g2(e2, t);
  return s4 ? { asset: e2, assetType: s4 } : null;
}
async function N2(e2, t, s4) {
  return A(e2.map((e3) => S(e3, s4)), t, s4);
}
async function A(e2, t, s4) {
  const a3 = await Promise.all(e2.map(async (e3) => {
    const a4 = I(await e3, t, s4);
    return s3(s4), a4;
  }));
  s3(s4);
  const { uploadResults: o2 } = await R(a3.map(({ item: e3 }) => e3), t, s4);
  return s3(s4), e2.map((e3, s5) => L(a3[s5], o2[s5], t));
}
async function S(e2, t) {
  const { asset: s4, assetType: a3 } = e2;
  if (s4 instanceof File)
    return { blob: s4, assetName: s4.name, assetType: a3 };
  const o2 = await s4.toBlob(t);
  return s3(t), { blob: o2, assetName: s4.assetName, assetType: a3 };
}
async function I(e2, o2, i3) {
  const { blob: u2, assetType: l, assetName: c } = e2;
  let p2 = null;
  try {
    const e3 = await p({ data: u2, name: c }, o2.url, i3);
    s3(i3), p2 = { assetType: l, assetUploadId: e3.itemID };
  } catch (f2) {
    f(f2), s.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${o2.url} does not support the REST Uploads API.`);
  }
  if (!p2) {
    const e3 = await Jt(u2);
    if (s3(i3), !e3.isBase64)
      throw new s2(`${o2.type}-layer:uploadAssets-failure`, "Expected gltf data in base64 format after conversion.", new Error());
    p2 = { assetType: l, assetData: e3.data };
  }
  if (!p2)
    throw new s2(`${o2.type}-layer:uploadAssets-failure`, "Unable to prepare uploadAsset request options.", new Error());
  return { item: p2, assetName: c };
}
async function R(s4, a3, o2) {
  const n2 = await j(V(a3.parsedUrl.path, "uploadAssets"), { timeout: 0, query: { f: "json", assets: JSON.stringify(s4) }, method: "post", responseType: "json" });
  if (s3(o2), n2.data.uploadResults.length !== s4.length)
    throw new s2(`${a3.type}-layer:uploadAssets-failure`, `Bad response. Uploaded ${s4.length} items and received ${n2.data.uploadResults.length} results.`, new Error());
  return n2.data;
}
function L(e2, s4, r3) {
  const { success: a3 } = s4;
  if (!a3) {
    const { error: a4 } = s4;
    throw new s2(`${r3.type}-layer:upload-failure`, `Failed to upload mesh file ${e2.assetName}. Error code: ${a4.code}. Error message: ${a4.messages}`, new Error());
  }
  const { assetHash: o2 } = s4, { assetName: n2, item: { assetType: i3 } } = e2, { infoFor3D: { supportedFormats: u2 } } = r3, l = e(i3, u2);
  if (!l)
    throw new s2(`${r3.type}-layer:upload-failure`, `The service allowed us to upload an asset of FormatID ${i3}, but it does not list it in its supported formats.`, new Error());
  return new a(n2, l, [new i(`${r3.parsedUrl.path}/assets/${o2}`, o2)]);
}
async function q(s4, r3, a3) {
  var _a;
  const o2 = s4.map(({ assetName: e2, parts: t }) => ({ assetName: e2, assetHash: t[0].partHash })), n2 = (_a = r3.capabilities) == null ? void 0 : _a.operations.supportsAsyncConvert3D, u2 = { query: { f: "json", assets: JSON.stringify(o2), transportType: "esriTransportTypeUrl", targetFormat: a3, async: n2 }, responseType: "json", timeout: 0 }, l = V(r3.parsedUrl.path, "convert3D"), c = (n2 ? await C(l, u2) : await j(l, u2)).data, { infoFor3D: { supportedFormats: d } } = r3;
  return c.assets.map((e2) => {
    const s5 = o(e2.contentType, d);
    if (!s5)
      throw new s2(`${r3.type}-layer:upload-failure`, `The service allowed us to upload an asset of FormatID ${s5}, but it does not list it in its supported formats.`, new Error());
    return new a(e2.assetName, e2.contentType, [new i(e2.assetURL, e2.assetHash)]);
  });
}
async function C(s4, r3) {
  const a3 = (await j(s4, r3)).data.statusUrl;
  for (; ; ) {
    const s5 = (await j(a3, { query: { f: "json" }, responseType: "json" })).data;
    switch (s5.status) {
      case "Completed":
        return j(s5.resultUrl, { query: { f: "json" }, responseType: "json" });
      case "CompletedWithErrors":
        throw new s2("async-convert3D-failed", "asynchronous convert3D call failed.");
      case "Failed ImportChanges":
      case "InProgress":
      case "Pending":
      case "ExportAttachments":
      case "ExportChanges":
      case "ExportingData":
      case "ExportingSnapshot":
      case "ImportAttachments":
      case "ProvisioningReplica":
      case "UnRegisteringReplica":
        break;
      default:
        throw new s2("async-convert3D-failed", "asynchronous convert3D call failed (undefined response status)");
    }
    await g(H);
  }
}
function P(e2) {
  return !!e2.infoFor3D && !!e2.url;
}
function B(e2) {
  const { infoFor3D: s4 } = e2, r3 = o("model/gltf-binary", s4.supportedFormats) ?? u("glb", s4.supportedFormats);
  if (!r3)
    throw new s2(`${e2.type}-layer:upload-failure`, "Layer does not support glb.", new Error());
  return r3;
}
var H = 1e3;
export {
  g3 as uploadAssets
};
//# sourceMappingURL=uploadAssets-UEWRUOOS.js.map
