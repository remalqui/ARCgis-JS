import {
  c as c2
} from "./chunk-QQMWRKOQ.js";
import {
  v,
  x,
  y as y2
} from "./chunk-2CQBXY7G.js";
import {
  m as m3,
  o as o4,
  p,
  t as t2
} from "./chunk-SUQV3FHQ.js";
import {
  e as e5
} from "./chunk-AEPMR2T7.js";
import {
  e as e3
} from "./chunk-EF6YPOUN.js";
import {
  m as m2
} from "./chunk-T5KDTHII.js";
import {
  n as n2,
  r as r3,
  s as s2
} from "./chunk-GXWNOUDM.js";
import {
  e as e4,
  o as o2
} from "./chunk-AYMF6OMA.js";
import {
  T as T2,
  i
} from "./chunk-FJXAEGHD.js";
import {
  B as B2,
  a as a2,
  g,
  o as o3
} from "./chunk-SS33L3LC.js";
import {
  Cn,
  yn,
  zn
} from "./chunk-SO6DBMQG.js";
import {
  B,
  C,
  P as P2,
  c,
  f as f3,
  h
} from "./chunk-KTSEQWMB.js";
import {
  M,
  m
} from "./chunk-MOPR7RFH.js";
import {
  F,
  O,
  O2,
  S,
  _,
  b,
  e as e2,
  f as f2,
  n,
  r,
  r2,
  t,
  z
} from "./chunk-KW3ZNPTA.js";
import {
  P,
  T,
  W,
  f2 as f,
  j,
  o
} from "./chunk-SFV6XLDZ.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/geometry/support/axisAngleDegrees.js
function h2(n3 = z2) {
  return [n3[0], n3[1], n3[2], n3[3]];
}
function U(n3, r5, t3 = h2()) {
  return r2(x2(t3), n3), t3[3] = r5, t3;
}
function g2(r5, s3, c3 = h2()) {
  return v(A, x2(r5), w(r5)), v(B3, x2(s3), w(s3)), y2(A, B3, A), y3(c3, m(x(x2(c3), A)));
}
function l2(n3, r5, t3, u = h2()) {
  return U(_, n3, D), U(O, r5, E), U(b, t3, F2), g2(D, E, D), g2(D, F2, u), u;
}
function x2(n3) {
  return n3;
}
function b2(n3) {
  return n3[3];
}
function w(n3) {
  return M(n3[3]);
}
function y3(n3, r5) {
  return n3[3] = r5, n3;
}
var z2 = [0, 0, 1, 0];
var A = e5();
var B3 = e5();
var C2 = h2();
var D = h2();
var E = h2();
var F2 = h2();

// node_modules/@arcgis/core/geometry/support/MeshTransform.js
var v2;
var b3 = v2 = class extends l {
  constructor(t3) {
    super(t3), this.translation = n(), this.rotationAxis = e2(z2), this.rotationAngle = 0, this.scale = r(1, 1, 1);
  }
  get rotation() {
    return U(this.rotationAxis, this.rotationAngle);
  }
  set rotation(t3) {
    this.rotationAxis = t(x2(t3)), this.rotationAngle = b2(t3);
  }
  get localMatrix() {
    const t3 = e4();
    return v(M2, x2(this.rotation), w(this.rotation)), P2(t3, M2, this.translation, this.scale), t3;
  }
  get localMatrixInverse() {
    return h(e4(), this.localMatrix);
  }
  applyLocal(t3, o6) {
    return O2(o6, t3, this.localMatrix);
  }
  applyLocalInverse(t3, o6) {
    return O2(o6, t3, this.localMatrixInverse);
  }
  equals(t3) {
    return this === t3 || null != t3 && B(this.localMatrix, t3.localMatrix);
  }
  clone() {
    const t3 = { translation: t(this.translation), rotationAxis: t(this.rotationAxis), rotationAngle: this.rotationAngle, scale: t(this.scale) };
    return new v2(t3);
  }
};
e([y({ type: [Number], nonNullable: true, json: { write: true } })], b3.prototype, "translation", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], b3.prototype, "rotationAxis", void 0), e([y({ type: Number, nonNullable: true, json: { write: true } })], b3.prototype, "rotationAngle", void 0), e([y({ type: [Number], nonNullable: true, json: { write: true } })], b3.prototype, "scale", void 0), e([y()], b3.prototype, "rotation", null), e([y()], b3.prototype, "localMatrix", null), e([y()], b3.prototype, "localMatrixInverse", null), b3 = v2 = e([a("esri.geometry.support.MeshTransform")], b3);
var M2 = e5();
var N = b3;

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function r4(e6, r5) {
  return e6.isGeographic || e6.isWebMercator && ((r5 == null ? void 0 : r5.geographic) ?? true);
}
function o5(r5, o6, g4) {
  const i2 = !r5.isGeoreferenced;
  null != (g4 == null ? void 0 : g4.geographic) && g4.geographic !== i2 && s.getLogger(o6).warnOnce(`Specifying the 'geographic' parameter (${g4.geographic}) for a Mesh vertex space of type "${r5.type}" is not supported. This parameter will be ignored.`);
}

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var g3 = s.getLogger("esri.geometry.support.meshUtils.normalProjection");
function _3(r5, e6, t3, o6, n3) {
  return k2(o6) ? (V(U2.TO_PCPF, i.fromTypedArray(r5), T2.fromTypedArray(e6), T2.fromTypedArray(t3), o6, i.fromTypedArray(n3)), n3) : (g3.error("Cannot convert spatial reference to PCPF"), n3);
}
function j2(r5, e6, t3, o6, n3) {
  return k2(o6) ? (V(U2.FROM_PCPF, i.fromTypedArray(r5), T2.fromTypedArray(e6), T2.fromTypedArray(t3), o6, i.fromTypedArray(n3)), n3) : (g3.error("Cannot convert to spatial reference from PCPF"), n3);
}
function h3(r5, e6, t3) {
  return yn(r5, e6, 0, t3, c2(e6), 0, r5.length / 3), t3;
}
function E2(r5, e6, t3) {
  return yn(r5, c2(t3), 0, e6, t3, 0, r5.length / 3), e6;
}
function M3(r5, o6, n3) {
  return g(N2, n3), n2(o6, r5, N2), B2(N2) || s2(o6, o6), o6;
}
function O3(r5, o6, n3) {
  if (g(N2, n3), n2(o6, r5, N2, 4), B2(N2) || s2(o6, o6, 4), r5 !== o6)
    for (let e6 = 3; e6 < r5.length; e6 += 4)
      o6[e6] = r5[e6];
  return o6;
}
function R(r5, e6, t3, o6, n3) {
  if (!k2(o6))
    return g3.error("Cannot convert spatial reference to PCPF"), n3;
  V(U2.TO_PCPF, i.fromTypedArray(r5, 4 * Float32Array.BYTES_PER_ELEMENT), T2.fromTypedArray(e6), T2.fromTypedArray(t3), o6, i.fromTypedArray(n3, 4 * Float32Array.BYTES_PER_ELEMENT));
  for (let f4 = 3; f4 < r5.length; f4 += 4)
    n3[f4] = r5[f4];
  return n3;
}
function v3(r5, e6, t3, o6, n3) {
  if (!k2(o6))
    return g3.error("Cannot convert to spatial reference from PCPF"), n3;
  V(U2.FROM_PCPF, i.fromTypedArray(r5, 16), T2.fromTypedArray(e6), T2.fromTypedArray(t3), o6, i.fromTypedArray(n3, 16));
  for (let f4 = 3; f4 < r5.length; f4 += 4)
    n3[f4] = r5[f4];
  return n3;
}
function V(r5, e6, t3, f4, a3, i2) {
  if (!e6)
    return;
  const m4 = t3.count, y4 = c2(a3);
  if (b4(a3))
    for (let c3 = 0; c3 < m4; c3++)
      f4.getVec(c3, B4), e6.getVec(c3, S2), zn(y4, B4, w2, y4), a2(N2, w2), r5 === U2.FROM_PCPF && o3(N2, N2), S(S2, S2, N2), i2.setVec(c3, S2);
  else
    for (let u = 0; u < m4; u++) {
      f4.getVec(u, B4), e6.getVec(u, S2), zn(y4, B4, w2, y4), a2(N2, w2);
      const a4 = f(t3.get(u, 1));
      let m5 = Math.cos(a4);
      r5 === U2.TO_PCPF && (m5 = 1 / m5), N2[0] *= m5, N2[1] *= m5, N2[2] *= m5, N2[3] *= m5, N2[4] *= m5, N2[5] *= m5, r5 === U2.FROM_PCPF && o3(N2, N2), S(S2, S2, N2), z(S2, S2), i2.setVec(u, S2);
    }
  return i2;
}
function k2(r5) {
  return b4(r5) || L(r5);
}
function b4(r5) {
  return r5.isWGS84 || o(r5) || T(r5) || P(r5);
}
function L(r5) {
  return r5.isWebMercator;
}
var U2;
!function(r5) {
  r5[r5.TO_PCPF = 0] = "TO_PCPF", r5[r5.FROM_PCPF = 1] = "FROM_PCPF";
}(U2 || (U2 = {}));
var B4 = n();
var S2 = n();
var w2 = e4();
var N2 = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/georeference.js
function O4(n3, t3, e6) {
  return r4(t3.spatialReference, e6) ? Z(n3, t3, e6) : L2(n3, t3, e6);
}
function T3(n3, t3, e6, r5) {
  const { position: o6, normal: i2, tangent: a3 } = n3;
  if (!t3.isRelative)
    return { position: o6, normal: i2, tangent: a3 };
  const l3 = (e6 == null ? void 0 : e6.localMatrix) ?? o2;
  return O4({ position: r3(new Float64Array(o6.length), o6, l3), normal: null != i2 ? M3(i2, new Float32Array(i2.length), l3) : null, tangent: null != a3 ? O3(a3, new Float32Array(a3.length), l3) : null }, t3.getOriginPoint(r5), { geographic: !t3.isGeoreferenced });
}
function q(n3, t3, e6) {
  if (e6 == null ? void 0 : e6.useTransform) {
    const { position: r5, normal: o6, tangent: i2 } = n3, { x: a3, y: s3, z: l3 } = t3, c3 = r(a3, s3, l3 ?? 0);
    return { vertexAttributes: { position: r5, normal: o6, tangent: i2 }, vertexSpace: e6.geographic ?? 1 ? new m3({ origin: c3 }) : new m2({ origin: c3 }), transform: new N() };
  }
  return { vertexAttributes: O4(n3, t3, e6), vertexSpace: new p(), transform: null };
}
function D2(n3, t3, e6) {
  return r4(t3.spatialReference, e6) ? K(n3, t3, e6) : J(n3, t3, e6);
}
function E3(n3, t3, e6, r5, o6) {
  if (!t3.isRelative)
    return D2(n3, r5, o6);
  const { spatialReference: i2 } = r5, a3 = T3(n3, t3, e6, i2);
  return r5.equals(t3.getOriginPoint(i2)) ? J(a3, r5, o6) : D2(a3, r5, o6);
}
function I({ positions: n3, transform: t3, vertexSpace: e6, inSpatialReference: i2, outSpatialReference: a3, outPositions: l3, local: f4 }) {
  const p2 = e6.isRelative ? e6.origin : f2, w3 = e6.isRelative ? (t3 == null ? void 0 : t3.localMatrix) ?? o2 : o2;
  if (e6.isGeoreferenced) {
    const t4 = l3 ?? t2(n3.length);
    if (C(w3, o2) ? o4(t4, n3) : r3(t4, n3, w3), !F(p2, f2)) {
      const [n4, e7, r5] = p2;
      for (let o6 = 0; o6 < t4.length; o6 += 3)
        t4[o6] += n4, t4[o6 + 1] += e7, t4[o6 + 2] += r5;
    }
    return yn(t4, i2, 0, t4, a3, 0, t4.length / 3), t4;
  }
  const A2 = c2(i2), x3 = !f4 && Cn(i2, A2) ? A2 : i2;
  zn(i2, p2, $, x3), c($, $, w3);
  const v4 = l3 ?? t2(n3.length);
  return r3(v4, n3, $), yn(v4, x3, 0, v4, a3, 0, v4.length / 3), v4;
}
function L2(n3, t3, e6) {
  const r5 = new Float64Array(n3.position.length), o6 = n3.position, i2 = t3.x, a3 = t3.y, s3 = t3.z ?? 0, l3 = Y(e6 ? e6.unit : null, t3.spatialReference);
  for (let c3 = 0; c3 < o6.length; c3 += 3)
    r5[c3] = o6[c3] * l3 + i2, r5[c3 + 1] = o6[c3 + 1] * l3 + a3, r5[c3 + 2] = o6[c3 + 2] * l3 + s3;
  return { position: r5, normal: n3.normal, tangent: n3.tangent };
}
function Z(n3, t3, e6) {
  const r5 = t3.spatialReference, o6 = N3(t3, e6, $), i2 = new Float64Array(n3.position.length), a3 = B5(n3.position, o6, r5, i2), s3 = g(nn, o6);
  return { position: a3, normal: C3(a3, i2, n3.normal, s3, r5), tangent: H(a3, i2, n3.tangent, s3, r5) };
}
function B5(n3, t3, e6, r5) {
  r3(r5, n3, t3);
  const o6 = new Float64Array(n3.length);
  return E2(r5, o6, e6);
}
function C3(n3, t3, e6, r5, o6) {
  if (null == e6)
    return null;
  const i2 = new Float32Array(e6.length);
  return n2(i2, e6, r5), j2(i2, n3, t3, o6, i2), i2;
}
function H(n3, t3, e6, r5, o6) {
  if (null == e6)
    return null;
  const i2 = new Float32Array(e6.length);
  n2(i2, e6, r5, 4);
  for (let a3 = 3; a3 < i2.length; a3 += 4)
    i2[a3] = e6[a3];
  return v3(i2, n3, t3, o6, i2), i2;
}
function J(n3, t3, e6) {
  const r5 = new Float64Array(n3.position.length), o6 = n3.position, i2 = t3.x, a3 = t3.y, s3 = t3.z ?? 0, l3 = Y(e6 ? e6.unit : null, t3.spatialReference);
  for (let c3 = 0; c3 < o6.length; c3 += 3)
    r5[c3] = (o6[c3] - i2) / l3, r5[c3 + 1] = (o6[c3 + 1] - a3) / l3, r5[c3 + 2] = (o6[c3 + 2] - s3) / l3;
  return { position: r5, normal: n3.normal, tangent: n3.tangent };
}
function K(n3, t3, e6) {
  const r5 = t3.spatialReference;
  N3(t3, e6, $);
  const o6 = h(_4, $), a3 = new Float64Array(n3.position.length), s3 = Q(n3.position, r5, o6, a3), l3 = g(nn, o6);
  return { position: s3, normal: W2(n3.normal, n3.position, a3, r5, l3), tangent: X(n3.tangent, n3.position, a3, r5, l3) };
}
function N3(n3, t3, e6) {
  zn(n3.spatialReference, [n3.x, n3.y, n3.z ?? 0], e6, c2(n3.spatialReference));
  const r5 = Y(t3 ? t3.unit : null, n3.spatialReference);
  return f3(e6, e6, [r5, r5, r5]), e6;
}
function Q(n3, t3, e6, r5) {
  const o6 = h3(n3, t3, r5), i2 = new Float64Array(o6.length);
  return r3(i2, o6, e6), i2;
}
function W2(n3, t3, e6, r5, o6) {
  if (null == n3)
    return null;
  const i2 = _3(n3, t3, e6, r5, new Float32Array(n3.length));
  return n2(i2, i2, o6), i2;
}
function X(n3, t3, e6, r5, o6) {
  if (null == n3)
    return null;
  const i2 = R(n3, t3, e6, r5, new Float32Array(n3.length));
  return n2(i2, i2, o6, 4), i2;
}
function Y(e6, r5) {
  if (null == e6)
    return 1;
  const o6 = W(r5);
  return 1 / j(o6, "meters", e6);
}
var $ = e4();
var _4 = e4();
var nn = e3();

export {
  h2 as h,
  g2 as g,
  l2 as l,
  x2 as x,
  w,
  N,
  r4 as r,
  o5 as o,
  _3 as _,
  j2 as j,
  h3 as h2,
  E2 as E,
  R,
  v3 as v,
  O4 as O,
  T3 as T,
  q,
  D2 as D,
  E3 as E2,
  I
};
//# sourceMappingURL=chunk-FQ5QI2CC.js.map
