import {
  s
} from "./chunk-6S2FCH6S.js";
import {
  I,
  e as e5,
  r as r2
} from "./chunk-TYYAH2P4.js";
import {
  t as t2
} from "./chunk-U3JB4DA4.js";
import {
  Be
} from "./chunk-3SADEOML.js";
import {
  e as e4
} from "./chunk-AEPMR2T7.js";
import {
  e as e2
} from "./chunk-EF6YPOUN.js";
import {
  e as e3
} from "./chunk-AYMF6OMA.js";
import {
  n as n3,
  r
} from "./chunk-AHAGGZUI.js";
import {
  x
} from "./chunk-D5MIJ6WT.js";
import {
  j as j3
} from "./chunk-7KX64CAH.js";
import {
  i
} from "./chunk-5HAVROZG.js";
import {
  n as n2,
  t
} from "./chunk-KW3ZNPTA.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import {
  n
} from "./chunk-MH2LNFJK.js";
import {
  f,
  j
} from "./chunk-HNHXEGH2.js";
import {
  e,
  o
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/layers/support/capabilities.js
var t3 = { analytics: { supportsCacheHint: false }, attachment: { supportsContentType: false, supportsExifInfo: false, supportsKeywords: false, supportsName: false, supportsSize: false, supportsCacheHint: false, supportsResize: false }, data: { isVersioned: false, supportsAttachment: false, supportsM: false, supportsZ: false }, editing: { supportsDeleteByAnonymous: false, supportsDeleteByOthers: false, supportsGeometryUpdate: false, supportsGlobalId: false, supportsReturnServiceEditsInSourceSpatialReference: false, supportsRollbackOnFailure: false, supportsUpdateByAnonymous: false, supportsUpdateByOthers: false, supportsUpdateWithoutM: false, supportsUploadWithItemId: false, supportsAsyncApplyEdits: false }, metadata: { supportsAdvancedFieldProperties: false }, operations: { supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsAdd: false, supportsDelete: false, supportsEditing: false, supportsChangeTracking: false, supportsQuery: false, supportsQueryAnalytics: false, supportsQueryAttachments: false, supportsQueryTopFeatures: false, supportsResizeAttachments: false, supportsSync: false, supportsUpdate: false, supportsExceedsLimitStatistics: false, supportsAsyncConvert3D: false }, queryRelated: { supportsCount: false, supportsOrderBy: false, supportsPagination: false, supportsCacheHint: false }, queryTopFeatures: { supportsCacheHint: false }, query: { maxRecordCount: 0, maxRecordCountFactor: 0, standardMaxRecordCount: 0, supportsCacheHint: false, supportsCentroid: false, supportsCompactGeometry: false, supportsDefaultSpatialReference: false, supportsFullTextSearch: false, supportsDisjointSpatialRelationship: false, supportsDistance: false, supportsDistinct: false, supportsExtent: false, supportsFormatPBF: false, supportsGeometryProperties: false, supportsHavingClause: false, supportsHistoricMoment: false, supportsMaxRecordCountFactor: false, supportsOrderBy: false, supportsPagination: false, supportsPercentileStatistics: false, supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryByOthers: false, supportsQueryGeometry: false, supportsResultType: false, supportsSqlExpression: false, supportsStandardizedQueriesOnly: false, supportsTopFeaturesQuery: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsStatistics: false, tileMaxRecordCount: 0 } };

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SProjectionUtil.js
var s2 = 1;
var c = 5 - s2;

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/interfaces.js
var A2;
!function(A3) {
  A3[A3.INVISIBLE = 0] = "INVISIBLE", A3[A3.TRANSPARENT = 1] = "TRANSPARENT", A3[A3.OPAQUE = 2] = "OPAQUE";
}(A2 || (A2 = {}));

// node_modules/@arcgis/core/views/3d/layers/support/edgeUtils.js
function f2(e11) {
  return { ...h2, ...e11, type: "solid" };
}
var h2 = { color: r(0, 0, 0, 0.2), size: 1, extensionLength: 0, opacity: 1, objectTransparency: A2.OPAQUE, hasSlicePlane: false };
var g = { color: r(0, 0, 0, 0.2), size: 1, extensionLength: 0, opacity: 1, objectTransparency: A2.OPAQUE, hasSlicePlane: false };

// node_modules/@arcgis/core/views/3d/support/orientedBoundingBox.js
var F = e4();
var H = n2();
var J2 = n2();
var K = n3();
var L = e2();
function O(e11 = [0, 0, 0], t5 = [-1, -1, -1], n8 = e4()) {
  return { center: t(e11), halfSize: t2(t5), quaternion: r2(n8) };
}
var te = (() => {
  const e11 = new Int8Array(162);
  let t5 = 0;
  const n8 = (n9) => {
    for (let a2 = 0; a2 < n9.length; a2++)
      e11[t5 + a2] = n9[a2];
    t5 += 6;
  };
  return n8([6, 2, 3, 1, 5, 4]), n8([0, 2, 3, 1, 5, 4]), n8([0, 2, 3, 7, 5, 4]), n8([0, 1, 3, 2, 6, 4]), n8([0, 1, 3, 2, 0, 0]), n8([0, 1, 5, 7, 3, 2]), n8([0, 1, 3, 7, 6, 4]), n8([0, 1, 3, 7, 6, 2]), n8([0, 1, 5, 7, 6, 2]), n8([0, 1, 5, 4, 6, 2]), n8([0, 1, 5, 4, 0, 0]), n8([0, 1, 3, 7, 5, 4]), n8([0, 2, 6, 4, 0, 0]), n8([0, 0, 0, 0, 0, 0]), n8([1, 3, 7, 5, 0, 0]), n8([2, 3, 7, 6, 4, 0]), n8([2, 3, 7, 6, 0, 0]), n8([2, 3, 1, 5, 7, 6]), n8([0, 1, 5, 7, 6, 2]), n8([0, 1, 5, 7, 6, 4]), n8([0, 1, 3, 7, 6, 4]), n8([4, 5, 7, 6, 2, 0]), n8([4, 5, 7, 6, 0, 0]), n8([4, 5, 1, 3, 7, 6]), n8([0, 2, 3, 7, 5, 4]), n8([6, 2, 3, 7, 5, 4]), n8([6, 2, 3, 1, 5, 4]), e11;
})();
var ie = n2();
var fe = n2();
var oe = n2();
var ce = e4();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SUtil.js
var X2 = i();
var ee;
function le(t5, r4, n8, o4, i4) {
  const s5 = [];
  for (const e11 of r4)
    if (e11 && i4.includes(e11.name)) {
      const r5 = `${t5}/nodes/${n8}/attributes/${e11.key}/0`;
      s5.push({ url: r5, storageInfo: e11 });
    }
  return j(s5.map((t6) => j2(t6.url, { responseType: "array-buffer" }).then((e11) => I(t6.storageInfo, e11.data)))).then((e11) => {
    const t6 = [];
    for (const r5 of o4) {
      const n9 = {};
      for (let t7 = 0; t7 < e11.length; t7++) {
        const o5 = e11[t7].value;
        null != o5 && (n9[s5[t7].storageInfo.name] = fe2(o5, r5));
      }
      t6.push(n9);
    }
    return t6;
  });
}
!function(e11) {
  e11[e11.OUTSIDE = 0] = "OUTSIDE", e11[e11.INTERSECTS_CENTER_OUTSIDE = 1] = "INTERSECTS_CENTER_OUTSIDE", e11[e11.INTERSECTS_CENTER_INSIDE = 2] = "INTERSECTS_CENTER_INSIDE", e11[e11.INSIDE = 3] = "INSIDE";
}(ee || (ee = {}));
var ce2 = -32768;
var ue = -(2 ** 31);
function fe2(e11, t5) {
  if (!e11)
    return null;
  const r4 = e11[t5];
  if (o(e11))
    return r4 === ce2 ? null : r4;
  if (e(e11))
    return r4 === ue ? null : r4;
  return r4 != r4 ? null : r4;
}
var je = f2({ color: [0, 0, 0, 0], opacity: 0 });
var ze = new Array(24);
var We = new s(ze, 3, true);
var Ae = n2();
var De = n2();
var Fe = e2();
var Ze = e3();
var He = e5();
var Ve = i();
var Xe = i();
var Ye = O();
var et = n2();
var tt = { data: new Array(72), size: 3, exclusive: true, stride: 3 };
var rt = e3();

// node_modules/@arcgis/core/layers/support/FetchAssociatedFeatureLayer.js
var i3 = class {
  constructor(t5, r4, e11, a2) {
    var _a;
    this._parsedUrl = t5, this._portalItem = r4, this._apiKey = e11, this.signal = a2, this._rootDocument = null;
    const n8 = (_a = this._parsedUrl) == null ? void 0 : _a.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);
    n8 && (this._urlParts = { root: n8[1], layerId: parseInt(n8[2], 10) });
  }
  async fetch() {
    if (!this._urlParts)
      return null;
    const t5 = this._portalItem ?? await this._portalItemFromServiceItemId();
    if (null == t5)
      return this._loadFromUrl();
    const r4 = await this._findAndLoadRelatedPortalItem(t5);
    return null == r4 ? null : this._loadFeatureLayerFromPortalItem(r4);
  }
  async fetchPortalItem() {
    if (!this._urlParts)
      return null;
    const t5 = this._portalItem ?? await this._portalItemFromServiceItemId();
    return null == t5 ? null : this._findAndLoadRelatedPortalItem(t5);
  }
  async _fetchRootDocument() {
    if (null != this._rootDocument)
      return this._rootDocument;
    if (null == this._urlParts)
      return this._rootDocument = {}, {};
    const t5 = { query: { f: "json", token: this._apiKey }, responseType: "json", signal: this.signal }, e11 = `${this._urlParts.root}/SceneServer`;
    try {
      const a2 = await j2(e11, t5);
      this._rootDocument = a2.data;
    } catch {
      this._rootDocument = {};
    }
    return this._rootDocument;
  }
  async _fetchServiceOwningPortalUrl() {
    var _a, _b;
    const a2 = (_a = this._parsedUrl) == null ? void 0 : _a.path, n8 = a2 ? (_b = n) == null ? void 0 : _b.findServerInfo(a2) : null;
    if (n8 == null ? void 0 : n8.owningSystemUrl)
      return n8.owningSystemUrl;
    const s5 = a2 ? a2.replace(/(.*\/rest)\/.*/i, "$1") + "/info" : null;
    try {
      const t5 = (await j2(s5, { query: { f: "json" }, responseType: "json", signal: this.signal })).data.owningSystemUrl;
      if (t5)
        return t5;
    } catch (i4) {
      f(i4);
    }
    return null;
  }
  async _findAndLoadRelatedPortalItem(t5) {
    try {
      return (await t5.fetchRelatedItems({ relationshipType: "Service2Service", direction: "reverse" }, { signal: this.signal })).find((t6) => "Feature Service" === t6.type) || null;
    } catch (r4) {
      return f(r4), null;
    }
  }
  async _loadFeatureLayerFromPortalItem(t5) {
    await t5.load({ signal: this.signal });
    const r4 = await this._findMatchingAssociatedSublayerUrl(t5.url ?? "");
    return new Be({ url: r4, portalItem: t5 }).load({ signal: this.signal });
  }
  async _loadFromUrl() {
    var _a;
    const t5 = await this._findMatchingAssociatedSublayerUrl(`${(_a = this._urlParts) == null ? void 0 : _a.root}/FeatureServer`);
    return new Be({ url: t5 }).load({ signal: this.signal });
  }
  async _findMatchingAssociatedSublayerUrl(t5) {
    var _a;
    const e11 = t5.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i, "$1"), a2 = (_a = this._urlParts) == null ? void 0 : _a.layerId, n8 = this._fetchRootDocument(), s5 = (t6) => {
      const a3 = { query: { f: "json" }, responseType: "json", authMode: t6, signal: this.signal };
      return j2(e11, a3);
    }, i4 = s5("anonymous").catch(() => s5("no-prompt")), [o4, l3] = await Promise.all([i4, n8]), c4 = l3 && l3.layers, u4 = o4.data && o4.data.layers;
    if (!Array.isArray(u4))
      throw new Error("expected layers array");
    if (Array.isArray(c4))
      for (let r4 = 0; r4 < Math.min(c4.length, u4.length); r4++) {
        if (c4[r4].id === a2)
          return `${e11}/${u4[r4].id}`;
      }
    else if (null != a2 && a2 < u4.length)
      return `${e11}/${u4[a2].id}`;
    throw new Error("could not find matching associated sublayer");
  }
  async _portalItemFromServiceItemId() {
    const t5 = (await this._fetchRootDocument()).serviceItemId;
    if (!t5)
      return null;
    const r4 = new x({ id: t5, apiKey: this._apiKey }), a2 = await this._fetchServiceOwningPortalUrl();
    null != a2 && (r4.portal = new j3({ url: a2 }));
    try {
      return r4.load({ signal: this.signal });
    } catch (i4) {
      return f(i4), null;
    }
  }
};

export {
  t3 as t,
  le,
  i3 as i
};
//# sourceMappingURL=chunk-PPF3HWPU.js.map
