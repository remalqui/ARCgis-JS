import {
  t
} from "./chunk-LLQHB2ZB.js";
import {
  G,
  I,
  M as M3,
  P,
  P2,
  Z,
  n,
  t as t2,
  v as v4,
  v2 as v5
} from "./chunk-BKDPNGLX.js";
import {
  M as M2,
  f as f3,
  g as g2
} from "./chunk-D5EV57FM.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import {
  e,
  r as r2,
  s as s5
} from "./chunk-LREUW66K.js";
import {
  b as b2
} from "./chunk-PM3CFO6N.js";
import {
  rt
} from "./chunk-KKGVORR5.js";
import {
  f as f4
} from "./chunk-Z36PKTLY.js";
import {
  D,
  F,
  M,
  S as S2,
  c,
  d,
  f as f2,
  g,
  m as m3,
  p as p2,
  v as v3,
  x,
  z
} from "./chunk-PRUCXFZ4.js";
import {
  m as m2
} from "./chunk-TQGXXOXA.js";
import {
  C as C2
} from "./chunk-ITRH3PGV.js";
import {
  C,
  O,
  i as i2,
  o as o3
} from "./chunk-ZBWBCN2I.js";
import {
  ae,
  i as i3
} from "./chunk-7KM4XBUC.js";
import {
  f,
  m,
  p
} from "./chunk-T4XWQYGC.js";
import {
  a as a3,
  l as l2,
  l2 as l3,
  o2,
  v as v2
} from "./chunk-TCASQSKO.js";
import {
  a as a2,
  i
} from "./chunk-5HAVROZG.js";
import {
  H,
  S2 as S,
  s2 as s4
} from "./chunk-SFV6XLDZ.js";
import {
  s as s3
} from "./chunk-VBD33VNW.js";
import {
  s as s2
} from "./chunk-HNHXEGH2.js";
import {
  l,
  o
} from "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  b,
  v
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/core/sql/WhereClauseCache.js
var c2 = class {
  constructor(e3, c4) {
    this._cache = new e(e3), this._invalidCache = new e(c4);
  }
  get(t5, c4) {
    const i4 = `${c4.uid}:${t5}`, r4 = this._cache.get(i4);
    if (r4)
      return r4;
    if (void 0 !== this._invalidCache.get(i4))
      return null;
    try {
      const r5 = f4.create(t5, c4);
      return this._cache.put(i4, r5), r5;
    } catch {
      return this._invalidCache.put(i4, null), null;
    }
  }
};

// node_modules/@arcgis/core/layers/graphics/data/attributeSupport.js
var n2 = new c2(50, 500);
var r3 = "feature-store:unsupported-query";
var t3 = " as ";
var o4 = new s3({ esriFieldTypeString: "string" });
var a4 = new s3({ esriFieldTypeOID: "oid", esriFieldTypeSmallInteger: "small-integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "single", esriFieldTypeDouble: "double", esriFieldTypeLong: "long" });
var l4 = new s3({ esriFieldTypeDate: "date" });
var d2 = new s3({ esriFieldTypeGUID: "guid", esriFieldTypeGlobalId: "global-id" });
var p3 = /* @__PURE__ */ new Set([...a4.jsonValues, ...l4.jsonValues, ...o4.jsonValues, ...d2.jsonValues]);
var u = new Intl.ListFormat("en-US", { type: "conjunction" }).format([...a4.apiValues, ...l4.apiValues, ...o4.apiValues, ...d2.apiValues]);
function g3(s6, i4, n4 = {}) {
  const t5 = y(s6, i4);
  if (!t5)
    throw new s(r3, "invalid SQL expression", { expression: s6 });
  const o5 = n4.expressionName || "expression";
  if (n4.validateStandardized && !t5.isStandardized)
    throw new s(r3, `${o5} is not standard`, { expression: s6 });
  if (n4.validateAggregate && !t5.isAggregate)
    throw new s(r3, `${o5} does not contain a valid aggregate function`, { expression: s6 });
  return t5.fieldNames;
}
function c3(e3, s6, i4) {
  if (!s6)
    return true;
  const n4 = "where clause", r4 = g3(s6, e3, { validateStandardized: true, expressionName: n4 });
  return m4(e3, r4, { expressionName: n4, query: i4 }), x2(e3, r4, { expressionName: n4, query: i4 }), true;
}
function f5(s6, i4, t5, o5) {
  if (!i4)
    return true;
  const a5 = "having", l5 = g3(i4, s6, { validateAggregate: true, expressionName: a5 });
  m4(s6, l5, { expressionName: a5, query: o5 }), x2(s6, l5, { expressionName: a5, query: o5 });
  const d3 = n2.get(i4, s6), p4 = d3 == null ? void 0 : d3.getExpressions().every((e3) => {
    var _a;
    const { aggregateType: i5, field: n4 } = e3, r4 = (_a = s6.get(n4)) == null ? void 0 : _a.name;
    return t5.some((e4) => {
      var _a2;
      const { onStatisticField: n5, statisticType: t6 } = e4, o6 = (_a2 = s6.get(n5)) == null ? void 0 : _a2.name;
      return o6 === r4 && t6.toLowerCase().trim() === i5;
    });
  });
  if (!p4)
    throw new s(r3, "expressions in having should also exist in outStatistics", { having: i4 });
  return true;
}
function y(e3, s6) {
  return e3 ? n2.get(e3, s6) : null;
}
function m4(e3, s6, i4 = {}) {
  i4.errorMessage || (i4.errorMessage = i4.expressionName ? `${i4.expressionName} contains invalid fields` : "Fields are invalid"), h(e3, s6, (e4, s7) => s7.has(e4), i4);
}
function x2(e3, s6, i4 = {}) {
  i4.errorMessage || (i4.errorMessage = i4.expressionName ? `${i4.expressionName} only supports ${u} field types` : `Only ${u} field types are supported`), h(e3, s6, (e4, s7) => !F2(e4, s7), i4);
}
function h(s6, i4, n4, t5 = {}) {
  const o5 = t5.verifyExpression ?? true, a5 = [];
  for (const e3 of i4) {
    const i5 = n4(e3, s6);
    if ("*" !== e3 && !i5)
      if (o5) {
        const i6 = w(e3);
        try {
          h(s6, g3(i6, s6, { validateStandardized: true }), n4, t5);
        } catch (l5) {
          const s7 = l5 == null ? void 0 : l5.details;
          if (s7 == null ? void 0 : s7.expression)
            throw l5;
          (s7 == null ? void 0 : s7.invalidFields) ? a5.push(...s7.invalidFields) : a5.push(e3);
        }
      } else
        a5.push(e3);
  }
  if (a5.length)
    throw new s(r3, t5.errorMessage, { invalidFields: a5, query: t5.query });
}
function w(e3) {
  return e3.split(t3)[0];
}
function v6(e3) {
  return e3.split(t3)[1];
}
function F2(e3, s6, i4 = p3) {
  const n4 = s6.get(e3);
  return !!n4 && !i4.has(n4.type);
}

// node_modules/@arcgis/core/layers/graphics/data/AttributesBuilder.js
var n3 = class {
  constructor(s6, a5, l5) {
    this._fieldDataCache = /* @__PURE__ */ new Map(), this._returnDistinctMap = /* @__PURE__ */ new Map(), this.returnDistinctValues = s6.returnDistinctValues ?? false, this.fieldsIndex = l5, this.featureAdapter = a5;
    const r4 = s6.outFields;
    if (r4 && !r4.includes("*")) {
      this.outFields = r4;
      let s7 = 0;
      for (const a6 of r4) {
        const r5 = w(a6), n4 = this.fieldsIndex.get(r5), u2 = n4 ? null : y(r5, l5), d3 = n4 ? n4.name : v6(a6) || "FIELD_EXP_" + s7++;
        this._fieldDataCache.set(a6, { alias: d3, clause: u2 });
      }
    }
  }
  countDistinctValues(t5) {
    return this.returnDistinctValues ? (t5.forEach((t6) => this.getAttributes(t6)), this._returnDistinctMap.size) : t5.length;
  }
  getAttributes(t5) {
    const e3 = this._processAttributesForOutFields(t5);
    return this._processAttributesForDistinctValues(e3);
  }
  getFieldValue(t5, i4, s6) {
    var _a;
    const a5 = s6 ? s6.name : i4;
    let l5 = null;
    return this._fieldDataCache.has(a5) ? l5 = (_a = this._fieldDataCache.get(a5)) == null ? void 0 : _a.clause : s6 || (l5 = y(i4, this.fieldsIndex), this._fieldDataCache.set(a5, { alias: a5, clause: l5 })), s6 ? this.featureAdapter.getAttribute(t5, a5) : l5 == null ? void 0 : l5.calculateValue(t5, this.featureAdapter);
  }
  getDataValues(t5, e3) {
    const i4 = e3.normalizationType, s6 = e3.normalizationTotal;
    return t5.map((t6) => {
      let r4 = e3.field && this.getFieldValue(t6, e3.field, this.fieldsIndex.get(e3.field));
      if (e3.field2 && (r4 = `${c(r4)}${e3.fieldDelimiter}${c(this.getFieldValue(t6, e3.field2, this.fieldsIndex.get(e3.field2)))}`, e3.field3 && (r4 = `${r4}${e3.fieldDelimiter}${c(this.getFieldValue(t6, e3.field3, this.fieldsIndex.get(e3.field3)))}`)), i4 && Number.isFinite(r4)) {
        const a5 = "field" === i4 && e3.normalizationField ? this.getFieldValue(t6, e3.normalizationField, this.fieldsIndex.get(e3.normalizationField)) : null;
        r4 = z(r4, i4, a5, s6);
      }
      return r4;
    });
  }
  async getExpressionValues(t5, e3, i4, a5) {
    const { arcadeUtils: l5 } = await i3(), n4 = l5.hasGeometryOperations(e3);
    n4 && await l5.enableGeometryOperations();
    const u2 = l5.createFunction(e3), d3 = i4 && l5.getViewInfo(i4), o5 = { fields: this.fieldsIndex.fields };
    return t5.map((t6) => {
      const e4 = { attributes: this.featureAdapter.getAttributes(t6), layer: o5, geometry: n4 ? { ...P(a5.geometryType, a5.hasZ, a5.hasM, this.featureAdapter.getGeometry(t6)), spatialReference: i4 == null ? void 0 : i4.spatialReference } : null }, r4 = l5.createExecContext(e4, d3);
      return l5.executeFunction(u2, r4);
    });
  }
  validateItem(t5, i4) {
    var _a, _b;
    return this._fieldDataCache.has(i4) || this._fieldDataCache.set(i4, { alias: i4, clause: y(i4, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i4)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testFeature(t5, this.featureAdapter)) ?? false;
  }
  validateItems(t5, i4) {
    var _a, _b;
    return this._fieldDataCache.has(i4) || this._fieldDataCache.set(i4, { alias: i4, clause: y(i4, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i4)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testSet(t5, this.featureAdapter)) ?? false;
  }
  _processAttributesForOutFields(t5) {
    const e3 = this.outFields;
    if (!e3 || !e3.length)
      return this.featureAdapter.getAttributes(t5);
    const i4 = {};
    for (const s6 of e3) {
      const { alias: e4, clause: a5 } = this._fieldDataCache.get(s6);
      i4[e4] = a5 ? a5.calculateValue(t5, this.featureAdapter) : this.featureAdapter.getAttribute(t5, e4);
    }
    return i4;
  }
  _processAttributesForDistinctValues(t5) {
    if (null == t5 || !this.returnDistinctValues)
      return t5;
    const e3 = this.outFields, i4 = [];
    if (e3)
      for (const l5 of e3) {
        const { alias: e4 } = this._fieldDataCache.get(l5);
        i4.push(t5[e4]);
      }
    else
      for (const l5 in t5)
        i4.push(t5[l5]);
    const s6 = `${(e3 || ["*"]).join(",")}=${i4.join(",")}`;
    let a5 = this._returnDistinctMap.get(s6) || 0;
    return this._returnDistinctMap.set(s6, ++a5), a5 > 1 ? null : t5;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/SnappingCandidate.js
function t4(t5, e3, r4) {
  return { objectId: t5, target: e3, distance: r4, type: "vertex" };
}
function e2(t5, e3, r4, n4, d3, a5 = false) {
  return { objectId: t5, target: e3, distance: r4, type: "edge", start: n4, end: d3, draped: a5 };
}

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineResult.js
var z2 = class {
  constructor(e3, t5, s6) {
    this.items = e3, this.query = t5, this.geometryType = s6.geometryType, this.hasM = s6.hasM, this.hasZ = s6.hasZ, this.fieldsIndex = s6.fieldsIndex, this.objectIdField = s6.objectIdField, this.spatialReference = s6.spatialReference, this.featureAdapter = s6.featureAdapter;
  }
  get size() {
    return this.items.length;
  }
  createQueryResponseForCount() {
    const e3 = new n3(this.query, this.featureAdapter, this.fieldsIndex);
    if (!this.query.outStatistics)
      return e3.countDistinctValues(this.items);
    const { groupByFieldsForStatistics: t5, having: s6, outStatistics: i4 } = this.query, a5 = t5 == null ? void 0 : t5.length;
    if (!!!a5)
      return 1;
    const r4 = /* @__PURE__ */ new Map(), n4 = /* @__PURE__ */ new Map(), l5 = /* @__PURE__ */ new Set();
    for (const o5 of i4) {
      const { statisticType: i5 } = o5, a6 = "exceedslimit" !== i5 ? o5.onStatisticField : void 0;
      if (!n4.has(a6)) {
        const s7 = [];
        for (const i6 of t5) {
          const t6 = this._getAttributeValues(e3, i6, r4);
          s7.push(t6);
        }
        n4.set(a6, this._calculateUniqueValues(s7, e3.returnDistinctValues));
      }
      const u2 = n4.get(a6);
      for (const t6 in u2) {
        const { data: i6, items: a7 } = u2[t6], r5 = i6.join(",");
        s6 && !e3.validateItems(a7, s6) || l5.add(r5);
      }
    }
    return l5.size;
  }
  async createQueryResponse() {
    let e3;
    if (this.query.outStatistics) {
      e3 = this.query.outStatistics.some((e4) => "exceedslimit" === e4.statisticType) ? this._createExceedsLimitQueryResponse(this.query) : await this._createStatisticsQueryResponse(this.query);
    } else
      e3 = this._createFeatureQueryResponse(this.query);
    if (this.query.returnQueryGeometry) {
      const t5 = this.query.geometry;
      s4(this.query.outSR) && !S(t5.spatialReference, this.query.outSR) ? e3.queryGeometry = Z({ spatialReference: this.query.outSR, ...g2(t5, t5.spatialReference, this.query.outSR) }) : e3.queryGeometry = Z({ spatialReference: this.query.outSR, ...t5 });
    }
    return e3;
  }
  createSnappingResponse(e3, t5) {
    const s6 = this.featureAdapter, i4 = b3(this.hasZ, this.hasM), { point: a5, mode: r4 } = e3, n4 = "number" == typeof e3.distance ? e3.distance : e3.distance.x, o5 = "number" == typeof e3.distance ? e3.distance : e3.distance.y, l5 = { candidates: [] }, d3 = "esriGeometryPolygon" === this.geometryType, m5 = this._getPointCreator(r4, this.spatialReference, t5), h2 = new A(null, 0), g4 = new A(null, 0), f6 = { x: 0, y: 0, z: 0 };
    for (const p4 of this.items) {
      const t6 = s6.getGeometry(p4);
      if (null == t6)
        continue;
      const { coords: r5, lengths: y2 } = t6;
      if (h2.coords = r5, g4.coords = r5, e3.returnEdge) {
        let e4 = 0;
        for (let t7 = 0; t7 < y2.length; t7++) {
          const r6 = y2[t7];
          for (let t8 = 0; t8 < r6; t8++, e4 += i4) {
            const c4 = h2;
            if (c4.coordsIndex = e4, t8 !== r6 - 1) {
              const t9 = g4;
              t9.coordsIndex = e4 + i4;
              const r7 = f6;
              R(f6, a5, c4, t9);
              const d4 = (a5.x - r7.x) / n4, h3 = (a5.y - r7.y) / o5, y3 = d4 * d4 + h3 * h3;
              y3 <= 1 && l5.candidates.push(e2(s6.getObjectId(p4), m5(r7), Math.sqrt(y3), m5(c4), m5(t9)));
            }
          }
        }
      }
      if (e3.returnVertex) {
        const e4 = d3 ? r5.length - i4 : r5.length;
        for (let t7 = 0; t7 < e4; t7 += i4) {
          const e5 = h2;
          e5.coordsIndex = t7;
          const i5 = (a5.x - e5.x) / n4, r6 = (a5.y - e5.y) / o5, u2 = i5 * i5 + r6 * r6;
          u2 <= 1 && l5.candidates.push(t4(s6.getObjectId(p4), m5(e5), Math.sqrt(u2)));
        }
      }
    }
    return l5.candidates.sort((e4, t6) => e4.distance - t6.distance), l5;
  }
  _getPointCreator(e3, t5, s6) {
    const i4 = null == s6 || S(t5, s6) ? (e4) => e4 : (e4) => g2(e4, t5, s6), { hasZ: a5 } = this, r4 = 0;
    return "3d" === e3 ? a5 ? ({ x: e4, y: t6, z: s7 }) => i4({ x: e4, y: t6, z: s7 }) : ({ x: e4, y: t6 }) => i4({ x: e4, y: t6, z: r4 }) : ({ x: e4, y: t6 }) => i4({ x: e4, y: t6 });
  }
  async createSummaryStatisticsResponse(e3) {
    const { field: t5, valueExpression: s6, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, minValue: n4, maxValue: o5, scale: l5 } = e3, u2 = this.fieldsIndex.isDateField(t5), c4 = await this._getDataValues({ field: t5, valueExpression: s6, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, scale: l5 }), d3 = m3({ normalizationType: a5, normalizationField: i4, minValue: n4, maxValue: o5 }), m5 = this.fieldsIndex.get(t5), h2 = { value: 0.5, fieldType: m5 == null ? void 0 : m5.type }, I2 = ae(m5) ? f2({ values: c4, supportsNullCount: d3, percentileParams: h2 }) : d({ values: c4, minValue: n4, maxValue: o5, useSampleStdDev: !a5, supportsNullCount: d3, percentileParams: h2 });
    return g(I2, u2);
  }
  async createUniqueValuesResponse(e3) {
    const { field: t5, valueExpression: s6, domains: i4, returnAllCodedValues: a5, scale: r4 } = e3, n4 = await this._getDataValues({ field: t5, field2: e3.field2, field3: e3.field3, fieldDelimiter: e3.fieldDelimiter, valueExpression: s6, scale: r4 }), o5 = x(n4);
    return F(o5, i4, a5, e3.fieldDelimiter);
  }
  async createClassBreaksResponse(e3) {
    const { field: t5, valueExpression: s6, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, classificationMethod: n4, standardDeviationInterval: o5, minValue: l5, maxValue: u2, numClasses: c4, scale: d3 } = e3, m5 = await this._getDataValues({ field: t5, valueExpression: s6, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, scale: d3 }), h2 = D(m5, { field: t5, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, classificationMethod: n4, standardDeviationInterval: o5, minValue: l5, maxValue: u2, numClasses: c4 });
    return S2(h2, n4);
  }
  async createHistogramResponse(e3) {
    const { field: t5, valueExpression: s6, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, classificationMethod: n4, standardDeviationInterval: o5, minValue: l5, maxValue: u2, numBins: c4, scale: d3 } = e3, m5 = await this._getDataValues({ field: t5, valueExpression: s6, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, scale: d3 });
    return M(m5, { field: t5, normalizationField: i4, normalizationType: a5, normalizationTotal: r4, classificationMethod: n4, standardDeviationInterval: o5, minValue: l5, maxValue: u2, numBins: c4 });
  }
  _sortFeatures(e3, t5, s6) {
    if (e3.length > 1 && t5 && t5.length)
      for (const i4 of t5.reverse()) {
        const t6 = i4.split(" "), a5 = t6[0], r4 = this.fieldsIndex.get(a5), n4 = !!t6[1] && "desc" === t6[1].toLowerCase(), o5 = v3(r4 == null ? void 0 : r4.type, n4);
        e3.sort((e4, t7) => {
          const i5 = s6(e4, a5, r4), n5 = s6(t7, a5, r4);
          return o5(i5, n5);
        });
      }
  }
  _createFeatureQueryResponse(e3) {
    const t5 = this.items, { geometryType: s6, hasM: i4, hasZ: r4, objectIdField: n4, spatialReference: o5 } = this, { outFields: l5, outSR: u2, quantizationParameters: c4, resultRecordCount: m5, resultOffset: h2, returnZ: g4, returnM: f6 } = e3, p4 = null != m5 && t5.length > (h2 || 0) + m5, y2 = l5 && (l5.includes("*") ? [...this.fieldsIndex.fields] : l5.map((e4) => this.fieldsIndex.get(e4)));
    return { exceededTransferLimit: p4, features: this._createFeatures(e3, t5), fields: y2, geometryType: s6, hasM: i4 && f6, hasZ: r4 && g4, objectIdFieldName: n4, spatialReference: Z(u2 || o5), transform: c4 && m2(c4) || null };
  }
  _createFeatures(e3, t5) {
    const s6 = new n3(e3, this.featureAdapter, this.fieldsIndex), { hasM: i4, hasZ: r4 } = this, { orderByFields: n4, quantizationParameters: l5, returnGeometry: u2, returnCentroid: c4, maxAllowableOffset: d3, resultOffset: g4, resultRecordCount: f6, returnZ: p4 = false, returnM: y2 = false } = e3, x3 = r4 && p4, I2 = i4 && y2;
    let T = [], V = 0;
    const F3 = [...t5];
    if (this._sortFeatures(F3, n4, (e4, t6, i5) => s6.getFieldValue(e4, t6, i5)), u2 || c4) {
      const e4 = m2(l5) ?? void 0;
      if (u2 && !c4)
        for (const t6 of F3)
          T[V++] = { attributes: s6.getAttributes(t6), geometry: P(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(t6), d3, e4, x3, I2) };
      else if (!u2 && c4)
        for (const t6 of F3)
          T[V++] = { attributes: s6.getAttributes(t6), centroid: G(this, this.featureAdapter.getCentroid(t6, this), e4) };
      else
        for (const t6 of F3)
          T[V++] = { attributes: s6.getAttributes(t6), centroid: G(this, this.featureAdapter.getCentroid(t6, this), e4), geometry: P(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(t6), d3, e4, x3, I2) };
    } else
      for (const a5 of F3) {
        const e4 = s6.getAttributes(a5);
        e4 && (T[V++] = { attributes: e4 });
      }
    const S3 = g4 || 0;
    if (null != f6) {
      const e4 = S3 + f6;
      T = T.slice(S3, Math.min(T.length, e4));
    }
    return T;
  }
  _createExceedsLimitQueryResponse(e3) {
    let t5 = false, s6 = Number.POSITIVE_INFINITY, i4 = Number.POSITIVE_INFINITY, a5 = Number.POSITIVE_INFINITY;
    for (const r4 of e3.outStatistics ?? [])
      if ("exceedslimit" === r4.statisticType) {
        s6 = null != r4.maxPointCount ? r4.maxPointCount : Number.POSITIVE_INFINITY, i4 = null != r4.maxRecordCount ? r4.maxRecordCount : Number.POSITIVE_INFINITY, a5 = null != r4.maxVertexCount ? r4.maxVertexCount : Number.POSITIVE_INFINITY;
        break;
      }
    if ("esriGeometryPoint" === this.geometryType)
      t5 = this.items.length > s6;
    else if (this.items.length > i4)
      t5 = true;
    else {
      const e4 = b3(this.hasZ, this.hasM), s7 = this.featureAdapter;
      t5 = this.items.reduce((e5, t6) => {
        const i5 = s7.getGeometry(t6);
        return e5 + (null != i5 && i5.coords.length || 0);
      }, 0) / e4 > a5;
    }
    return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(t5) } }] };
  }
  async _createStatisticsQueryResponse(e3) {
    const t5 = { attributes: {} }, s6 = [], i4 = /* @__PURE__ */ new Map(), a5 = /* @__PURE__ */ new Map(), r4 = /* @__PURE__ */ new Map(), n4 = /* @__PURE__ */ new Map(), l5 = new n3(e3, this.featureAdapter, this.fieldsIndex), u2 = e3.outStatistics, { groupByFieldsForStatistics: c4, having: d3, orderByFields: m5 } = e3, h2 = c4 && c4.length, g4 = !!h2, f6 = g4 ? c4[0] : null, p4 = g4 && !this.fieldsIndex.get(f6);
    for (const o5 of u2 ?? []) {
      const { outStatisticFieldName: e4, statisticType: u3 } = o5, m6 = o5, y3 = "exceedslimit" !== u3 ? o5.onStatisticField : void 0, x3 = "percentile_disc" === u3 || "percentile_cont" === u3, I2 = "EnvelopeAggregate" === u3 || "CentroidAggregate" === u3 || "ConvexHullAggregate" === u3, T = g4 && 1 === h2 && (y3 === f6 || p4) && "count" === u3;
      if (g4) {
        if (!r4.has(y3)) {
          const e5 = [];
          for (const t7 of c4) {
            const s7 = this._getAttributeValues(l5, t7, i4);
            e5.push(s7);
          }
          r4.set(y3, this._calculateUniqueValues(e5, !I2 && l5.returnDistinctValues));
        }
        const t6 = r4.get(y3);
        for (const s7 in t6) {
          const { count: a6, data: r5, items: o6, itemPositions: u4 } = t6[s7], h3 = r5.join(",");
          if (!d3 || l5.validateItems(o6, d3)) {
            const t7 = n4.get(h3) || { attributes: {} };
            if (I2) {
              t7.aggregateGeometries || (t7.aggregateGeometries = {});
              const { aggregateGeometries: e5, outStatisticFieldName: s9 } = await this._getAggregateGeometry(m6, o6);
              t7.aggregateGeometries[s9] = e5;
            } else {
              let s9 = null;
              if (T)
                s9 = a6;
              else {
                const e5 = this._getAttributeValues(l5, y3, i4), t8 = u4.map((t9) => e5[t9]);
                s9 = x3 && "statisticParameters" in m6 ? this._getPercentileValue(m6, t8) : this._getStatisticValue(m6, t8, null, l5.returnDistinctValues);
              }
              t7.attributes[e4] = s9;
            }
            let s8 = 0;
            c4.forEach((e5, i5) => t7.attributes[this.fieldsIndex.get(e5) ? e5 : "EXPR_" + ++s8] = r5[i5]), n4.set(h3, t7);
          }
        }
      } else if (I2) {
        t5.aggregateGeometries || (t5.aggregateGeometries = {});
        const { aggregateGeometries: e5, outStatisticFieldName: s7 } = await this._getAggregateGeometry(m6, this.items);
        t5.aggregateGeometries[s7] = e5;
      } else {
        const s7 = this._getAttributeValues(l5, y3, i4);
        t5.attributes[e4] = x3 && "statisticParameters" in m6 ? this._getPercentileValue(m6, s7) : this._getStatisticValue(m6, s7, a5, l5.returnDistinctValues);
      }
      s6.push({ name: e4, alias: e4, type: "esriFieldTypeDouble" });
    }
    const y2 = g4 ? Array.from(n4.values()) : [t5];
    return this._sortFeatures(y2, m5, (e4, t6) => e4.attributes[t6]), { fields: s6, features: y2 };
  }
  async _getAggregateGeometry(a5, r4) {
    const { convexHull: n4, union: o5 } = await import("./geometryEngineJSON-IVXHWXT4.js"), { statisticType: l5, outStatisticFieldName: u2 } = a5, { featureAdapter: c4, spatialReference: d3, geometryType: h2, hasZ: g4, hasM: f6 } = this, p4 = r4.map((e3) => P(h2, g4, f6, c4.getGeometry(e3))), y2 = n4(d3, p4, true)[0], x3 = { aggregateGeometries: null, outStatisticFieldName: null };
    if ("EnvelopeAggregate" === l5) {
      const e3 = y2 ? v2(y2) : l3(o5(d3, p4));
      x3.aggregateGeometries = { ...e3, spatialReference: d3 }, x3.outStatisticFieldName = u2 || "extent";
    } else if ("CentroidAggregate" === l5) {
      const s6 = y2 ? o2(y2) : l2(l3(o5(d3, p4)));
      x3.aggregateGeometries = { x: s6[0], y: s6[1], spatialReference: d3 }, x3.outStatisticFieldName = u2 || "centroid";
    } else
      "ConvexHullAggregate" === l5 && (x3.aggregateGeometries = y2, x3.outStatisticFieldName = u2 || "convexHull");
    return x3;
  }
  _getStatisticValue(e3, t5, s6, i4) {
    const { onStatisticField: a5, statisticType: r4 } = e3;
    let n4 = null;
    n4 = (s6 == null ? void 0 : s6.has(a5)) ? s6.get(a5) : ae(this.fieldsIndex.get(a5)) ? f2({ values: t5, returnDistinct: i4 }) : d({ values: i4 ? [...new Set(t5)] : t5, minValue: null, maxValue: null, useSampleStdDev: true }), s6 && s6.set(a5, n4);
    return n4["var" === r4 ? "variance" : r4];
  }
  _getPercentileValue(e3, t5) {
    const { onStatisticField: s6, statisticParameters: i4, statisticType: a5 } = e3, { value: r4, orderBy: n4 } = i4, o5 = this.fieldsIndex.get(s6);
    return p2(t5, { value: r4, orderBy: n4, fieldType: o5 == null ? void 0 : o5.type, isDiscrete: "percentile_disc" === a5 });
  }
  _getAttributeValues(e3, t5, s6) {
    if (s6.has(t5))
      return s6.get(t5);
    const i4 = this.fieldsIndex.get(t5), a5 = this.items.map((s7) => e3.getFieldValue(s7, t5, i4));
    return s6.set(t5, a5), a5;
  }
  _calculateUniqueValues(e3, t5) {
    const s6 = {}, i4 = this.items, a5 = i4.length;
    for (let r4 = 0; r4 < a5; r4++) {
      const a6 = i4[r4], n4 = [];
      for (const t6 of e3)
        n4.push(t6[r4]);
      const o5 = n4.join(",");
      null == s6[o5] ? s6[o5] = { count: 1, data: n4, items: [a6], itemPositions: [r4] } : (t5 || s6[o5].count++, s6[o5].items.push(a6), s6[o5].itemPositions.push(r4));
    }
    return s6;
  }
  async _getDataValues(e3) {
    const t5 = new n3(this.query, this.featureAdapter, this.fieldsIndex), { valueExpression: s6, scale: i4 } = e3, a5 = s6 ? { viewingMode: "map", scale: i4, spatialReference: this.query.outSR || this.spatialReference } : null;
    return s6 ? t5.getExpressionValues(this.items, s6, a5, { geometryType: this.geometryType, hasZ: this.hasZ, hasM: this.hasM }) : t5.getDataValues(this.items, { field: e3.field, field2: e3.field2, field3: e3.field3, fieldDelimiter: e3.fieldDelimiter, normalizationField: e3.normalizationField, normalizationType: e3.normalizationType, normalizationTotal: e3.normalizationTotal });
  }
};
function R(e3, t5, s6, i4) {
  const a5 = i4.x - s6.x, r4 = i4.y - s6.y, n4 = a5 * a5 + r4 * r4, o5 = (t5.x - s6.x) * a5 + (t5.y - s6.y) * r4, l5 = Math.min(1, Math.max(0, o5 / n4));
  e3.x = s6.x + a5 * l5, e3.y = s6.y + r4 * l5;
}
function b3(e3, t5) {
  return e3 ? t5 ? 4 : 3 : t5 ? 3 : 2;
}
var A = class {
  constructor(e3, t5) {
    this.coords = e3, this.coordsIndex = t5;
  }
  get x() {
    return this.coords[this.coordsIndex];
  }
  get y() {
    return this.coords[this.coordsIndex + 1];
  }
  get z() {
    return this.coords[this.coordsIndex + 2];
  }
};

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
function $(e3) {
  return null != e3 && e3.every((e4) => "exceedslimit" !== e4.statisticType);
}
var W = "feature-store:unsupported-query";
var X = new r2(2e6);
var Y = 0;
var ee = class {
  constructor(e3) {
    this._geometryQueryCache = null, this._changeHandle = null, this.capabilities = { query: t }, this.geometryType = e3.geometryType, this.hasM = !!e3.hasM, this.hasZ = !!e3.hasZ, this.objectIdField = e3.objectIdField, this.spatialReference = e3.spatialReference, this.definitionExpression = e3.definitionExpression, this.featureStore = e3.featureStore, this.aggregateAdapter = e3.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e3.timeInfo, e3.cacheSpatialQueries && (this._geometryQueryCache = new s5(Y++ + "$$", X)), this.fieldsIndex = new r(e3.fields), e3.scheduler && e3.priority && (this._frameTask = e3.scheduler.registerTask(e3.priority));
  }
  destroy() {
    this._frameTask = o(this._frameTask), this.clearCache(), l(this._geometryQueryCache), this._changeHandle = o(this._changeHandle), l(this.fieldsIndex);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  clearCache() {
    var _a;
    (_a = this._geometryQueryCache) == null ? void 0 : _a.clear(), this._allFeaturesPromise = null, this._timeExtentPromise = null;
  }
  async executeQuery(e3, t5) {
    try {
      return (await this._executeQuery(e3, {}, t5)).createQueryResponse();
    } catch (i4) {
      if (i4 !== M3)
        throw i4;
      return new z2([], e3, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e3 = {}, t5) {
    try {
      return (await this._executeQuery(e3, { returnGeometry: false, returnCentroid: false, outSR: null }, t5)).createQueryResponseForCount();
    } catch (i4) {
      if (i4 !== M3)
        throw i4;
      return 0;
    }
  }
  async executeQueryForExtent(e3, t5) {
    const i4 = e3.outSR;
    try {
      const s6 = await this._executeQuery(e3, { returnGeometry: true, returnCentroid: false, outSR: null }, t5), r4 = s6.size;
      if (!r4)
        return { count: 0, extent: null };
      return { count: r4, extent: await this._getBounds(s6.items, s6.spatialReference, i4 || this.spatialReference) };
    } catch (s6) {
      if (s6 === M3)
        return { count: 0, extent: null };
      throw s6;
    }
  }
  async executeQueryForIds(e3, t5) {
    return this.executeQueryForIdSet(e3, t5).then((e4) => Array.from(e4));
  }
  async executeQueryForIdSet(e3, t5) {
    try {
      const i4 = await this._executeQuery(e3, { returnGeometry: true, returnCentroid: false, outSR: null }, t5), s6 = i4.items, r4 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e4 of s6)
          r4.add(i4.featureAdapter.getObjectId(e4));
      }, t5), r4;
    } catch (i4) {
      if (i4 === M3)
        return /* @__PURE__ */ new Set();
      throw i4;
    }
  }
  async executeQueryForSnapping(e3, t5) {
    const { point: i4, distance: s6, returnEdge: r4, returnVertex: a5 } = e3;
    if (!r4 && !a5)
      return { candidates: [] };
    const n4 = await this._reschedule(() => this._checkQuerySupport(e3.query), t5), u2 = !S(i4.spatialReference, this.spatialReference);
    u2 && await f3(i4.spatialReference, this.spatialReference);
    const o5 = "number" == typeof s6 ? s6 : s6.x, l5 = "number" == typeof s6 ? s6 : s6.y, c4 = { xmin: i4.x - o5, xmax: i4.x + o5, ymin: i4.y - l5, ymax: i4.y + l5, spatialReference: i4.spatialReference }, h2 = u2 ? g2(c4, this.spatialReference) : c4;
    if (!h2)
      return { candidates: [] };
    const p4 = (await b2(p(i4), null, { signal: t5 }))[0], m5 = (await b2(p(h2), null, { signal: t5 }))[0];
    if (null == p4 || null == m5)
      return { candidates: [] };
    const f6 = new z2(await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(m5.toJSON())), t5), n4, this);
    await this._reschedule(() => this._executeObjectIdsQuery(f6), t5), await this._reschedule(() => this._executeTimeQuery(f6), t5), await this._reschedule(() => this._executeAttributesQuery(f6), t5);
    const d3 = p4.toJSON(), y2 = u2 ? g2(d3, this.spatialReference) : d3, _ = u2 ? Math.max(h2.xmax - h2.xmin, h2.ymax - h2.ymin) / 2 : s6;
    return f6.createSnappingResponse({ ...e3, point: y2, distance: _ }, i4.spatialReference);
  }
  async executeQueryForLatestObservations(e3, t5) {
    if (!this.timeInfo || !this.timeInfo.trackIdField)
      throw new s(W, "Missing timeInfo or timeInfo.trackIdField", { query: e3, timeInfo: this.timeInfo });
    try {
      const i4 = await this._executeQuery(e3, {}, t5);
      return await this._reschedule(() => this._filterLatest(i4), t5), i4.createQueryResponse();
    } catch (s6) {
      if (s6 !== M3)
        throw s6;
      return new z2([], e3, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e3 = {}, t5, i4) {
    const { field: s6, normalizationField: r4, valueExpression: a5 } = t5;
    return (await this._getQueryEngineResultForStats(e3, { field: s6, normalizationField: r4, valueExpression: a5 }, i4)).createSummaryStatisticsResponse(t5);
  }
  async executeQueryForUniqueValues(e3 = {}, t5, i4) {
    const { field: s6, field2: r4, field3: a5, valueExpression: n4 } = t5;
    return (await this._getQueryEngineResultForStats(e3, { field: s6, field2: r4, field3: a5, valueExpression: n4 }, i4)).createUniqueValuesResponse(t5);
  }
  async executeQueryForClassBreaks(e3 = {}, t5, i4) {
    const { field: s6, normalizationField: r4, valueExpression: a5 } = t5;
    return (await this._getQueryEngineResultForStats(e3, { field: s6, normalizationField: r4, valueExpression: a5 }, i4)).createClassBreaksResponse(t5);
  }
  async executeQueryForHistogram(e3 = {}, t5, i4) {
    const { field: s6, normalizationField: r4, valueExpression: a5 } = t5;
    return (await this._getQueryEngineResultForStats(e3, { field: s6, normalizationField: r4, valueExpression: a5 }, i4)).createHistogramResponse(t5);
  }
  async fetchRecomputedExtents(e3) {
    const [t5, i4] = await Promise.all(["getFullExtent" in this.featureStore && this.featureStore.getFullExtent ? Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)) : this._getBounds(await this._getAllFeatures(), this.spatialReference, this.spatialReference), null != this._timeExtentPromise ? this._timeExtentPromise : this._timeExtentPromise = t2(this.timeInfo, this.featureStore)]);
    return s2(e3), { fullExtent: t5, timeExtent: i4 };
  }
  async _getBounds(e3, t5, i4) {
    const s6 = O(i2(), C);
    await this.featureStore.forEachBounds(e3, (e4) => o3(s6, e4));
    const r4 = { xmin: s6[0], ymin: s6[1], xmax: s6[3], ymax: s6[4], spatialReference: Z(this.spatialReference) };
    this.hasZ && isFinite(s6[2]) && isFinite(s6[5]) && (r4.zmin = s6[2], r4.zmax = s6[5]);
    const a5 = g2(r4, t5, i4);
    if (a5.spatialReference = Z(i4), a5.xmax - a5.xmin == 0) {
      const e4 = H(a5.spatialReference);
      a5.xmin -= e4, a5.xmax += e4;
    }
    if (a5.ymax - a5.ymin == 0) {
      const e4 = H(a5.spatialReference);
      a5.ymin -= e4, a5.ymax += e4;
    }
    if (this.hasZ && null != a5.zmin && null != a5.zmax && a5.zmax - a5.zmin == 0) {
      const e4 = H(a5.spatialReference);
      a5.zmin -= e4, a5.zmax += e4;
    }
    return a5;
  }
  async _schedule(e3, t5) {
    return null != this._frameTask ? this._frameTask.schedule(e3, t5) : e3(C2);
  }
  async _reschedule(e3, t5) {
    return null != this._frameTask ? this._frameTask.reschedule(e3, t5) : e3(C2);
  }
  async _getAllFeaturesQueryEngineResult(e3) {
    return new z2(await this._getAllFeatures(), e3, this);
  }
  async _getAllFeatures() {
    if (null == this._allFeaturesPromise) {
      const e4 = [];
      this._allFeaturesPromise = (async () => {
        await this.featureStore.forEach((t6) => e4.push(t6));
      })().then(() => e4);
    }
    const e3 = this._allFeaturesPromise, t5 = await e3;
    return e3 === this._allFeaturesPromise ? t5.slice() : this._getAllFeatures();
  }
  async _executeQuery(e3, t5, i4) {
    e3 = a(e3), e3 = await this._schedule(() => v4(e3, this.definitionExpression, this.spatialReference), i4), e3 = await this._reschedule(() => this._checkQuerySupport(e3), i4), e3 = { ...e3, ...t5 };
    const r4 = await this._reschedule(() => this._executeSceneFilterQuery(e3, i4), i4), a5 = await this._reschedule(() => this._executeGeometryQuery(e3, r4, i4), i4);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a5), i4), await this._reschedule(() => this._executeObjectIdsQuery(a5), i4), await this._reschedule(() => this._executeTimeQuery(a5), i4), await this._reschedule(() => this._executeAttributesQuery(a5), i4), a5;
  }
  async _executeSceneFilterQuery(e3, t5) {
    if (null == e3.sceneFilter)
      return null;
    const { outSR: i4, returnGeometry: s6, returnCentroid: r4 } = e3, a5 = this.featureStore.featureSpatialReference, n4 = e3.sceneFilter.geometry, u2 = null == a5 || S(a5, n4.spatialReference) ? n4 : g2(n4, a5);
    if (!u2)
      return null;
    const o5 = s6 || r4, l5 = s4(i4) && !S(this.spatialReference, i4) && o5 ? async (e4) => this._project(e4, i4) : (e4) => e4, c4 = this.featureAdapter, h2 = await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(u2)), t5);
    if ("disjoint" === e3.sceneFilter.spatialRelationship) {
      if (!h2.length)
        return null;
      const i5 = /* @__PURE__ */ new Set();
      for (const e4 of h2)
        i5.add(c4.getObjectId(e4));
      const s7 = await this._reschedule(() => this._getAllFeatures(), t5), r5 = await this._reschedule(async () => {
        const r6 = await v5("esriSpatialRelDisjoint", u2, this.geometryType, this.hasZ, this.hasM), a6 = (e4) => !i5.has(c4.getObjectId(e4)) || r6(c4.getGeometry(e4)), n5 = await this._runSpatialFilter(s7, a6, t5);
        return new z2(n5, e3, this);
      }, t5);
      return l5(r5);
    }
    if (!h2.length)
      return new z2([], e3, this);
    if (this._canExecuteSinglePass(u2, e3))
      return l5(new z2(h2, e3, this));
    const p4 = await v5("esriSpatialRelContains", u2, this.geometryType, this.hasZ, this.hasM), m5 = await this._runSpatialFilter(h2, (e4) => p4(c4.getGeometry(e4)), t5);
    return l5(new z2(m5, e3, this));
  }
  async _executeGeometryQuery(i4, s6, r4) {
    if (null != s6 && 0 === s6.items.length)
      return s6;
    i4 = null != s6 ? s6.query : i4;
    const { geometry: a5, outSR: n4, spatialRel: u2, returnGeometry: o5, returnCentroid: l5 } = i4, c4 = this.featureStore.featureSpatialReference, h2 = !a5 || null == c4 || S(c4, a5.spatialReference) ? a5 : g2(a5, c4), p4 = o5 || l5, m5 = s4(n4) && !S(this.spatialReference, n4), f6 = this._geometryQueryCache && null == s6 ? m5 && p4 ? JSON.stringify({ originalFilterGeometry: a5, spatialRelationship: u2, outSpatialReference: n4 }) : JSON.stringify({ originalFilterGeometry: a5, spatialRelationship: u2 }) : null, d3 = f6 ? this._geometryQueryCache.get(f6) : null;
    if (null != d3)
      return new z2(d3, i4, this);
    const y2 = async (e3) => (m5 && p4 && await this._project(e3, n4), f6 && this._geometryQueryCache.put(f6, e3.items, e3.items.length + 1), e3);
    if (!h2)
      return y2(null != s6 ? s6 : await this._getAllFeaturesQueryEngineResult(i4));
    const g4 = this.featureAdapter;
    let _ = await this._reschedule(() => this._searchFeatures(this._getQueryBBoxes(a5)), r4);
    if ("esriSpatialRelDisjoint" === u2) {
      if (!_.length)
        return y2(null != s6 ? s6 : await this._getAllFeaturesQueryEngineResult(i4));
      const e3 = /* @__PURE__ */ new Set();
      for (const i5 of _)
        e3.add(g4.getObjectId(i5));
      const t5 = null != s6 ? s6.items : await this._reschedule(() => this._getAllFeatures(), r4), a6 = await this._reschedule(async () => {
        const s7 = await v5(u2, h2, this.geometryType, this.hasZ, this.hasM), a7 = (t6) => !e3.has(g4.getObjectId(t6)) || s7(g4.getGeometry(t6)), n5 = await this._runSpatialFilter(t5, a7, r4);
        return new z2(n5, i4, this);
      }, r4);
      return y2(a6);
    }
    if (null != s6) {
      const i5 = new v();
      _ = _.filter((e3) => b(s6.items, e3, s6.items.length, i5) >= 0);
    }
    if (!_.length) {
      const e3 = new z2([], i4, this);
      return f6 && this._geometryQueryCache.put(f6, e3.items, 1), e3;
    }
    if (this._canExecuteSinglePass(h2, i4))
      return y2(new z2(_, i4, this));
    const x3 = await v5(u2, h2, this.geometryType, this.hasZ, this.hasM), w2 = await this._runSpatialFilter(_, (e3) => x3(g4.getGeometry(e3)), r4);
    return y2(new z2(w2, i4, this));
  }
  _executeAggregateIdsQuery(e3) {
    if (0 === e3.items.length || !e3.query.aggregateIds || !e3.query.aggregateIds.length || null == this.aggregateAdapter)
      return;
    const t5 = /* @__PURE__ */ new Set();
    for (const s6 of e3.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s6).forEach((e4) => t5.add(e4));
    }
    const i4 = this.featureAdapter.getObjectId;
    e3.items = e3.items.filter((e4) => t5.has(i4(e4)));
  }
  _executeObjectIdsQuery(e3) {
    if (0 === e3.items.length || !e3.query.objectIds || !e3.query.objectIds.length)
      return;
    const t5 = new Set(e3.query.objectIds), i4 = this.featureAdapter.getObjectId;
    e3.items = e3.items.filter((e4) => t5.has(i4(e4)));
  }
  _executeTimeQuery(e3) {
    if (0 === e3.items.length)
      return;
    const t5 = n(this.timeInfo, e3.query.timeExtent, this.featureAdapter);
    null != t5 && (e3.items = e3.items.filter(t5));
  }
  _executeAttributesQuery(e3) {
    if (0 === e3.items.length)
      return;
    const t5 = y(e3.query.where, this.fieldsIndex);
    if (t5) {
      if (!t5.isStandardized)
        throw new TypeError("Where clause is not standardized");
      e3.items = e3.items.filter((e4) => t5.testFeature(e4, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e3, t5, i4) {
    if (!t5)
      return e3;
    if (null == this._frameTask)
      return e3.filter((e4) => t5(e4));
    let s6 = 0;
    const r4 = new Array(), a5 = async (n4) => {
      for (; s6 < e3.length; ) {
        const u2 = e3[s6++];
        t5(u2) && (r4.push(u2), n4.madeProgress()), n4.done && await this._reschedule((e4) => a5(e4), i4);
      }
    };
    return this._reschedule((e4) => a5(e4), i4).then(() => r4);
  }
  _filterLatest(e3) {
    const { trackIdField: t5, startTimeField: i4, endTimeField: s6 } = this.timeInfo, r4 = s6 || i4, a5 = /* @__PURE__ */ new Map(), n4 = this.featureAdapter.getAttribute;
    for (const u2 of e3.items) {
      const e4 = n4(u2, t5), i5 = n4(u2, r4), s7 = a5.get(e4);
      (!s7 || i5 > n4(s7, r4)) && a5.set(e4, u2);
    }
    e3.items = Array.from(a5.values());
  }
  _canExecuteSinglePass(e3, t5) {
    const { spatialRel: i4 } = t5;
    return I(e3) && ("esriSpatialRelEnvelopeIntersects" === i4 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i4 || "esriSpatialRelContains" === i4 || "esriSpatialRelWithin" === i4));
  }
  async _project(e3, t5) {
    if (!t5 || S(this.spatialReference, t5))
      return e3;
    const i4 = this.featureAdapter, s6 = await M2(e3.items.map((e4) => P(this.geometryType, this.hasZ, this.hasM, i4.getGeometry(e4))), this.spatialReference, t5);
    return e3.items = s6.map((t6, s7) => i4.cloneWithGeometry(e3.items[s7], rt(t6, this.hasZ, this.hasM))), e3;
  }
  _getQueryBBoxes(e3) {
    if (I(e3)) {
      if (m(e3))
        return [a2(e3.xmin, e3.ymin, e3.xmax, e3.ymax)];
      if (f(e3))
        return e3.rings.map((e4) => a2(Math.min(e4[0][0], e4[2][0]), Math.min(e4[0][1], e4[2][1]), Math.max(e4[0][0], e4[2][0]), Math.max(e4[0][1], e4[2][1])));
    }
    return [a3(i(), e3)];
  }
  async _searchFeatures(e3) {
    const t5 = /* @__PURE__ */ new Set();
    await Promise.all(e3.map((e4) => this.featureStore.forEachInBounds(e4, (e5) => t5.add(e5))));
    const i4 = Array.from(t5.values());
    return t5.clear(), i4;
  }
  async _checkStatisticsSupport(e3, t5) {
    if ((e3.distance ?? 0) < 0 || null != e3.geometryPrecision || e3.multipatchOption || e3.pixelSize || e3.relationParam || e3.text || e3.outStatistics || e3.groupByFieldsForStatistics || e3.having || e3.orderByFields)
      throw new s(W, "Unsupported query options", { query: e3 });
    return this._checkAttributesQuerySupport(e3), Promise.all([this._checkStatisticsParamsSupport(t5, e3), P2(e3, this.geometryType, this.spatialReference), f3(this.spatialReference, e3.outSR)]).then(() => e3);
  }
  async _checkStatisticsParamsSupport(e3, t5) {
    let s6 = [];
    if (e3.valueExpression) {
      const { arcadeUtils: t6 } = await i3();
      s6 = t6.extractFieldNames(e3.valueExpression);
    }
    if (e3.field && s6.push(e3.field), e3.field2 && s6.push(e3.field2), e3.field3 && s6.push(e3.field3), e3.normalizationField && s6.push(e3.normalizationField), !s6.length && !e3.valueExpression)
      throw new s(W, "field or valueExpression is required", { params: e3 });
    m4(this.fieldsIndex, s6, { errorMessage: "Cannot calculate statistics for missing fields", query: t5 }), x2(this.fieldsIndex, s6, { expressionName: "statistics", query: t5 });
  }
  async _checkQuerySupport(e3) {
    if ((e3.distance ?? 0) < 0 || null != e3.geometryPrecision || e3.multipatchOption || e3.pixelSize || e3.relationParam || e3.text)
      throw new s(W, "Unsupported query options", { query: e3 });
    return this._checkAttributesQuerySupport(e3), this._checkStatisticsQuerySupport(e3), Promise.all([P2(e3, this.geometryType, this.spatialReference), f3(this.spatialReference, e3.outSR)]).then(() => e3);
  }
  _checkAttributesQuerySupport(e3) {
    const { outFields: t5, orderByFields: s6, returnDistinctValues: r4, outStatistics: a5 } = e3, n4 = a5 ? a5.map((e4) => e4.outStatisticFieldName && e4.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
    if (s6 && s6.length > 0) {
      const t6 = " asc", i4 = " desc", r5 = s6.map((e4) => {
        const s7 = e4.toLowerCase();
        return s7.includes(t6) ? s7.split(t6)[0] : s7.includes(i4) ? s7.split(i4)[0] : e4;
      }).filter((e4) => !n4.includes(e4));
      m4(this.fieldsIndex, r5, { expressionName: "orderByFields", query: e3 });
    }
    if (t5 && t5.length > 0)
      m4(this.fieldsIndex, t5, { expressionName: "outFields", query: e3 });
    else if (r4)
      throw new s(W, "outFields should be specified for returnDistinctValues", { query: e3 });
    c3(this.fieldsIndex, e3.where, e3);
  }
  _checkStatisticsQuerySupport(e3) {
    const { outStatistics: t5, groupByFieldsForStatistics: s6, having: r4 } = e3, a5 = s6 && s6.length, n4 = t5 && t5.length;
    if (r4) {
      if (!a5 || !n4)
        throw new s(W, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: e3 });
      f5(this.fieldsIndex, r4, t5, e3);
    }
    if (n4) {
      if (!$(t5))
        return;
      const r5 = t5.map((e4) => e4.onStatisticField).filter(Boolean);
      m4(this.fieldsIndex, r5, { expressionName: "onStatisticFields", query: e3 }), a5 && m4(this.fieldsIndex, s6, { expressionName: "groupByFieldsForStatistics", query: e3 });
      const n5 = /* @__PURE__ */ new Set([...a4.jsonValues, ...l4.jsonValues]), u2 = new Intl.ListFormat("en-US", { type: "conjunction" }).format([...a4.apiValues, ...l4.apiValues]);
      for (const s7 of t5) {
        const { onStatisticField: t6, statisticType: r6 } = s7;
        if (("percentile_disc" === r6 || "percentile_cont" === r6) && "statisticParameters" in s7) {
          const { statisticParameters: t7 } = s7;
          if (!t7)
            throw new s(W, "statisticParameters should be set for percentile type", { definition: s7, query: e3 });
        } else if ("count" !== r6 && "min" !== r6 && "max" !== r6 && t6 && F2(t6, this.fieldsIndex, n5))
          throw new s(W, `outStatistics with '${r6}' statistic type, only supports ${u2} field types`, { definition: s7, query: e3 });
      }
    }
  }
  async _getQueryEngineResultForStats(e3, t5, i4) {
    e3 = a(e3);
    try {
      e3 = await this._schedule(() => v4(e3, this.definitionExpression, this.spatialReference), i4), e3 = await this._reschedule(() => this._checkStatisticsSupport(e3, t5), i4);
      const s6 = await this._reschedule(() => this._executeSceneFilterQuery(e3, i4), i4), r4 = await this._reschedule(() => this._executeGeometryQuery(e3, s6, i4), i4);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r4), i4), await this._reschedule(() => this._executeObjectIdsQuery(r4), i4), await this._reschedule(() => this._executeTimeQuery(r4), i4), await this._reschedule(() => this._executeAttributesQuery(r4), i4), r4;
    } catch (r4) {
      if (r4 !== M3)
        throw r4;
      return new z2([], e3, this);
    }
  }
};

export {
  ee
};
//# sourceMappingURL=chunk-R6YQG4NY.js.map
