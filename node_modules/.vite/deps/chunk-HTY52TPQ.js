import {
  t as t3
} from "./chunk-MSLDEOHR.js";
import {
  t
} from "./chunk-B5TYSRH2.js";
import {
  t as t2
} from "./chunk-6DURKJBD.js";
import {
  b
} from "./chunk-PM3CFO6N.js";
import {
  v
} from "./chunk-T4XWQYGC.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  L,
  V
} from "./chunk-O3CHVGVF.js";

// node_modules/@arcgis/core/rest/query/operations/query.js
var l = "Layer does not support extent calculation.";
function s(t4, e) {
  if (e && "extent" === t4.type)
    return `${t4.xmin},${t4.ymin},${t4.xmax},${t4.ymax}`;
  if (e && "point" === t4.type)
    return `${t4.x},${t4.y}`;
  const n = t4.toJSON();
  return delete n.spatialReference, JSON.stringify(n);
}
function y(t4, e) {
  const n = t4.geometry, i = t4.toJSON();
  delete i.compactGeometryEnabled, delete i.defaultSpatialReferenceEnabled;
  const a = i;
  let o, u, l2;
  if (null != n && (u = n.spatialReference, l2 = n.spatialReference.wkid || JSON.stringify(n.spatialReference), a.geometryType = v(n), a.geometry = s(n, t4.compactGeometryEnabled), a.inSR = l2), i.groupByFieldsForStatistics && (a.groupByFieldsForStatistics = i.groupByFieldsForStatistics.join(",")), i.objectIds && (a.objectIds = i.objectIds.join(",")), i.orderByFields && (a.orderByFields = i.orderByFields.join(",")), !i.outFields || !i.returnDistinctValues && ((e == null ? void 0 : e.returnCountOnly) || (e == null ? void 0 : e.returnExtentOnly) || (e == null ? void 0 : e.returnIdsOnly)) ? delete a.outFields : i.outFields.includes("*") ? a.outFields = "*" : a.outFields = i.outFields.join(","), i.outSR ? (a.outSR = i.outSR.wkid || JSON.stringify(i.outSR), o = t4.outSpatialReference) : n && (i.returnGeometry || i.returnCentroid) && (a.outSR = a.inSR, o = u), i.returnGeometry && delete i.returnGeometry, i.outStatistics && (a.outStatistics = JSON.stringify(i.outStatistics)), i.fullText && (a.fullText = JSON.stringify(i.fullText)), i.pixelSize && (a.pixelSize = JSON.stringify(i.pixelSize)), i.quantizationParameters && (t4.defaultSpatialReferenceEnabled && null != u && null != t4.quantizationParameters && null != t4.quantizationParameters.extent && u.equals(t4.quantizationParameters.extent.spatialReference) && delete i.quantizationParameters.extent.spatialReference, a.quantizationParameters = JSON.stringify(i.quantizationParameters)), i.parameterValues && (a.parameterValues = JSON.stringify(i.parameterValues)), i.rangeValues && (a.rangeValues = JSON.stringify(i.rangeValues)), i.dynamicDataSource && (a.layer = JSON.stringify({ source: i.dynamicDataSource }), delete i.dynamicDataSource), i.timeExtent) {
    const t5 = i.timeExtent, { start: e2, end: n2 } = t5;
    null == e2 && null == n2 || (a.time = e2 === n2 ? e2 : `${e2 ?? "null"},${n2 ?? "null"}`), delete i.timeExtent;
  }
  return t4.defaultSpatialReferenceEnabled && null != u && null != o && u.equals(o) && (a.defaultSR = a.inSR, delete a.inSR, delete a.outSR), a;
}
async function m(t4, e, n, r) {
  const i = null != e.timeExtent && e.timeExtent.isEmpty ? { data: { features: [] } } : await x(t4, e, "json", r);
  return t3(e, n, i.data), i;
}
async function c(t4, e, n, r) {
  if (null != e.timeExtent && e.timeExtent.isEmpty)
    return { data: n.createFeatureResult() };
  const i = await f(t4, e, r), a = i;
  return a.data = t2(i.data, n), a;
}
function f(t4, e, n) {
  return x(t4, e, "pbf", n);
}
function d(t4, e, n) {
  return null != e.timeExtent && e.timeExtent.isEmpty ? Promise.resolve({ data: { objectIds: [] } }) : x(t4, e, "json", n, { returnIdsOnly: true });
}
function p(t4, e, n) {
  return null != e.timeExtent && e.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : x(t4, e, "json", n, { returnIdsOnly: true, returnCountOnly: true });
}
async function S(t4, e, n) {
  if (null != e.timeExtent && e.timeExtent.isEmpty)
    return { data: { count: 0, extent: null } };
  const r = await x(t4, e, "json", n, { returnExtentOnly: true, returnCountOnly: true }), i = r.data;
  if (i.hasOwnProperty("extent"))
    return r;
  if (i.features)
    throw new Error(l);
  if (i.hasOwnProperty("count"))
    throw new Error(l);
  return r;
}
async function x(r, o, u, l2 = {}, s2 = {}) {
  const m2 = "string" == typeof r ? L(r) : r, c2 = o.geometry ? [o.geometry] : [];
  l2.responseType = "pbf" === u ? "array-buffer" : "json";
  const f2 = await b(c2, null, l2), d2 = f2 && f2[0];
  null != d2 && ((o = o.clone()).geometry = d2);
  const p2 = t({ ...m2.query, f: u, ...s2, ...y(o, s2) });
  return j(V(m2.path, E(o, s2) ? "query3d" : "query"), { ...l2, query: { ...p2, ...l2.query } });
}
function E(t4, e) {
  return null != t4.formatOf3DObjects && !(e.returnCountOnly || e.returnExtentOnly || e.returnIdsOnly);
}

export {
  m,
  c,
  f,
  d,
  p,
  S
};
//# sourceMappingURL=chunk-HTY52TPQ.js.map
