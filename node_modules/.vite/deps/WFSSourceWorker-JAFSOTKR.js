import {
  H
} from "./chunk-SCYZEDVN.js";
import "./chunk-PODY5IF6.js";
import {
  I,
  T
} from "./chunk-CKK5HS7D.js";
import {
  d as d3
} from "./chunk-TG63P74N.js";
import {
  m
} from "./chunk-M72PBKGH.js";
import "./chunk-APDPMAO5.js";
import {
  ee
} from "./chunk-R6YQG4NY.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-BKDPNGLX.js";
import {
  f,
  g
} from "./chunk-D5EV57FM.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-YBMFRTPB.js";
import {
  rt,
  st
} from "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-Z36PKTLY.js";
import "./chunk-S2P7FTAG.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-PRUCXFZ4.js";
import "./chunk-KLV5OJVG.js";
import "./chunk-TQGXXOXA.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-ITRH3PGV.js";
import "./chunk-BRDC7DKL.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  d as d2
} from "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-3GSONYPC.js";
import {
  S2 as S,
  p
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import {
  d,
  s as s3
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/WFSSourceWorker.js
var d4 = class {
  constructor() {
    this._queryEngine = null, this._customParameters = null, this._snapshotFeatures = async (e) => {
      const { objectIdField: t } = this._queryEngine, r2 = await H(this._getFeatureUrl ?? "", this._featureType.typeName, this._getFeatureOutputFormat, { customParameters: this._customParameters, dateFields: this._queryEngine.fieldsIndex.dateFields.map((e2) => e2.name), signal: e });
      await T(r2), s3(e);
      const a = I(r2, { geometryType: this._queryEngine.geometryType, hasZ: false, objectIdField: t });
      if (!S(this._queryEngine.spatialReference, p))
        for (const s4 of a)
          null != s4.geometry && (s4.geometry = rt(g(st(s4.geometry, this._queryEngine.geometryType, false, false), p, this._queryEngine.spatialReference)));
      let p2 = 1;
      for (const s4 of a) {
        const e2 = {};
        d3(this._fieldsIndex, e2, s4.attributes, true), s4.attributes = e2, null == s4.attributes[t] && (s4.objectId = s4.attributes[t] = p2++);
      }
      return a;
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, t) {
    const { getFeatureUrl: r2, getFeatureOutputFormat: a, spatialReference: i, fields: n, geometryType: o, featureType: u, objectIdField: h, customParameters: y } = e;
    this._featureType = u, this._customParameters = y, this._getFeatureUrl = r2, this._getFeatureOutputFormat = a, this._fieldsIndex = new r(n), await this._checkProjection(i), s3(t), this._queryEngine = new ee({ fields: n, geometryType: o, hasM: false, hasZ: false, objectIdField: h, spatialReference: i, timeInfo: null, featureStore: new m({ geometryType: o, hasM: false, hasZ: false }) });
    const l = await this._snapshotFeatures(t.signal);
    return this._queryEngine.featureStore.addMany(l), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async applyEdits() {
    throw new s2("wfs-source:editing-not-supported", "applyEdits() is not supported on WFSLayer");
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(s4) {
    var _a;
    return this._customParameters = s4, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e) => {
      this._queryEngine.featureStore.clear(), e && this._queryEngine.featureStore.addMany(e);
    }, (e) => {
      this._queryEngine.featureStore.clear(), d(e) || s.getLogger("esri.layers.WFSLayer").error(new s2("wfs-layer:getfeature-error", "An error occurred during the GetFeature request", { error: e }));
    }), await this._waitSnapshotComplete(), { extent: (await this._queryEngine.fetchRecomputedExtents()).fullExtent };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _checkProjection(e) {
    try {
      await f(p, e);
    } catch {
      throw new s2("unsupported-projection", "Projection not supported", { spatialReference: e });
    }
  }
};
export {
  d4 as default
};
//# sourceMappingURL=WFSSourceWorker-JAFSOTKR.js.map
