import {
  s
} from "./chunk-VD2BLFWE.js";
import {
  e
} from "./chunk-3TMT4LDG.js";
import {
  A,
  B,
  C,
  D,
  E,
  F,
  G,
  H,
  I,
  L,
  M,
  O,
  S,
  T,
  U,
  V,
  a,
  b,
  c,
  d,
  g,
  h,
  i,
  j,
  k,
  l,
  m,
  o,
  p,
  q,
  u,
  v,
  w,
  x,
  y,
  z
} from "./chunk-FJXAEGHD.js";

// node_modules/@arcgis/core/views/3d/support/buffer/InterleavedLayout.js
var D2 = class _D {
  constructor(t, e2) {
    this.layout = t, this.buffer = "number" == typeof e2 ? new ArrayBuffer(e2 * t.stride) : e2;
    for (const i2 of t.fields.keys()) {
      const e3 = t.fields.get(i2);
      this[i2] = new e3.constructor(this.buffer, e3.offset, this.stride);
    }
  }
  get stride() {
    return this.layout.stride;
  }
  get count() {
    return this.buffer.byteLength / this.stride;
  }
  get byteLength() {
    return this.buffer.byteLength;
  }
  getField(t, e2) {
    const i2 = this[t];
    return i2 && i2.elementCount === e2.ElementCount && i2.elementType === e2.ElementType ? i2 : null;
  }
  slice(t, e2) {
    return new _D(this.layout, this.buffer.slice(t * this.stride, e2 * this.stride));
  }
  copyFrom(t, e2 = 0, i2 = 0, s2 = t.count) {
    const r = this.stride;
    if (r % 4 == 0) {
      const n = new Uint32Array(t.buffer, e2 * r, s2 * r / 4);
      new Uint32Array(this.buffer, i2 * r, s2 * r / 4).set(n);
    } else {
      const n = new Uint8Array(t.buffer, e2 * r, s2 * r);
      new Uint8Array(this.buffer, i2 * r, s2 * r).set(n);
    }
    return this;
  }
};
var G2 = class _G {
  constructor(t = null) {
    this._stride = 0, this._lastAligned = 0, this._fields = /* @__PURE__ */ new Map(), t && (this._stride = t.stride, t.fields.forEach((t2) => this._fields.set(t2[0], { ...t2[1], constructor: N(t2[1].constructor) })));
  }
  vec2f(e2, i2) {
    return this._appendField(e2, u, i2), this;
  }
  vec2f64(t, i2) {
    return this._appendField(t, m, i2), this;
  }
  vec3f(t, e2) {
    return this._appendField(t, i, e2), this;
  }
  vec3f64(t, e2) {
    return this._appendField(t, T, e2), this;
  }
  vec4f(t, e2) {
    return this._appendField(t, c, e2), this;
  }
  vec4f64(t, e2) {
    return this._appendField(t, h, e2), this;
  }
  mat3f(t, e2) {
    return this._appendField(t, l, e2), this;
  }
  mat3f64(t, e2) {
    return this._appendField(t, a, e2), this;
  }
  mat4f(t, e2) {
    return this._appendField(t, p, e2), this;
  }
  mat4f64(t, e2) {
    return this._appendField(t, b, e2), this;
  }
  vec4u8(t, e2) {
    return this._appendField(t, x, e2), this;
  }
  f32(t, e2) {
    return this._appendField(t, y, e2), this;
  }
  f64(t, e2) {
    return this._appendField(t, o, e2), this;
  }
  u8(t, e2) {
    return this._appendField(t, d, e2), this;
  }
  u16(t, e2) {
    return this._appendField(t, g, e2), this;
  }
  i8(t, e2) {
    return this._appendField(t, j, e2), this;
  }
  vec2i8(t, e2) {
    return this._appendField(t, V, e2), this;
  }
  vec2i16(t, e2) {
    return this._appendField(t, q, e2), this;
  }
  vec2u8(t, e2) {
    return this._appendField(t, A, e2), this;
  }
  vec4u16(t, e2) {
    return this._appendField(t, L, e2), this;
  }
  u32(t, e2) {
    return this._appendField(t, B, e2), this;
  }
  _appendField(t, e2, i2) {
    if (this._fields.has(t))
      return void s(false, `${t} already added to vertex buffer layout`);
    const s2 = e2.ElementCount * e(e2.ElementType), r = this._stride;
    this._stride += s2, this._fields.set(t, { size: s2, constructor: e2, offset: r, optional: i2 });
  }
  createBuffer(t) {
    return new D2(this, t);
  }
  createView(t) {
    return new D2(this, t);
  }
  clone() {
    const t = new _G();
    return t._stride = this._stride, t._fields = /* @__PURE__ */ new Map(), this._fields.forEach((e2, i2) => t._fields.set(i2, e2)), t.BufferType = this.BufferType, t;
  }
  get stride() {
    if (this._lastAligned !== this._fields.size) {
      let t = 1;
      this._fields.forEach((e2) => t = Math.max(t, e(e2.constructor.ElementType))), this._stride = Math.floor((this._stride + t - 1) / t) * t, this._lastAligned = this._fields.size;
    }
    return this._stride;
  }
  get fields() {
    return this._fields;
  }
};
function H2() {
  return new G2();
}
var I2 = class {
  constructor(t) {
    this.fields = new Array(), t.fields.forEach((t2, e2) => {
      const i2 = { ...t2, constructor: K(t2.constructor) };
      this.fields.push([e2, i2]);
    }), this.stride = t.stride;
  }
};
var J = [y, u, i, c, l, p, o, m, T, h, a, b, d, A, O, x, g, w, E, L, B, F, I, U, j, V, M, S, k, q, v, z, C, D, G, H];
function K(t) {
  return `${t.ElementType}_${t.ElementCount}`;
}
function N(t) {
  return O2.get(t);
}
var O2 = /* @__PURE__ */ new Map();
J.forEach((t) => O2.set(K(t), t));

export {
  H2 as H,
  I2 as I
};
//# sourceMappingURL=chunk-QOPVYP7U.js.map
