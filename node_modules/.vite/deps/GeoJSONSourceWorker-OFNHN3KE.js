import {
  I,
  L,
  T
} from "./chunk-CKK5HS7D.js";
import {
  c,
  d as d3,
  h,
  u,
  y
} from "./chunk-TG63P74N.js";
import {
  a,
  i as i2,
  o
} from "./chunk-P34MS5MD.js";
import "./chunk-FHYNSVC4.js";
import {
  m
} from "./chunk-M72PBKGH.js";
import "./chunk-APDPMAO5.js";
import {
  ee
} from "./chunk-R6YQG4NY.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-BKDPNGLX.js";
import {
  f,
  g
} from "./chunk-D5EV57FM.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-YBMFRTPB.js";
import {
  et,
  nt,
  rt,
  st,
  tt
} from "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import "./chunk-TDPKDZC3.js";
import "./chunk-M5UHI5WR.js";
import "./chunk-Z36PKTLY.js";
import "./chunk-S2P7FTAG.js";
import {
  i
} from "./chunk-WZAASLQW.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-PRUCXFZ4.js";
import "./chunk-KLV5OJVG.js";
import "./chunk-TQGXXOXA.js";
import "./chunk-SO7CVIZK.js";
import "./chunk-ITRH3PGV.js";
import "./chunk-BRDC7DKL.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import {
  B
} from "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  d as d2
} from "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import {
  v
} from "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-3GSONYPC.js";
import {
  S2 as S,
  p
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import {
  d
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var O = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
var C = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t = await this._fetch(e);
      return this._createFeatures(t);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._fieldsIndex = this._createDefaultAttributes = null;
  }
  async load(e, t = {}) {
    this._loadOptions = { url: e.url, customParameters: e.customParameters };
    const i3 = [];
    await this._checkProjection(e.spatialReference);
    let r2 = null;
    e.url && (r2 = await this._fetch(t == null ? void 0 : t.signal));
    const n = L(r2, { geometryType: e.geometryType }), o2 = e.fields || n.fields || [], l = null != e.hasZ ? e.hasZ : n.hasZ, u2 = n.geometryType;
    let d4 = e.objectIdField || n.objectIdFieldName || "__OBJECTID";
    const p2 = e.spatialReference || p;
    let c2 = e.timeInfo;
    o2 === n.fields && n.unknownFields.length > 0 && i3.push({ name: "geojson-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: n.unknownFields } });
    let y2 = new r(o2).get(d4);
    y2 ? ("esriFieldTypeString" !== y2.type && (y2.type = "esriFieldTypeOID"), y2.editable = false, y2.nullable = false, d4 = y2.name) : (y2 = { alias: d4, name: d4, type: "string" === n.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID", editable: false, nullable: false }, o2.unshift(y2));
    const m2 = {};
    for (const a2 of o2) {
      if (null == a2.name && (a2.name = a2.alias), null == a2.alias && (a2.alias = a2.name), !a2.name)
        throw new s2("geojson-layer:invalid-field-name", "field name is missing", { field: a2 });
      if (!i.jsonValues.includes(a2.type))
        throw new s2("geojson-layer:invalid-field-type", `invalid type for field "${a2.name}"`, { field: a2 });
      if (a2.name !== y2.name) {
        const e2 = B(a2);
        void 0 !== e2 && (m2[a2.name] = e2);
      }
    }
    this._fieldsIndex = new r(o2);
    const _ = this._fieldsIndex.requiredFields.indexOf(y2);
    if (_ > -1 && this._fieldsIndex.requiredFields.splice(_, 1), c2) {
      if (c2.startTimeField) {
        const e2 = this._fieldsIndex.get(c2.startTimeField);
        e2 ? (c2.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.startTimeField = null;
      }
      if (c2.endTimeField) {
        const e2 = this._fieldsIndex.get(c2.endTimeField);
        e2 ? (c2.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.endTimeField = null;
      }
      if (c2.trackIdField) {
        const e2 = this._fieldsIndex.get(c2.trackIdField);
        e2 ? c2.trackIdField = e2.name : (c2.trackIdField = null, i3.push({ name: "geojson-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: c2 } }));
      }
      c2.startTimeField || c2.endTimeField || (i3.push({ name: "geojson-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: c2 } }), c2 = null);
    }
    const I2 = u2 ? o(u2) : void 0, b = { warnings: i3, featureErrors: [], layerDefinition: { ...O, drawingInfo: I2 ?? void 0, templates: a(m2), extent: void 0, geometryType: u2, objectIdField: d4, fields: o2, hasZ: !!l, timeInfo: c2 } };
    this._queryEngine = new ee({ fields: o2, geometryType: u2, hasM: false, hasZ: l, objectIdField: d4, spatialReference: p2, timeInfo: c2, featureStore: new m({ geometryType: u2, hasM: false, hasZ: l }), cacheSpatialQueries: true }), this._createDefaultAttributes = i2(m2, d4);
    const w = await this._createFeatures(r2);
    this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, w);
    const T2 = this._normalizeFeatures(w, b.warnings, b.featureErrors);
    this._queryEngine.featureStore.addMany(T2);
    const { fullExtent: x, timeExtent: q } = await this._queryEngine.fetchRecomputedExtents();
    if (b.layerDefinition.extent = x, q) {
      const { start: e2, end: t2 } = q;
      b.layerDefinition.timeInfo.timeExtent = [e2, t2];
    }
    return b;
  }
  async applyEdits(e) {
    const { spatialReference: t, geometryType: s3 } = this._queryEngine;
    return await Promise.all([y(t, s3), f(e.adds, t), f(e.updates, t)]), await this._waitSnapshotComplete(), this._applyEdits(e);
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(e) {
    var _a;
    this._loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
      const t = this._normalizeFeatures(e2);
      t && this._queryEngine.featureStore.addMany(t);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), d(e2) || s.getLogger("esri.layers.GeoJSONLayer").error(new s2("geojson-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: n, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n, timeExtent: a2 };
  }
  async _createFeatures(e) {
    if (null == e)
      return [];
    const { geometryType: t, hasZ: s3, objectIdField: i3 } = this._queryEngine, r2 = I(e, { geometryType: t, hasZ: s3, objectIdField: i3 });
    if (!S(this._queryEngine.spatialReference, p))
      for (const n of r2)
        null != n.geometry && (n.geometry = rt(g(st(n.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), p, this._queryEngine.spatialReference)));
    return r2;
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: s3, customParameters: i3 } = this._loadOptions, r2 = (await j(s3, { responseType: "json", query: { ...i3 }, signal: t })).data;
    return await T(r2), r2;
  }
  _normalizeFeatures(e, t, s3) {
    const { objectIdField: i3 } = this._queryEngine, r2 = [];
    for (const n of e) {
      const e2 = this._createDefaultAttributes(), a2 = d3(this._fieldsIndex, e2, n.attributes, true, t);
      a2 ? s3 == null ? void 0 : s3.push(a2) : (this._assignObjectId(e2, n.attributes, true), n.attributes = e2, n.objectId = e2[i3], r2.push(n));
    }
    return r2;
  }
  async _applyEdits(e) {
    const { adds: t, updates: s3, deletes: i3 } = e, r2 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if (t && t.length && this._applyAddEdits(r2, t), s3 && s3.length && this._applyUpdateEdits(r2, s3), i3 && i3.length) {
      for (const e2 of i3)
        r2.deleteResults.push(c(e2));
      this._queryEngine.featureStore.removeManyById(i3);
    }
    const { fullExtent: n, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n, timeExtent: a2, featureEditResults: r2 };
  }
  _applyAddEdits(e, t) {
    const { addResults: s3 } = e, { geometryType: i3, hasM: r2, hasZ: a2, objectIdField: o2, spatialReference: l, featureStore: u2 } = this._queryEngine, p2 = [];
    for (const d4 of t) {
      if (d4.geometry && i3 !== v(d4.geometry)) {
        s3.push(u("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), r3 = d3(this._fieldsIndex, t2, d4.attributes);
      if (r3)
        s3.push(r3);
      else {
        if (this._assignObjectId(t2, d4.attributes), d4.attributes = t2, null != d4.uid) {
          const t3 = d4.attributes[o2];
          e.uidToObjectId[d4.uid] = t3;
        }
        if (null != d4.geometry) {
          const e2 = d4.geometry.spatialReference ?? l;
          d4.geometry = g(h(d4.geometry, e2), e2, l);
        }
        p2.push(d4), s3.push(c(d4.attributes[o2]));
      }
    }
    u2.addMany(et([], p2, i3, a2, r2, o2));
  }
  _applyUpdateEdits({ updateResults: e }, t) {
    const { geometryType: s3, hasM: i3, hasZ: r2, objectIdField: a2, spatialReference: o2, featureStore: l } = this._queryEngine;
    for (const u2 of t) {
      const { attributes: t2, geometry: d4 } = u2, h2 = t2 && t2[a2];
      if (null == h2) {
        e.push(u(`Identifier field ${a2} missing`));
        continue;
      }
      if (!l.has(h2)) {
        e.push(u(`Feature with object id ${h2} missing`));
        continue;
      }
      const y2 = nt(l.getFeature(h2), s3, r2, i3);
      if (null != d4) {
        if (s3 !== v(d4)) {
          e.push(u("Incorrect geometry type."));
          continue;
        }
        const t3 = d4.spatialReference ?? o2;
        y2.geometry = g(h(d4, t3), t3, o2);
      }
      if (t2) {
        const s4 = d3(this._fieldsIndex, y2.attributes, t2);
        if (s4) {
          e.push(s4);
          continue;
        }
      }
      l.add(tt(y2, s3, r2, i3, a2)), e.push(c(h2));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s3 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s3.type)
      return () => s3.name + "-" + Date.now().toString(16);
    let i3 = Number.NEGATIVE_INFINITY;
    for (const r2 of t)
      r2.objectId && (i3 = Math.max(i3, r2.objectId));
    return i3 = Math.max(0, i3) + 1, () => i3++;
  }
  _assignObjectId(e, t, s3 = false) {
    const i3 = this._queryEngine.objectIdField;
    e[i3] = s3 && i3 in t ? t[i3] : this._objectIdGenerator();
  }
  async _checkProjection(e) {
    try {
      await f(p, e);
    } catch {
      throw new s2("geojson-layer", "Projection not supported");
    }
  }
};
export {
  C as default
};
//# sourceMappingURL=GeoJSONSourceWorker-OFNHN3KE.js.map
