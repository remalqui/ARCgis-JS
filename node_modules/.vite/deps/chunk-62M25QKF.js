import {
  e
} from "./chunk-TNXVIMSN.js";
import {
  c
} from "./chunk-XFLBB3FK.js";
import {
  p
} from "./chunk-E4GDJ764.js";
import {
  A
} from "./chunk-Z2T56FN3.js";
import {
  d
} from "./chunk-RL6GG46M.js";
import {
  b
} from "./chunk-YC4PIRSZ.js";
import {
  M
} from "./chunk-VFQINJTY.js";
import {
  h
} from "./chunk-7E3Q7HTF.js";
import {
  s as s2
} from "./chunk-VBD33VNW.js";
import {
  u
} from "./chunk-CIDWM2UN.js";
import {
  n
} from "./chunk-MH2LNFJK.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var d2 = new s2({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function y(t, e2, n2, o) {
  const s3 = await C(t);
  if (await f(t, e2, o), !s3.addAttachment)
    throw new s(o, "Layer source does not support addAttachment capability");
  return s3.addAttachment(e2, n2);
}
function f(t, e2, n2) {
  const { attributes: o } = e2, { objectIdField: s3 } = t;
  return t.get("capabilities.data.supportsAttachment") ? e2 ? o ? s3 && o[s3] ? Promise.resolve() : Promise.reject(new s(n2, `feature is missing the identifying attribute ${s3}`)) : Promise.reject(new s(n2, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(n2, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(n2, "this layer doesn't support attachments"));
}
async function m(t, e2, n2, o, s3) {
  const a = await C(t);
  if (await f(t, e2, s3), !a.updateAttachment)
    throw new s(s3, "Layer source does not support updateAttachment capability");
  return a.updateAttachment(e2, n2, o);
}
async function h2(t, e2, r) {
  const { applyEdits: n2 } = await import("./editingSupport-6GK7R2PV.js"), o = await t.load();
  return n2(o, o.source, e2, r);
}
async function w(t, e2, r) {
  const { uploadAssets: n2 } = await import("./editingSupport-6GK7R2PV.js"), o = await t.load();
  return n2(o, o.source, e2, r);
}
async function b2(t, e2, n2, o) {
  const s3 = await C(t);
  if (await f(t, e2, o), !s3.deleteAttachments)
    throw new s(o, "Layer source does not support deleteAttachments capability");
  return s3.deleteAttachments(e2, n2);
}
async function g(t, e2, n2) {
  const o = (await t.load({ signal: e2 == null ? void 0 : e2.signal })).source;
  if (!o.fetchRecomputedExtents)
    throw new s(n2, "Layer source does not support fetchUpdates capability");
  return o.fetchRecomputedExtents(e2);
}
async function j(t, e2, n2, o) {
  var _a, _b;
  e2 = c.from(e2), await t.load();
  const s3 = t.source, a = t.capabilities;
  if (!((_a = a == null ? void 0 : a.data) == null ? void 0 : _a.supportsAttachment))
    throw new s(o, "this layer doesn't support attachments");
  const { attachmentTypes: i, objectIds: u2, globalIds: p2, num: l, size: d3, start: y2, where: f2 } = e2;
  if (!((_b = a == null ? void 0 : a.operations) == null ? void 0 : _b.supportsQueryAttachments)) {
    if ((i == null ? void 0 : i.length) > 0 || (p2 == null ? void 0 : p2.length) > 0 || (d3 == null ? void 0 : d3.length) > 0 || l || y2 || f2)
      throw new s(o, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", e2);
  }
  if (!((u2 == null ? void 0 : u2.length) || (p2 == null ? void 0 : p2.length) || f2))
    throw new s(o, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", e2);
  if (!s3.queryAttachments)
    throw new s(o, "Layer source does not support queryAttachments capability", e2);
  return s3.queryAttachments(e2);
}
async function q(t, e2, n2, o) {
  const s3 = await C(t);
  if (!s3.queryObjectIds)
    throw new s(o, "Layer source does not support queryObjectIds capability");
  return s3.queryObjectIds(b.from(e2) ?? t.createQuery(), n2);
}
async function F(t, e2, n2, o) {
  const s3 = await C(t);
  if (!s3.queryFeatureCount)
    throw new s(o, "Layer source does not support queryFeatureCount capability");
  return s3.queryFeatureCount(b.from(e2) ?? t.createQuery(), n2);
}
async function I(t, e2, n2, o) {
  const s3 = await C(t);
  if (!s3.queryExtent)
    throw new s(o, "Layer source does not support queryExtent capability");
  return s3.queryExtent(b.from(e2) ?? t.createQuery(), n2);
}
async function P(t, e2, n2, o) {
  const s3 = await C(t);
  if (!s3.queryRelatedFeatures)
    throw new s(o, "Layer source does not support queryRelatedFeatures capability");
  return s3.queryRelatedFeatures(d.from(e2), n2);
}
async function A2(t, e2, n2, o) {
  const s3 = await C(t);
  if (!s3.queryRelatedFeaturesCount)
    throw new s(o, "Layer source does not support queryRelatedFeaturesCount capability");
  return s3.queryRelatedFeaturesCount(d.from(e2), n2);
}
async function O(t) {
  const e2 = t.source;
  if (e2 == null ? void 0 : e2.refresh)
    try {
      const { dataChanged: r, updates: n2 } = await e2.refresh();
      if (null != n2 && (t.sourceJSON = { ...t.sourceJSON, ...n2 }, t.read(n2, { origin: "service", url: t.parsedUrl })), r)
        return true;
    } catch {
    }
  if (t.definitionExpression)
    try {
      return (await e(t.definitionExpression, t.fieldsIndex)).hasDateFunctions;
    } catch {
    }
  return false;
}
function E(t) {
  const e2 = new b(), r = t.get("capabilities.data"), n2 = t.get("capabilities.query");
  e2.historicMoment = t.historicMoment, e2.gdbVersion = t.gdbVersion, e2.returnGeometry = true, n2 && (e2.compactGeometryEnabled = n2.supportsCompactGeometry, e2.defaultSpatialReferenceEnabled = n2.supportsDefaultSpatialReference), r && (r.supportsZ && null != t.returnZ && (e2.returnZ = t.returnZ), r.supportsM && null != t.returnM && (e2.returnM = t.returnM)), e2.outFields = ["*"];
  const { timeOffset: o, timeExtent: s3 } = t;
  return e2.timeExtent = null != o && null != s3 ? s3.offset(-o.value, o.unit) : s3 || null, e2.multipatchOption = "multipatch" === t.geometryType ? "xyFootprint" : null, e2;
}
function S(t) {
  const { globalIdField: e2, fields: r } = t;
  if (e2)
    return e2;
  if (r) {
    for (const n2 of r)
      if ("esriFieldTypeGlobalID" === n2.type)
        return n2.name;
  }
}
function R(t) {
  const { objectIdField: e2, fields: r } = t;
  if (e2)
    return e2;
  if (r) {
    for (const n2 of r)
      if ("esriFieldTypeOID" === n2.type)
        return n2.name;
  }
}
function x(t) {
  return t.currentVersion ? t.currentVersion : t.hasOwnProperty("capabilities") || t.hasOwnProperty("drawingInfo") || t.hasOwnProperty("hasAttachments") || t.hasOwnProperty("htmlPopupType") || t.hasOwnProperty("relationships") || t.hasOwnProperty("timeInfo") || t.hasOwnProperty("typeIdField") || t.hasOwnProperty("types") ? 10 : 9.3;
}
async function C(t) {
  return (await t.load()).source;
}
async function L(e2, r) {
  if (!n)
    return;
  if (n.findCredential(e2))
    return;
  let n2;
  try {
    const o = await h(e2, r);
    o && (n2 = await n.checkSignInStatus(`${o}/sharing`));
  } catch (o) {
  }
  if (n2)
    try {
      const n3 = null != r ? r.signal : null;
      await n.getCredential(e2, { signal: n3 });
    } catch (o) {
    }
}
async function M2(t, e2) {
  var _a;
  const r = (_a = t.parsedUrl) == null ? void 0 : _a.path;
  r && G(t) && await L(r, e2);
}
function G(t) {
  const e2 = t.editFieldsInfo;
  return !(!(e2 == null ? void 0 : e2.creatorField) && !(e2 == null ? void 0 : e2.editorField)) || (t.userHasUpdateItemPrivileges ? t.hasUpdateItemRestrictions : !!t.userHasFullEditingPrivileges && t.hasFullEditingRestrictions);
}
function Q(t) {
  var _a;
  return !((_a = t.sourceJSON) == null ? void 0 : _a.isMultiServicesView) && (t.userHasUpdateItemPrivileges || t.editingEnabled);
}
var U = u({ types: M });
function v(t, e2) {
  if (t.defaultSymbol)
    return t.types && t.types.length ? new A({ defaultSymbol: U(t.defaultSymbol, t, e2), field: t.typeIdField, uniqueValueInfos: t.types.map((t2) => ({ id: t2.id, symbol: U(t2.symbol, t2, e2) })) }) : new p({ symbol: U(t.defaultSymbol, t, e2) });
}

export {
  d2 as d,
  y,
  m,
  h2 as h,
  w,
  b2 as b,
  g,
  j,
  q,
  F,
  I,
  P,
  A2 as A,
  O,
  E,
  S,
  R,
  x,
  M2 as M,
  Q,
  v
};
//# sourceMappingURL=chunk-62M25QKF.js.map
