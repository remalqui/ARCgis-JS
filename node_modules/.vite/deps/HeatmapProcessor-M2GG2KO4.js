import {
  p
} from "./chunk-GJYHS5OW.js";
import {
  o
} from "./chunk-BBJLFBMQ.js";
import {
  c
} from "./chunk-JSMUQBPG.js";
import {
  a as a2
} from "./chunk-QAWS7Y22.js";
import {
  s
} from "./chunk-SCOBW7KR.js";
import "./chunk-AHAGGZUI.js";
import "./chunk-LNMNRMVX.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-4RFFPIT2.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-XN5VV437.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HNHXEGH2.js";
import {
  n
} from "./chunk-DWOEYHKS.js";
import "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors/HeatmapProcessor.js
var d = class {
  constructor(e2, t) {
    this.offset = e2, this.extent = t;
  }
};
function l(e2) {
  const t = e2.key, s2 = /* @__PURE__ */ new Map(), r = 256, i = c, a3 = e2.tileInfoView.tileInfo.isWrappable;
  return s2.set(o(t, -1, -1, a3).id, new d([-i, -i], [i - r, i - r, i, i])), s2.set(o(t, 0, -1, a3).id, new d([0, -i], [0, i - r, i, i])), s2.set(o(t, 1, -1, a3).id, new d([i, -i], [0, i - r, r, i])), s2.set(o(t, -1, 0, a3).id, new d([-i, 0], [i - r, 0, i, i])), s2.set(o(t, 1, 0, a3).id, new d([i, 0], [0, 0, r, i])), s2.set(o(t, -1, 1, a3).id, new d([-i, i], [i - r, 0, i, r])), s2.set(o(t, 0, 1, a3).id, new d([0, i], [0, 0, i, r])), s2.set(o(t, 1, 1, a3).id, new d([i, i], [0, 0, r, r])), s2;
}
var p2 = class extends p {
  constructor() {
    super(...arguments), this.type = "heatmap", this._tileKeyToFeatureSets = /* @__PURE__ */ new Map();
  }
  initialize() {
    this.handles.add([this.tileStore.on("update", this.onTileUpdate.bind(this))]);
  }
  async update(e2, t) {
    const s2 = t.schema.processors[0];
    if ("heatmap" !== s2.type)
      return;
    a2(this._schema, s2) && (e2.mesh = true, this._schema = s2);
  }
  onTileUpdate(e2) {
    for (const t of e2.removed)
      this._tileKeyToFeatureSets.delete(t.key.id);
  }
  onTileClear(e2) {
    const t = { clear: true };
    return this._tileKeyToFeatureSets.delete(e2.key.id), this.remoteClient.invoke("tileRenderer.onTileData", { tileKey: e2.id, data: t });
  }
  async onTileMessage(e2, s2, r) {
    this._tileKeyToFeatureSets.has(e2.key.id) || this._tileKeyToFeatureSets.set(e2.key.id, /* @__PURE__ */ new Map());
    const o2 = this._tileKeyToFeatureSets.get(e2.key.id);
    if (o2 && null != s2.addOrUpdate && s2.addOrUpdate.hasFeatures && o2.set(s2.addOrUpdate.instance, s2), s2.end) {
      const s3 = [], o3 = l(e2);
      this._tileKeyToFeatureSets.forEach((r2, i) => {
        if (i === e2.key.id)
          r2.forEach((e3) => n(e3.addOrUpdate, (e4) => s3.push(e4)));
        else if (o3.has(i)) {
          const e3 = o3.get(i), [a4, n3] = e3.offset;
          r2.forEach((e4) => n(e4.addOrUpdate, (e5) => {
            const t = e5.transform(a4, n3, 1, 1);
            s3.push(t);
          }));
        }
      });
      const a3 = s(s3, this._schema.mesh, 512, 512), n2 = { tileKey: e2.key.id, intensityInfo: a3 }, d2 = [a3.matrix];
      return this.remoteClient.invoke("tileRenderer.onTileData", n2, { ...r, transferList: d2 });
    }
  }
  onTileError(e2, t, s2) {
    return this.remoteClient.invoke("tileRenderer.onTileError", { tileKey: e2.id, error: t }, s2);
  }
};
p2 = e([a("esri.views.2d.layers.features.processors.HeatmapProcessor")], p2);
var c2 = p2;
export {
  c2 as default
};
//# sourceMappingURL=HeatmapProcessor-M2GG2KO4.js.map
