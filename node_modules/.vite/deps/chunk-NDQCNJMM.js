import {
  l
} from "./chunk-R2HXL6HT.js";
import {
  e
} from "./chunk-2PAQQUAG.js";
import {
  d
} from "./chunk-SFV6XLDZ.js";

// node_modules/@arcgis/core/views/2d/tiling/LODInfo.js
function o(t, r2) {
  return [t, r2];
}
function i(t, r2, o3) {
  return t[0] = r2, t[1] = o3, t;
}
function e2(t, r2, o3, i3, e3) {
  return t[0] = r2, t[1] = o3, t[2] = i3, t[3] = e3, t;
}
var s = new e("0/0/0/0");
var n = class _n {
  static create(r2, e3, s2 = null) {
    const l2 = d(r2.spatialReference), h2 = e3.origin || o(r2.origin.x, r2.origin.y), a2 = o(r2.size[0] * e3.resolution, r2.size[1] * e3.resolution), u = o(-1 / 0, -1 / 0), m = o(1 / 0, 1 / 0), g = o(1 / 0, 1 / 0);
    null != s2 && (i(u, Math.max(0, Math.floor((s2.xmin - h2[0]) / a2[0])), Math.max(0, Math.floor((h2[1] - s2.ymax) / a2[1]))), i(m, Math.max(0, Math.floor((s2.xmax - h2[0]) / a2[0])), Math.max(0, Math.floor((h2[1] - s2.ymin) / a2[1]))), i(g, m[0] - u[0] + 1, m[1] - u[1] + 1));
    const { cols: w, rows: c } = e3;
    let d2, f, F, z;
    return !s2 && w && c && (i(u, w[0], c[0]), i(m, w[1], c[1]), i(g, w[1] - w[0] + 1, c[1] - c[0] + 1)), r2.isWrappable ? (d2 = o(Math.ceil(Math.round((l2.valid[1] - l2.valid[0]) / e3.resolution) / r2.size[0]), g[1]), f = o(Math.floor((l2.origin[0] - h2[0]) / a2[0]), u[1]), F = o(d2[0] + f[0] - 1, m[1]), z = true) : (f = u, F = m, d2 = g, z = false), new _n(e3.level, e3.resolution, e3.scale, h2, u, m, g, a2, f, F, d2, z);
  }
  constructor(t, r2, o3, i3, e3, s2, n3, l2, h2, a2, u, m) {
    this.level = t, this.resolution = r2, this.scale = o3, this.origin = i3, this.first = e3, this.last = s2, this.size = n3, this.norm = l2, this.worldStart = h2, this.worldEnd = a2, this.worldSize = u, this.wrap = m;
  }
  normalizeCol(t) {
    if (!this.wrap)
      return t;
    const r2 = this.worldSize[0];
    return t < 0 ? r2 - 1 - Math.abs((t + 1) % r2) : t % r2;
  }
  denormalizeCol(t, r2) {
    return this.wrap ? this.worldSize[0] * r2 + t : t;
  }
  getWorldForColumn(t) {
    return this.wrap ? Math.floor(t / this.worldSize[0]) : 0;
  }
  getFirstColumnForWorld(t) {
    return t * this.worldSize[0] + this.first[0];
  }
  getLastColumnForWorld(t) {
    return t * this.worldSize[0] + this.first[0] + this.size[0] - 1;
  }
  getColumnForX(t) {
    return (t - this.origin[0]) / this.norm[0];
  }
  getXForColumn(t) {
    return this.origin[0] + t * this.norm[0];
  }
  getRowForY(t) {
    return (this.origin[1] - t) / this.norm[1];
  }
  getYForRow(t) {
    return this.origin[1] - t * this.norm[1];
  }
  getTileBounds(t, r2, o3 = false) {
    s.set(r2);
    const i3 = o3 ? s.col : this.denormalizeCol(s.col, s.world), n3 = s.row;
    return e2(t, this.getXForColumn(i3), this.getYForRow(n3 + 1), this.getXForColumn(i3 + 1), this.getYForRow(n3)), t;
  }
  getTileCoords(t, r2, o3 = false) {
    s.set(r2);
    const e3 = o3 ? s.col : this.denormalizeCol(s.col, s.world);
    return Array.isArray(t) ? i(t, this.getXForColumn(e3), this.getYForRow(s.row)) : (t.x = this.getXForColumn(e3), t.y = this.getYForRow(s.row)), t;
  }
};

// node_modules/@arcgis/core/views/2d/tiling/TileSpan.js
var o2 = class {
  constructor(o3, s2, t) {
    this.row = o3, this.colFrom = s2, this.colTo = t;
  }
};

// node_modules/@arcgis/core/views/2d/tiling/TileInfoView.js
var i2 = new e("0/0/0/0");
var n2 = class _n {
  static create(e3, t) {
    e3[1] > t[1] && ([e3, t] = [t, e3]);
    const [o3, l2] = e3, [s2, i3] = t, r2 = s2 - o3, a2 = i3 - l2, h2 = 0 !== a2 ? r2 / a2 : 0, c = (Math.ceil(l2) - l2) * h2, f = (Math.floor(l2) - l2) * h2;
    return new _n(o3, Math.floor(l2), Math.ceil(i3), h2, r2 < 0 ? c : f, r2 < 0 ? f : c, r2 < 0 ? s2 : o3, r2 < 0 ? o3 : s2);
  }
  constructor(e3, t, o3, l2, s2, i3, n3, r2) {
    this.x = e3, this.ymin = t, this.ymax = o3, this.invM = l2, this.leftAdjust = s2, this.rightAdjust = i3, this.leftBound = n3, this.rightBound = r2;
  }
  incrRow() {
    this.x += this.invM;
  }
  getLeftCol() {
    return Math.max(this.x + this.leftAdjust, this.leftBound);
  }
  getRightCol() {
    return Math.min(this.x + this.rightAdjust, this.rightBound);
  }
};
var r = [[0, 0], [0, 0], [0, 0], [0, 0]];
var a = 1e-6;
var h = class {
  constructor(e3, o3 = null, l2 = e3.lods[0].level, s2 = e3.lods[e3.lods.length - 1].level) {
    this.tileInfo = e3, this.fullExtent = o3, this.scales = [], this._infoByScale = {}, this._infoByLevel = {};
    const i3 = e3.lods.filter((e4) => e4.level >= l2 && e4.level <= s2);
    this.minScale = i3[0].scale, this.maxScale = i3[i3.length - 1].scale;
    const n3 = this._lodInfos = i3.map((l3) => n.create(e3, l3, o3));
    i3.forEach((e4, t) => {
      this._infoByLevel[e4.level] = n3[t], this._infoByScale[e4.scale] = n3[t], this.scales[t] = e4.scale;
    }, this), this._wrap = e3.isWrappable;
  }
  get spatialReference() {
    return this.tileInfo.spatialReference;
  }
  getLODInfoAt(e3) {
    return this._infoByLevel["number" == typeof e3 ? e3 : e3.level];
  }
  getTileBounds(e3, t, o3 = false) {
    i2.set(t);
    const l2 = this._infoByLevel[i2.level];
    return l2 ? l2.getTileBounds(e3, i2, o3) : e3;
  }
  getTileCoords(e3, t, o3 = false) {
    i2.set(t);
    const l2 = this._infoByLevel[i2.level];
    return l2 ? l2.getTileCoords(e3, i2, o3) : e3;
  }
  getTileCoverage(e3, t = 192, l2 = true, i3 = "closest") {
    if (!l2 && (e3.scale > this.minScale || e3.scale < this.maxScale))
      return null;
    const a2 = "closest" === i3 ? this.getClosestInfoForScale(e3.scale) : this.getSmallestInfoForScale(e3.scale), h2 = l.pool.acquire(a2), c = this._wrap;
    let f, u, m, g = 1 / 0, d2 = -1 / 0;
    const v = h2.spans;
    r[0][0] = r[0][1] = r[1][1] = r[3][0] = -t, r[1][0] = r[2][0] = e3.size[0] + t, r[2][1] = r[3][1] = e3.size[1] + t;
    for (const o3 of r)
      e3.toMap(o3, o3), o3[0] = a2.getColumnForX(o3[0]), o3[1] = a2.getRowForY(o3[1]);
    const y = [];
    let _ = 3;
    for (let o3 = 0; o3 < 4; o3++) {
      if (r[o3][1] === r[_][1]) {
        _ = o3;
        continue;
      }
      const e4 = n2.create(r[o3], r[_]);
      g = Math.min(e4.ymin, g), d2 = Math.max(e4.ymax, d2), void 0 === y[e4.ymin] && (y[e4.ymin] = []), y[e4.ymin].push(e4), _ = o3;
    }
    if (null == g || null == d2 || d2 - g > 100)
      return null;
    let p = [];
    for (f = g; f < d2; ) {
      null != y[f] && (p = p.concat(y[f])), u = 1 / 0, m = -1 / 0;
      for (let e4 = p.length - 1; e4 >= 0; e4--) {
        const t2 = p[e4];
        u = Math.min(u, t2.getLeftCol()), m = Math.max(m, t2.getRightCol());
      }
      if (u = Math.floor(u), m = Math.floor(m), f >= a2.first[1] && f <= a2.last[1])
        if (c)
          if (a2.size[0] < a2.worldSize[0]) {
            const e4 = Math.floor(m / a2.worldSize[0]);
            for (let t2 = Math.floor(u / a2.worldSize[0]); t2 <= e4; t2++)
              v.push(new o2(f, Math.max(a2.getFirstColumnForWorld(t2), u), Math.min(a2.getLastColumnForWorld(t2), m)));
          } else
            v.push(new o2(f, u, m));
        else
          u > a2.last[0] || m < a2.first[0] || (u = Math.max(u, a2.first[0]), m = Math.min(m, a2.last[0]), v.push(new o2(f, u, m)));
      f += 1;
      for (let e4 = p.length - 1; e4 >= 0; e4--) {
        const t2 = p[e4];
        t2.ymax >= f ? t2.incrRow() : p.splice(e4, 1);
      }
    }
    return h2;
  }
  getTileParentId(e3) {
    i2.set(e3);
    const t = this._infoByLevel[i2.level], o3 = this._lodInfos.indexOf(t) - 1;
    return o3 < 0 ? null : (this._getTileIdAtLOD(i2, this._lodInfos[o3], i2), i2.id);
  }
  getTileResolution(e3) {
    const t = this._infoByLevel["object" == typeof e3 ? e3.level : e3];
    return t ? t.resolution : -1;
  }
  getTileScale(e3) {
    const t = this._infoByLevel[e3.level];
    return t ? t.scale : -1;
  }
  intersects(e3, t) {
    i2.set(t);
    const o3 = this._infoByLevel[i2.level], l2 = e3.lodInfo;
    if (l2.resolution > o3.resolution) {
      this._getTileIdAtLOD(i2, l2, i2);
      const t2 = l2.denormalizeCol(i2.col, i2.world);
      for (const o4 of e3.spans)
        if (o4.row === i2.row && o4.colFrom <= t2 && o4.colTo >= t2)
          return true;
    }
    if (l2.resolution < o3.resolution) {
      const [t2, s3, n3, r2] = e3.spans.reduce((e4, t3) => (e4[0] = Math.min(e4[0], t3.row), e4[1] = Math.max(e4[1], t3.row), e4[2] = Math.min(e4[2], t3.colFrom), e4[3] = Math.max(e4[3], t3.colTo), e4), [1 / 0, -1 / 0, 1 / 0, -1 / 0]), a2 = o3.denormalizeCol(i2.col, i2.world), h2 = l2.getColumnForX(o3.getXForColumn(a2)), c = l2.getRowForY(o3.getYForRow(i2.row)), f = l2.getColumnForX(o3.getXForColumn(a2 + 1)) - 1, u = l2.getRowForY(o3.getYForRow(i2.row + 1)) - 1;
      return !(h2 > r2 || f < n3 || c > s3 || u < t2);
    }
    const s2 = l2.denormalizeCol(i2.col, i2.world);
    return e3.spans.some((e4) => e4.row === i2.row && e4.colFrom <= s2 && e4.colTo >= s2);
  }
  normalizeBounds(t, o3, l2) {
    if (t[0] = o3[0], t[1] = o3[1], t[2] = o3[2], t[3] = o3[3], this._wrap) {
      const o4 = d(this.tileInfo.spatialReference), s2 = -l2 * (o4.valid[1] - o4.valid[0]);
      t[0] += s2, t[2] += s2;
    }
    return t;
  }
  getSmallestInfoForScale(e3) {
    const t = this.scales;
    if (this._infoByScale[e3])
      return this._infoByScale[e3];
    if (e3 > t[0])
      return this._infoByScale[t[0]];
    for (let o3 = 1; o3 < t.length - 1; o3++)
      if (e3 > t[o3] + a)
        return this._infoByScale[t[o3 - 1]];
    return this._infoByScale[t[t.length - 1]];
  }
  getClosestInfoForScale(e3) {
    const t = this.scales;
    return this._infoByScale[e3] || (e3 = t.reduce((t2, o3) => Math.abs(o3 - e3) < Math.abs(t2 - e3) ? o3 : t2, t[0])), this._infoByScale[e3];
  }
  scaleToLevel(e3) {
    const t = this.scales;
    if (this._infoByScale[e3])
      return this._infoByScale[e3].level;
    for (let o3 = t.length - 1; o3 >= 0; o3--)
      if (e3 < t[o3]) {
        if (o3 === t.length - 1)
          return this._infoByScale[t[t.length - 1]].level;
        return this._infoByScale[t[o3]].level + (t[o3] - e3) / (t[o3] - t[o3 + 1]);
      }
    return this._infoByScale[t[0]].level;
  }
  scaleToZoom(e3) {
    return this.tileInfo.scaleToZoom(e3);
  }
  _getTileIdAtLOD(e3, t, o3) {
    const l2 = this._infoByLevel[o3.level];
    return e3.set(o3), t.resolution < l2.resolution ? null : (t.resolution === l2.resolution || (e3.level = t.level, e3.col = Math.floor(o3.col * l2.resolution / t.resolution + 0.01), e3.row = Math.floor(o3.row * l2.resolution / t.resolution + 0.01)), e3);
  }
};

export {
  h
};
//# sourceMappingURL=chunk-NDQCNJMM.js.map
