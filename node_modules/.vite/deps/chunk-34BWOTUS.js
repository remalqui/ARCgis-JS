import {
  s as s4
} from "./chunk-JUHOAKXP.js";
import {
  M as M2,
  c,
  e as e2,
  f as f2,
  h,
  i as i3,
  r as r5
} from "./chunk-EL72ISXP.js";
import {
  n as n2,
  r as r4
} from "./chunk-VZAEQ6CY.js";
import {
  C,
  a as a3,
  g,
  j,
  l as l2,
  o as o2,
  q,
  r as r3,
  s as s3,
  v,
  y as y2,
  z
} from "./chunk-X4Y5OF5X.js";
import {
  i as i2
} from "./chunk-KTEJJM3A.js";
import {
  $,
  Cn,
  Y,
  nn
} from "./chunk-SO6DBMQG.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import {
  n
} from "./chunk-BVNZ3ETW.js";
import {
  p as p2
} from "./chunk-T4XWQYGC.js";
import {
  i
} from "./chunk-MOPR7RFH.js";
import {
  r as r2
} from "./chunk-TJB4CGOM.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  H,
  S2 as S,
  d,
  f,
  o2 as o,
  p2 as p,
  r,
  s2 as s,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import {
  s as s2
} from "./chunk-3PLRSFLA.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  a
} from "./chunk-2YSHZRCT.js";

// node_modules/@arcgis/core/Camera.js
var u = class extends i2(l) {
  constructor(...o4) {
    super(...o4), this.position = new x([0, 0, 0]), this.heading = 0, this.tilt = 0, this.fov = 55;
  }
  normalizeCtorArgs(o4, r7, t2, e4) {
    if (o4 && "object" == typeof o4 && ("x" in o4 || Array.isArray(o4))) {
      const s5 = { position: o4 };
      return null != r7 && (s5.heading = r7), null != t2 && (s5.tilt = t2), null != e4 && (s5.fov = e4), s5;
    }
    return o4;
  }
  writePosition(o4, r7, t2, e4) {
    const s5 = o4.clone();
    s5.x = a(o4.x || 0), s5.y = a(o4.y || 0), s5.z = o4.hasZ ? a(o4.z || 0) : o4.z, r7[t2] = s5.write({}, e4);
  }
  readPosition(o4, r7) {
    const t2 = new x();
    return t2.read(o4, r7), t2.x = a(t2.x || 0), t2.y = a(t2.y || 0), t2.z = t2.hasZ ? a(t2.z || 0) : t2.z, t2;
  }
  equals(o4) {
    return null != o4 && (this.tilt === o4.tilt && this.heading === o4.heading && this.fov === o4.fov && this.position.equals(o4.position));
  }
};
e([y({ type: x, json: { write: { isRequired: true } } })], u.prototype, "position", void 0), e([r("position")], u.prototype, "writePosition", null), e([o("position")], u.prototype, "readPosition", null), e([y({ type: Number, nonNullable: true, json: { write: { isRequired: true } } }), s2((o4) => s4.normalize(a(o4)))], u.prototype, "heading", void 0), e([y({ type: Number, nonNullable: true, json: { write: { isRequired: true } } }), s2((o4) => i(a(o4), -180, 180))], u.prototype, "tilt", void 0), e([y({ type: Number, nonNullable: true, json: { read: false, write: false } })], u.prototype, "fov", void 0), u = e([a2("esri.Camera")], u);
var d2 = u;

// node_modules/@arcgis/core/Viewpoint.js
var p3;
var n3 = p3 = class extends l {
  constructor(r7) {
    super(r7), this.rotation = 0, this.scale = 0, this.targetGeometry = null, this.camera = null;
  }
  castRotation(r7) {
    return (r7 %= 360) < 0 && (r7 += 360), r7;
  }
  clone() {
    return new p3({ rotation: this.rotation, scale: this.scale, targetGeometry: null != this.targetGeometry ? this.targetGeometry.clone() : null, camera: null != this.camera ? this.camera.clone() : null });
  }
};
function m() {
  return { enabled: !this.camera };
}
e([y({ type: Number, json: { write: true, origins: { "web-map": { default: 0, write: true }, "web-scene": { write: { overridePolicy: m } } } } })], n3.prototype, "rotation", void 0), e([s2("rotation")], n3.prototype, "castRotation", null), e([y({ type: Number, json: { write: true, origins: { "web-map": { default: 0, write: true }, "web-scene": { write: { overridePolicy: m } } } } })], n3.prototype, "scale", void 0), e([y({ types: n, json: { read: p2, write: true, origins: { "web-scene": { read: p2, write: { overridePolicy: m } } } } })], n3.prototype, "targetGeometry", void 0), e([y({ type: d2, json: { write: true } })], n3.prototype, "camera", void 0), n3 = p3 = e([a2("esri.Viewpoint")], n3);
var l3 = n3;

// node_modules/@arcgis/core/chunks/mat2df64.js
function e3() {
  return [1, 0, 0, 1, 0, 0];
}
function r6(e4) {
  return [e4[0], e4[1], e4[2], e4[3], e4[4], e4[5]];
}
function t(e4, r7, t2, n5, o4, a4) {
  return [e4, r7, t2, n5, o4, a4];
}
function n4(e4, r7) {
  return new Float64Array(e4, r7, 6);
}
var o3 = Object.freeze(Object.defineProperty({ __proto__: null, clone: r6, create: e3, createView: n4, fromValues: t }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/2d/viewpointUtils.js
var C2 = 96;
var E = 39.37;
var O = 180 / Math.PI;
function Q(t2) {
  return t2.wkid ? t2 : t2.spatialReference || f.WGS84;
}
function U(t2, e4) {
  return e4.type ? r3(t2, e4.x, e4.y) : a3(t2, e4);
}
function B(t2) {
  return H(t2);
}
function D(t2, e4) {
  const n5 = Math.max(1, e4[0]), r7 = Math.max(1, e4[1]);
  return Math.max(t2.width / n5, t2.height / r7) * ot(t2.spatialReference);
}
async function T(t2, n5, r7, o4) {
  var _a, _b;
  let a4, i4;
  if (!t2)
    return null;
  if (Array.isArray(t2) && !t2.length)
    return null;
  if (V.isCollection(t2) && (t2 = t2.toArray()), Array.isArray(t2) && t2.length && "object" == typeof t2[0]) {
    const e4 = t2.every((t3) => "attributes" in t3), a5 = t2.some((t3) => !t3.geometry);
    let i5 = t2;
    if (e4 && a5 && n5 && n5.allLayerViews) {
      const e5 = /* @__PURE__ */ new Map();
      for (const n6 of t2) {
        const t3 = n6.layer, r9 = e5.get(t3) || [], o6 = n6.attributes[t3.objectIdField];
        null != o6 && r9.push(o6), e5.set(t3, r9);
      }
      const r8 = [];
      e5.forEach((t3, e6) => {
        const o6 = n5.allLayerViews.find((t4) => t4.layer.id === e6.id);
        if (o6 && "queryFeatures" in o6) {
          const n6 = e6.createQuery();
          n6.objectIds = t3, n6.returnGeometry = true, r8.push(o6.queryFeatures(n6));
        }
      });
      const o5 = await Promise.all(r8), a6 = [];
      for (const t3 of o5)
        if (t3 && t3.features && t3.features.length)
          for (const e6 of t3.features)
            null != e6.geometry && a6.push(e6.geometry);
      i5 = a6;
    }
    for (const t3 of i5)
      o4 = await T(t3, n5, r7, o4);
    return o4;
  }
  if (Array.isArray(t2) && 2 === t2.length && "number" == typeof t2[0] && "number" == typeof t2[1])
    a4 = new x(t2);
  else if (t2 instanceof p)
    a4 = t2;
  else if ("geometry" in t2) {
    if (t2.geometry)
      a4 = t2.geometry;
    else if (t2.layer) {
      const e4 = t2.layer, r8 = n5.allLayerViews.find((t3) => t3.layer.id === e4.id);
      if (r8 && "queryFeatures" in r8) {
        const n6 = e4.createQuery();
        n6.objectIds = [t2.attributes[e4.objectIdField]], n6.returnGeometry = true;
        const o5 = await r8.queryFeatures(n6);
        a4 = (_b = (_a = o5 == null ? void 0 : o5.features) == null ? void 0 : _a[0]) == null ? void 0 : _b.geometry;
      }
    }
  }
  if (null == a4)
    return null;
  if (i4 = "point" === a4.type ? new M({ xmin: a4.x, ymin: a4.y, xmax: a4.x, ymax: a4.y, spatialReference: a4.spatialReference }) : a4.extent, !i4)
    return null;
  Y() || Cn(i4.spatialReference, r7) || await $();
  const c2 = nn(i4, r7);
  return c2 ? o4 = o4 ? o4.union(c2) : c2 : null;
}
function W(t2) {
  if (t2 && (!Array.isArray(t2) || "number" != typeof t2[0]) && ("object" == typeof t2 || Array.isArray(t2) && "object" == typeof t2[0])) {
    if ("layer" in t2 && t2.layer && t2.layer.minScale && t2.layer.maxScale) {
      const e4 = t2.layer;
      return { min: e4.minScale, max: e4.maxScale };
    }
    if (Array.isArray(t2) && t2.length && t2.every((t3) => "layer" in t3)) {
      let e4 = 0, n5 = 0;
      for (const r7 of t2) {
        const t3 = r7.layer;
        t3 && t3.minScale && t3.maxScale && (e4 = t3.minScale < e4 ? t3.minScale : e4, n5 = t3.maxScale > n5 ? t3.maxScale : n5);
      }
      return e4 && n5 ? { min: e4, max: n5 } : null;
    }
  }
}
function H2(t2, e4) {
  return S(Q(t2), e4) ? t2 : nn(t2, e4);
}
async function J(e4, n5) {
  if (!e4 || !n5)
    return new l3({ targetGeometry: new x(), scale: 0, rotation: 0 });
  let r7 = n5.spatialReference;
  const { constraints: o4, padding: a4, viewpoint: i4, size: c2 } = n5, s5 = [a4 ? c2[0] - a4.left - a4.right : c2[0], a4 ? c2[1] - a4.top - a4.bottom : c2[1]];
  let u2 = null;
  e4 instanceof l3 ? u2 = e4 : e4.viewpoint ? u2 = e4.viewpoint : e4.target && "esri.Viewpoint" === e4.target.declaredClass && (u2 = e4.target);
  let f3 = null;
  u2 && u2.targetGeometry ? f3 = u2.targetGeometry : e4 instanceof M ? f3 = e4 : (e4 || e4 && ("center" in e4 || "extent" in e4 || "target" in e4)) && (f3 = await T(e4.center, n5, r7) || await T(e4.extent, n5, r7) || await T(e4.target, n5, r7) || await T(e4, n5, r7)), !f3 && i4 && i4.targetGeometry ? f3 = i4.targetGeometry : !f3 && n5.extent && (f3 = n5.extent), r7 || (r7 = Q(n5.spatialReference || n5.extent || f3)), Y() || S(f3.spatialReference, r7) || Cn(f3, r7) || await $();
  const l4 = H2(f3.center ?? f3, r7);
  let m2 = 0;
  if (u2 && null != u2.targetGeometry && "point" === u2.targetGeometry.type)
    m2 = u2.scale;
  else if ("scale" in e4 && e4.scale)
    m2 = e4.scale;
  else if ("zoom" in e4 && -1 !== e4.zoom && o4 && o4.effectiveLODs)
    m2 = o4.zoomToScale(e4.zoom);
  else if (Array.isArray(f3) || "point" === f3.type || "extent" === f3.type && 0 === f3.width && 0 === f3.height) {
    const t2 = H2(n5.extent, r7);
    m2 = null != t2 ? D(t2, s5) : n5.extent ? D(n5.extent, s5) : i4.scale;
  } else
    m2 = D(H2(f3.extent, r7), s5);
  const y3 = W(e4);
  y3 && (y3.min && y3.min > m2 ? m2 = y3.min : y3.max && y3.max < m2 && (m2 = y3.max));
  let p4 = 0;
  u2 ? p4 = u2.rotation : e4.hasOwnProperty("rotation") ? p4 = e4.rotation : i4 && (p4 = i4.rotation);
  let g2 = new l3({ targetGeometry: l4, scale: m2, rotation: p4 });
  return o4 && (g2 = o4.fit(g2), o4.constrainByGeometry(g2), o4.rotationEnabled || (g2.rotation = p4)), g2;
}
function K(t2, e4) {
  const n5 = t2.targetGeometry, r7 = e4.targetGeometry;
  return n5.x = r7.x, n5.y = r7.y, n5.spatialReference = r7.spatialReference, t2.scale = e4.scale, t2.rotation = e4.rotation, t2;
}
function X(t2, e4, n5) {
  return n5 ? r3(t2, 0.5 * (e4[0] - n5.right + n5.left), 0.5 * (e4[1] - n5.bottom + n5.top)) : l2(t2, e4, 0.5);
}
var Y2 = function() {
  const t2 = n2();
  return function(e4, n5, r7) {
    const o4 = n5.targetGeometry;
    U(t2, o4);
    const a4 = 0.5 * et(n5);
    return e4.xmin = t2[0] - a4 * r7[0], e4.ymin = t2[1] - a4 * r7[1], e4.xmax = t2[0] + a4 * r7[0], e4.ymax = t2[1] + a4 * r7[1], e4.spatialReference = o4.spatialReference, e4;
  };
}();
function Z(t2, e4, n5, r7, o4) {
  var _a;
  return yt(t2, e4, n5.center), t2.scale = D(n5, r7), (_a = o4 == null ? void 0 : o4.constraints) == null ? void 0 : _a.constrain(t2), t2;
}
function $2(t2, e4, n5, r7) {
  return ct(t2, e4, n5, r7), r5(t2, t2);
}
var _ = function() {
  const t2 = n2();
  return function(e4, n5, r7) {
    return C(e4, at(e4, n5), X(t2, n5, r7));
  };
}();
var tt = function() {
  const t2 = e3(), e4 = n2();
  return function(n5, r7, c2, s5) {
    const u2 = et(r7), f3 = rt(r7);
    return r3(e4, u2, u2), M2(t2, e4), e2(t2, t2, f3), i3(t2, t2, _(e4, c2, s5)), i3(t2, t2, [0, s5.top - s5.bottom]), r3(n5, t2[4], t2[5]);
  };
}();
function et(t2) {
  return t2.scale * nt(t2.targetGeometry);
}
function nt(t2) {
  return null != t2 && s(t2.spatialReference) ? 1 / (B(t2.spatialReference) * E * C2) : 1;
}
function rt(t2) {
  return r2(t2.rotation) || 0;
}
function ot(t2) {
  return s(t2) ? B(t2) * E * C2 : 1;
}
function at(t2, e4) {
  return l2(t2, e4, 0.5);
}
var it = function() {
  const t2 = n2(), e4 = n2(), n5 = n2();
  return function(r7, o4, u2, f3, l4, p4) {
    return g(t2, o4), l2(e4, u2, 0.5 * p4), r3(n5, 1 / f3 * p4, -1 / f3 * p4), f2(r7, e4), l4 && e2(r7, r7, l4), c(r7, r7, n5), i3(r7, r7, t2), r7;
  };
}();
var ct = function() {
  const t2 = n2();
  return function(e4, n5, r7, o4) {
    const a4 = et(n5), i4 = rt(n5);
    return U(t2, n5.targetGeometry), it(e4, t2, r7, a4, i4, o4);
  };
}();
var st = function() {
  const t2 = n2();
  return function(e4, n5, r7, o4) {
    const a4 = et(n5);
    return U(t2, n5.targetGeometry), it(e4, t2, r7, a4, 0, o4);
  };
}();
function ut(t2) {
  const e4 = d(t2);
  return e4 ? e4.valid[1] - e4.valid[0] : 0;
}
function ft(t2, e4) {
  return Math.round(ut(t2) / e4);
}
var lt = function() {
  const t2 = n2(), e4 = n2(), n5 = [0, 0, 0];
  return function(r7, o4, a4) {
    o2(t2, r7, o4), v(t2, t2), o2(e4, r7, a4), v(e4, e4), y2(n5, t2, e4);
    let i4 = Math.acos(j(t2, e4) / (q(t2) * q(e4))) * O;
    return n5[2] < 0 && (i4 = -i4), isNaN(i4) && (i4 = 0), i4;
  };
}();
var mt = function() {
  const t2 = n2();
  return function(e4, n5, r7, o4) {
    const a4 = e4.targetGeometry;
    return K(e4, n5), tt(t2, n5, r7, o4), a4.x += t2[0], a4.y += t2[1], e4;
  };
}();
var yt = function(t2, e4, n5) {
  K(t2, e4);
  const r7 = t2.targetGeometry;
  return r7.x = n5.x, r7.y = n5.y, r7.spatialReference = n5.spatialReference, t2;
};
var pt = function() {
  const t2 = n2();
  return function(e4, n5, r7, o4, a4) {
    a4 || (a4 = "center"), C(t2, r7, o4), l2(t2, t2, 0.5);
    const i4 = t2[0], c2 = t2[1];
    switch (a4) {
      case "center":
        r3(t2, 0, 0);
        break;
      case "left":
        r3(t2, -i4, 0);
        break;
      case "top":
        r3(t2, 0, c2);
        break;
      case "right":
        r3(t2, i4, 0);
        break;
      case "bottom":
        r3(t2, 0, -c2);
        break;
      case "top-left":
        r3(t2, -i4, c2);
        break;
      case "bottom-left":
        r3(t2, -i4, -c2);
        break;
      case "top-right":
        r3(t2, i4, c2);
        break;
      case "bottom-right":
        r3(t2, i4, -c2);
    }
    return Rt(e4, n5, t2), e4;
  };
}();
function gt(t2, e4, n5) {
  return K(t2, e4), t2.rotation += n5, t2;
}
function xt(t2, e4, n5) {
  return K(t2, e4), t2.rotation = n5, t2;
}
var ht = function() {
  const t2 = n2();
  return function(e4, n5, r7, o4, a4) {
    return K(e4, n5), isNaN(r7) || 0 === r7 || (jt(t2, o4, n5, a4), e4.scale = n5.scale * r7, Gt(t2, t2, e4, a4), Rt(e4, e4, r3(t2, t2[0] - o4[0], o4[1] - t2[1]))), e4;
  };
}();
function bt(t2, e4, n5) {
  return K(t2, e4), t2.scale = n5, t2;
}
var wt = function() {
  const t2 = n2();
  return function(e4, n5, r7, o4, a4, i4) {
    return K(e4, n5), isNaN(r7) || 0 === r7 || (jt(t2, a4, n5, i4), e4.scale = n5.scale * r7, e4.rotation += o4, Gt(t2, t2, e4, i4), Rt(e4, e4, r3(t2, t2[0] - a4[0], a4[1] - t2[1]))), e4;
  };
}();
var dt = function() {
  const t2 = n2(), e4 = n2();
  return function(n5, r7, o4, a4, i4, c2, s5) {
    return _(e4, c2, s5), s3(t2, i4, e4), a4 ? wt(n5, r7, o4, a4, t2, c2) : ht(n5, r7, o4, t2, c2);
  };
}();
var jt = function() {
  const t2 = e3();
  return function(e4, n5, r7, o4) {
    return z(e4, n5, $2(t2, r7, o4, 1));
  };
}();
var Gt = function() {
  const t2 = e3();
  return function(e4, n5, r7, o4) {
    return z(e4, n5, ct(t2, r7, o4, 1));
  };
}();
var Rt = function() {
  const t2 = n2(), e4 = e3();
  return function(n5, r7, o4) {
    K(n5, r7);
    const a4 = et(r7), i4 = n5.targetGeometry;
    return h(e4, rt(r7)), c(e4, e4, r4(a4, a4)), z(t2, o4, e4), i4.x += t2[0], i4.y += t2[1], n5;
  };
}();

export {
  l3 as l,
  e3 as e,
  D,
  J,
  K,
  X,
  Y2 as Y,
  Z,
  _,
  et,
  it,
  ct,
  st,
  ut,
  ft,
  lt,
  mt,
  yt,
  pt,
  gt,
  xt,
  bt,
  wt,
  dt,
  Rt
};
//# sourceMappingURL=chunk-34BWOTUS.js.map
