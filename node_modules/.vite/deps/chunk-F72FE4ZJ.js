import {
  M as M2
} from "./chunk-MOPR7RFH.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  d
} from "./chunk-SFV6XLDZ.js";
import {
  s as s5
} from "./chunk-3PLRSFLA.js";
import {
  s as s4
} from "./chunk-VBD33VNW.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  s as s3
} from "./chunk-HNHXEGH2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  has,
  t
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/layers/support/SimpleBandStatistics.js
var l2 = class {
  constructor(l5 = null, a6 = null, t3 = null) {
    this.minValue = l5, this.maxValue = a6, this.noDataValue = t3;
  }
};

// node_modules/@arcgis/core/layers/support/rasterFormats/pixelRangeUtils.js
var t2 = 9999999e31;
var e2 = 2e-7;
var n = { u1: [0, 1], u2: [0, 3], u4: [0, 15], u8: [0, 255], s8: [-128, 127], u16: [0, 65535], s16: [-32768, 32767], u32: [0, 4294967295], s32: [-2147483648, 2147483647], f32: [-34028234663852886e22, 34028234663852886e22], f64: [-Number.MAX_VALUE, Number.MAX_VALUE], unknown: void 0, c64: void 0, c128: void 0 };
function s6(t3) {
  return n[t3] ?? [-34028234663852886e22, 34028234663852886e22];
}
function u(n3, u6, i4) {
  if (n3.depthCount && n3.depthCount > 1)
    return;
  const { pixels: a6, statistics: o3, pixelType: l5 } = n3, r3 = a6[0].length, f4 = n3.bandMasks ?? [], c5 = n3.mask ?? new Uint8Array(r3).fill(255), b3 = "f32" === l5 || "f64" === l5, m4 = s6(l5);
  let d5 = false;
  for (let s9 = 0; s9 < a6.length; s9++) {
    const n4 = "number" == typeof u6 ? u6 : u6[s9];
    if (null == n4)
      continue;
    const h4 = (o3 == null ? void 0 : o3[s9].minValue) ?? m4[0], p5 = (o3 == null ? void 0 : o3[s9].maxValue) ?? m4[1];
    if (h4 > n4 + Number.EPSILON || p5 < n4 - Number.EPSILON)
      continue;
    const N = f4[s9] || new Uint8Array(r3).fill(255), M5 = a6[s9], A3 = i4 == null ? void 0 : i4.customFloatTolerance;
    if (b3 && 0 !== A3) {
      let s10 = A3;
      s10 || (s10 = Math.abs(n4) >= t2 ? e2 * Math.abs(n4) : "f32" === l5 ? 2 ** -23 : Number.EPSILON);
      for (let t3 = 0; t3 < M5.length; t3++)
        N[t3] && Math.abs(M5[t3] - n4) < s10 && (M5[t3] = 0, N[t3] = 0, c5[t3] = 0, d5 = true);
    } else
      for (let t3 = 0; t3 < M5.length; t3++)
        N[t3] && M5[t3] === n4 && (M5[t3] = 0, N[t3] = 0, c5[t3] = 0, d5 = true);
    f4[s9] = N;
  }
  d5 && (n3.bandMasks = f4, n3.mask = c5), d5 && "updateStatistics" in n3 && n3.updateStatistics();
}

// node_modules/@arcgis/core/layers/support/PixelBlock.js
var p;
var c = p = class extends l {
  static createEmptyBand(t3, e3) {
    return new (p.getPixelArrayConstructor(t3))(e3);
  }
  static getPixelArrayConstructor(t3) {
    let e3;
    switch (t3) {
      case "u1":
      case "u2":
      case "u4":
      case "u8":
        e3 = Uint8Array;
        break;
      case "u16":
        e3 = Uint16Array;
        break;
      case "u32":
        e3 = Uint32Array;
        break;
      case "s8":
        e3 = Int8Array;
        break;
      case "s16":
        e3 = Int16Array;
        break;
      case "s32":
        e3 = Int32Array;
        break;
      case "f32":
      case "c64":
      case "c128":
      case "unknown":
        e3 = Float32Array;
        break;
      case "f64":
        e3 = Float64Array;
    }
    return e3;
  }
  constructor(t3) {
    super(t3), this.width = null, this.height = null, this.pixelType = "f32", this.validPixelCount = null, this.mask = null, this.maskIsAlpha = false, this.premultiplyAlpha = false, this.statistics = null, this.depthCount = 1;
  }
  castPixelType(t3) {
    if (!t3)
      return "f32";
    let e3 = t3.toLowerCase();
    return ["u1", "u2", "u4"].includes(e3) ? e3 = "u8" : ["unknown", "u8", "s8", "u16", "s16", "u32", "s32", "f32", "f64"].includes(e3) || (e3 = "f32"), e3;
  }
  getPlaneCount() {
    var _a;
    return (_a = this.pixels) == null ? void 0 : _a.length;
  }
  addData(t3) {
    if (!t3.pixels || t3.pixels.length !== this.width * this.height)
      throw new s2("pixelblock:invalid-or-missing-pixels", "add data requires valid pixels array that has same length defined by pixel block width * height");
    this.pixels || (this.pixels = []), this.statistics || (this.statistics = []), this.pixels.push(t3.pixels), this.statistics.push(t3.statistics ?? new l2());
  }
  getAsRGBA() {
    const t3 = new ArrayBuffer(this.width * this.height * 4);
    switch (this.pixelType) {
      case "s8":
      case "s16":
      case "u16":
      case "s32":
      case "u32":
      case "f32":
      case "f64":
        this._fillFromNon8Bit(t3);
        break;
      default:
        this._fillFrom8Bit(t3);
    }
    return new Uint8ClampedArray(t3);
  }
  getAsRGBAFloat() {
    const t3 = new Float32Array(this.width * this.height * 4);
    return this._fillFrom32Bit(t3), t3;
  }
  updateStatistics() {
    if (!this.pixels)
      return;
    this.statistics = this.pixels.map((t4) => this._calculateBandStatistics(t4, this.mask));
    const t3 = this.mask;
    let e3 = 0;
    if (null != t3)
      for (let s9 = 0; s9 < t3.length; s9++)
        t3[s9] && e3++;
    else
      e3 = this.width * this.height;
    this.validPixelCount = e3;
  }
  clamp(t3) {
    if (!t3 || "f64" === t3 || "f32" === t3 || !this.pixels)
      return;
    const [e3, s9] = s6(t3), i4 = this.pixels, l5 = this.width * this.height, r3 = i4.length;
    let o3, a6, n3;
    const c5 = [];
    for (let h4 = 0; h4 < r3; h4++) {
      n3 = p.createEmptyBand(t3, l5), o3 = i4[h4];
      for (let t4 = 0; t4 < l5; t4++)
        a6 = o3[t4], n3[t4] = a6 > s9 ? s9 : a6 < e3 ? e3 : a6;
      c5.push(n3);
    }
    this.pixels = c5, this.pixelType = t3;
  }
  extractBands(t3) {
    var _a;
    const { pixels: e3, statistics: s9 } = this;
    if (null == t3 || 0 === t3.length || !e3 || 0 === e3.length)
      return this;
    const i4 = e3.length, l5 = t3.some((t4) => t4 >= e3.length), r3 = i4 === t3.length && !t3.some((t4, e4) => t4 !== e4);
    if (l5 || r3)
      return this;
    const o3 = ((_a = this.bandMasks) == null ? void 0 : _a.length) === i4 ? t3.map((t4) => this.bandMasks[t4]) : void 0;
    let { mask: a6, validPixelCount: n3 } = this;
    const { width: h4, height: c5 } = this;
    if (o3) {
      if (1 === o3.length)
        a6 = o3[0];
      else {
        const t4 = h4 * c5;
        a6 = new Uint8Array(t4).fill(255);
        for (let e4 = 0; e4 < o3.length; e4++) {
          const s10 = o3[e4];
          for (let e5 = 0; e5 < t4; e5++)
            s10[e5] || (a6[e5] = 0);
        }
      }
      n3 = a6.filter((t4) => !!t4).length;
    }
    return new p({ pixelType: this.pixelType, width: h4, height: c5, mask: a6, bandMasks: o3, validPixelCount: n3, maskIsAlpha: this.maskIsAlpha, pixels: t3.map((t4) => e3[t4]), statistics: s9 && t3.map((t4) => s9[t4]) });
  }
  clone() {
    const t3 = new p({ width: this.width, height: this.height, pixelType: this.pixelType, maskIsAlpha: this.maskIsAlpha, validPixelCount: this.validPixelCount });
    let e3;
    null != this.mask && (this.mask instanceof Uint8Array ? t3.mask = new Uint8Array(this.mask) : t3.mask = this.mask.slice(0)), this.bandMasks && (t3.bandMasks = this.bandMasks.map((t4) => new Uint8Array(t4)));
    const s9 = p.getPixelArrayConstructor(this.pixelType);
    if (this.pixels && this.pixels.length > 0) {
      t3.pixels = [];
      const i4 = !!this.pixels[0].slice;
      for (e3 = 0; e3 < this.pixels.length; e3++)
        t3.pixels[e3] = i4 ? this.pixels[e3].slice(0, this.pixels[e3].length) : new s9(this.pixels[e3]);
    }
    if (this.statistics)
      for (t3.statistics = [], e3 = 0; e3 < this.statistics.length; e3++)
        t3.statistics[e3] = a(this.statistics[e3]);
    return t3.premultiplyAlpha = this.premultiplyAlpha, t3;
  }
  _fillFrom8Bit(t3) {
    const { mask: e3, maskIsAlpha: s9, premultiplyAlpha: i4, pixels: r3 } = this;
    if (!t3 || !r3 || !r3.length)
      return void s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    let o3, a6, n3, h4;
    o3 = a6 = n3 = r3[0], r3.length >= 3 ? (a6 = r3[1], n3 = r3[2]) : 2 === r3.length && (a6 = r3[1]);
    const p5 = new Uint32Array(t3), c5 = this.width * this.height;
    if (o3.length === c5)
      if (null != e3 && e3.length === c5)
        if (s9)
          for (h4 = 0; h4 < c5; h4++) {
            const t4 = e3[h4];
            if (t4) {
              const e4 = t4 / 255;
              p5[h4] = i4 ? t4 << 24 | n3[h4] * e4 << 16 | a6[h4] * e4 << 8 | o3[h4] * e4 : t4 << 24 | n3[h4] << 16 | a6[h4] << 8 | o3[h4];
            }
          }
        else
          for (h4 = 0; h4 < c5; h4++)
            e3[h4] && (p5[h4] = 255 << 24 | n3[h4] << 16 | a6[h4] << 8 | o3[h4]);
      else
        for (h4 = 0; h4 < c5; h4++)
          p5[h4] = 255 << 24 | n3[h4] << 16 | a6[h4] << 8 | o3[h4];
    else
      s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
  }
  _fillFromNon8Bit(t3) {
    const { pixels: e3, mask: s9, statistics: i4 } = this;
    if (!t3 || !e3 || !e3.length)
      return void s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The input pixel block is empty.");
    const r3 = this.pixelType;
    let o3 = 1, a6 = 0, n3 = 1;
    if (i4 && i4.length > 0) {
      for (const t4 of i4)
        if (null != t4.minValue && (a6 = Math.min(a6, t4.minValue)), null != t4.maxValue && null != t4.minValue) {
          const e4 = t4.maxValue - t4.minValue;
          n3 = Math.max(n3, e4);
        }
      o3 = 255 / n3;
    } else {
      let t4 = 255;
      "s8" === r3 ? (a6 = -128, t4 = 127) : "u16" === r3 ? t4 = 65535 : "s16" === r3 ? (a6 = -32768, t4 = 32767) : "u32" === r3 ? t4 = 4294967295 : "s32" === r3 ? (a6 = -2147483648, t4 = 2147483647) : "f32" === r3 ? (a6 = -34e38, t4 = 34e38) : "f64" === r3 && (a6 = -Number.MAX_VALUE, t4 = Number.MAX_VALUE), o3 = 255 / (t4 - a6);
    }
    const h4 = new Uint32Array(t3), p5 = this.width * this.height;
    let c5, u6, g4, f4, m4;
    if (c5 = u6 = g4 = e3[0], c5.length !== p5)
      return s.getLogger(this).error("getAsRGBA()", "Unable to convert to RGBA. The pixelblock is invalid.");
    if (e3.length >= 2)
      if (u6 = e3[1], e3.length >= 3 && (g4 = e3[2]), null != s9 && s9.length === p5)
        for (f4 = 0; f4 < p5; f4++)
          s9[f4] && (h4[f4] = 255 << 24 | (g4[f4] - a6) * o3 << 16 | (u6[f4] - a6) * o3 << 8 | (c5[f4] - a6) * o3);
      else
        for (f4 = 0; f4 < p5; f4++)
          h4[f4] = 255 << 24 | (g4[f4] - a6) * o3 << 16 | (u6[f4] - a6) * o3 << 8 | (c5[f4] - a6) * o3;
    else if (null != s9 && s9.length === p5)
      for (f4 = 0; f4 < p5; f4++)
        m4 = (c5[f4] - a6) * o3, s9[f4] && (h4[f4] = 255 << 24 | m4 << 16 | m4 << 8 | m4);
    else
      for (f4 = 0; f4 < p5; f4++)
        m4 = (c5[f4] - a6) * o3, h4[f4] = 255 << 24 | m4 << 16 | m4 << 8 | m4;
  }
  _fillFrom32Bit(t3) {
    const { pixels: e3, mask: s9 } = this;
    if (!t3 || !e3 || !e3.length)
      return s.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The input pixel block is empty.");
    let i4, r3, o3, a6;
    i4 = r3 = o3 = e3[0], e3.length >= 3 ? (r3 = e3[1], o3 = e3[2]) : 2 === e3.length && (r3 = e3[1]);
    const n3 = this.width * this.height;
    if (i4.length !== n3)
      return s.getLogger(this).error("getAsRGBAFloat()", "Unable to convert to RGBA. The pixelblock is invalid.");
    let h4 = 0;
    if (null != s9 && s9.length === n3)
      for (a6 = 0; a6 < n3; a6++)
        t3[h4++] = i4[a6], t3[h4++] = r3[a6], t3[h4++] = o3[a6], t3[h4++] = 1 & s9[a6];
    else
      for (a6 = 0; a6 < n3; a6++)
        t3[h4++] = i4[a6], t3[h4++] = r3[a6], t3[h4++] = o3[a6], t3[h4++] = 1;
  }
  _calculateBandStatistics(t3, e3) {
    let s9 = 1 / 0, i4 = -1 / 0;
    const l5 = t3.length;
    let r3, o3 = 0;
    if (null != e3)
      for (r3 = 0; r3 < l5; r3++)
        e3[r3] && (o3 = t3[r3], s9 = o3 < s9 ? o3 : s9, i4 = o3 > i4 ? o3 : i4);
    else
      for (r3 = 0; r3 < l5; r3++)
        o3 = t3[r3], s9 = o3 < s9 ? o3 : s9, i4 = o3 > i4 ? o3 : i4;
    return new l2(s9, i4);
  }
};
e([y({ json: { write: true } })], c.prototype, "width", void 0), e([y({ json: { write: true } })], c.prototype, "height", void 0), e([y({ json: { write: true } })], c.prototype, "pixelType", void 0), e([s5("pixelType")], c.prototype, "castPixelType", null), e([y({ json: { write: true } })], c.prototype, "validPixelCount", void 0), e([y({ json: { write: true } })], c.prototype, "mask", void 0), e([y({ json: { write: true } })], c.prototype, "maskIsAlpha", void 0), e([y({ json: { write: true } })], c.prototype, "pixels", void 0), e([y()], c.prototype, "premultiplyAlpha", void 0), e([y({ json: { write: true } })], c.prototype, "statistics", void 0), e([y({ json: { write: true } })], c.prototype, "depthCount", void 0), e([y({ json: { write: true } })], c.prototype, "noDataValues", void 0), e([y({ json: { write: true } })], c.prototype, "bandMasks", void 0), c = p = e([a2("esri.layers.support.PixelBlock")], c);
var u2 = c;

// node_modules/@arcgis/core/layers/support/rasterFunctions/pixelUtils.js
var n2;
var l3;
!function(t3) {
  t3[t3.matchAny = 0] = "matchAny", t3[t3.matchAll = 1] = "matchAll";
}(n2 || (n2 = {})), function(t3) {
  t3[t3.bestMatch = 0] = "bestMatch", t3[t3.fail = 1] = "fail";
}(l3 || (l3 = {}));
var i = 6;
function o(t3) {
  return null != t3 && "esri.layers.support.PixelBlock" === t3.declaredClass && t3.pixels && t3.pixels.length > 0;
}
function r(e3) {
  var _a;
  if (!(e3 == null ? void 0 : e3.length) || e3.some((t3) => !o(t3)))
    return null;
  if (1 === e3.length)
    return ((_a = e3[0]) == null ? void 0 : _a.clone()) ?? null;
  const n3 = e3, { width: l5, height: i4, pixelType: s9 } = n3[0];
  if (n3.some((t3) => t3.width !== l5 || t3.height !== i4))
    return null;
  const r3 = n3.map(({ mask: t3 }) => t3).filter((t3) => null != t3);
  let a6 = null;
  r3.length && (a6 = new Uint8Array(l5 * i4), a6.set(r3[0]), r3.length > 1 && m(r3.slice(1), a6));
  const h4 = [];
  n3.forEach(({ pixels: t3 }) => h4.push(...t3));
  const f4 = n3.map(({ statistics: t3 }) => t3).filter((t3) => t3 == null ? void 0 : t3.length), c5 = [];
  return f4.forEach((t3) => c5.push(...t3)), new u2({ pixelType: s9, width: l5, height: i4, mask: a6, pixels: h4, statistics: c5.length ? c5 : null });
}
function a3(t3) {
  if (!t3)
    return;
  const e3 = t3.colormap;
  if (!e3 || 0 === e3.length)
    return;
  const n3 = e3.sort((t4, e4) => t4[0] - e4[0]);
  let l5 = 0;
  n3[0][0] < 0 && (l5 = n3[0][0]);
  const i4 = Math.max(256, n3[n3.length - 1][0] - l5 + 1), o3 = new Uint8Array(4 * i4), s9 = [];
  let r3, a6 = 0, h4 = 0;
  const f4 = 5 === n3[0].length;
  if (i4 > 65536)
    return n3.forEach((t4) => {
      s9[t4[0] - l5] = f4 ? t4.slice(1) : t4.slice(1).concat([255]);
    }), { indexed2DColormap: s9, offset: l5, alphaSpecified: f4 };
  if (t3.fillUnspecified)
    for (r3 = n3[h4], a6 = r3[0] - l5; a6 < i4; a6++)
      o3[4 * a6] = r3[1], o3[4 * a6 + 1] = r3[2], o3[4 * a6 + 2] = r3[3], o3[4 * a6 + 3] = f4 ? r3[4] : 255, a6 === r3[0] - l5 && (r3 = h4 === n3.length - 1 ? r3 : n3[++h4]);
  else
    for (a6 = 0; a6 < n3.length; a6++)
      r3 = n3[a6], h4 = 4 * (r3[0] - l5), o3[h4] = r3[1], o3[h4 + 1] = r3[2], o3[h4 + 2] = r3[3], o3[h4 + 3] = f4 ? r3[4] : 255;
  return { indexedColormap: o3, offset: l5, alphaSpecified: f4 };
}
function h(t3, e3) {
  if (!o(t3))
    return t3;
  if (!e3 || !e3.indexedColormap && !e3.indexed2DColormap)
    return t3;
  const n3 = t3.clone(), l5 = n3.pixels;
  let i4 = n3.mask;
  const s9 = n3.width * n3.height;
  if (1 !== l5.length)
    return t3;
  const { indexedColormap: r3, indexed2DColormap: a6, offset: h4, alphaSpecified: f4 } = e3;
  let c5 = 0;
  const u6 = l5[0], p5 = new Uint8Array(u6.length), x3 = new Uint8Array(u6.length), d5 = new Uint8Array(u6.length);
  let m4, g4 = 0;
  if (r3) {
    const t4 = r3.length - 1;
    if (null != i4)
      for (c5 = 0; c5 < s9; c5++)
        i4[c5] && (g4 = 4 * (u6[c5] - h4), g4 < h4 || g4 > t4 ? i4[c5] = 0 : (p5[c5] = r3[g4], x3[c5] = r3[g4 + 1], d5[c5] = r3[g4 + 2], i4[c5] = r3[g4 + 3]));
    else {
      for (i4 = new Uint8Array(s9), c5 = 0; c5 < s9; c5++)
        g4 = 4 * (u6[c5] - h4), g4 < h4 || g4 > t4 ? i4[c5] = 0 : (p5[c5] = r3[g4], x3[c5] = r3[g4 + 1], d5[c5] = r3[g4 + 2], i4[c5] = r3[g4 + 3]);
      n3.mask = i4;
    }
  } else if (a6)
    if (null != i4)
      for (c5 = 0; c5 < s9; c5++)
        i4[c5] && (m4 = a6[u6[c5]], p5[c5] = m4[0], x3[c5] = m4[1], d5[c5] = m4[2], i4[c5] = m4[3]);
    else {
      for (i4 = new Uint8Array(s9), c5 = 0; c5 < s9; c5++)
        m4 = a6[u6[c5]], p5[c5] = m4[0], x3[c5] = m4[1], d5[c5] = m4[2], i4[c5] = m4[3];
      n3.mask = i4;
    }
  return n3.pixels = [p5, x3, d5], n3.statistics = null, n3.pixelType = "u8", n3.maskIsAlpha = f4, n3;
}
function f(e3, n3) {
  if (!o(e3))
    return null;
  const { pixels: l5, mask: i4 } = e3, s9 = l5.length;
  let r3 = n3.lut;
  const { offset: a6 } = n3;
  r3 && 1 === r3[0].length && (r3 = l5.map(() => r3));
  const h4 = [], f4 = n3.outputPixelType || "u8";
  for (let t3 = 0; t3 < s9; t3++) {
    const e4 = c2(l5[t3], i4, r3[t3], a6 || 0, f4);
    h4.push(e4);
  }
  const u6 = new u2({ width: e3.width, height: e3.height, pixels: h4, mask: i4, pixelType: f4 });
  return u6.updateStatistics(), u6;
}
function c2(e3, n3, l5, i4, o3) {
  const s9 = e3.length, r3 = u2.createEmptyBand(o3, s9);
  if (n3)
    for (let t3 = 0; t3 < s9; t3++)
      n3[t3] && (r3[t3] = l5[e3[t3] - i4]);
  else
    for (let t3 = 0; t3 < s9; t3++)
      r3[t3] = l5[e3[t3] - i4];
  return r3;
}
function u3(t3, e3) {
  if (!o(t3))
    return null;
  const n3 = t3.clone(), { pixels: l5 } = n3, i4 = n3.width * n3.height, s9 = e3.length, r3 = Math.floor(s9 / 2), a6 = e3[Math.floor(r3)], h4 = l5[0];
  let f4, c5, u6, p5, x3, d5, m4 = false;
  const g4 = new Uint8Array(i4), y5 = new Uint8Array(i4), w4 = new Uint8Array(i4);
  let k3 = n3.mask;
  const M5 = 4 === e3[0].mappedColor.length;
  for (k3 || (k3 = new Uint8Array(i4), k3.fill(M5 ? 255 : 1), n3.mask = k3), x3 = 0; x3 < i4; x3++)
    if (k3[x3]) {
      for (f4 = h4[x3], m4 = false, d5 = r3, c5 = a6, u6 = 0, p5 = s9 - 1; p5 - u6 > 1; ) {
        if (f4 === c5.value) {
          m4 = true;
          break;
        }
        f4 > c5.value ? u6 = d5 : p5 = d5, d5 = Math.floor((u6 + p5) / 2), c5 = e3[Math.floor(d5)];
      }
      m4 || (f4 === e3[u6].value ? (c5 = e3[u6], m4 = true) : f4 === e3[p5].value ? (c5 = e3[p5], m4 = true) : f4 < e3[u6].value ? (m4 = false, c5 = null) : f4 > e3[u6].value && (f4 < e3[p5].value ? (c5 = e3[u6], m4 = true) : p5 === s9 - 1 ? (m4 = false, c5 = null) : (c5 = e3[p5], m4 = true))), m4 ? (g4[x3] = c5.mappedColor[0], y5[x3] = c5.mappedColor[1], w4[x3] = c5.mappedColor[2], k3[x3] = c5.mappedColor[3]) : g4[x3] = y5[x3] = w4[x3] = k3[x3] = 0;
    }
  return n3.pixels = [g4, y5, w4], n3.mask = k3, n3.pixelType = "u8", n3.maskIsAlpha = M5, n3;
}
function p2(n3, l5) {
  if (!o(n3))
    return null;
  const { width: i4, height: s9 } = n3, { inputRanges: r3, outputValues: a6, outputPixelType: h4, noDataRanges: f4, allowUnmatched: c5, isLastInputRangeInclusive: u6 } = l5, p5 = n3.pixels[0], x3 = u2.createEmptyBand(h4, p5.length), d5 = n3.mask, m4 = new Uint8Array(i4 * s9);
  d5 ? m4.set(d5) : m4.fill(255);
  const g4 = n3.pixelType.startsWith("f") ? 1e-6 : 0, y5 = r3.map((t3) => t3 - g4);
  y5[0] = r3[0], y5[y5.length - 1] = r3[r3.length - 1] + (u6 ? 1e-6 : 0);
  const w4 = r3.length / 2, [k3, M5] = s6(h4);
  for (let t3 = 0; t3 < s9; t3++)
    for (let e3 = 0; e3 < i4; e3++) {
      const n4 = t3 * i4 + e3;
      if (m4[n4]) {
        const t4 = p5[n4];
        let e4 = false;
        for (let l6 = w4 - 1; l6 >= 0; l6--)
          if (t4 === y5[2 * l6] || t4 > y5[2 * l6] && t4 < y5[2 * l6 + 1]) {
            x3[n4] = a6[l6], e4 = true;
            break;
          }
        e4 || (c5 ? x3[n4] = t4 > M5 ? M5 : t4 < k3 ? k3 : t4 : m4[n4] = 0);
      }
    }
  const A3 = f4 == null ? void 0 : f4.length;
  if (A3)
    for (let t3 = 0; t3 < s9; t3++)
      for (let e3 = 0; e3 < i4; e3++) {
        const n4 = t3 * i4 + e3;
        if (!d5 || d5[n4]) {
          const t4 = p5[n4];
          for (let e4 = 0; e4 < A3; e4 += 2)
            if (t4 >= f4[e4] && t4 <= f4[e4 + 1]) {
              x3[n4] = 0, m4[n4] = 0;
              break;
            }
        }
      }
  return new u2({ width: i4, height: s9, pixelType: h4, pixels: [x3], mask: m4 });
}
function x(t3, e3, n3, l5) {
  const i4 = null != n3 && n3.length >= 2 ? new Set(n3) : null, o3 = 1 === (n3 == null ? void 0 : n3.length) ? n3[0] : null, s9 = !!(e3 == null ? void 0 : e3.length);
  for (let r3 = 0; r3 < t3.length; r3++)
    if (l5[r3]) {
      const n4 = t3[r3];
      if (s9) {
        let t4 = false;
        for (let l6 = 0; l6 < e3.length; l6 += 2)
          if (n4 >= e3[l6] && n4 <= e3[l6 + 1]) {
            t4 = true;
            break;
          }
        t4 || (l5[r3] = 0);
      }
      l5[r3] && (n4 === o3 || (i4 == null ? void 0 : i4.has(n4))) && (l5[r3] = 0);
    }
}
function d2(t3, e3) {
  const n3 = t3[0].length;
  for (let l5 = 0; l5 < n3; l5++)
    if (e3[l5]) {
      let n4 = false;
      for (let e4 = 0; e4 < t3.length; e4++)
        if (t3[e4][l5]) {
          n4 = true;
          break;
        }
      n4 || (e3[l5] = 0);
    }
}
function m(t3, e3) {
  const n3 = t3[0].length;
  for (let l5 = 0; l5 < n3; l5++)
    if (e3[l5]) {
      let n4 = false;
      for (let e4 = 0; e4 < t3.length; e4++)
        if (0 === t3[e4][l5]) {
          n4 = true;
          break;
        }
      n4 && (e3[l5] = 0);
    }
}
function g(e3, n3) {
  if (!o(e3))
    return null;
  const { width: l5, height: i4, pixels: s9 } = e3, r3 = l5 * i4, a6 = new Uint8Array(r3);
  e3.mask ? a6.set(e3.mask) : a6.fill(255);
  const h4 = s9.length, { includedRanges: f4, noDataValues: u6, outputPixelType: p5, matchAll: g4, lookups: y5 } = n3;
  if (y5) {
    const t3 = [];
    for (let e4 = 0; e4 < h4; e4++) {
      const n4 = y5[e4], l6 = c2(s9[e4], a6, n4.lut, n4.offset || 0, "u8");
      t3.push(l6);
    }
    1 === t3.length ? a6.set(t3[0]) : g4 ? d2(t3, a6) : m(t3, a6);
  } else if (g4) {
    const t3 = [];
    for (let e4 = 0; e4 < h4; e4++) {
      const n4 = new Uint8Array(r3);
      n4.set(a6), x(s9[e4], f4 == null ? void 0 : f4.slice(2 * e4, 2 * e4 + 2), u6 == null ? void 0 : u6[e4], n4), t3.push(n4);
    }
    1 === t3.length ? a6.set(t3[0]) : d2(t3, a6);
  } else
    for (let t3 = 0; t3 < h4; t3++)
      x(s9[t3], f4 == null ? void 0 : f4.slice(2 * t3, 2 * t3 + 2), u6 == null ? void 0 : u6[t3], a6);
  return new u2({ width: l5, height: i4, pixelType: p5, pixels: s9, mask: a6 });
}
function y2(n3) {
  const { srcPixelType: l5, inputRanges: i4, outputValues: o3, allowUnmatched: s9, noDataRanges: r3, isLastInputRangeInclusive: a6, outputPixelType: h4 } = n3;
  if ("u8" !== l5 && "s8" !== l5 && "u16" !== l5 && "s16" !== l5)
    return null;
  const f4 = l5.includes("16") ? 65536 : 256, c5 = l5.includes("s") ? -f4 / 2 : 0, u6 = u2.createEmptyBand(h4, f4), p5 = new Uint8Array(f4);
  s9 && p5.fill(255);
  const [x3, d5] = s6(h4);
  if ((i4 == null ? void 0 : i4.length) && (o3 == null ? void 0 : o3.length)) {
    const t3 = 1e-6, e3 = i4.map((e4) => e4 - t3);
    e3[0] = i4[0], a6 && (e3[e3.length - 1] = i4[i4.length - 1]);
    for (let n4 = 0; n4 < e3.length; n4++) {
      const t4 = o3[n4] > d5 ? d5 : o3[n4] < x3 ? x3 : o3[n4], l6 = Math.ceil(e3[2 * n4] - c5), i5 = Math.floor(e3[2 * n4 + 1] - c5);
      for (let e4 = l6; e4 <= i5; e4++)
        u6[e4] = t4, p5[e4] = 255;
    }
  }
  if (r3 == null ? void 0 : r3.length)
    for (let t3 = 0; t3 < r3.length; t3++) {
      const e3 = Math.ceil(r3[2 * t3] - c5), n4 = Math.floor(r3[2 * t3 + 1] - c5);
      for (let t4 = e3; t4 <= n4; t4++)
        p5[t4] = 0;
    }
  return { lut: u6, offset: c5, mask: p5 };
}
function w(t3, e3, n3) {
  if ("u8" !== t3 && "s8" !== t3 && "u16" !== t3 && "s16" !== t3)
    return null;
  const l5 = t3.includes("16") ? 65536 : 256, i4 = t3.includes("s") ? -l5 / 2 : 0, o3 = new Uint8Array(l5);
  if (e3)
    for (let s9 = 0; s9 < e3.length; s9++) {
      const t4 = Math.ceil(e3[2 * s9] - i4), n4 = Math.floor(e3[2 * s9 + 1] - i4);
      for (let e4 = t4; e4 <= n4; e4++)
        o3[e4] = 255;
    }
  else
    o3.fill(255);
  if (n3)
    for (let s9 = 0; s9 < n3.length; s9++)
      o3[n3[s9] - i4] = 0;
  return { lut: o3, offset: i4 };
}
function k(t3, e3, n3, l5, i4, o3, s9, r3) {
  return { xmin: i4 <= n3 * t3 ? 0 : i4 < n3 * t3 + t3 ? i4 - n3 * t3 : t3, ymin: o3 <= l5 * e3 ? 0 : o3 < l5 * e3 + e3 ? o3 - l5 * e3 : e3, xmax: i4 + s9 <= n3 * t3 ? 0 : i4 + s9 < n3 * t3 + t3 ? i4 + s9 - n3 * t3 : t3, ymax: o3 + r3 <= l5 * e3 ? 0 : o3 + r3 < l5 * e3 + e3 ? o3 + r3 - l5 * e3 : e3 };
}
function M3(t3, e3) {
  if (!t3 || 0 === t3.length)
    return null;
  const n3 = t3.find((t4) => t4.pixelBlock);
  if (!n3 || null == n3.pixelBlock)
    return null;
  const l5 = (n3.extent.xmax - n3.extent.xmin) / n3.pixelBlock.width, i4 = (n3.extent.ymax - n3.extent.ymin) / n3.pixelBlock.height, o3 = 0.01 * Math.min(l5, i4), s9 = t3.sort((t4, e4) => Math.abs(t4.extent.ymax - e4.extent.ymax) > o3 ? e4.extent.ymax - t4.extent.ymax : Math.abs(t4.extent.xmin - e4.extent.xmin) > o3 ? t4.extent.xmin - e4.extent.xmin : 0), r3 = Math.min.apply(null, s9.map((t4) => t4.extent.xmin)), a6 = Math.min.apply(null, s9.map((t4) => t4.extent.ymin)), h4 = Math.max.apply(null, s9.map((t4) => t4.extent.xmax)), f4 = Math.max.apply(null, s9.map((t4) => t4.extent.ymax)), c5 = { x: Math.round((e3.xmin - r3) / l5), y: Math.round((f4 - e3.ymax) / i4) }, u6 = { width: Math.round((h4 - r3) / l5), height: Math.round((f4 - a6) / i4) }, p5 = { width: Math.round((e3.xmax - e3.xmin) / l5), height: Math.round((e3.ymax - e3.ymin) / i4) };
  if (Math.round(u6.width / n3.pixelBlock.width) * Math.round(u6.height / n3.pixelBlock.height) !== s9.length || c5.x < 0 || c5.y < 0 || u6.width < p5.width || u6.height < p5.height)
    return null;
  return { extent: e3, pixelBlock: U(s9.map((t4) => t4.pixelBlock), u6, { clipOffset: c5, clipSize: p5 }) };
}
function A(t3, e3, n3, l5, i4, o3) {
  const { width: s9, height: r3 } = n3.block, { x: a6, y: h4 } = n3.offset, { width: f4, height: c5 } = n3.mosaic, u6 = k(s9, r3, l5, i4, a6, h4, f4, c5);
  let p5 = 0, x3 = 0;
  if (o3) {
    const t4 = o3.hasGCSSShiftTransform ? 360 : o3.halfWorldWidth ?? 0, e4 = s9 * o3.resolutionX, n4 = o3.startX + l5 * e4;
    n4 < t4 && n4 + e4 > t4 ? x3 = o3.rightPadding : n4 >= t4 && (p5 = o3.leftMargin - o3.rightPadding, x3 = 0);
  }
  if (u6.xmax -= x3, "number" != typeof e3)
    for (let d5 = u6.ymin; d5 < u6.ymax; d5++) {
      const n4 = (i4 * r3 + d5 - h4) * f4 + (l5 * s9 - a6) + p5, o4 = d5 * s9;
      for (let l6 = u6.xmin; l6 < u6.xmax; l6++)
        t3[n4 + l6] = e3[o4 + l6];
    }
  else
    for (let d5 = u6.ymin; d5 < u6.ymax; d5++) {
      const n4 = (i4 * r3 + d5 - h4) * f4 + (l5 * s9 - a6) + p5;
      for (let l6 = u6.xmin; l6 < u6.xmax; l6++)
        t3[n4 + l6] = e3;
    }
}
function U(e3, n3, l5 = {}) {
  var _a;
  const { clipOffset: i4, clipSize: s9, alignmentInfo: r3, blockWidths: a6 } = l5;
  if (a6)
    return b(e3, n3, { blockWidths: a6 });
  const h4 = e3.find((t3) => o(t3));
  if (null == h4)
    return null;
  const f4 = s9 ? s9.width : n3.width, c5 = s9 ? s9.height : n3.height, u6 = h4.width, p5 = h4.height, x3 = n3.width / u6, d5 = n3.height / p5, m4 = { offset: i4 || { x: 0, y: 0 }, mosaic: s9 || n3, block: { width: u6, height: p5 } }, g4 = h4.pixelType, y5 = u2.getPixelArrayConstructor(g4), w4 = h4.pixels.length, k3 = [];
  let M5, U3;
  for (let t3 = 0; t3 < w4; t3++) {
    U3 = new y5(f4 * c5);
    for (let n4 = 0; n4 < d5; n4++)
      for (let l6 = 0; l6 < x3; l6++) {
        const i5 = e3[n4 * x3 + l6];
        o(i5) && (M5 = i5.pixels[t3], A(U3, M5, m4, l6, n4, r3));
      }
    k3.push(U3);
  }
  const T2 = e3.some((t3) => null == t3 || null != t3.mask && t3.mask.length > 0), v3 = e3.some((t3) => null != t3 && t3.bandMasks && t3.bandMasks.length > 1), C2 = T2 ? new Uint8Array(f4 * c5) : void 0, B2 = v3 ? [] : void 0;
  if (C2) {
    for (let t3 = 0; t3 < d5; t3++)
      for (let n4 = 0; n4 < x3; n4++) {
        const l6 = e3[t3 * x3 + n4], i5 = null != l6 ? l6.mask : null;
        A(C2, null != i5 ? i5 : l6 ? 255 : 0, m4, n4, t3, r3);
      }
    if (B2)
      for (let t3 = 0; t3 < w4; t3++) {
        const n4 = new Uint8Array(f4 * c5);
        for (let l6 = 0; l6 < d5; l6++)
          for (let i5 = 0; i5 < x3; i5++) {
            const o3 = e3[l6 * x3 + i5], s10 = ((_a = o3 == null ? void 0 : o3.bandMasks) == null ? void 0 : _a[t3]) ?? (o3 == null ? void 0 : o3.mask);
            A(n4, null != s10 ? s10 : o3 ? 255 : 0, m4, i5, l6, r3);
          }
        B2.push(n4);
      }
  }
  const S3 = new u2({ width: f4, height: c5, pixels: k3, pixelType: g4, bandMasks: B2, mask: C2 });
  return S3.updateStatistics(), S3;
}
function b(e3, n3, l5) {
  var _a;
  const i4 = e3.find((t3) => null != t3);
  if (null == i4)
    return null;
  const s9 = e3.some((t3) => null == t3 || !!t3.mask), { width: r3, height: a6 } = n3, h4 = s9 ? new Uint8Array(r3 * a6) : null, { blockWidths: f4 } = l5, c5 = [], u6 = i4.getPlaneCount(), p5 = u2.getPixelArrayConstructor(i4.pixelType);
  if (s9)
    for (let t3 = 0, y5 = 0; t3 < e3.length; y5 += f4[t3], t3++) {
      const n4 = e3[t3];
      if (!o(n4))
        continue;
      const l6 = n4.mask;
      for (let e4 = 0; e4 < a6; e4++)
        for (let i5 = 0; i5 < f4[t3]; i5++)
          h4[e4 * r3 + i5 + y5] = null == l6 ? 255 : l6[e4 * n4.width + i5];
    }
  const x3 = e3.some((t3) => null != t3 && t3.bandMasks && t3.bandMasks.length > 1), d5 = x3 ? [] : void 0, m4 = r3 * a6;
  for (let t3 = 0; t3 < u6; t3++) {
    const n4 = new p5(m4), l6 = x3 ? new Uint8Array(m4) : void 0;
    for (let i5 = 0, s10 = 0; i5 < e3.length; s10 += f4[i5], i5++) {
      const h5 = e3[i5];
      if (!o(h5))
        continue;
      const c6 = h5.pixels[t3];
      if (null != c6) {
        for (let t4 = 0; t4 < a6; t4++)
          for (let e4 = 0; e4 < f4[i5]; e4++)
            n4[t4 * r3 + e4 + s10] = c6[t4 * h5.width + e4];
        if (l6) {
          const e4 = ((_a = h5.bandMasks) == null ? void 0 : _a[t3]) ?? h5.mask;
          for (let t4 = 0; t4 < a6; t4++)
            for (let n5 = 0; n5 < f4[i5]; n5++)
              l6[t4 * r3 + n5 + s10] = e4 ? e4[t4 * h5.width + n5] : 255;
        }
      }
    }
    c5.push(n4), d5 && l6 && d5.push(l6);
  }
  const g4 = new u2({ width: r3, height: a6, mask: h4, bandMasks: d5, pixels: c5, pixelType: i4.pixelType });
  return g4.updateStatistics(), g4;
}
function T(t3, e3, n3) {
  if (!o(t3))
    return null;
  const { width: l5, height: i4 } = t3, s9 = e3.x, r3 = e3.y, a6 = n3.width + s9, h4 = n3.height + r3;
  if (s9 < 0 || r3 < 0 || a6 > l5 || h4 > i4)
    return t3;
  if (0 === s9 && 0 === r3 && a6 === l5 && h4 === i4)
    return t3;
  t3.mask || (t3.mask = new Uint8Array(l5 * i4));
  const f4 = t3.mask;
  for (let o3 = 0; o3 < i4; o3++) {
    const t4 = o3 * l5;
    for (let e4 = 0; e4 < l5; e4++)
      f4[t4 + e4] = o3 < r3 || o3 >= h4 || e4 < s9 || e4 >= a6 ? 0 : 1;
  }
  return t3.updateStatistics(), t3;
}
function v(t3) {
  if (!o(t3))
    return null;
  const e3 = t3.clone(), { width: n3, height: l5, pixels: i4 } = t3, s9 = i4[0], r3 = e3.pixels[0], a6 = t3.mask;
  for (let o3 = 2; o3 < l5 - 1; o3++) {
    const t4 = /* @__PURE__ */ new Map();
    for (let l6 = o3 - 2; l6 < o3 + 2; l6++)
      for (let e5 = 0; e5 < 4; e5++) {
        const i5 = l6 * n3 + e5;
        S(t4, s9[i5], a6 ? a6[i5] : 1);
      }
    r3[o3 * n3] = C(t4), r3[o3 * n3 + 1] = r3[o3 * n3 + 2] = r3[o3 * n3];
    let e4 = 3;
    for (; e4 < n3 - 1; e4++) {
      let l6 = (o3 - 2) * n3 + e4 + 1;
      S(t4, s9[l6], a6 ? a6[l6] : 1), l6 = (o3 - 1) * n3 + e4 + 1, S(t4, s9[l6], a6 ? a6[l6] : 1), l6 = o3 * n3 + e4 + 1, S(t4, s9[l6], a6 ? a6[l6] : 1), l6 = (o3 + 1) * n3 + e4 + 1, S(t4, s9[l6], a6 ? a6[l6] : 1), l6 = (o3 - 2) * n3 + e4 - 3, B(t4, s9[l6], a6 ? a6[l6] : 1), l6 = (o3 - 1) * n3 + e4 - 3, B(t4, s9[l6], a6 ? a6[l6] : 1), l6 = o3 * n3 + e4 - 3, B(t4, s9[l6], a6 ? a6[l6] : 1), l6 = (o3 + 1) * n3 + e4 - 3, B(t4, s9[l6], a6 ? a6[l6] : 1), r3[o3 * n3 + e4] = C(t4);
    }
    r3[o3 * n3 + e4 + 1] = r3[o3 * n3 + e4];
  }
  for (let o3 = 0; o3 < n3; o3++)
    r3[o3] = r3[n3 + o3] = r3[2 * n3 + o3], r3[(l5 - 1) * n3 + o3] = r3[(l5 - 2) * n3 + o3];
  return e3.updateStatistics(), e3;
}
function C(t3) {
  if (0 === t3.size)
    return 0;
  let e3 = 0, n3 = -1, l5 = 0;
  const i4 = t3.keys();
  let o3 = i4.next();
  for (; !o3.done; )
    l5 = t3.get(o3.value), l5 > e3 && (n3 = o3.value, e3 = l5), o3 = i4.next();
  return n3;
}
function B(t3, e3, n3) {
  if (0 === n3)
    return;
  const l5 = t3.get(e3);
  1 === l5 ? t3.delete(e3) : t3.set(e3, l5 - 1);
}
function S(t3, e3, n3) {
  0 !== n3 && t3.set(e3, t3.has(e3) ? t3.get(e3) + 1 : 1);
}
function P(e3, n3, l5) {
  let { x: i4, y: s9 } = n3;
  const { width: r3, height: a6 } = l5;
  if (0 === i4 && 0 === s9 && a6 === e3.height && r3 === e3.width)
    return e3;
  const { width: h4, height: f4 } = e3, c5 = Math.max(0, s9), u6 = Math.max(0, i4), p5 = Math.min(i4 + r3, h4), x3 = Math.min(s9 + a6, f4);
  if (p5 < 0 || x3 < 0 || !o(e3))
    return null;
  i4 = Math.max(0, -i4), s9 = Math.max(0, -s9);
  const { pixels: d5 } = e3, m4 = r3 * a6, g4 = d5.length, y5 = [];
  for (let o3 = 0; o3 < g4; o3++) {
    const n4 = d5[o3], l6 = u2.createEmptyBand(e3.pixelType, m4);
    for (let t3 = c5; t3 < x3; t3++) {
      const e4 = t3 * h4;
      let o4 = (t3 + s9 - c5) * r3 + i4;
      for (let t4 = u6; t4 < p5; t4++)
        l6[o4++] = n4[e4 + t4];
    }
    y5.push(l6);
  }
  const w4 = new Uint8Array(m4), k3 = e3.mask;
  for (let t3 = c5; t3 < x3; t3++) {
    const e4 = t3 * h4;
    let n4 = (t3 + s9 - c5) * r3 + i4;
    for (let t4 = u6; t4 < p5; t4++)
      w4[n4++] = k3 ? k3[e4 + t4] : 1;
  }
  const M5 = new u2({ width: l5.width, height: l5.height, pixelType: e3.pixelType, pixels: y5, mask: w4 });
  return M5.updateStatistics(), M5;
}
function _(e3, n3 = true) {
  if (!o(e3))
    return null;
  const { pixels: l5, width: i4, height: s9, mask: r3, pixelType: a6 } = e3, h4 = [], f4 = Math.round(i4 / 2), c5 = Math.round(s9 / 2), u6 = s9 - 1, p5 = i4 - 1;
  for (let o3 = 0; o3 < l5.length; o3++) {
    const e4 = l5[o3], r4 = u2.createEmptyBand(a6, f4 * c5);
    let x4 = 0;
    for (let t3 = 0; t3 < s9; t3 += 2)
      for (let l6 = 0; l6 < i4; l6 += 2) {
        const o4 = e4[t3 * i4 + l6];
        if (n3) {
          const n4 = l6 === p5 ? o4 : e4[t3 * i4 + l6 + 1], s10 = t3 === u6 ? o4 : e4[t3 * i4 + l6 + i4], a7 = l6 === p5 ? s10 : t3 === u6 ? n4 : e4[t3 * i4 + l6 + i4 + 1];
          r4[x4++] = (o4 + n4 + s10 + a7) / 4;
        } else
          r4[x4++] = o4;
      }
    h4.push(r4);
  }
  let x3 = null;
  if (null != r3) {
    x3 = new Uint8Array(f4 * c5);
    let t3 = 0;
    for (let e4 = 0; e4 < s9; e4 += 2)
      for (let l6 = 0; l6 < i4; l6 += 2) {
        const o3 = r3[e4 * i4 + l6];
        if (n3) {
          const n4 = l6 === p5 ? o3 : r3[e4 * i4 + l6 + 1], s10 = e4 === u6 ? o3 : r3[e4 * i4 + l6 + i4], a7 = l6 === p5 ? s10 : e4 === u6 ? n4 : r3[e4 * i4 + l6 + i4 + 1];
          x3[t3++] = o3 * n4 * s10 * a7 ? 1 : 0;
        } else
          x3[t3++] = o3;
      }
  }
  return new u2({ width: f4, height: c5, pixelType: a6, pixels: h4, mask: x3 });
}
function W(t3, e3, n3) {
  if (!o(t3))
    return null;
  const { width: l5, height: i4 } = e3;
  let { width: s9, height: r3 } = t3;
  const a6 = /* @__PURE__ */ new Map(), h4 = { x: 0, y: 0 }, f4 = null == n3 ? 1 : 1 + n3;
  let c5 = t3;
  for (let o3 = 0; o3 < f4; o3++) {
    const t4 = Math.ceil(s9 / l5), n4 = Math.ceil(r3 / i4);
    for (let s10 = 0; s10 < n4; s10++) {
      h4.y = s10 * i4;
      for (let n5 = 0; n5 < t4; n5++) {
        h4.x = n5 * l5;
        const t5 = P(c5, h4, e3);
        a6.set(`${o3}/${s10}/${n5}`, t5);
      }
    }
    o3 < f4 - 1 && (c5 = _(c5)), s9 = Math.round(s9 / 2), r3 = Math.round(r3 / 2);
  }
  return a6;
}
function E(t3, e3, n3, l5, i4 = 0) {
  const { width: o3, height: s9 } = t3, { width: r3, height: a6 } = e3, h4 = l5.cols, f4 = l5.rows, c5 = Math.ceil(r3 / h4 - 0.1 / h4), u6 = Math.ceil(a6 / f4 - 0.1 / f4);
  let p5, x3, d5, m4, g4, y5, w4;
  const k3 = c5 * h4, M5 = k3 * u6 * f4, A3 = new Float32Array(M5), U3 = new Float32Array(M5), b3 = new Uint32Array(M5), T2 = new Uint32Array(M5);
  let v3, C2, B2 = 0;
  for (let S3 = 0; S3 < u6; S3++)
    for (let t4 = 0; t4 < c5; t4++) {
      p5 = 12 * (S3 * c5 + t4), x3 = n3[p5], d5 = n3[p5 + 1], m4 = n3[p5 + 2], g4 = n3[p5 + 3], y5 = n3[p5 + 4], w4 = n3[p5 + 5];
      for (let e4 = 0; e4 < f4; e4++) {
        B2 = (S3 * f4 + e4) * k3 + t4 * h4, C2 = (e4 + 0.5) / f4;
        for (let t5 = 0; t5 < e4; t5++)
          v3 = (t5 + 0.5) / h4, A3[B2 + t5] = (x3 * v3 + d5 * C2 + m4) * o3 + i4, U3[B2 + t5] = (g4 * v3 + y5 * C2 + w4) * s9 + i4, b3[B2 + t5] = Math.floor(A3[B2 + t5]), T2[B2 + t5] = Math.floor(U3[B2 + t5]);
      }
      p5 += 6, x3 = n3[p5], d5 = n3[p5 + 1], m4 = n3[p5 + 2], g4 = n3[p5 + 3], y5 = n3[p5 + 4], w4 = n3[p5 + 5];
      for (let e4 = 0; e4 < f4; e4++) {
        B2 = (S3 * f4 + e4) * k3 + t4 * h4, C2 = (e4 + 0.5) / f4;
        for (let t5 = e4; t5 < h4; t5++)
          v3 = (t5 + 0.5) / h4, A3[B2 + t5] = (x3 * v3 + d5 * C2 + m4) * o3 + i4, U3[B2 + t5] = (g4 * v3 + y5 * C2 + w4) * s9 + i4, b3[B2 + t5] = Math.floor(A3[B2 + t5]), T2[B2 + t5] = Math.floor(U3[B2 + t5]);
      }
    }
  return { offsets_x: A3, offsets_y: U3, offsets_xi: b3, offsets_yi: T2, gridWidth: k3 };
}
function I(t3, e3) {
  const { coefficients: n3, spacing: l5 } = e3, { offsets_x: i4, offsets_y: o3, gridWidth: s9 } = E(t3, t3, n3, { rows: l5[0], cols: l5[1] }), { width: r3, height: a6 } = t3, h4 = new Float32Array(r3 * a6), f4 = 180 / Math.PI;
  for (let c5 = 0; c5 < a6; c5++)
    for (let t4 = 0; t4 < r3; t4++) {
      const e4 = c5 * s9 + t4, n4 = 0 === c5 ? e4 : e4 - s9, l6 = c5 === a6 - 1 ? e4 : e4 + s9, u6 = i4[n4] - i4[l6], p5 = o3[l6] - o3[n4];
      if (isNaN(u6) || isNaN(p5))
        h4[c5 * r3 + t4] = 90;
      else {
        let e5 = Math.atan2(p5, u6) * f4;
        e5 = (360 + e5) % 360, h4[c5 * r3 + t4] = e5;
      }
    }
  return h4;
}
function R(e3, n3, l5, i4, s9 = "nearest") {
  if (!o(e3))
    return null;
  "majority" === s9 && (e3 = v(e3));
  const { pixels: r3, mask: a6, bandMasks: h4, pixelType: f4 } = e3, c5 = e3.width, u6 = e3.height, p5 = u2.getPixelArrayConstructor(f4), x3 = r3.length, { width: d5, height: m4 } = n3;
  let g4 = false;
  for (let t3 = 0; t3 < l5.length; t3 += 3)
    -1 === l5[t3] && -1 === l5[t3 + 1] && -1 === l5[t3 + 2] && (g4 = true);
  const { offsets_x: y5, offsets_y: w4, offsets_xi: k3, offsets_yi: M5, gridWidth: A3 } = E({ width: c5, height: u6 }, n3, l5, i4, "majority" === s9 ? 0.5 : 0);
  let U3;
  const b3 = (t3, e4, n4, l6) => {
    const i5 = t3 instanceof Float32Array || t3 instanceof Float64Array ? 0 : 0.5;
    for (let o3 = 0; o3 < m4; o3++) {
      U3 = o3 * A3;
      for (let s10 = 0; s10 < d5; s10++) {
        if (y5[U3] < 0 || w4[U3] < 0)
          t3[o3 * d5 + s10] = 0;
        else if (l6)
          t3[o3 * d5 + s10] = e4[k3[U3] + M5[U3] * c5];
        else {
          const l7 = Math.floor(y5[U3]), r4 = Math.floor(w4[U3]), a7 = Math.ceil(y5[U3]), h5 = Math.ceil(w4[U3]), f5 = y5[U3] - l7, u7 = w4[U3] - r4;
          if (!n4 || n4[l7 + r4 * c5] && n4[a7 + r4 * c5] && n4[l7 + h5 * c5] && n4[a7 + h5 * c5]) {
            const n5 = (1 - f5) * e4[l7 + r4 * c5] + f5 * e4[a7 + r4 * c5], p6 = (1 - f5) * e4[l7 + h5 * c5] + f5 * e4[a7 + h5 * c5];
            t3[o3 * d5 + s10] = (1 - u7) * n5 + u7 * p6 + i5;
          } else
            t3[o3 * d5 + s10] = e4[k3[U3] + M5[U3] * c5];
        }
        U3++;
      }
    }
  }, T2 = [];
  let C2;
  const B2 = (h4 == null ? void 0 : h4.length) === x3, S3 = [];
  for (let t3 = 0; t3 < x3; t3++) {
    if (B2) {
      const e4 = new Uint8Array(d5 * m4);
      b3(e4, h4[t3], h4[t3], true), S3.push(e4);
    }
    C2 = new p5(d5 * m4), b3(C2, r3[t3], B2 ? h4[t3] : a6, "nearest" === s9 || "majority" === s9), T2.push(C2);
  }
  const P3 = new u2({ width: d5, height: m4, pixelType: f4, pixels: T2, bandMasks: B2 ? S3 : void 0 });
  if (null != a6)
    P3.mask = new Uint8Array(d5 * m4), b3(P3.mask, a6, a6, true);
  else if (g4) {
    P3.mask = new Uint8Array(d5 * m4);
    for (let t3 = 0; t3 < d5 * m4; t3++)
      P3.mask[t3] = y5[t3] < 0 || w4[t3] < 0 ? 0 : 1;
  }
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/vectorFieldUtils.js
var r2 = /* @__PURE__ */ new Map();
r2.set("meter-per-second", 1), r2.set("kilometer-per-hour", 0.277778), r2.set("knots", 0.514444), r2.set("feet-per-second", 0.3048), r2.set("mile-per-hour", 0.44704);
var o2 = 180 / Math.PI;
var i2 = 5;
var s7 = new s4({ esriMetersPerSecond: "meter-per-second", esriKilometersPerHour: "kilometer-per-hour", esriKnots: "knots", esriFeetPerSecond: "feet-per-second", esriMilesPerHour: "mile-per-hour" });
function a4(t3, e3) {
  return r2.get(t3) / r2.get(e3) || 1;
}
function h2(t3) {
  return (450 - t3) % 360;
}
function l4(t3, e3 = "geographic") {
  const [n3, r3] = t3, i4 = Math.sqrt(n3 * n3 + r3 * r3);
  let s9 = Math.atan2(r3, n3) * o2;
  return s9 = (360 + s9) % 360, "geographic" === e3 && (s9 = h2(s9)), [i4, s9];
}
function c3(t3, e3 = "geographic") {
  let n3 = t3[1];
  "geographic" === e3 && (n3 = h2(n3)), n3 %= 360;
  const r3 = t3[0];
  return [r3 * Math.cos(n3 / o2), r3 * Math.sin(n3 / o2)];
}
function u4(t3, e3, r3, o3 = "geographic") {
  if (!o(t3) || null == r3)
    return t3;
  const i4 = "vector-magdir" === e3 ? t3.clone() : f2(t3, e3), s9 = i4.pixels[1];
  for (let n3 = 0; n3 < s9.length; n3++)
    s9[n3] = "geographic" === o3 ? (s9[n3] + r3[n3] + 270) % 360 : (s9[n3] + 360 - r3[n3]) % 360;
  return "vector-magdir" === e3 ? i4 : f2(i4, "vector-magdir");
}
function f2(t3, r3, o3 = "geographic", i4 = 1) {
  if (!o(t3))
    return t3;
  const { pixels: s9, width: a6, height: h4 } = t3, u6 = a6 * h4, f4 = s9[0], p5 = s9[1], m4 = t3.pixelType.startsWith("f") ? t3.pixelType : "f32", d5 = u2.createEmptyBand(m4, u6), g4 = u2.createEmptyBand(m4, u6);
  let x3 = 0;
  for (let e3 = 0; e3 < h4; e3++)
    for (let t4 = 0; t4 < a6; t4++)
      "vector-uv" === r3 ? ([d5[x3], g4[x3]] = l4([f4[x3], p5[x3]], o3), d5[x3] *= i4) : ([d5[x3], g4[x3]] = c3([f4[x3], p5[x3]], o3), d5[x3] *= i4, g4[x3] *= i4), x3++;
  const M5 = new u2({ pixelType: m4, width: t3.width, height: t3.height, mask: t3.mask, validPixelCount: t3.validPixelCount, maskIsAlpha: t3.maskIsAlpha, pixels: [d5, g4] });
  return M5.updateStatistics(), M5;
}
function p3(t3, e3, r3 = 1) {
  if (1 === r3 || !o(t3))
    return t3;
  const o3 = t3.clone(), { pixels: i4, width: s9, height: a6 } = o3, h4 = i4[0], l5 = i4[1];
  let c5 = 0;
  for (let n3 = 0; n3 < a6; n3++)
    for (let t4 = 0; t4 < s9; t4++)
      "vector-uv" === e3 ? (h4[c5] *= r3, l5[c5] *= r3) : h4[c5] *= r3, c5++;
  return o3.updateStatistics(), o3;
}
function m2(t3, e3, n3, r3, o3) {
  if (null == o3 || !o3.spatialReference.equals(t3.spatialReference))
    return { extent: t3, width: Math.round(e3 / r3), height: Math.round(n3 / r3), resolution: t3.width / e3 };
  const i4 = o3.xmin, s9 = o3.ymax, a6 = (t3.xmax - t3.xmin) / e3 * r3, h4 = (t3.ymax - t3.ymin) / n3 * r3, l5 = (a6 + h4) / 2;
  return t3.xmin = i4 + Math.floor((t3.xmin - i4) / a6) * a6, t3.xmax = i4 + Math.ceil((t3.xmax - i4) / a6) * a6, t3.ymin = s9 + Math.floor((t3.ymin - s9) / h4) * h4, t3.ymax = s9 + Math.ceil((t3.ymax - s9) / h4) * h4, { extent: t3, width: Math.round(t3.width / a6), height: Math.round(t3.height / h4), resolution: l5 };
}
var d3 = g2(0, 0, 0);
function g2(t3 = 0, e3 = 0, n3 = Math.PI, r3 = true) {
  r3 && (n3 = (2 * Math.PI - n3) % (2 * Math.PI));
  const o3 = r3 ? -1 : 1, i4 = 13 * o3, s9 = -7 * o3, a6 = -2 * o3, h4 = -16 * o3, l5 = 21.75, [c5, u6] = M4(0, e3 + i4, n3, l5), [f4, p5] = M4(t3 - 5.5, e3 + s9, n3, l5), [m4, d5] = M4(t3 + 5.5, e3 + s9, n3, l5), [g4, x3] = M4(t3 - 1.5, e3 + a6, n3, l5), [k3, w4] = M4(t3 + 1.5, e3 + a6, n3, l5), [y5, P3] = M4(t3 - 1.5, e3 + h4, n3, l5), [b3, v3] = M4(t3 + 1.5, e3 + h4, n3, l5);
  return [c5, u6, f4, p5, g4, x3, k3, w4, m4, d5, y5, P3, b3, v3];
}
function x2(t3 = 0, e3 = Math.PI, n3 = true) {
  n3 && (e3 = (2 * Math.PI - e3) % (2 * Math.PI));
  const r3 = 10, o3 = n3 ? -1 : 1, s9 = 5 * o3, a6 = 20 * o3, h4 = 25 * o3, l5 = 45, c5 = 0, u6 = 0, f4 = 2, p5 = 0, m4 = f4 * o3, d5 = n3 ? 1 : -1, g4 = r3 / 2 * d5;
  let [x3, k3] = [c5 + g4, u6 - a6], [w4, y5] = [x3 + f4 * d5, k3], [P3, b3] = [w4 - p5 * d5, y5 + m4], [v3, I3] = [c5 - g4, u6 - h4], [A3, _3] = [v3 + p5 * d5, I3 - m4], U3 = Math.ceil(t3 / i2), S3 = Math.floor(U3 / 10);
  U3 -= 8 * S3;
  const D = [], F = [];
  for (let i4 = 0; i4 < U3 / 2; i4++, S3--) {
    S3 <= 0 && U3 % 2 == 1 && i4 === (U3 - 1) / 2 && (v3 = c5, A3 = v3 + p5 * d5, I3 = (I3 + k3) / 2, _3 = I3 - m4);
    const [t4, n4] = M4(v3, I3, e3, l5);
    if (S3 > 0) {
      const [r4, o4] = M4(w4, I3, e3, l5), [i5, s10] = M4(x3, k3, e3, l5);
      D.push(r4), D.push(o4), D.push(t4), D.push(n4), D.push(i5), D.push(s10);
    } else {
      const [r4, o4] = M4(w4, y5, e3, l5), [i5, s10] = M4(P3, b3, e3, l5), [a7, h5] = M4(A3, _3, e3, l5);
      F.push(t4), F.push(n4), F.push(a7), F.push(h5), F.push(i5), F.push(s10), F.push(r4), F.push(o4);
    }
    I3 += s9, k3 += s9, y5 += s9, b3 += s9, _3 += s9;
  }
  const [N, j] = M4(c5 + g4, u6 + a6, e3, l5), J = (r3 / 2 + f4) * d5, [O, q] = M4(c5 + J, u6 + a6, e3, l5), [B2, E2] = M4(c5 + g4, u6 - h4, e3, l5), [T2, C2] = M4(c5 + J, u6 - h4, e3, l5);
  return { pennants: D, barbs: F, shaft: [N, j, O, q, B2, E2, T2, C2] };
}
function M4(t3, e3, n3, r3 = 1) {
  const o3 = Math.sqrt(t3 * t3 + e3 * e3) / r3, i4 = (2 * Math.PI + Math.atan2(e3, t3)) % (2 * Math.PI);
  return [o3, (2 * Math.PI + i4 - n3) % (2 * Math.PI)];
}
var k2 = [0, 1, 3, 6, 10, 16, 21, 27, 33, 40, 47, 55, 63];
var w2 = [0, 0.5, 1, 1.5, 2];
var y3 = [0, 0.25, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4];
function P2(t3, e3, n3, r3) {
  const o3 = a4(r3 || "knots", n3);
  let i4;
  for (i4 = 1; i4 < e3.length; i4++)
    if (i4 === e3.length - 1) {
      if (t3 < e3[i4] * o3)
        break;
    } else if (t3 <= e3[i4] * o3)
      break;
  return Math.min(i4 - 1, e3.length - 2);
}
function b2(t3, e3, n3, r3, o3) {
  let i4 = 0;
  switch (e3) {
    case "beaufort_kn":
      i4 = P2(t3, k2, "knots", n3);
      break;
    case "beaufort_km":
      i4 = P2(t3, k2, "kilometer-per-hour", n3);
      break;
    case "beaufort_ft":
      i4 = P2(t3, k2, "feet-per-second", n3);
      break;
    case "beaufort_m":
      i4 = P2(t3, k2, "meter-per-second", n3);
      break;
    case "classified_arrow":
      i4 = P2(t3, o3 ?? [], r3, n3);
      break;
    case "ocean_current_m":
      i4 = P2(t3, w2, "meter-per-second", n3);
      break;
    case "ocean_current_kn":
      i4 = P2(t3, y3, "knots", n3);
  }
  return i4;
}
function v2(t3, e3) {
  const { style: n3, inputUnit: r3, outputUnit: o3, breakValues: i4 } = e3, a6 = s7.fromJSON(r3), h4 = s7.fromJSON(o3), l5 = 7 * 6, c5 = 15;
  let u6 = 0, f4 = 0;
  const { width: p5, height: m4, mask: x3 } = t3, M5 = t3.pixels[0], k3 = t3.pixels[1], w4 = null != x3 ? x3.filter((t4) => t4 > 0).length : p5 * m4, y5 = new Float32Array(w4 * l5), P3 = new Uint32Array(c5 * w4), v3 = e3.invertDirection ? g2(0, 0, 0, false) : d3;
  for (let s9 = 0; s9 < m4; s9++)
    for (let t4 = 0; t4 < p5; t4++) {
      const e4 = s9 * p5 + t4;
      if (!x3 || x3[s9 * p5 + t4]) {
        const r4 = (k3[e4] + 360) % 360 / 180 * Math.PI, o4 = b2(M5[e4], n3, a6, h4, i4);
        for (let n4 = 0; n4 < v3.length; n4 += 2)
          y5[u6++] = (t4 + 0.5) / p5, y5[u6++] = (s9 + 0.5) / m4, y5[u6++] = v3[n4], y5[u6++] = v3[n4 + 1] + r4, y5[u6++] = o4, y5[u6++] = M5[e4];
        const c6 = 7 * (u6 / l5 - 1);
        P3[f4++] = c6, P3[f4++] = c6 + 1, P3[f4++] = c6 + 2, P3[f4++] = c6 + 0, P3[f4++] = c6 + 4, P3[f4++] = c6 + 3, P3[f4++] = c6 + 0, P3[f4++] = c6 + 2, P3[f4++] = c6 + 3, P3[f4++] = c6 + 2, P3[f4++] = c6 + 5, P3[f4++] = c6 + 3, P3[f4++] = c6 + 5, P3[f4++] = c6 + 6, P3[f4++] = c6 + 3;
      }
    }
  return { vertexData: y5, indexData: P3 };
}
var I2 = [];
function A2(t3, e3) {
  if (0 === I2.length)
    for (let i4 = 0; i4 < 30; i4++)
      I2.push(x2(5 * i4, 0, !e3.invertDirection));
  const n3 = a4(s7.fromJSON(e3.inputUnit), "knots"), { width: r3, height: o3, mask: h4 } = t3, l5 = t3.pixels[0], c5 = t3.pixels[1], u6 = 6, f4 = [], p5 = [];
  let m4 = 0, d5 = 0;
  for (let s9 = 0; s9 < o3; s9++)
    for (let t4 = 0; t4 < r3; t4++) {
      const e4 = s9 * r3 + t4, a6 = l5[e4] * n3;
      if ((!h4 || h4[s9 * r3 + t4]) && a6 >= i2) {
        const n4 = (c5[e4] + 360) % 360 / 180 * Math.PI, { pennants: i4, barbs: h5, shaft: l6 } = I2[Math.min(Math.floor(a6 / 5), 29)];
        if (i4.length + h5.length === 0)
          continue;
        let g4 = f4.length / u6;
        const x3 = (t4 + 0.5) / r3, M5 = (s9 + 0.5) / o3;
        for (let t5 = 0; t5 < i4.length; t5 += 2)
          f4[m4++] = x3, f4[m4++] = M5, f4[m4++] = i4[t5], f4[m4++] = i4[t5 + 1] + n4, f4[m4++] = 0, f4[m4++] = a6;
        for (let t5 = 0; t5 < h5.length; t5 += 2)
          f4[m4++] = x3, f4[m4++] = M5, f4[m4++] = h5[t5], f4[m4++] = h5[t5 + 1] + n4, f4[m4++] = 0, f4[m4++] = a6;
        for (let t5 = 0; t5 < l6.length; t5 += 2)
          f4[m4++] = x3, f4[m4++] = M5, f4[m4++] = l6[t5], f4[m4++] = l6[t5 + 1] + n4, f4[m4++] = 0, f4[m4++] = a6;
        for (let t5 = 0; t5 < i4.length / 6; t5++)
          p5[d5++] = g4, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, g4 += 3;
        for (let t5 = 0; t5 < h5.length / 8; t5++)
          p5[d5++] = g4, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, p5[d5++] = g4 + 3, g4 += 4;
        p5[d5++] = g4 + 0, p5[d5++] = g4 + 1, p5[d5++] = g4 + 2, p5[d5++] = g4 + 1, p5[d5++] = g4 + 3, p5[d5++] = g4 + 2, g4 += 4;
      }
    }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p5) };
}
function _2(t3, e3) {
  const n3 = 4 * 6;
  let r3 = 0, o3 = 0;
  const { width: h4, height: l5, mask: c5 } = t3, u6 = t3.pixels[0], f4 = [], p5 = [], m4 = a4(s7.fromJSON(e3.inputUnit), "knots"), d5 = "wind_speed" === e3.style ? i2 : Number.MAX_VALUE;
  for (let i4 = 0; i4 < l5; i4++)
    for (let t4 = 0; t4 < h4; t4++) {
      const e4 = u6[i4 * h4 + t4] * m4;
      if ((!c5 || c5[i4 * h4 + t4]) && e4 < d5) {
        for (let n4 = 0; n4 < 4; n4++)
          f4[r3++] = (t4 + 0.5) / h4, f4[r3++] = (i4 + 0.5) / l5, f4[r3++] = n4 < 2 ? -0.5 : 0.5, f4[r3++] = n4 % 2 == 0 ? -0.5 : 0.5, f4[r3++] = 0, f4[r3++] = e4;
        const s9 = 4 * (r3 / n3 - 1);
        p5[o3++] = s9, p5[o3++] = s9 + 1, p5[o3++] = s9 + 2, p5[o3++] = s9 + 1, p5[o3++] = s9 + 2, p5[o3++] = s9 + 3;
      }
    }
  return { vertexData: new Float32Array(f4), indexData: new Uint32Array(p5) };
}
function U2(t3, e3) {
  return "simple_scalar" === e3.style ? _2(t3, e3) : "wind_speed" === e3.style ? A2(t3, e3) : v2(t3, e3);
}
function S2(t3, n3, r3, o3 = [0, 0], i4 = 0.5) {
  const { width: s9, height: a6, mask: h4 } = t3, [u6, f4] = t3.pixels, [p5, m4] = o3, d5 = Math.round((s9 - p5) / r3), g4 = Math.round((a6 - m4) / r3), x3 = d5 * g4, M5 = new Float32Array(x3), k3 = new Float32Array(x3), w4 = new Uint8Array(x3), y5 = "vector-uv" === n3;
  for (let e3 = 0; e3 < g4; e3++)
    for (let t4 = 0; t4 < d5; t4++) {
      let n4 = 0;
      const o4 = e3 * d5 + t4, g5 = Math.max(0, e3 * r3 + m4), x4 = Math.max(0, t4 * r3 + p5), P4 = Math.min(a6, g5 + r3), b3 = Math.min(s9, x4 + r3);
      for (let t5 = g5; t5 < P4; t5++)
        for (let e4 = x4; e4 < b3; e4++) {
          const r4 = t5 * s9 + e4;
          if (!h4 || h4[r4]) {
            n4++;
            const t6 = y5 ? [u6[r4], f4[r4]] : [u6[r4], (360 + f4[r4]) % 360], [e5, i5] = y5 ? t6 : c3(t6);
            M5[o4] += e5, k3[o4] += i5;
          }
        }
      if (n4 >= (P4 - g5) * (b3 - x4) * (1 - i4)) {
        w4[o4] = 1;
        const [t5, e4] = l4([M5[o4] / n4, k3[o4] / n4]);
        M5[o4] = t5, k3[o4] = e4;
      } else
        w4[o4] = 0, M5[o4] = 0, k3[o4] = 0;
    }
  const P3 = new u2({ width: d5, height: g4, pixels: [M5, k3], mask: w4 });
  return P3.updateStatistics(), P3;
}

// node_modules/@arcgis/core/views/2d/engine/flow/dataUtils.js
var i3 = s.getLogger("esri.views.2d.engine.flow.dataUtils");
var a5 = 10;
async function s8(t3, e3, r3, o3) {
  const l5 = performance.now(), s9 = c4(e3, r3), f4 = performance.now(), h4 = u5(e3, s9, r3.width, r3.height), p5 = performance.now(), g4 = m3(h4, true), y5 = performance.now(), x3 = "Streamlines" === t3 ? d4(g4, a5) : w3(g4), M5 = performance.now();
  return has("esri-2d-profiler") && (i3.info("I.1", "_createFlowFieldFromData (ms)", Math.round(f4 - l5)), i3.info("I.2", "_getStreamlines (ms)", Math.round(p5 - f4)), i3.info("I.3", "createAnimatedLinesData (ms)", Math.round(y5 - p5)), i3.info("I.4", "create{Streamlines|Particles}Mesh (ms)", Math.round(M5 - y5)), i3.info("I.5", "createFlowMesh (ms)", Math.round(M5 - l5)), i3.info("I.6", "Mesh size (bytes)", x3.vertexData.buffer.byteLength + x3.indexData.buffer.byteLength)), await Promise.resolve(), s3(o3), x3;
}
function c4(t3, e3) {
  const n3 = h3(e3.data, e3.width, e3.height, t3.smoothing);
  if (t3.interpolate) {
    return (t4, r3) => {
      const o3 = Math.floor(t4), l5 = Math.floor(r3);
      if (o3 < 0 || o3 >= e3.width)
        return [0, 0];
      if (l5 < 0 || l5 >= e3.height)
        return [0, 0];
      const i4 = t4 - o3, a6 = r3 - l5, s9 = o3, c5 = l5, f4 = o3 < e3.width - 1 ? o3 + 1 : o3, u6 = l5 < e3.height - 1 ? l5 + 1 : l5, h4 = n3[2 * (c5 * e3.width + s9)], m4 = n3[2 * (c5 * e3.width + f4)], d5 = n3[2 * (u6 * e3.width + s9)], w4 = n3[2 * (u6 * e3.width + f4)], p5 = n3[2 * (c5 * e3.width + s9) + 1], g4 = n3[2 * (c5 * e3.width + f4) + 1];
      return [(h4 * (1 - a6) + d5 * a6) * (1 - i4) + (m4 * (1 - a6) + w4 * a6) * i4, (p5 * (1 - a6) + n3[2 * (u6 * e3.width + s9) + 1] * a6) * (1 - i4) + (g4 * (1 - a6) + n3[2 * (u6 * e3.width + f4) + 1] * a6) * i4];
    };
  }
  return (t4, r3) => {
    const o3 = Math.round(t4), l5 = Math.round(r3);
    return o3 < 0 || o3 >= e3.width || l5 < 0 || l5 >= e3.height ? [0, 0] : [n3[2 * (l5 * e3.width + o3)], n3[2 * (l5 * e3.width + o3) + 1]];
  };
}
function f3(t3, e3, n3, r3, o3, l5, i4, a6, s9) {
  const c5 = [];
  let f4 = n3, u6 = r3, h4 = 0, [m4, d5] = e3(f4, u6);
  m4 *= t3.velocityScale, d5 *= t3.velocityScale;
  const w4 = Math.sqrt(m4 * m4 + d5 * d5);
  let p5, g4;
  c5.push({ x: f4, y: u6, t: h4, speed: w4 });
  for (let y5 = 0; y5 < t3.verticesPerLine; y5++) {
    let [n4, r4] = e3(f4, u6);
    n4 *= t3.velocityScale, r4 *= t3.velocityScale;
    const m5 = Math.sqrt(n4 * n4 + r4 * r4);
    if (m5 < t3.minSpeedThreshold)
      return c5;
    const d6 = n4 / m5, w5 = r4 / m5;
    f4 += d6 * t3.segmentLength, u6 += w5 * t3.segmentLength;
    if (h4 += t3.segmentLength / m5, Math.acos(d6 * p5 + w5 * g4) > t3.maxTurnAngle)
      return c5;
    if (t3.collisions) {
      const t4 = Math.round(f4 * s9), e4 = Math.round(u6 * s9);
      if (t4 < 0 || t4 > i4 - 1 || e4 < 0 || e4 > a6 - 1)
        return c5;
      const n5 = l5[e4 * i4 + t4];
      if (-1 !== n5 && n5 !== o3)
        return c5;
      l5[e4 * i4 + t4] = o3;
    }
    c5.push({ x: f4, y: u6, t: h4, speed: m5 }), p5 = d6, g4 = w5;
  }
  return c5;
}
function u5(t3, e3, n3, o3) {
  const l5 = [], i4 = new t(), a6 = 1 / Math.max(t3.lineCollisionWidth, 1), s9 = Math.round(n3 * a6), c5 = Math.round(o3 * a6), u6 = new Int32Array(s9 * c5);
  for (let r3 = 0; r3 < u6.length; r3++)
    u6[r3] = -1;
  const h4 = [];
  for (let r3 = 0; r3 < o3; r3 += t3.lineSpacing)
    for (let e4 = 0; e4 < n3; e4 += t3.lineSpacing)
      h4.push({ x: e4, y: r3, sort: i4.getFloat() });
  h4.sort((t4, e4) => t4.sort - e4.sort);
  for (const { x: r3, y: m4 } of h4)
    if (i4.getFloat() < t3.density) {
      const n4 = f3(t3, e3, r3, m4, l5.length, u6, s9, c5, a6);
      if (n4.length < 2)
        continue;
      l5.push(n4);
    }
  return l5;
}
function h3(t3, e3, n3, r3) {
  if (0 === r3)
    return t3;
  const o3 = Math.round(3 * r3), l5 = new Array(2 * o3 + 1);
  let i4 = 0;
  for (let c5 = -o3; c5 <= o3; c5++) {
    const t4 = Math.exp(-c5 * c5 / (r3 * r3));
    l5[c5 + o3] = t4, i4 += t4;
  }
  for (let c5 = -o3; c5 <= o3; c5++)
    l5[c5 + o3] /= i4;
  const a6 = new Float32Array(t3.length);
  for (let c5 = 0; c5 < n3; c5++)
    for (let n4 = 0; n4 < e3; n4++) {
      let r4 = 0, i5 = 0;
      for (let a7 = -o3; a7 <= o3; a7++) {
        if (n4 + a7 < 0 || n4 + a7 >= e3)
          continue;
        const s10 = l5[a7 + o3];
        r4 += s10 * t3[2 * (c5 * e3 + (n4 + a7))], i5 += s10 * t3[2 * (c5 * e3 + (n4 + a7)) + 1];
      }
      a6[2 * (c5 * e3 + n4)] = r4, a6[2 * (c5 * e3 + n4) + 1] = i5;
    }
  const s9 = new Float32Array(t3.length);
  for (let c5 = 0; c5 < e3; c5++)
    for (let t4 = 0; t4 < n3; t4++) {
      let r4 = 0, i5 = 0;
      for (let s10 = -o3; s10 <= o3; s10++) {
        if (t4 + s10 < 0 || t4 + s10 >= n3)
          continue;
        const f4 = l5[s10 + o3];
        r4 += f4 * a6[2 * ((t4 + s10) * e3 + c5)], i5 += f4 * a6[2 * ((t4 + s10) * e3 + c5) + 1];
      }
      s9[2 * (t4 * e3 + c5)] = r4, s9[2 * (t4 * e3 + c5) + 1] = i5;
    }
  return s9;
}
function m3(t3, e3) {
  const n3 = new t(), o3 = t3.reduce((t4, e4) => t4 + e4.length, 0), l5 = new Float32Array(4 * o3), i4 = new Array(t3.length);
  let a6 = 0, s9 = 0;
  for (const r3 of t3) {
    const t4 = a6;
    for (const e4 of r3)
      l5[4 * a6] = e4.x, l5[4 * a6 + 1] = e4.y, l5[4 * a6 + 2] = e4.t, l5[4 * a6 + 3] = e4.speed, a6++;
    i4[s9++] = { startVertex: t4, numberOfVertices: r3.length, totalTime: r3[r3.length - 1].t, timeSeed: e3 ? n3.getFloat() : 0 };
  }
  return { lineVertices: l5, lineDescriptors: i4 };
}
function d4(t3, e3) {
  const n3 = 9, { lineVertices: r3, lineDescriptors: o3 } = t3;
  let l5 = 0, i4 = 0;
  for (const m4 of o3) {
    l5 += 2 * m4.numberOfVertices;
    i4 += 6 * (m4.numberOfVertices - 1);
  }
  const a6 = new Float32Array(l5 * n3), s9 = new Uint32Array(i4);
  let c5 = 0, f4 = 0;
  function u6() {
    s9[f4++] = c5 - 2, s9[f4++] = c5, s9[f4++] = c5 - 1, s9[f4++] = c5, s9[f4++] = c5 + 1, s9[f4++] = c5 - 1;
  }
  function h4(t4, e4, r4, o4, l6, i5, s10, f5) {
    const u7 = c5 * n3;
    let h5 = 0;
    a6[u7 + h5++] = t4, a6[u7 + h5++] = e4, a6[u7 + h5++] = 1, a6[u7 + h5++] = r4, a6[u7 + h5++] = i5, a6[u7 + h5++] = s10, a6[u7 + h5++] = o4 / 2, a6[u7 + h5++] = l6 / 2, a6[u7 + h5++] = f5, c5++, a6[u7 + h5++] = t4, a6[u7 + h5++] = e4, a6[u7 + h5++] = -1, a6[u7 + h5++] = r4, a6[u7 + h5++] = i5, a6[u7 + h5++] = s10, a6[u7 + h5++] = -o4 / 2, a6[u7 + h5++] = -l6 / 2, a6[u7 + h5++] = f5, c5++;
  }
  for (const m4 of o3) {
    const { totalTime: t4, timeSeed: n4 } = m4;
    let o4 = null, l6 = null, i5 = null, a7 = null, s10 = null, c6 = null;
    for (let f5 = 0; f5 < m4.numberOfVertices; f5++) {
      const d5 = r3[4 * (m4.startVertex + f5)], w4 = r3[4 * (m4.startVertex + f5) + 1], p5 = r3[4 * (m4.startVertex + f5) + 2], g4 = r3[4 * (m4.startVertex + f5) + 3];
      let y5 = null, x3 = null, M5 = null, A3 = null;
      if (f5 > 0) {
        y5 = d5 - o4, x3 = w4 - l6;
        const r4 = Math.sqrt(y5 * y5 + x3 * x3);
        if (y5 /= r4, x3 /= r4, f5 > 1) {
          let t5 = y5 + s10, n5 = x3 + c6;
          const r5 = Math.sqrt(t5 * t5 + n5 * n5);
          t5 /= r5, n5 /= r5;
          const o5 = Math.min(1 / (t5 * y5 + n5 * x3), e3);
          t5 *= o5, n5 *= o5, M5 = -n5, A3 = t5;
        } else
          M5 = -x3, A3 = y5;
        null !== M5 && null !== A3 && (h4(o4, l6, i5, M5, A3, t4, n4, g4), u6());
      }
      o4 = d5, l6 = w4, i5 = p5, s10 = y5, c6 = x3, a7 = g4;
    }
    h4(o4, l6, i5, -c6, s10, t4, n4, a7);
  }
  return { vertexData: a6, indexData: s9 };
}
function w3(t3) {
  const e3 = 16, n3 = 1, r3 = 2, { lineVertices: o3, lineDescriptors: l5 } = t3;
  let i4 = 0, a6 = 0;
  for (const U3 of l5) {
    const t4 = U3.numberOfVertices - 1;
    i4 += 4 * t4 * 2, a6 += 6 * t4 * 2;
  }
  const s9 = new Float32Array(i4 * e3), c5 = new Uint32Array(a6);
  let f4, u6, h4, m4, d5, w4, p5, g4, y5, x3, M5, A3, I3, V, F = 0, D = 0;
  function v3() {
    c5[D++] = F - 8, c5[D++] = F - 7, c5[D++] = F - 6, c5[D++] = F - 7, c5[D++] = F - 5, c5[D++] = F - 6, c5[D++] = F - 4, c5[D++] = F - 3, c5[D++] = F - 2, c5[D++] = F - 3, c5[D++] = F - 1, c5[D++] = F - 2;
  }
  function b3(t4, o4, l6, i5, a7, c6, f5, u7, h5, m5, d6, w5, p6, g5) {
    const y6 = F * e3;
    let x4 = 0;
    for (const e4 of [n3, r3])
      for (const n4 of [1, 2, 3, 4])
        s9[y6 + x4++] = t4, s9[y6 + x4++] = o4, s9[y6 + x4++] = l6, s9[y6 + x4++] = i5, s9[y6 + x4++] = f5, s9[y6 + x4++] = u7, s9[y6 + x4++] = h5, s9[y6 + x4++] = m5, s9[y6 + x4++] = e4, s9[y6 + x4++] = n4, s9[y6 + x4++] = p6, s9[y6 + x4++] = g5, s9[y6 + x4++] = a7 / 2, s9[y6 + x4++] = c6 / 2, s9[y6 + x4++] = d6 / 2, s9[y6 + x4++] = w5 / 2, F++;
  }
  function S3(t4, e4) {
    let n4 = y5 + M5, r4 = x3 + A3;
    const o4 = Math.sqrt(n4 * n4 + r4 * r4);
    n4 /= o4, r4 /= o4;
    const l6 = y5 * n4 + x3 * r4;
    n4 /= l6, r4 /= l6;
    let i5 = M5 + I3, a7 = A3 + V;
    const s10 = Math.sqrt(i5 * i5 + a7 * a7);
    i5 /= s10, a7 /= s10;
    const c6 = M5 * i5 + A3 * a7;
    i5 /= c6, a7 /= c6, b3(f4, u6, h4, m4, -r4, n4, d5, w4, p5, g4, -a7, i5, t4, e4), v3();
  }
  function k3(t4, e4, n4, r4, o4, l6) {
    if (y5 = M5, x3 = A3, M5 = I3, A3 = V, null == y5 && null == x3 && (y5 = M5, x3 = A3), null != d5 && null != w4) {
      I3 = t4 - d5, V = e4 - w4;
      const n5 = Math.sqrt(I3 * I3 + V * V);
      I3 /= n5, V /= n5;
    }
    null != y5 && null != x3 && S3(o4, l6), f4 = d5, u6 = w4, h4 = p5, m4 = g4, d5 = t4, w4 = e4, p5 = n4, g4 = r4;
  }
  function L(t4, e4) {
    y5 = M5, x3 = A3, M5 = I3, A3 = V, null == y5 && null == x3 && (y5 = M5, x3 = A3), null != y5 && null != x3 && S3(t4, e4);
  }
  for (const U3 of l5) {
    f4 = null, u6 = null, h4 = null, m4 = null, d5 = null, w4 = null, p5 = null, g4 = null, y5 = null, x3 = null, M5 = null, A3 = null, I3 = null, V = null;
    const { totalTime: t4, timeSeed: e4 } = U3;
    for (let n4 = 0; n4 < U3.numberOfVertices; n4++) {
      k3(o3[4 * (U3.startVertex + n4)], o3[4 * (U3.startVertex + n4) + 1], o3[4 * (U3.startVertex + n4) + 2], o3[4 * (U3.startVertex + n4) + 3], t4, e4);
    }
    L(t4, e4);
  }
  return { vertexData: s9, indexData: c5 };
}
function p4(t3, n3) {
  const r3 = n3.pixels, { width: o3, height: l5 } = n3, i4 = new Float32Array(o3 * l5 * 2), a6 = n3.mask || new Uint8Array(o3 * l5 * 2);
  if (n3.mask || a6.fill(255), "vector-uv" === t3)
    for (let e3 = 0; e3 < o3 * l5; e3++)
      i4[2 * e3] = r3[0][e3], i4[2 * e3 + 1] = -r3[1][e3];
  else if ("vector-magdir" === t3)
    for (let s9 = 0; s9 < o3 * l5; s9++) {
      const t4 = r3[0][s9], n4 = M2(r3[1][s9]), o4 = Math.cos(n4 - Math.PI / 2), l6 = Math.sin(n4 - Math.PI / 2);
      i4[2 * s9] = o4 * t4, i4[2 * s9 + 1] = l6 * t4;
    }
  return { data: i4, mask: a6, width: o3, height: l5 };
}
async function g3(t3, e3, n3, r3, a6, s9) {
  const c5 = performance.now(), f4 = d(e3.spatialReference);
  if (!f4) {
    const o3 = await y4(t3, e3, n3, r3, a6, s9);
    return has("esri-2d-profiler") && i3.info("I.7", "loadImagery, early exit (ms)", Math.round(performance.now() - c5)), has("esri-2d-profiler") && i3.info("I.9", "Number of parts", 1), o3;
  }
  const [u6, h4] = f4.valid, m4 = h4 - u6, d5 = Math.ceil(e3.width / m4), w4 = e3.width / d5, p5 = Math.round(n3 / d5);
  let g4 = e3.xmin;
  const x3 = [], M5 = performance.now();
  for (let o3 = 0; o3 < d5; o3++) {
    const n4 = new M({ xmin: g4, xmax: g4 + w4, ymin: e3.ymin, ymax: e3.ymax, spatialReference: e3.spatialReference });
    x3.push(y4(t3, n4, p5, r3, a6, s9)), g4 += w4;
  }
  const A3 = await Promise.all(x3);
  has("esri-2d-profiler") && i3.info("I.8", "All calls to _fetchPart (ms)", Math.round(performance.now() - M5)), has("esri-2d-profiler") && i3.info("I.9", "Number of parts", A3.length);
  const I3 = { data: new Float32Array(n3 * r3 * 2), mask: new Uint8Array(n3 * r3), width: n3, height: r3 };
  let V = 0;
  for (const o3 of A3) {
    for (let t4 = 0; t4 < o3.height; t4++)
      for (let e4 = 0; e4 < o3.width; e4++)
        V + e4 >= n3 || (I3.data[2 * (t4 * n3 + V + e4)] = o3.data[2 * (t4 * o3.width + e4)], I3.data[2 * (t4 * n3 + V + e4) + 1] = o3.data[2 * (t4 * o3.width + e4) + 1], I3.mask[t4 * n3 + V + e4] = o3.mask[t4 * o3.width + e4]);
    V += o3.width;
  }
  return has("esri-2d-profiler") && i3.info("I.10", "loadImagery, general exit (ms)", Math.round(performance.now() - c5)), I3;
}
async function y4(t3, e3, n3, r3, o3, l5) {
  const i4 = { requestProjectedLocalDirections: true, signal: l5 };
  if (null != o3 && (i4.timeExtent = o3), "imagery" === t3.type) {
    await t3.load({ signal: l5 });
    const o4 = t3.rasterInfo.dataType, a7 = await t3.fetchImage(e3, n3, r3, i4);
    return a7 && null != a7.pixelData && null != a7.pixelData.pixelBlock ? p4(o4, a7.pixelData.pixelBlock) : { data: new Float32Array(n3 * r3 * 2), mask: new Uint8Array(n3 * r3), width: n3, height: r3 };
  }
  await t3.load({ signal: l5 });
  const a6 = t3.rasterInfo.dataType, s9 = await t3.fetchPixels(e3, n3, r3, i4);
  return s9 && null != s9.pixelBlock ? p4(a6, s9.pixelBlock) : { data: new Float32Array(n3 * r3 * 2), mask: new Uint8Array(n3 * r3), width: n3, height: r3 };
}

export {
  s6 as s,
  u,
  u2,
  n2 as n,
  l3 as l,
  i,
  o,
  r,
  a3 as a,
  h,
  f,
  c2 as c,
  u3,
  p2 as p,
  g,
  y2 as y,
  w,
  M3 as M,
  U,
  T,
  W,
  I,
  R,
  s7 as s2,
  a4 as a2,
  l4 as l2,
  u4,
  f2,
  p3 as p2,
  m2 as m,
  _2 as _,
  U2,
  S2 as S,
  s8 as s3,
  g3 as g2
};
//# sourceMappingURL=chunk-F72FE4ZJ.js.map
