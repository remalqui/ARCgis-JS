import {
  p,
  w
} from "./chunk-G5WJIWPP.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/layers/support/LayerFloorInfo.js
var l2;
var i = l2 = class extends l {
  constructor(o2) {
    super(o2), this.floorField = null, this.viewAllMode = false, this.viewAllLevelIds = new V();
  }
  clone() {
    return new l2({ floorField: this.floorField, viewAllMode: this.viewAllMode, viewAllLevelIds: this.viewAllLevelIds });
  }
};
e([y({ type: String, json: { write: true } })], i.prototype, "floorField", void 0), e([y({ json: { read: false, write: false } })], i.prototype, "viewAllMode", void 0), e([y({ json: { read: false, write: false } })], i.prototype, "viewAllLevelIds", void 0), i = l2 = e([a("esri.layers.support.LayerFloorInfo")], i);
var p2 = i;

// node_modules/@arcgis/core/layers/support/serviceCapabilitiesUtils.js
var e2 = { name: "supportsName", size: "supportsSize", contentType: "supportsContentType", keywords: "supportsKeywords", exifInfo: "supportsExifInfo" };
function r(t, s, e3) {
  return !!o(t, s, e3);
}
function p3(t, s, e3) {
  return o(t, s, e3);
}
function o(t, s, e3) {
  return t && t.hasOwnProperty(s) ? t[s] : e3;
}
function u(t) {
  var _a;
  const s = (_a = t == null ? void 0 : t.supportedSpatialAggregationStatistics) == null ? void 0 : _a.map((t2) => t2.toLowerCase());
  return { envelope: !!(s == null ? void 0 : s.includes("envelopeaggregate")), centroid: !!(s == null ? void 0 : s.includes("centroidaggregate")), convexHull: !!(s == null ? void 0 : s.includes("convexhullaggregate")) };
}
function a2(t, s) {
  var _a;
  const e3 = (_a = t == null ? void 0 : t.supportedOperationsWithCacheHint) == null ? void 0 : _a.map((t2) => t2.toLowerCase());
  return !!(e3 == null ? void 0 : e3.includes(s.toLowerCase()));
}
function n(t, s) {
  return { analytics: i2(t), attachment: c(t), data: d(t), metadata: l3(t), operations: y2(t.capabilities, t, s), query: m(t, s), queryRelated: h(t), queryTopFeatures: C(t), editing: g(t) };
}
function i2(t) {
  return { supportsCacheHint: a2(t.advancedQueryCapabilities, "queryAnalytics") };
}
function c(t) {
  const s = t.attachmentProperties, p4 = { supportsName: false, supportsSize: false, supportsContentType: false, supportsKeywords: false, supportsExifInfo: false, supportsCacheHint: a2(t.advancedQueryCapabilities, "queryAttachments"), supportsResize: r(t, "supportsAttachmentsResizing", false) };
  return s && Array.isArray(s) && s.forEach((t2) => {
    const s2 = e2[t2.name];
    s2 && (p4[s2] = !!t2.isEnabled);
  }), p4;
}
function d(t) {
  return { isVersioned: r(t, "isDataVersioned", false), supportsAttachment: r(t, "hasAttachments", false), supportsM: r(t, "hasM", false), supportsZ: r(t, "hasZ", false) };
}
function l3(t) {
  return { supportsAdvancedFieldProperties: r(t, "supportsFieldDescriptionProperty", false) };
}
function y2(s, e3, p4) {
  const o2 = s ? s.toLowerCase().split(",").map((t) => t.trim()) : [], u2 = p4 ? p(p4) : null, a3 = o2.includes(null != u2 && "MapServer" === u2.serverType ? "data" : "query"), n2 = o2.includes("editing") && !e3.datesInUnknownTimezone;
  let i3 = n2 && o2.includes("create"), c2 = n2 && o2.includes("delete"), d2 = n2 && o2.includes("update");
  const l4 = o2.includes("changetracking"), y3 = e3.advancedQueryCapabilities;
  return n2 && !(i3 || c2 || d2) && (i3 = c2 = d2 = true), { supportsCalculate: r(e3, "supportsCalculate", false), supportsTruncate: r(e3, "supportsTruncate", false), supportsValidateSql: r(e3, "supportsValidateSql", false), supportsAdd: i3, supportsDelete: c2, supportsEditing: n2, supportsChangeTracking: l4, supportsQuery: a3, supportsQueryAnalytics: r(y3, "supportsQueryAnalytic", false), supportsQueryAttachments: r(y3, "supportsQueryAttachments", false), supportsQueryTopFeatures: r(y3, "supportsTopFeaturesQuery", false), supportsResizeAttachments: r(e3, "supportsAttachmentsResizing", false), supportsSync: o2.includes("sync"), supportsUpdate: d2, supportsExceedsLimitStatistics: r(e3, "supportsExceedsLimitStatistics", false), supportsAsyncConvert3D: r(e3, "supportsAsyncConvert3D", false) };
}
function m(t, e3) {
  const o2 = t.advancedQueryCapabilities, n2 = t.ownershipBasedAccessControlForFeatures, i3 = t.archivingInfo, c2 = t.currentVersion, d2 = e3 == null ? void 0 : e3.includes("MapServer"), l4 = !d2 || c2 >= has("mapserver-pbf-version-support"), y3 = w(e3), m2 = new Set((t.supportedQueryFormats ?? "").split(",").map((t2) => t2.toLowerCase().trim()));
  return { supportsStatistics: r(o2, "supportsStatistics", t.supportsStatistics), supportsPercentileStatistics: r(o2, "supportsPercentileStatistics", false), supportsSpatialAggregationStatistics: r(o2, "supportsSpatialAggregationStatistics", false), supportedSpatialAggregationStatistics: u(o2), supportsCentroid: r(o2, "supportsReturningGeometryCentroid", false), supportsDistance: r(o2, "supportsQueryWithDistance", false), supportsDistinct: r(o2, "supportsDistinct", t.supportsAdvancedQueries), supportsExtent: r(o2, "supportsReturningQueryExtent", false), supportsGeometryProperties: r(o2, "supportsReturningGeometryProperties", false), supportsHavingClause: r(o2, "supportsHavingClause", false), supportsOrderBy: r(o2, "supportsOrderBy", t.supportsAdvancedQueries), supportsPagination: r(o2, "supportsPagination", false), supportsQuantization: r(t, "supportsCoordinatesQuantization", false), supportsQuantizationEditMode: r(t, "supportsQuantizationEditMode", false), supportsQueryGeometry: r(t, "supportsReturningQueryGeometry", false), supportsResultType: r(o2, "supportsQueryWithResultType", false), supportsMaxRecordCountFactor: r(o2, "supportsMaxRecordCountFactor", false), supportsSqlExpression: r(o2, "supportsSqlExpression", false), supportsStandardizedQueriesOnly: r(t, "useStandardizedQueries", false), supportsTopFeaturesQuery: r(o2, "supportsTopFeaturesQuery", false), supportsQueryByOthers: r(n2, "allowOthersToQuery", true), supportsHistoricMoment: r(i3, "supportsQueryWithHistoricMoment", false), supportsFormatPBF: l4 && m2.has("pbf"), supportsDisjointSpatialRelationship: r(o2, "supportsDisjointSpatialRel", false), supportsCacheHint: r(o2, "supportsQueryWithCacheHint", false) || a2(o2, "query"), supportsDefaultSpatialReference: r(o2, "supportsDefaultSR", false), supportsCompactGeometry: y3, supportsFullTextSearch: r(o2, "supportsFullTextSearch", false), maxRecordCountFactor: p3(t, "maxRecordCountFactor", void 0), maxRecordCount: p3(t, "maxRecordCount", void 0), standardMaxRecordCount: p3(t, "standardMaxRecordCount", void 0), tileMaxRecordCount: p3(t, "tileMaxRecordCount", void 0) };
}
function h(t) {
  const s = t.advancedQueryCapabilities, e3 = r(s, "supportsAdvancedQueryRelated", false);
  return { supportsPagination: r(s, "supportsQueryRelatedPagination", false), supportsCount: e3, supportsOrderBy: e3, supportsCacheHint: a2(s, "queryRelated") };
}
function C(t) {
  return { supportsCacheHint: a2(t.advancedQueryCapabilities, "queryTopFilter") };
}
function g(t) {
  const s = t.ownershipBasedAccessControlForFeatures, e3 = t ? t.advancedEditingCapabilities : void 0;
  return { supportsGeometryUpdate: r(t, "allowGeometryUpdates", true), supportsGlobalId: r(t, "supportsApplyEditsWithGlobalIds", false), supportsReturnServiceEditsInSourceSpatialReference: r(t, "supportsReturnServiceEditsInSourceSR", false), supportsRollbackOnFailure: r(t, "supportsRollbackOnFailureParameter", false), supportsUpdateWithoutM: r(t, "allowUpdateWithoutMValues", false), supportsUploadWithItemId: r(t, "supportsAttachmentsByUploadId", false), supportsDeleteByAnonymous: r(s, "allowAnonymousToDelete", true), supportsDeleteByOthers: r(s, "allowOthersToDelete", true), supportsUpdateByAnonymous: r(s, "allowAnonymousToUpdate", true), supportsUpdateByOthers: r(s, "allowOthersToUpdate", true), supportsAsyncApplyEdits: r(e3, "supportsAsyncApplyEdits", false) };
}

export {
  p2 as p,
  n
};
//# sourceMappingURL=chunk-7XRP3RPT.js.map
