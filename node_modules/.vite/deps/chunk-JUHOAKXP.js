import {
  i
} from "./chunk-MOPR7RFH.js";

// node_modules/@arcgis/core/core/Cyclical.js
var i2 = class {
  constructor(n, i3) {
    this.min = n, this.max = i3, this.range = i3 - n;
  }
  ndiff(n, i3 = 0) {
    return Math.ceil((n - i3) / this.range) * this.range + i3;
  }
  _normalize(n, i3, t2, o2 = 0, r2 = false) {
    return (t2 -= o2) < n ? t2 += this.ndiff(n - t2) : t2 > i3 && (t2 -= this.ndiff(t2 - i3)), r2 && t2 === i3 && (t2 = n), t2 + o2;
  }
  normalize(n, i3 = 0, t2 = false) {
    return this._normalize(this.min, this.max, n, i3, t2);
  }
  clamp(i3, t2 = 0) {
    return i(i3 - t2, this.min, this.max) + t2;
  }
  monotonic(n, i3, t2) {
    return n < i3 ? i3 : i3 + this.ndiff(n - i3, t2);
  }
  minimalMonotonic(n, i3, t2) {
    return this._normalize(n, n + this.range, i3, t2);
  }
  center(n, i3, t2) {
    return i3 = this.monotonic(n, i3, t2), this.normalize((n + i3) / 2, t2);
  }
  diff(n, i3, t2) {
    return this.monotonic(n, i3, t2) - n;
  }
  shortestSignedDiff(n, i3) {
    n = this.normalize(n);
    const t2 = (i3 = this.normalize(i3)) - n, o2 = i3 < n ? this.minimalMonotonic(n, i3) - n : i3 - this.minimalMonotonic(i3, n);
    return Math.abs(t2) < Math.abs(o2) ? t2 : o2;
  }
  contains(n, i3, t2) {
    return i3 = this.minimalMonotonic(n, i3), (t2 = this.minimalMonotonic(n, t2)) > n && t2 < i3;
  }
};
function t(n) {
  for (const i3 in n) {
    const t2 = n[i3];
    t2 instanceof Function && (n[i3] = t2.bind(n));
  }
  return n;
}
var o = t(new i2(0, 2 * Math.PI));
var r = t(new i2(-Math.PI, Math.PI));
var s = t(new i2(0, 360));

export {
  s
};
//# sourceMappingURL=chunk-JUHOAKXP.js.map
