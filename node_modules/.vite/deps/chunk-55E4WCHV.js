import {
  i as i2,
  r,
  s as s2
} from "./chunk-UQOM5GR4.js";
import {
  f,
  l,
  m,
  s,
  u
} from "./chunk-T4XWQYGC.js";
import {
  a,
  y
} from "./chunk-TCASQSKO.js";
import {
  i
} from "./chunk-5HAVROZG.js";
import {
  A,
  d
} from "./chunk-SFV6XLDZ.js";

// node_modules/@arcgis/core/geometry/support/normalizeUtilsSync.js
function c(t) {
  return p(t, true);
}
function a2(t) {
  return p(t, false);
}
function p(t, s3) {
  if (null == t)
    return null;
  const c2 = t.spatialReference, a3 = d(c2), p2 = "toJSON" in t ? t.toJSON() : t;
  if (!a3)
    return p2;
  const y3 = A(c2) ? 102100 : 4326, I2 = r[y3].maxX, g2 = r[y3].minX;
  if (l(p2))
    return d2(p2, I2, g2);
  if (u(p2))
    return p2.points = p2.points.map((t2) => d2(t2, I2, g2)), p2;
  if (m(p2))
    return f2(p2, a3);
  if (f(p2) || s(p2)) {
    const t2 = a(C, p2), n = { xmin: t2[0], ymin: t2[1], xmax: t2[2], ymax: t2[3] }, e = i2(n.xmin, g2) * (2 * I2), h = 0 === e ? p2 : s2(p2, e);
    return n.xmin += e, n.xmax += e, n.xmax > I2 ? O(h, I2, s3) : n.xmin < g2 ? O(h, g2, s3) : h;
  }
  return p2;
}
function f2(t, i3) {
  if (!i3)
    return t;
  const s3 = y2(t, i3).map((t2) => t2.extent);
  return s3.length < 2 ? s3[0] || t : s3.length > 2 ? (t.xmin = i3.valid[0], t.xmax = i3.valid[1], t) : { rings: s3.map((t2) => [[t2.xmin, t2.ymin], [t2.xmin, t2.ymax], [t2.xmax, t2.ymax], [t2.xmax, t2.ymin], [t2.xmin, t2.ymin]]) };
}
function d2(t, i3, s3) {
  if (Array.isArray(t)) {
    const n = t[0];
    if (n > i3) {
      const s4 = i2(n, i3);
      t[0] = n + s4 * (-2 * i3);
    } else if (n < s3) {
      const i4 = i2(n, s3);
      t[0] = n + i4 * (-2 * s3);
    }
  } else {
    const n = t.x;
    if (n > i3) {
      const s4 = i2(n, i3);
      t.x += s4 * (-2 * i3);
    } else if (n < s3) {
      const i4 = i2(n, s3);
      t.x += i4 * (-2 * s3);
    }
  }
  return t;
}
function y2(t, i3) {
  const s3 = [], { ymin: n, ymax: e, xmin: h, xmax: o } = t, r2 = t.xmax - t.xmin, [u2, m2] = i3.valid, { x, frameId: _ } = I(t.xmin, i3), { x: l2, frameId: c2 } = I(t.xmax, i3), a3 = x === l2 && r2 > 0;
  if (r2 > 2 * m2) {
    const t2 = { xmin: h < o ? x : l2, ymin: n, xmax: m2, ymax: e }, i4 = { xmin: u2, ymin: n, xmax: h < o ? l2 : x, ymax: e }, r3 = { xmin: 0, ymin: n, xmax: m2, ymax: e }, a4 = { xmin: u2, ymin: n, xmax: 0, ymax: e }, p2 = [], f3 = [];
    g(t2, r3) && p2.push(_), g(t2, a4) && f3.push(_), g(i4, r3) && p2.push(c2), g(i4, a4) && f3.push(c2);
    for (let s4 = _ + 1; s4 < c2; s4++)
      p2.push(s4), f3.push(s4);
    s3.push(new P(t2, [_]), new P(i4, [c2]), new P(r3, p2), new P(a4, f3));
  } else
    x > l2 || a3 ? s3.push(new P({ xmin: x, ymin: n, xmax: m2, ymax: e }, [_]), new P({ xmin: u2, ymin: n, xmax: l2, ymax: e }, [c2])) : s3.push(new P({ xmin: x, ymin: n, xmax: l2, ymax: e }, [_]));
  return s3;
}
function I(t, i3) {
  const [s3, n] = i3.valid, e = 2 * n;
  let h, o = 0;
  return t > n ? (h = Math.ceil(Math.abs(t - n) / e), t -= h * e, o = h) : t < s3 && (h = Math.ceil(Math.abs(t - s3) / e), t += h * e, o = -h), { x: t, frameId: o };
}
function g(t, i3) {
  const { xmin: s3, ymin: n, xmax: e, ymax: h } = i3;
  return v(t, s3, n) && v(t, s3, h) && v(t, e, h) && v(t, e, n);
}
function v(t, i3, s3) {
  return i3 >= t.xmin && i3 <= t.xmax && s3 >= t.ymin && s3 <= t.ymax;
}
function O(t, i3, n = true) {
  const e = !s(t);
  if (e && y(t), n) {
    return new S().cut(t, i3);
  }
  const h = e ? t.rings : t.paths, o = e ? 4 : 2, u2 = h.length, m2 = -2 * i3;
  for (let s3 = 0; s3 < u2; s3++) {
    const t2 = h[s3];
    if (t2 && t2.length >= o) {
      const i4 = [];
      for (const s4 of t2)
        i4.push([s4[0] + m2, s4[1]]);
      h.push(i4);
    }
  }
  return e ? t.rings = h : t.paths = h, t;
}
var P = class {
  constructor(t, i3) {
    this.extent = t, this.frameIds = i3;
  }
};
var C = i();
var S = class {
  constructor() {
    this._linesIn = [], this._linesOut = [];
  }
  cut(t, i3) {
    let s3;
    if (this._xCut = i3, t.rings)
      this._closed = true, s3 = t.rings, this._minPts = 4;
    else {
      if (!t.paths)
        return null;
      this._closed = false, s3 = t.paths, this._minPts = 2;
    }
    for (const e of s3) {
      if (!e || e.length < this._minPts)
        continue;
      let t2 = true;
      for (const i4 of e)
        t2 ? (this.moveTo(i4), t2 = false) : this.lineTo(i4);
      this._closed && this.close();
    }
    this._pushLineIn(), this._pushLineOut(), s3 = [];
    for (const e of this._linesIn)
      e && e.length >= this._minPts && s3.push(e);
    const n = -2 * this._xCut;
    for (const e of this._linesOut)
      if (e && e.length >= this._minPts) {
        for (const t2 of e)
          t2[0] += n;
        s3.push(e);
      }
    return this._closed ? t.rings = s3 : t.paths = s3, t;
  }
  moveTo(t) {
    this._pushLineIn(), this._pushLineOut(), this._prevSide = this._side(t[0]), this._moveTo(t[0], t[1], this._prevSide), this._prevPt = t, this._firstPt = t;
  }
  lineTo(t) {
    const i3 = this._side(t[0]);
    if (i3 * this._prevSide == -1) {
      const s3 = this._intersect(this._prevPt, t);
      this._lineTo(this._xCut, s3, 0), this._prevSide = 0, this._lineTo(t[0], t[1], i3);
    } else
      this._lineTo(t[0], t[1], i3);
    this._prevSide = i3, this._prevPt = t;
  }
  close() {
    const t = this._firstPt, i3 = this._prevPt;
    t[0] === i3[0] && t[1] === i3[1] || this.lineTo(t), this._checkClosingPt(this._lineIn), this._checkClosingPt(this._lineOut);
  }
  _moveTo(t, i3, s3) {
    this._closed ? (this._lineIn.push([s3 <= 0 ? t : this._xCut, i3]), this._lineOut.push([s3 >= 0 ? t : this._xCut, i3])) : (s3 <= 0 && this._lineIn.push([t, i3]), s3 >= 0 && this._lineOut.push([t, i3]));
  }
  _lineTo(t, i3, s3) {
    this._closed ? (this._addPolyVertex(this._lineIn, s3 <= 0 ? t : this._xCut, i3), this._addPolyVertex(this._lineOut, s3 >= 0 ? t : this._xCut, i3)) : s3 < 0 ? (0 === this._prevSide && this._pushLineOut(), this._lineIn.push([t, i3])) : s3 > 0 ? (0 === this._prevSide && this._pushLineIn(), this._lineOut.push([t, i3])) : this._prevSide < 0 ? (this._lineIn.push([t, i3]), this._lineOut.push([t, i3])) : this._prevSide > 0 && (this._lineOut.push([t, i3]), this._lineIn.push([t, i3]));
  }
  _addPolyVertex(t, i3, s3) {
    const n = t.length;
    n > 1 && t[n - 1][0] === i3 && t[n - 2][0] === i3 ? t[n - 1][1] = s3 : t.push([i3, s3]);
  }
  _checkClosingPt(t) {
    const i3 = t.length;
    i3 > 3 && t[0][0] === this._xCut && t[i3 - 2][0] === this._xCut && t[1][0] === this._xCut && (t[0][1] = t[i3 - 2][1], t.pop());
  }
  _side(t) {
    return t < this._xCut ? -1 : t > this._xCut ? 1 : 0;
  }
  _intersect(t, i3) {
    const s3 = (this._xCut - t[0]) / (i3[0] - t[0]);
    return t[1] + s3 * (i3[1] - t[1]);
  }
  _pushLineIn() {
    this._lineIn && this._lineIn.length >= this._minPts && this._linesIn.push(this._lineIn), this._lineIn = [];
  }
  _pushLineOut() {
    this._lineOut && this._lineOut.length >= this._minPts && this._linesOut.push(this._lineOut), this._lineOut = [];
  }
};

export {
  c,
  a2 as a
};
//# sourceMappingURL=chunk-55E4WCHV.js.map
