{
  "version": 3,
  "sources": ["../../@esri/calcite-components/dist/components/composed-offset-position.esm.js"],
  "sourcesContent": ["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.4.3\n */\n/* eslint-disable @typescript-eslint/ban-types */\nfunction offsetParent(element) {\n    return offsetParentPolyfill(element);\n}\nfunction offsetTop(element) {\n    return offsetTopLeftPolyfill(element, 'offsetTop');\n}\nfunction offsetLeft(element) {\n    return offsetTopLeftPolyfill(element, 'offsetLeft');\n}\nfunction flatTreeParent(element) {\n    if (element.assignedSlot) {\n        return element.assignedSlot;\n    }\n    if (element.parentNode instanceof ShadowRoot) {\n        return element.parentNode.host;\n    }\n    return element.parentNode;\n}\nfunction ancestorTreeScopes(element) {\n    const scopes = new Set();\n    let currentScope = element.getRootNode();\n    while (currentScope) {\n        scopes.add(currentScope);\n        currentScope = currentScope.parentNode\n            ? currentScope.parentNode.getRootNode()\n            : null;\n    }\n    return scopes;\n}\nfunction offsetParentPolyfill(element) {\n    // Do an initial walk to check for display:none ancestors.\n    for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        if (getComputedStyle(ancestor).display === 'none') {\n            return null;\n        }\n    }\n    for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        const style = getComputedStyle(ancestor);\n        // Display:contents nodes aren't in the layout tree so they should be skipped.\n        if (style.display === 'contents') {\n            continue;\n        }\n        if (style.position !== 'static' || style.filter !== 'none') {\n            return ancestor;\n        }\n        if (ancestor.tagName === 'BODY') {\n            return ancestor;\n        }\n    }\n    return null;\n}\nfunction offsetTopLeftPolyfill(element, offsetTopOrLeft) {\n    let value = element[offsetTopOrLeft];\n    let nextOffsetParent = offsetParentPolyfill(element);\n    const scopes = ancestorTreeScopes(element);\n    while (nextOffsetParent && !scopes.has(nextOffsetParent.getRootNode())) {\n        value -= nextOffsetParent[offsetTopOrLeft];\n        nextOffsetParent = offsetParentPolyfill(nextOffsetParent);\n    }\n    return value;\n}\n\nexport { offsetLeft, offsetParent, offsetTop };\n"],
  "mappings": ";;;AAMA,SAAS,aAAa,SAAS;AAC3B,SAAO,qBAAqB,OAAO;AACvC;AACA,SAAS,UAAU,SAAS;AACxB,SAAO,sBAAsB,SAAS,WAAW;AACrD;AACA,SAAS,WAAW,SAAS;AACzB,SAAO,sBAAsB,SAAS,YAAY;AACtD;AACA,SAAS,eAAe,SAAS;AAC7B,MAAI,QAAQ,cAAc;AACtB,WAAO,QAAQ;AAAA,EACnB;AACA,MAAI,QAAQ,sBAAsB,YAAY;AAC1C,WAAO,QAAQ,WAAW;AAAA,EAC9B;AACA,SAAO,QAAQ;AACnB;AACA,SAAS,mBAAmB,SAAS;AACjC,QAAM,SAAS,oBAAI,IAAI;AACvB,MAAI,eAAe,QAAQ,YAAY;AACvC,SAAO,cAAc;AACjB,WAAO,IAAI,YAAY;AACvB,mBAAe,aAAa,aACtB,aAAa,WAAW,YAAY,IACpC;AAAA,EACV;AACA,SAAO;AACX;AACA,SAAS,qBAAqB,SAAS;AAEnC,WAAS,WAAW,SAAS,UAAU,WAAW,eAAe,QAAQ,GAAG;AACxE,QAAI,EAAE,oBAAoB,UAAU;AAChC;AAAA,IACJ;AACA,QAAI,iBAAiB,QAAQ,EAAE,YAAY,QAAQ;AAC/C,aAAO;AAAA,IACX;AAAA,EACJ;AACA,WAAS,WAAW,eAAe,OAAO,GAAG,UAAU,WAAW,eAAe,QAAQ,GAAG;AACxF,QAAI,EAAE,oBAAoB,UAAU;AAChC;AAAA,IACJ;AACA,UAAM,QAAQ,iBAAiB,QAAQ;AAEvC,QAAI,MAAM,YAAY,YAAY;AAC9B;AAAA,IACJ;AACA,QAAI,MAAM,aAAa,YAAY,MAAM,WAAW,QAAQ;AACxD,aAAO;AAAA,IACX;AACA,QAAI,SAAS,YAAY,QAAQ;AAC7B,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,sBAAsB,SAAS,iBAAiB;AACrD,MAAI,QAAQ,QAAQ,eAAe;AACnC,MAAI,mBAAmB,qBAAqB,OAAO;AACnD,QAAM,SAAS,mBAAmB,OAAO;AACzC,SAAO,oBAAoB,CAAC,OAAO,IAAI,iBAAiB,YAAY,CAAC,GAAG;AACpE,aAAS,iBAAiB,eAAe;AACzC,uBAAmB,qBAAqB,gBAAgB;AAAA,EAC5D;AACA,SAAO;AACX;",
  "names": []
}
