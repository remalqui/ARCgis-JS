import {
  e as e3
} from "./chunk-HSAM6HYE.js";
import {
  r
} from "./chunk-7YWQQHOF.js";
import {
  c as c4
} from "./chunk-TBMS67KR.js";
import {
  x
} from "./chunk-PEYWLFGJ.js";
import {
  T,
  e2
} from "./chunk-NE5U5H4D.js";
import {
  c as c2,
  f as f2
} from "./chunk-YM46NRFF.js";
import {
  c as c3
} from "./chunk-3Y3ICAIL.js";
import {
  n as n3
} from "./chunk-TNXVIMSN.js";
import {
  l,
  l2,
  n as n4
} from "./chunk-HPXPYN62.js";
import {
  o as o3
} from "./chunk-A6DRT2G4.js";
import {
  t
} from "./chunk-GTENSI4J.js";
import {
  f
} from "./chunk-XP6ESZGI.js";
import {
  K as K2,
  V,
  W
} from "./chunk-3VTULECI.js";
import {
  L as L2,
  S as S2
} from "./chunk-TBHRKIAA.js";
import {
  E,
  F,
  G,
  H,
  I,
  J,
  K,
  P,
  Q,
  R as R2,
  S,
  U as U2,
  c,
  de,
  z
} from "./chunk-JSMUQBPG.js";
import {
  a as a2
} from "./chunk-QAWS7Y22.js";
import {
  D,
  L,
  U
} from "./chunk-BCDDCNQ2.js";
import {
  n as n5
} from "./chunk-KKBQS7Z3.js";
import {
  e
} from "./chunk-D5NSNTGJ.js";
import {
  n as n2
} from "./chunk-QNFDBY7V.js";
import {
  o as o2,
  s as s5
} from "./chunk-EL72ISXP.js";
import {
  i as i2,
  s as s4
} from "./chunk-SS33L3LC.js";
import {
  o,
  u
} from "./chunk-EIE3W25Z.js";
import {
  j
} from "./chunk-TCASQSKO.js";
import {
  i
} from "./chunk-5HAVROZG.js";
import {
  d
} from "./chunk-SFV6XLDZ.js";
import {
  C
} from "./chunk-HNHXEGH2.js";
import {
  a,
  n,
  s
} from "./chunk-DWOEYHKS.js";
import {
  s2,
  s3
} from "./chunk-W2N7YT6I.js";
import {
  R,
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/rendererUtils.js
var s6 = 8;
var l3 = s6 - 2;
var a3 = s2.getLogger("esri.views.2d.layers.features.support.rendererUtils");
var n6 = (e6) => {
  if (!("visualVariables" in e6) || !e6.visualVariables || !e6.visualVariables.length)
    return e6;
  const r5 = e6.clone(), t3 = r5.visualVariables.map((e7) => u2(e7) ? p(e7) : e7);
  return r5.visualVariables = t3, r5;
};
function i3(e6) {
  return e6.map((e7) => u2(e7) ? p(e7.clone()) : e7);
}
function u2(e6) {
  return ("size" === e6.type || "color" === e6.type || "opacity" === e6.type) && null != e6.stops;
}
function p(e6) {
  return e6.stops = m(e6.type, e6.stops ?? []), e6;
}
function c5(e6, r5, t3) {
  return (1 - t3) * e6 + t3 * r5;
}
function f3(e6, r5) {
  const [o4, ...s8] = r5, a5 = s8.pop(), n9 = s8[0].value, i6 = s8[s8.length - 1].value, u4 = (i6 - n9) / l3, p3 = [];
  for (let l4 = n9; l4 < i6; l4 += u4) {
    let o5 = 0;
    for (; l4 >= s8[o5].value; )
      o5++;
    const a6 = s8[o5], n10 = r5[o5 - 1], i7 = l4 - n10.value, u5 = a6.value === n10.value ? 1 : i7 / (a6.value - n10.value);
    if ("color" === e6) {
      const e7 = s8[o5], t3 = r5[o5 - 1], a7 = e7.color.clone();
      a7.r = c5(t3.color.r, a7.r, u5), a7.g = c5(t3.color.g, a7.g, u5), a7.b = c5(t3.color.b, a7.b, u5), a7.a = c5(t3.color.a, a7.a, u5), p3.push({ value: l4, color: a7, label: e7.label });
    } else if ("size" === e6) {
      const e7 = s8[o5], a7 = r5[o5 - 1], n11 = o(e7.size), i8 = c5(o(a7.size), n11, u5);
      p3.push({ value: l4, size: i8, label: e7.label });
    } else {
      const e7 = s8[o5], t3 = c5(r5[o5 - 1].opacity, e7.opacity, u5);
      p3.push({ value: l4, opacity: t3, label: e7.label });
    }
  }
  return [o4, ...p3, a5];
}
function b(e6) {
  const [r5, ...t3] = e6, o4 = t3.pop();
  for (; t3.length > l3; ) {
    let e7 = 0, r6 = 0;
    for (let o5 = 1; o5 < t3.length; o5++) {
      const s8 = t3[o5 - 1], l4 = t3[o5], a5 = Math.abs(l4.value - s8.value);
      a5 > r6 && (r6 = a5, e7 = o5);
    }
    t3.splice(e7, 1);
  }
  return [r5, ...t3, o4];
}
function m(e6, r5) {
  return r5.length <= s6 ? r5 : (a3.warn(`Found ${r5.length} Visual Variable stops, but MapView only supports ${s6}. Displayed stops will be simplified.`), r5.length > 2 * s6 ? f3(e6, r5) : b(r5));
}
function g() {
  if (has("heatmap-force-raster"))
    return "raster";
  const { supportsTextureFloat: e6, supportsTextureHalfFloat: r5, supportsColorBufferFloat: t3, supportsColorBufferFloatBlend: s8, supportsColorBufferHalfFloat: l4 } = n5("2d");
  return e6 && t3 && s8 || r5 && l4 ? "symbol" : has("heatmap-allow-raster-fallback") ? "raster" : "none";
}
function h(r5) {
  if (!r5)
    return true;
  switch (r5.type) {
    case "dot-density":
      if (!n5("2d").supportsTextureFloat)
        return a3.error(new s3("webgl-missing-extension", "Missing WebGL extension OES_Texture_Float which is required for DotDensity")), false;
      break;
    case "heatmap": {
      const r6 = g();
      if ("none" === r6 || "raster" === r6 && !has("heatmap-force-raster")) {
        const t3 = n5("2d"), s8 = ["supportsTextureFloat", "supportsTextureHalfFloat", "supportsColorBufferFloat", "supportsColorBufferFloatBlend", "supportsColorBufferHalfFloat"].filter((e6) => !t3[e6]).join(", ");
        if ("none" === r6)
          return a3.errorOnce(new s3("webgl-missing-extension", `Missing WebGL${t3.type} requirements for Heatmap: ${s8}`)), false;
        "raster" === r6 && a3.warnOnce(`Missing WebGL${t3.type} requirements for accelerated Heatmap: ${s8}. Feature support may be limited.`);
      }
      break;
    }
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/util/vvFlagUtils.js
function e4(e6) {
  if (!e6)
    return L2.NONE;
  let r5 = 0;
  for (const i6 of e6)
    if ("size" === i6.type) {
      const t3 = l2(i6);
      r5 |= t3, "outline" === i6.target && (r5 |= t3 << 4);
    } else
      "color" === i6.type ? r5 |= L2.COLOR : "opacity" === i6.type ? r5 |= L2.OPACITY : "rotation" === i6.type && (r5 |= L2.ROTATION);
  return r5;
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var c6 = 512;
var f4 = 50;
function g2(e6, t3) {
  const n9 = d(t3);
  if (!n9)
    return null;
  const [o4, s8] = n9.valid;
  return e6[2] > s8 ? [i([e6[0], e6[1], s8, e6[3]]), i([o4, e6[1], o4 + e6[2] - s8, e6[3]])] : e6[0] < o4 ? [i([o4, e6[1], e6[2], e6[3]]), i([s8 - (o4 - e6[0]), e6[1], s8, e6[3]])] : null;
}
function u3(e6) {
  return "text" === e6 || "esriTS" === e6;
}
function p2(e6) {
  return "simple-marker" === e6 || "picture-marker" === e6 || "esriSMS" === e6 || "esriPMS" === e6;
}
function h2(e6) {
  switch (e6.geometry.type) {
    case "point":
    case "multipoint":
      return 0;
    case "polyline":
      return 1;
    case "polygon":
    case "extent":
      return 2;
  }
  return 0;
}
function x2(e6) {
  if (!e6)
    return null;
  const { xmin: t3, ymin: i6, xmax: r5, ymax: o4, spatialReference: s8 } = e6;
  return new j({ rings: [[[t3, i6], [t3, o4], [r5, o4], [r5, i6], [t3, i6]]], spatialReference: s8 });
}

// node_modules/@arcgis/core/views/2d/layers/features/support/pixelBuffering.js
function m2(t3, e6) {
  if (!("visualVariables" in t3))
    return 0;
  if (!t3.hasVisualVariables("size"))
    return 0;
  const r5 = t3.getVisualVariablesForType("size");
  if (!r5[0])
    return 0;
  const i6 = r5[0];
  if (e6 && "cluster_count" === i6.field && "cluster" === e6.type)
    return e6.clusterMaxSize;
  if ("outline" === i6.target)
    return 0;
  if ("stops" === i6.transformationType)
    return i6.stops.map((t4) => t4.size).reduce(g3, 0);
  if ("clamped-linear" === i6.transformationType) {
    let t4 = -1 / 0, e7 = -1 / 0;
    return t4 = "number" == typeof i6.maxSize ? i6.maxSize : i6.maxSize.stops.map((t5) => t5.size).reduce(g3, 0), e7 = "number" == typeof i6.minSize ? i6.minSize : i6.minSize.stops.map((t5) => t5.size).reduce(g3, 0), Math.max(t4, e7);
  }
  return "real-world-size" === i6.transformationType ? 30 : void 0;
}
var y = { sdf: true, code: 99, metrics: z.metrics, rect: new t(0, 0, 24, 24), page: 0, textureBinding: 2 };
function g3(t3, e6) {
  return Math.max(t3, e6);
}

// node_modules/@arcgis/core/views/2d/layers/features/schemaUtils.js
var x3 = s2.getLogger("esri.views.2d.layers.features.schemaUtils");
var h3 = "ValidationError";
function v(e6) {
  return e6;
}
function T2(e6, t3) {
  let r5 = 0, i6 = 0, n9 = S2.DEFAULT;
  if (null != e6) {
    if (i6 = m2(e6, t3), "visualVariables" in e6 && (r5 = e4(e6.visualVariables || []), "dot-density" === e6.type && (n9 = S2.DOT_DENSITY)), "heatmap" === e6.type && (n9 = S2.HEATMAP), "dictionary" === e6.type)
      return { maxVVSize: i6, vvFlags: r5, symbologyType: S2.DEFAULT };
    if ("pie-chart" === e6.type)
      return { maxVVSize: i6, vvFlags: r5, symbologyType: S2.PIE_CHART };
    if (n9 !== S2.DOT_DENSITY && n9 !== S2.HEATMAP) {
      const t4 = e6.getSymbols();
      "backgroundFillSymbol" in e6 && e6.backgroundFillSymbol && t4.push(e6.backgroundFillSymbol);
      let r6 = true, i7 = true;
      for (const e7 of t4)
        if ("cim" !== e7.type && "web-style" !== e7.type || (i7 = false), "simple-fill" === e7.type || "picture-fill" === e7.type) {
          const t5 = e7.outline, n10 = t5 && "none" !== t5.style && "solid" !== t5.style, s8 = "simple-fill" === e7.type && "none" !== e7.style && "solid" !== e7.style;
          n10 && (r6 = false), ("picture-fill" === e7.type || s8 || n10) && (i7 = false);
        }
      r6 ? n9 = i7 ? S2.OUTLINE_FILL_SIMPLE : S2.OUTLINE_FILL : i7 && (n9 = S2.SIMPLE);
    }
  }
  return { vvFlags: r5, maxVVSize: i6, symbologyType: n9 };
}
var S4 = null;
function w2(e6) {
  if (has("esri-2d-update-debug")) {
    const t3 = E2(e6, true);
    console.debug("Created new schema", t3), console.debug("Schema diff", a2(S4, t3)), S4 = t3;
  }
  return E2(e6);
}
function E2(e6, t3 = false) {
  var _a, _b;
  try {
    const r5 = R3(e6, t3), i6 = D2(e6), s8 = {};
    r5.map((t4) => F2(s8, e6, t4));
    const l4 = null != e6.subtypeCode ? `${e6.subtypeField} = ${e6.subtypeCode}` : null, o4 = n3(e6.definitionExpression, l4);
    return { source: { definitionExpression: o4, fields: e6.fields.map((e7) => e7.toJSON()), gdbVersion: e6.gdbVersion, historicMoment: (_a = e6.historicMoment) == null ? void 0 : _a.getTime(), outFields: e6.availableFields, pixelBuffer: e6.pixelBuffer, spatialReference: e6.spatialReference.toJSON(), timeExtent: (_b = e6.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: e6.customParameters }, attributes: { fields: {}, indexCount: 0 }, processors: r5, tileRenderer: i6, targets: s8 };
  } catch (r5) {
    if (r5.fieldName === h3)
      return x3.error(r5), null;
    throw r5;
  }
}
function F2(e6, r5, i6) {
  switch (i6.target) {
    case "feature":
      return void O(e6, V2(r5), i6);
    case "aggregate": {
      if (!("featureReduction" in r5))
        return;
      const n9 = r5.featureReduction;
      switch (n9 == null ? void 0 : n9.type) {
        case "selection":
          throw new s3(h3, "Mapview does not support `selection` reduction type", n9);
        case "binning":
          return O(e6, V2(r5), i6), void N(e6, n9, r5.fields.map((e7) => e7.toJSON()), i6);
        case "cluster":
          return O(e6, V2(r5), i6), void L3(e6, n9, r5.fields.map((e7) => e7.toJSON()), i6);
      }
    }
  }
}
function I2(e6, t3) {
  var _a, _b;
  for (const r5 in t3) {
    const i6 = t3[r5];
    if (i6.target !== e6.name)
      continue;
    const n9 = e6.attributes[r5];
    if (n9 == null ? void 0 : n9.context) {
      const e7 = n9.context;
      e7.mesh = e7.mesh || ((_a = i6.context) == null ? void 0 : _a.mesh), e7.storage = e7.storage || ((_b = i6.context) == null ? void 0 : _b.storage);
    } else
      e6.attributes[r5] = i6;
  }
  return e6;
}
function V2(e6) {
  var _a, _b, _c;
  return [((_a = e6.filter) == null ? void 0 : _a.toJSON()) ?? null, ((_c = (_b = e6.featureEffect) == null ? void 0 : _b.filter) == null ? void 0 : _c.toJSON()) ?? null];
}
function O(e6, t3, r5) {
  return e6.feature || (e6.feature = { name: "feature", input: "source", filters: t3, attributes: {} }), I2(e6.feature, r5.attributes.fields), e6;
}
function z2(e6, r5) {
  const { onStatisticExpression: i6, onStatisticField: n9, statisticType: s8 } = e6;
  switch (s8) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (i6) {
        const { returnType: r6 } = i6;
        return r6 ? "string" === r6 ? "esriFieldTypeString" : "esriFieldTypeDouble" : (x3.error(new s3(h3, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", e6)), "esriFieldTypeString");
      }
      const s9 = r5.find((e7) => e7.name === n9);
      return s9 ? s9.type : (x3.error(new s3(h3, "Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined", e6)), "esriFieldTypeString");
    }
  }
}
function N(e6, t3, r5, i6) {
  return e6.aggregate || (e6.aggregate = { name: "aggregate", type: "bin", filters: null, input: "feature", params: { fixedBinLevel: t3.fixedBinLevel, fields: (t3.fields ?? []).map((e7) => ({ ...e7.toJSON(), type: z2(e7, r5) })) }, attributes: {} }), I2(e6.aggregate, i6.attributes.fields), e6;
}
function L3(e6, t3, r5, n9) {
  const s8 = n9.aggregateFields ?? [], l4 = /* @__PURE__ */ new Set();
  for (const i6 of s8)
    l4.add(i6.name);
  for (const i6 of (t3 == null ? void 0 : t3.fields) ?? [])
    l4.has(i6.name) || s8.push(i6);
  return e6.aggregate || (e6.aggregate = { name: "aggregate", type: "cluster", input: "feature", filters: null, attributes: {}, params: { clusterRadius: u(t3.clusterRadius / 2), clusterPixelBuffer: 64 * Math.ceil(u(t3.clusterMaxSize) / 64), fields: s8.map((e7) => ({ ...e7.toJSON(), type: z2(e7, r5) })) } }), I2(e6.aggregate, n9.attributes.fields), e6;
}
function M(e6, t3) {
  return t3.field ? j2(e6, { ...t3, type: "field", field: t3.field }) : t3.valueExpression ? j2(e6, { ...t3, type: "expression", valueExpression: t3.valueExpression }) : { field: void 0, fieldIndex: void 0 };
}
function j2(e6, t3) {
  switch (t3.type) {
    case "expression": {
      const r5 = v(t3.valueExpression);
      if (!e6.fields[r5]) {
        const i6 = e6.indexCount++;
        e6.fields[r5] = { ...t3, name: r5, fieldIndex: i6 };
      }
      return { fieldIndex: e6.fields[r5].fieldIndex };
    }
    case "label-expression": {
      const r5 = v(JSON.stringify(t3.label));
      if (!e6.fields[r5]) {
        const i6 = e6.indexCount++;
        e6.fields[r5] = { ...t3, name: r5, fieldIndex: i6 };
      }
      return { fieldIndex: e6.fields[r5].fieldIndex };
    }
    case "field": {
      const r5 = t3.field;
      return "aggregate" === t3.target && e6.fields[r5] || (e6.fields[r5] = { ...t3, name: r5 }), { field: r5 };
    }
    case "statistic":
      return e6.fields[t3.name] = { ...t3 }, { field: t3.name };
  }
}
function R3(e6, t3 = false) {
  const r5 = new Array();
  let i6 = 0;
  return r5.push(A(e6, i6++, t3)), r5;
}
function U3(e6, t3, r5, i6, n9, s8 = false) {
  const l4 = j2(e6, { type: "label-expression", target: r5, context: { mesh: true }, resultType: "string", label: { labelExpression: t3.labelExpression, labelExpressionInfo: t3.labelExpressionInfo ? { expression: t3.labelExpressionInfo.expression } : null, symbol: !!t3.symbol, where: t3.where } }), { fieldIndex: o4 } = l4;
  return { ...o3(t3, n9, s8), fieldIndex: o4, target: r5, index: i6 };
}
function B(e6, r5, i6) {
  var _a;
  const n9 = "featureReduction" in r5 && r5.featureReduction;
  if (!n9)
    return { fields: [], labels: [], matcher: void 0, rendererOverride: void 0 };
  const s8 = "aggregate", o4 = [];
  let a5 = null, u4 = e3(r5.geometryType), d3 = [], p3 = null;
  if (n9)
    switch (n9.type) {
      case "selection":
        return x3.error(new s3(h3, "Mapview does not support `selection` reduction type", n9)), { fields: [], labels: [], matcher: void 0, rendererOverride: void 0 };
      case "cluster":
      case "binning":
        if (o4.push(...n9.fields ?? []), "cluster" === n9.type ? u4 = "esriGeometryPoint" : "binning" === n9.type && (u4 = "esriGeometryPolygon"), n9.renderer && !((_a = n9.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated)) {
          if ("cluster" === n9.type) {
            const { renderer: e7 } = f2(n9.renderer, n9, null);
            p3 = e7;
          } else
            p3 = n9.renderer;
          const t3 = T2(n9.renderer, n9);
          a5 = _(e6, s8, n9.renderer, t3, i6), d3 = n9 && n9.labelsVisible && n9.labelingInfo || [];
        } else if ("cluster" === n9.type) {
          if (p3 = c2(o4, r5.renderer, n9, null, true), n9.symbol) {
            const e7 = T2(p3, n9);
            a5 = { type: "simple", symbol: o3(n9.symbol, e7, i6), symbologyType: e7.symbologyType };
          }
          d3 = n9 && n9.labelsVisible && n9.labelingInfo || [];
        }
    }
  k(e6, o4);
  return { labels: c3(d3, "binning" === n9.type ? "esriGeometryPolygon" : u4), matcher: a5, fields: o4, rendererOverride: p3 };
}
function A(e6, r5, i6 = false) {
  var _a;
  const n9 = { indexCount: 0, fields: {} }, s8 = "featureReduction" in e6 ? e6.featureReduction ?? void 0 : void 0, a5 = s8 ? "aggregate" : "feature";
  if ("sublayers" in e6) {
    const r6 = { type: "subtype", subtypeField: e6.subtypeField, renderers: {}, symbologyType: S2.DEFAULT }, s9 = { type: "subtype", mapping: {}, target: "feature", subtypeField: e6.subtypeField }, l4 = { type: "subtype", classes: {} }, u5 = { type: "symbol", target: "feature", aggregateFields: [], attributes: n9, storage: s9, mesh: { matcher: r6, aggregateMatcher: null, labels: l4, sortKey: null } }, f6 = /* @__PURE__ */ new Set();
    let p4 = 0;
    for (const { renderer: c7, subtypeCode: y3, labelingInfo: m5, labelsVisible: g5 } of e6.sublayers) {
      let e7 = 0;
      "visualVariables" in c7 && c7.visualVariables && (c7.visualVariables.some((e8) => "rotation" !== e8.type) && x3.warnOnce("SubtypeGroupLayer currently only supports rotation visualVariables. All other visualVariable types will be ignored."), e7 = e4(c7.visualVariables.filter((e8) => "size" !== e8.type)));
      const u6 = { symbologyType: S2.DEFAULT, vvFlags: e7, maxVVSize: 0 }, b3 = _(n9, a5, c7, u6, i6), v3 = C2(n9, a5, c7), T3 = g5 && m5;
      if ("dictionary" === b3.type)
        throw new s3(h3, "Dictionary renderer is not supported in subtype layers");
      if ("subtype" === b3.type)
        throw new s3(h3, "Nested subtype renderers is not supported");
      if (null != v3 && "subtype" === v3.type)
        throw new s3(h3, "Nested subtype storage is not supported");
      if (null != v3 && null != v3.attributeMapping)
        throw new s3(h3, "Non-visual-variable attributes are not supported in subtype layers");
      if ("heatmap" === b3.type)
        throw new s3(h3, "Heatmaps are not supported in subtype layers");
      if ("pie-chart" === b3.type)
        throw new s3(h3, "Pie-charts are not supported in subtype layers");
      if (f6.has(y3))
        throw new s3(h3, "Subtype codes for sublayers must be unique");
      f6.add(y3), r6.renderers[y3] = b3, s9.mapping[y3] = v3, T3 && (l4.classes[y3] = T3.map((e8) => U3(n9, e8, "feature", p4++, u6, i6)));
    }
    return u5;
  }
  if ("heatmap" === ((_a = e6.renderer) == null ? void 0 : _a.type) && "raster" === g()) {
    const { radius: t3, fieldOffset: r6, field: i7 } = e6.renderer;
    return { type: "heatmap", aggregateFields: [], attributes: n9, target: a5, storage: null, mesh: { radius: t3, fieldOffset: r6, field: M(n9, { target: a5, field: i7, resultType: "numeric" }).field } };
  }
  const u4 = B(n9, e6, i6), f5 = e3(e6.geometryType), p3 = u4.rendererOverride ?? e6.renderer, y2 = T2(p3, s8), m4 = _(n9, a5, p3, y2, i6), g4 = C2(n9, a5, p3), v2 = P2(n9, e6.orderBy, e6.renderer, s8), S5 = e6.labelsVisible && e6.labelingInfo || [], w3 = c3(S5, f5);
  let E3 = 0;
  const F3 = [...w3.map((e7) => U3(n9, e7, "feature", E3++, y2, i6)), ...u4.labels.map((e7) => U3(n9, e7, "aggregate", E3++, y2, i6))];
  return { type: "symbol", target: a5, attributes: n9, aggregateFields: u4.fields, storage: g4, mesh: { matcher: m4, labels: { type: "simple", classes: F3 }, aggregateMatcher: u4.matcher, sortKey: v2 } };
}
function D2(e6) {
  var _a;
  return "heatmap" === ((_a = e6.renderer) == null ? void 0 : _a.type) && "raster" === g() ? { type: "heatmap" } : { type: "symbol" };
}
function P2(e6, r5, i6, n9) {
  if (null != n9)
    return null;
  if (null != r5 && r5.length) {
    r5.length > 1 && x3.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${r5.length}. All but the first will be discarded`);
    const i7 = r5[0], n10 = "ascending" === i7.order ? "asc" : "desc";
    if (i7.field)
      return { field: i7.field, order: n10 };
    if (i7.valueExpression) {
      return { fieldIndex: j2(e6, { type: "expression", target: "feature", valueExpression: i7.valueExpression, resultType: "numeric" }).fieldIndex, order: n10 };
    }
    return x3.error(new s3(h3, "Expected to find a field or valueExpression for OrderByInfo", i7)), null;
  }
  if (null != i6 && "unique-value" === i6.type && i6.orderByClassesEnabled) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function k(e6, t3) {
  const r5 = { mesh: true, storage: true };
  for (const i6 of t3) {
    const { name: t4, onStatisticField: n9, onStatisticExpression: s8, statisticType: l4 } = i6;
    let o4, a5;
    const u4 = "numeric", d3 = "feature";
    if (s8) {
      a5 = j2(e6, { type: "expression", target: d3, valueExpression: s8.expression, resultType: u4 }).fieldIndex;
    } else {
      o4 = j2(e6, { type: "field", target: d3, field: n9, resultType: u4 }).field;
    }
    j2(e6, { type: "statistic", target: "aggregate", name: t4, context: r5, inField: o4, inFieldIndex: a5, statisticType: l4 });
  }
}
function C2(e6, t3, r5) {
  let i6;
  switch (r5.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      i6 = { visualVariables: true, attributes: null };
      break;
    default:
      i6 = c4(r5).getStorageSpec(r5);
  }
  return J2(e6, t3, i6, r5);
}
function J2(e6, t3, r5, i6) {
  if (null == r5)
    return null;
  const { visualVariables: n9, attributes: s8 } = r5;
  let l4 = null;
  n9 && "visualVariables" in i6 && (l4 = q(e6, t3, i6.visualVariables));
  const o4 = null != l4 ? 4 : 0;
  let a5 = null;
  return null != s8 && (a5 = s8.map((r6, i7) => {
    const { field: n10, fieldIndex: s9 } = M(e6, { valueExpression: r6.valueExpression, field: r6.field, resultType: "numeric", target: t3 });
    return { binding: i7 + o4, field: n10, fieldIndex: s9 };
  })), { type: "simple", target: t3, attributeMapping: a5, vvMapping: l4 };
}
function q(t3, r5, i6) {
  if (!i6 || !i6.length)
    return [];
  const n9 = { storage: true }, s8 = "numeric";
  return i3(i6).map((e6) => {
    const i7 = V(e6.type), { field: l4, fieldIndex: o4 } = M(t3, { target: r5, valueExpression: e6.valueExpression, field: e6.field, context: n9, resultType: s8 });
    switch (e6.type) {
      case "size":
        return "$view.scale" === e6.valueExpression ? null : { type: "size", binding: i7, field: l4, fieldIndex: o4, normalizationField: M(t3, { target: r5, field: e6.normalizationField, context: n9, resultType: s8 }).field, valueRepresentation: e6.valueRepresentation ?? null };
      case "color":
        return { type: "color", binding: i7, field: l4, fieldIndex: o4, normalizationField: M(t3, { target: r5, field: e6.normalizationField, context: n9, resultType: s8 }).field };
      case "opacity":
        return { type: "opacity", binding: i7, field: l4, fieldIndex: o4, normalizationField: M(t3, { target: r5, field: e6.normalizationField, context: n9, resultType: s8 }).field };
      case "rotation":
        return { type: "rotation", binding: i7, field: l4, fieldIndex: o4 };
    }
  }).filter(R);
}
function _(e6, t3, r5, i6, n9 = false) {
  const s8 = e6 ?? { indexCount: 0, fields: {} };
  switch (r5.type) {
    case "simple":
    case "dot-density":
      return G2(s8, r5, i6, n9);
    case "class-breaks":
      return $(s8, t3, r5, i6, n9);
    case "unique-value":
      return K3(s8, t3, r5, i6, n9);
    case "dictionary":
      return Y(s8, r5, i6, n9);
    case "heatmap":
      return Q2(s8, r5, i6, n9);
    case "pie-chart":
      return H2(s8, r5, i6, n9);
  }
}
function G2(e6, t3, r5, i6 = false) {
  const n9 = t3.getSymbols(), s8 = n9.length ? n9[0] : null;
  return { type: "simple", symbol: o3(s8, r5, i6), symbologyType: r5.symbologyType };
}
function H2(e6, t3, r5, i6 = false) {
  const n9 = t3.getSymbols(), s8 = n9[0], l4 = n9.length > 1 ? n9[1] : null;
  return { type: "pie-chart", markerSymbol: o3(s8, r5, i6), fillSymbol: o3(l4, r5, i6), symbologyType: r5.symbologyType };
}
function $(e6, t3, r5, i6, n9 = false) {
  const s8 = { mesh: true, use: "renderer.field" }, l4 = r5.backgroundFillSymbol, { field: o4, fieldIndex: a5 } = M(e6, { target: t3, field: r5.field, valueExpression: r5.valueExpression, resultType: "numeric", context: s8 }), u4 = r5.normalizationType, d3 = "log" === u4 ? "esriNormalizeByLog" : "percent-of-total" === u4 ? "esriNormalizeByPercentOfTotal" : "field" === u4 ? "esriNormalizeByField" : null, p3 = r5.classBreakInfos.map((e7) => ({ symbol: o3(e7.symbol, i6, n9), min: e7.minValue, max: e7.maxValue })).sort((e7, t4) => e7.min - t4.min);
  return { type: "interval", attributes: e6.fields, field: o4, fieldIndex: a5, backgroundFillSymbol: o3(l4, i6, n9), defaultSymbol: o3(r5.defaultSymbol, i6, n9), intervals: p3, normalizationField: r5.normalizationField, normalizationTotal: r5.normalizationTotal, normalizationType: d3, isMaxInclusive: r5.isMaxInclusive, symbologyType: i6.symbologyType };
}
function K3(e6, r5, i6, n9, s8 = false) {
  const l4 = [], o4 = i6.backgroundFillSymbol, a5 = { target: r5, context: { mesh: true }, resultType: "string" };
  if (i6.field && "string" != typeof i6.field)
    throw new s3(h3, "Expected renderer.field to be a string", i6);
  const { field: u4, fieldIndex: d3 } = M(e6, { ...a5, field: i6.field, valueExpression: i6.valueExpression });
  for (const t3 of i6.uniqueValueInfos ?? [])
    l4.push({ value: "" + t3.value, symbol: o3(t3.symbol, n9, s8) });
  return { type: "map", attributes: e6.fields, field: u4, fieldIndex: d3, field2: M(e6, { ...a5, field: i6.field2 }).field, field3: M(e6, { ...a5, field: i6.field3 }).field, fieldDelimiter: i6.fieldDelimiter ?? void 0, backgroundFillSymbol: o3(o4, n9), defaultSymbol: o3(i6.defaultSymbol, n9), map: l4, symbologyType: n9.symbologyType };
}
function Y(e6, t3, r5, i6 = false) {
  return { type: "dictionary", config: t3.config, fieldMap: t3.fieldMap, scaleExpression: t3.scaleExpression, url: t3.url, symbolOptions: r5, symbologyType: r5.symbologyType };
}
function Q2(e6, t3, r5, i6 = false) {
  const n9 = t3.getSymbols(), s8 = n9.length ? n9[0] : null;
  return { type: "heatmap", symbol: o3(s8, r5, i6), symbologyType: r5.symbologyType };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/AttributeStoreView.js
var j3 = s2.getLogger("esri.views.2d.engine.webgl.AttributeStoreView");
var k2 = n4(l, j3);
var M2 = class {
  constructor(t3, e6, i6) {
    this._texture = null, this._lastTexture = null, this._fbos = {}, this.texelSize = 4;
    const { buffer: s8, pixelType: r5, textureOnly: a5 } = t3, n9 = W(r5);
    this.shared = i6, this.pixelType = r5, this.size = e6, this.textureOnly = a5, a5 || (this.data = new n9(s8)), this._resetRange();
  }
  destroy() {
    n(this._texture, (t3) => t3.dispose());
    for (const t3 in this._fbos)
      n(this._fbos[t3], (e6) => {
        "0" === t3 && e6.detachColorTexture(), e6.dispose();
      }), this._fbos[t3] = null;
    this._texture = null;
  }
  get _textureDesc() {
    const t3 = new e2();
    return t3.wrapMode = D.CLAMP_TO_EDGE, t3.samplingMode = L.NEAREST, t3.dataType = this.pixelType, t3.width = this.size, t3.height = this.size, t3;
  }
  setData(t3, e6, i6) {
    const s8 = f(t3), r5 = this.data, a5 = s8 * this.texelSize + e6;
    !r5 || a5 >= r5.length || (r5[a5] = i6, this.dirtyStart = Math.min(this.dirtyStart, s8), this.dirtyEnd = Math.max(this.dirtyEnd, s8));
  }
  getData(t3, e6) {
    if (null == this.data)
      return null;
    const i6 = f(t3) * this.texelSize + e6;
    return !this.data || i6 >= this.data.length ? null : this.data[i6];
  }
  getTexture(t3) {
    return this._texture ?? this._initTexture(t3);
  }
  getFBO(t3, e6 = 0) {
    if (!this._fbos[e6]) {
      const i6 = 0 === e6 ? this.getTexture(t3) : this._textureDesc;
      this._fbos[e6] = new x(t3, i6);
    }
    return this._fbos[e6];
  }
  get locked() {
    return !(this.pixelType !== U.UNSIGNED_BYTE || !this.shared || this.textureOnly || !has("esri-atomics") || !this.data) && 1 === Atomics.load(this.data, 0);
  }
  get hasDirty() {
    const t3 = this.dirtyStart;
    return this.dirtyEnd >= t3;
  }
  updateTexture(e6, i6) {
    if (!this.locked) {
      try {
        const i7 = this.dirtyStart, s8 = this.dirtyEnd;
        if (!this.hasDirty)
          return;
        this._resetRange();
        const r5 = this.data.buffer, a5 = this.getTexture(e6), n9 = 4, d3 = (i7 - i7 % this.size) / this.size, h5 = (s8 - s8 % this.size) / this.size, u4 = d3, o4 = this.size, l4 = h5, p3 = d3 * this.size * n9, x4 = (o4 + l4 * this.size) * n9 - p3, _2 = W(this.pixelType), g4 = new _2(r5, p3 * _2.BYTES_PER_ELEMENT, x4), c7 = this.size, f5 = l4 - u4 + 1;
        if (f5 > this.size)
          return void j3.error(new s3("mapview-webgl", "Out-of-bounds index when updating AttributeData"));
        a5.updateData(0, 0, u4, c7, f5, g4);
      } catch (s8) {
      }
      i6();
    }
  }
  update(t3) {
    const { data: e6, start: i6, end: s8 } = t3;
    if (null != e6 && null != this.data) {
      const s9 = this.data, r5 = i6 * this.texelSize;
      for (let i7 = 0; i7 < e6.length; i7++) {
        const a5 = 1 << i7 % this.texelSize;
        t3.layout & a5 && (s9[r5 + i7] = e6[i7]);
      }
    }
    this.dirtyStart = Math.min(this.dirtyStart, i6), this.dirtyEnd = Math.max(this.dirtyEnd, s8);
  }
  resize(t3, e6) {
    const i6 = this.size;
    if (this.size = e6, this.textureOnly)
      return void (i6 !== this.size && (this._lastTexture = this._texture, this._texture = null));
    const s8 = W(this.pixelType);
    this.destroy(), this.data = new s8(t3.buffer);
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
  _initTexture(t3) {
    const e6 = new T(t3, this._textureDesc, this.data ?? void 0);
    if (null != this._lastTexture && this._fbos[0]) {
      const i6 = this._lastTexture.descriptor.width, s8 = this._lastTexture.descriptor.height, r5 = this._lastTexture.descriptor.dataType, a5 = this._lastTexture.descriptor.pixelFormat, n9 = this.getFBO(t3), d3 = K2(r5), h5 = new (W(r5))(new ArrayBuffer(i6 * s8 * d3 * this.texelSize)), u4 = t3.getBoundFramebufferObject(), { x: o4, y: l4, width: p3, height: x4 } = t3.getViewport();
      t3.bindFramebuffer(n9), n9.readPixels(0, 0, i6, s8, a5, r5, h5), e6.updateData(0, 0, 0, 2 * i6, s8 / 2, h5), t3.setViewport(o4, l4, p3, x4), t3.bindFramebuffer(u4);
    }
    return this.destroy(), this._texture = e6, this._texture;
  }
};
var O2 = class {
  constructor(t3) {
    this._onUpdate = t3, this._initialized = false, this._forceNextUpload = false, this._locked = false;
  }
  initialize(t3) {
    const { blocks: e6, shared: s8, size: r5 } = t3;
    if (this.shared = s8, this.size = r5, k2("Initializing AttributeStoreView", t3), null == this._data)
      this._data = s(e6, (t4) => new M2(t4, r5, s8));
    else
      for (let i6 = 0; i6 < this._data.length; i6++) {
        const t4 = this._data[i6], a5 = e6[i6];
        null != a5 && (null == t4 ? this._data[i6] = new M2(a5, r5, s8) : t4.resize(a5, r5));
      }
    this._initialized = true;
  }
  destroy() {
    n(this._data, (t3) => s(t3, (t4) => t4.destroy())), n(this._defaultTexture, (t3) => t3.dispose());
  }
  isEmpty() {
    return null == this._data;
  }
  isUpdating() {
    const t3 = null != this._pendingAttributeUpdate, e6 = t3;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStoreView ${e6}
  -> hasPendingUpdate ${t3}`), e6;
  }
  getBlock(t3) {
    if (null == this._data)
      return null;
    return this._data[t3];
  }
  setLabelMinZoom(t3, e6) {
    this.setData(t3, 0, 1, e6);
  }
  getLabelMinZoom(t3) {
    return this.getData(t3, 0, 1, 255);
  }
  getFilterFlags(t3) {
    return this.getData(t3, 0, 0, 0);
  }
  getVVSize(t3) {
    return this.getData(t3, S, 0, 0);
  }
  getData(t3, e6, i6, s8) {
    if (!this._data)
      return 0;
    const r5 = this._data[e6];
    if (null == r5)
      return 0;
    const a5 = r5.getData(t3, i6);
    return null != a5 ? a5 : s8;
  }
  setData(t3, e6, i6, s8) {
    this._data[e6].setData(t3, i6, s8);
  }
  lockTextureUpload() {
    this._locked = true;
  }
  unlockTextureUpload() {
    this._locked = false;
  }
  forceTextureUpload() {
    this._forceNextUpload = true;
  }
  async requestUpdate(e6) {
    if (this._pendingAttributeUpdate)
      return void j3.error(new s3("mapview-webgl", "Tried to update attribute data with a pending update"));
    const i6 = C();
    return k2("AttributeStoreView Update Requested", e6), this._pendingAttributeUpdate = { data: e6, resolver: i6 }, this._onUpdate(), i6.promise;
  }
  update() {
    if (this._initialized && null != this._pendingAttributeUpdate) {
      has("esri-2d-update-debug") && console.debug("AttributeStoreView::update");
      const { data: t3, resolver: e6 } = this._pendingAttributeUpdate, i6 = this._data;
      for (let r5 = 0; r5 < t3.blocks.length; r5++) {
        const e7 = t3.blocks[r5], a5 = i6[r5];
        n(a5, (t4) => n(e7, (e8) => {
          k2(`Updating block ${r5}`, e8), t4.update(e8);
        }));
      }
      this._pendingAttributeUpdate = null, e6(), this._onUpdate();
    }
  }
  bindTextures(t3, e6 = true) {
    var _a, _b, _c, _d, _e, _f, _g;
    const i6 = this._getDefaultTexture(t3);
    if (!this._initialized)
      return t3.bindTexture(i6, E), void (e6 && (t3.bindTexture(i6, F), t3.bindTexture(i6, G), t3.bindTexture(i6, H), t3.bindTexture(i6, I), t3.bindTexture(i6, J), t3.bindTexture(i6, K)));
    const s8 = this._data;
    this._locked && !this._forceNextUpload || (a(s8, (e7) => e7.updateTexture(t3, () => this._onUpdate())), this._forceNextUpload = false), t3.bindTexture(((_a = s8[P]) == null ? void 0 : _a.getTexture(t3)) ?? i6, E), e6 && (t3.bindTexture(((_b = s8[R2]) == null ? void 0 : _b.getTexture(t3)) ?? i6, K), t3.bindTexture(((_c = s8[Q]) == null ? void 0 : _c.getTexture(t3)) ?? i6, F), t3.bindTexture(((_d = s8[S]) == null ? void 0 : _d.getTexture(t3)) ?? i6, G), t3.bindTexture(((_e = s8[U2]) == null ? void 0 : _e.getTexture(t3)) ?? i6, H), t3.bindTexture(((_f = s8[I]) == null ? void 0 : _f.getTexture(t3)) ?? i6, I), t3.bindTexture(((_g = s8[J]) == null ? void 0 : _g.getTexture(t3)) ?? i6, J));
  }
  _getDefaultTexture(t3) {
    if (null == this._defaultTexture) {
      const e6 = new e2();
      e6.wrapMode = D.CLAMP_TO_EDGE, e6.samplingMode = L.NEAREST, e6.width = 1, e6.height = 1, this._defaultTexture = new T(t3, e6, new Uint8Array(4));
    }
    return this._defaultTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/FreeList.js
var t2 = class _t {
  constructor(a5) {
    if (this.next = null, !Array.isArray(a5))
      return void (this.data = a5);
    this.data = a5[0];
    let e6 = this;
    for (let n9 = 1; n9 < a5.length; n9++)
      e6.next = new _t([a5[n9]]), e6 = e6.next;
  }
  *values() {
    let t3 = this;
    for (; t3; )
      yield t3.data, t3 = t3.next;
  }
  forEach(t3) {
    let a5 = this;
    for (; a5; )
      t3(a5.data), a5 = a5.next;
  }
  find(t3) {
    var _a;
    return t3(this.data) ? this : (_a = this.next) == null ? void 0 : _a.find(t3);
  }
  max(t3, a5 = this) {
    const e6 = t3(this.data) > t3(a5.data) ? this : a5;
    return this.next ? this.next.max(t3, e6) : e6;
  }
  remove(t3, a5 = null) {
    var _a;
    return this === t3 ? a5 ? (a5.next = this.next, a5) : this.next : ((_a = this.next) == null ? void 0 : _a.remove(t3, this)) ?? null;
  }
  get last() {
    return this.next ? this.next.last : this;
  }
};
var a4 = class {
  constructor(a5) {
    this._head = null, null != a5 && (this._head = new t2(a5));
  }
  get head() {
    return this._head;
  }
  maxAvailableSpace() {
    if (null == this._head)
      return 0;
    const t3 = this._head.max((t4) => t4.end - t4.start);
    return t3.data.end - t3.data.start;
  }
  firstFit(t3) {
    if (null == this._head)
      return null;
    let a5 = null, e6 = this._head;
    for (; e6; ) {
      const n9 = e6.data.end - e6.data.start;
      if (n9 === t3)
        return a5 ? a5.next = e6.next : this._head = e6.next, e6.data.start;
      if (n9 > t3) {
        const a6 = e6.data.start;
        return e6.data.start += t3, a6;
      }
      a5 = e6, e6 = e6.next;
    }
    return null;
  }
  free(a5, e6) {
    const n9 = a5 + e6;
    if (null == this._head) {
      const e7 = new t2({ start: a5, end: n9 });
      return void (this._head = e7);
    }
    if (n9 <= this._head.data.start) {
      if (n9 === this._head.data.start)
        return void (this._head.data.start -= e6);
      const r6 = new t2({ start: a5, end: n9 });
      return r6.next = this._head, void (this._head = r6);
    }
    let r5 = this._head, s8 = r5.next;
    for (; s8; ) {
      if (s8.data.start >= n9) {
        if (r5.data.end === a5) {
          if (r5.data.end += e6, r5.data.end === s8.data.start) {
            const t3 = s8.data.end - s8.data.start;
            return r5.data.end += t3, void (r5.next = s8.next);
          }
          return;
        }
        if (s8.data.start === n9)
          return void (s8.data.start -= e6);
        const d4 = new t2({ start: a5, end: n9 });
        return d4.next = r5.next, void (r5.next = d4);
      }
      r5 = s8, s8 = s8.next;
    }
    if (a5 === r5.data.end)
      return void (r5.data.end += e6);
    const d3 = new t2({ start: a5, end: n9 });
    r5.next = d3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLTile.js
var h4 = class {
  acquire(s8) {
    return { refCount: 1, version: -1, labelMat2d: n2(), tileMat3: e(), dvs: e() };
  }
  release(s8) {
  }
};
var m3 = class _m extends r {
  constructor(s8, t3, r5, e6) {
    super(s8, t3, r5, e6, c, c);
  }
  destroy() {
    super.destroy(), this._transforms && _m.TransformCache.release(this.key.hash);
  }
  setTransform(i6) {
    const o4 = this.resolution / i6.resolution, n9 = this.transforms.tileMat3, [h5, m4] = i6.toScreenNoRotation([0, 0], [this.x, this.y]), c7 = this.width / this.rangeX * o4, f5 = this.height / this.rangeY * o4;
    s4(n9, c7, 0, 0, 0, f5, 0, h5, m4, 1), i2(this.transforms.dvs, i6.displayViewMat3, n9);
    const d3 = this.transforms.labelMat2d, l4 = window.devicePixelRatio, u4 = s5(n2(), c7 * l4, 0, 0, f5 * l4, h5 * l4, m4 * l4);
    o2(d3, i6.viewMat2d, u4);
  }
  _createTransforms() {
    return _m.TransformCache.acquire(this.key.hash);
  }
};
m3.TransformCache = new h4();

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureDisplayList.js
var e5 = class {
  constructor(t3, e6, n9, i6, a5) {
    this.target = t3, this.geometryType = e6, this.materialKey = n9, this.indexFrom = i6, this.indexCount = a5;
  }
  get indexEnd() {
    return this.indexFrom + this.indexCount;
  }
  extend(t3) {
    this.indexCount += t3;
  }
};
var n8 = class _n {
  constructor(t3, e6) {
    this.geometryType = 0, this._target = t3, this.geometryType = e6;
  }
  static from(t3, e6, i6, a5) {
    const d3 = new _n(t3, e6);
    if (null != a5)
      for (const n9 of a5)
        i6.seekIndex(n9), d3.addRecord(i6);
    else
      for (; i6.next(); )
        d3.addRecord(i6);
    return d3;
  }
  addRecord(n9) {
    const i6 = this._target, a5 = this.geometryType, d3 = n9.materialKey;
    let s8 = n9.indexFrom, r5 = n9.indexCount;
    const o4 = n9.vertexFrom, l4 = n9.vertexCount;
    if (r5 || (s8 = o4, r5 = l4), null == this._head) {
      const n10 = new e5(i6, a5, d3, s8, r5);
      return void (this._head = new t2(n10));
    }
    let h5 = null, x4 = this._head;
    for (; x4; ) {
      if (s8 < x4.data.indexFrom)
        return this._insert(d3, s8, r5, h5, x4);
      h5 = x4, x4 = x4.next;
    }
    this._insert(d3, s8, r5, h5, null);
  }
  forEach(t3) {
    null != this._head && this._head.forEach(t3);
  }
  *infos() {
    if (null != this._head)
      for (const t3 of this._head.values())
        yield t3;
  }
  _insert(n9, i6, a5, d3, s8) {
    if (null == d3 && null == s8) {
      const d4 = new e5(this._target, this.geometryType, n9, i6, a5);
      this._head = new t2(d4);
    }
    return null == d3 && null != s8 ? this._insertAtHead(n9, i6, a5, s8) : null != d3 && null == s8 ? this._insertAtEnd(n9, i6, a5, d3) : null != d3 && null != s8 ? this._insertAtMiddle(n9, i6, a5, d3, s8) : void 0;
  }
  _insertAtHead(n9, i6, a5, d3) {
    const s8 = i6 + a5;
    if (n9 === d3.data.materialKey && s8 === d3.data.indexFrom)
      d3.data.indexFrom = i6, d3.data.indexCount += a5;
    else {
      const s9 = new e5(this._target, this.geometryType, n9, i6, a5);
      this._head = new t2(s9), this._head.next = d3;
    }
  }
  _insertAtEnd(n9, i6, a5, d3) {
    if (d3.data.materialKey === n9 && d3.data.indexEnd === i6)
      d3.data.indexCount += a5;
    else {
      const s8 = new e5(this._target, this.geometryType, n9, i6, a5), r5 = new t2(s8);
      d3.next = r5;
    }
  }
  _insertAtMiddle(n9, i6, a5, d3, s8) {
    const r5 = i6 + a5;
    if (d3.data.materialKey === n9 && d3.data.indexEnd === i6)
      d3.data.indexCount += a5, d3.data.materialKey === s8.data.materialKey && d3.data.indexEnd === s8.data.indexFrom && (d3.data.indexCount += s8.data.indexCount, d3.next = s8.next);
    else if (n9 === s8.data.materialKey && r5 === s8.data.indexFrom)
      s8.data.indexFrom = i6, s8.data.indexCount += a5;
    else {
      const r6 = new e5(this._target, this.geometryType, n9, i6, a5), o4 = new t2(r6);
      d3.next = o4, o4.next = s8;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/DisplayRecordReader.js
var s7 = 2147483647;
var r4 = class _r {
  constructor(t3) {
    this._head = t3, this._cursor = t3;
  }
  static from(t3, e6 = 0, s8 = t3.byteLength / i5.BYTES_PER_RECORD - e6) {
    const _2 = new i5(new Int32Array(t3, e6 * i5.BYTES_PER_RECORD, s8 * i5.ELEMENTS_PER_RECORD));
    return new _r(_2);
  }
  size() {
    let t3 = this._cursor, e6 = 0;
    for (; t3; )
      e6 += t3.size(), t3 = t3._link;
    return e6;
  }
  get id() {
    return this._cursor.id;
  }
  set id(t3) {
    this._cursor.id = t3;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  set materialKey(t3) {
    this._cursor.materialKey = t3;
  }
  get insertAfter() {
    return this._cursor.insertAfter;
  }
  get indexFrom() {
    return this._cursor.indexFrom;
  }
  set indexFrom(t3) {
    this._cursor.indexFrom = t3;
  }
  get indexCount() {
    return this._cursor.indexCount;
  }
  set indexCount(t3) {
    this._cursor.indexCount = t3;
  }
  get vertexFrom() {
    return this._cursor.vertexFrom;
  }
  set vertexFrom(t3) {
    this._cursor.vertexFrom = t3;
  }
  get vertexCount() {
    return this._cursor.vertexCount;
  }
  set vertexCount(t3) {
    this._cursor.vertexCount = t3;
  }
  get sortKey() {
    return this._cursor.sortKey;
  }
  set sortKey(t3) {
    this._cursor.sortKey = t3;
  }
  get index() {
    return this._cursor._indexStart + this._cursor._index;
  }
  seekIndex(t3) {
    let e6 = t3;
    for (this._cursor = this._head; this._cursor; ) {
      const t4 = this._cursor.size();
      if (e6 < t4)
        return this._cursor._index = e6, true;
      e6 -= t4, this._cursor = this._cursor._link;
    }
    return false;
  }
  forEach(t3) {
    const e6 = this.getCursor();
    for (; e6.next(); )
      t3(e6);
  }
  link(t3) {
    if (!this._head)
      return void (this._head = t3._head);
    let e6 = this._head;
    for (; e6._link; )
      e6 = e6._link;
    e6._link = t3._head, e6._link._indexStart = e6._indexStart + e6.size();
  }
  getCursor() {
    return this.copy();
  }
  getDrawInfo(t3, s8) {
    return new e5(t3, s8, this.materialKey, this.indexFrom, this.indexCount);
  }
  lookup(t3) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t3); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  copy() {
    var _a;
    const t3 = new _r((_a = this._head) == null ? void 0 : _a.copy());
    if (!t3._head)
      return t3;
    let e6 = t3._head, s8 = t3._head._link;
    for (; s8; )
      e6._link = s8.copy(), e6 = s8, s8 = e6._link;
    return t3;
  }
  next() {
    return !!this._cursor && (!!this._cursor.next() || !!this._cursor._link && (this._cursor = this._cursor._link, this.next()));
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  delete(t3) {
    let e6 = this._head, s8 = null;
    for (; e6; ) {
      if (e6.delete(t3))
        return e6.isEmpty() && (null != s8 && (s8._link = e6._link), e6 === this._head && (this._head = e6._link), e6 === this._cursor && (this._cursor = e6._link)), true;
      s8 = e6, e6 = e6._link;
    }
    return false;
  }
};
r4.ELEMENTS_PER_RECORD = de, r4.BYTES_PER_RECORD = r4.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;
var i5 = class _i {
  constructor(t3) {
    this._link = null, this._index = -1, this._indexStart = 0, this._packedRecordsF32 = null, this._deletedCount = 0, this._offsets = { instance: null }, this._packedRecords = t3;
  }
  static from(t3, e6 = 0, s8 = t3.byteLength / this.BYTES_PER_RECORD - e6) {
    return new _i(new Int32Array(t3, e6 * this.BYTES_PER_RECORD, s8 * this.ELEMENTS_PER_RECORD));
  }
  delete(t3) {
    const e6 = this._index, r5 = this.lookup(t3);
    if (r5)
      for (this.id = s7, ++this._deletedCount; this.next() && this.id === t3; )
        this.id = s7, ++this._deletedCount;
    return this._index = e6, r5;
  }
  isEmpty() {
    return this._deletedCount === this.size();
  }
  link(t3) {
    this._link ? this._link.link(t3) : this._link = t3;
  }
  lookup(t3) {
    if (null == this._offsets.instance) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t4 = this.copy();
      t4._index = -1;
      let e7 = 0;
      for (; t4.next(); )
        t4.id !== e7 && (this._offsets.instance.set(t4.id, t4._index), e7 = t4.id);
    }
    if (!this._offsets.instance.has(t3))
      return false;
    const e6 = this._index;
    return this._index = this._offsets.instance.get(t3), this.id !== s7 || (this._index = e6, false);
  }
  get id() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD];
  }
  set id(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD] = t3;
  }
  get materialKey() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 1];
  }
  set materialKey(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 1] = t3;
  }
  get insertAfter() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 2];
  }
  get indexFrom() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 3];
  }
  set indexFrom(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 3] = t3;
  }
  get indexCount() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 4];
  }
  set indexCount(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 4] = t3;
  }
  get vertexFrom() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 5];
  }
  set vertexFrom(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 5] = t3;
  }
  get vertexCount() {
    return this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 6];
  }
  set vertexCount(t3) {
    this._packedRecords[this._index * _i.ELEMENTS_PER_RECORD + 6] = t3;
  }
  get sortKey() {
    return this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _i.ELEMENTS_PER_RECORD + 7];
  }
  set sortKey(t3) {
    this._packedRecordsF32 || (this._packedRecordsF32 = new Float32Array(this._packedRecords.buffer)), this._packedRecordsF32[this._index * _i.ELEMENTS_PER_RECORD + 7] = t3;
  }
  get index() {
    return this._index;
  }
  size() {
    return this._packedRecords.length / _i.ELEMENTS_PER_RECORD;
  }
  next() {
    for (; ++this._index < this.size() && this.id === s7; )
      ;
    return this._index < this.size();
  }
  peekId() {
    const t3 = (this._index + 1) * _i.ELEMENTS_PER_RECORD;
    return t3 >= this._packedRecords.length ? 0 : this._packedRecords[t3];
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t3 = new _i(this._packedRecords);
    return t3._indexStart = this._indexStart, t3._link = this._link, t3._index = this._index, t3._offsets = this._offsets, t3._deletedCount = this._deletedCount, t3;
  }
};
i5.ELEMENTS_PER_RECORD = de, i5.BYTES_PER_RECORD = i5.ELEMENTS_PER_RECORD * Int32Array.BYTES_PER_ELEMENT;

export {
  a4 as a,
  m3 as m,
  n8 as n,
  r4 as r,
  c6 as c,
  f4 as f,
  g2 as g,
  u3 as u,
  p2 as p,
  h2 as h,
  x2 as x,
  n6 as n2,
  h as h2,
  T2 as T,
  w2 as w,
  _,
  O2 as O
};
//# sourceMappingURL=chunk-TOXOPWS2.js.map
