import {
  i
} from "./chunk-FJYIB7HF.js";
import {
  DateTime,
  FixedOffsetZone,
  IANAZone,
  Zone
} from "./chunk-ODFH3BSN.js";

// node_modules/@arcgis/core/arcade/ArcadeDate.js
var i2 = class {
};
var o;
i2.instance = new IANAZone("Etc/UTC"), function(e) {
  e.TimeZoneNotRecognised = "TimeZoneNotRecognised";
}(o || (o = {}));
var a = { [o.TimeZoneNotRecognised]: "Timezone identifier has not been recognised." };
var d = class _d extends Error {
  constructor(t, n) {
    super(i(a[t], n)), this.declaredRootClass = "esri.arcade.arcadedate.dateerror", Error.captureStackTrace && Error.captureStackTrace(this, _d);
  }
};
var c = class _c {
  constructor(e) {
    this._date = e, this.declaredRootClass = "esri.arcade.arcadedate";
  }
  static fromParts(e = 0, t = 1, r = 1, s = 0, i3 = 0, o2 = 0, a2 = 0, d2) {
    if (isNaN(e) || isNaN(t) || isNaN(r) || isNaN(s) || isNaN(i3) || isNaN(o2) || isNaN(a2))
      return null;
    let m = 0;
    const h = DateTime.local(e, t).daysInMonth;
    r < 1 && (m = r - 1, r = 1), r > h && (m = r - h, r = h);
    let l = 0;
    t > 12 ? (l = t - 12, t = 12) : t < 1 && (l = t - 1, t = 1);
    let f = 0;
    i3 > 59 ? (f = i3 - 59, i3 = 59) : i3 < 0 && (f = i3, i3 = 0);
    let w = 0;
    o2 > 59 ? (w = o2 - 59, o2 = 59) : o2 < 0 && (w = o2, o2 = 0);
    let T = 0;
    a2 > 999 ? (T = a2 - 999, a2 = 999) : a2 < 0 && (T = a2, a2 = 0);
    let y = DateTime.fromObject({ day: r, year: e, month: t, hour: s, minute: i3, second: o2, millisecond: a2 }, { zone: u(d2) });
    return 0 !== l && (y = y.plus({ months: l })), 0 !== m && (y = y.plus({ days: m })), 0 !== f && (y = y.plus({ minutes: f })), 0 !== w && (y = y.plus({ seconds: w })), 0 !== T && (y = y.plus({ milliseconds: T })), new _c(y);
  }
  static get systemTimeZoneCanonicalName() {
    return Intl.DateTimeFormat().resolvedOptions().timeZone ?? "system";
  }
  static arcadeDateAndZoneToArcadeDate(e, t) {
    const n = u(t);
    return e.isUnknownTimeZone || n === i2.instance ? _c.fromParts(e.year, e.monthJS + 1, e.day, e.hour, e.minute, e.second, e.millisecond, n) : new _c(e._date.setZone(t));
  }
  static dateJSToArcadeDate(e) {
    return new _c(DateTime.fromJSDate(e, { zone: "system" }));
  }
  static dateJSAndZoneToArcadeDate(e, t = "system") {
    return new _c(DateTime.fromJSDate(e, { zone: t }));
  }
  static unknownEpochToArcadeDate(e) {
    return new _c(DateTime.fromMillis(e, { zone: i2.instance }));
  }
  static unknownDateJSToArcadeDate(e) {
    return new _c(DateTime.fromMillis(e.getTime(), { zone: i2.instance }));
  }
  static epochToArcadeDate(e, t = "system") {
    return new _c(DateTime.fromMillis(e, { zone: t }));
  }
  static dateTimeToArcadeDate(e) {
    return new _c(e);
  }
  clone() {
    return new _c(this._date);
  }
  changeTimeZone(e) {
    const t = u(e);
    return _c.dateTimeToArcadeDate(this._date.setZone(t));
  }
  static dateTimeAndZoneToArcadeDate(e, t) {
    const n = u(t);
    return e.zone === i2.instance || n === i2.instance ? _c.fromParts(e.year, e.month, e.day, e.hour, e.minute, e.second, e.millisecond, n) : new _c(e.setZone(n));
  }
  static nowToArcadeDate(e) {
    return new _c(DateTime.fromJSDate(/* @__PURE__ */ new Date(), { zone: e }));
  }
  static nowUTCToArcadeDate() {
    return new _c(DateTime.utc());
  }
  get isSystem() {
    return "system" === this.timeZone || this.timeZone === _c.systemTimeZoneCanonicalName;
  }
  equals(e) {
    return this.isSystem && e.isSystem ? this.toNumber() === e.toNumber() : this.isUnknownTimeZone === e.isUnknownTimeZone && this._date.equals(e._date);
  }
  get isUnknownTimeZone() {
    return this._date.zone === i2.instance;
  }
  get isValid() {
    return this._date.isValid;
  }
  get hour() {
    return this._date.hour;
  }
  get second() {
    return this._date.second;
  }
  get day() {
    return this._date.day;
  }
  get dayOfWeekISO() {
    return this._date.weekday;
  }
  get dayOfWeekJS() {
    let e = this._date.weekday;
    return e > 6 && (e = 0), e;
  }
  get millisecond() {
    return this._date.millisecond;
  }
  get monthISO() {
    return this._date.month;
  }
  get weekISO() {
    return this._date.weekNumber;
  }
  get yearISO() {
    return this._date.weekYear;
  }
  get monthJS() {
    return this._date.month - 1;
  }
  get year() {
    return this._date.year;
  }
  get minute() {
    return this._date.minute;
  }
  get zone() {
    return this._date.zone;
  }
  get timeZoneOffset() {
    return this.isUnknownTimeZone ? 0 : this._date.offset;
  }
  get timeZone() {
    if (this.isUnknownTimeZone)
      return "unknown";
    if ("system" === this._date.zone.type)
      return "system";
    const e = this.zone;
    return "fixed" === e.type ? 0 === e.fixed ? "utc" : e.formatOffset(0, "short") : e.name;
  }
  stringify() {
    return JSON.stringify(this.toJSDate());
  }
  plus(e) {
    return new _c(this._date.plus(e));
  }
  diff(e, t = "milliseconds") {
    return this._date.diff(e._date, t)[t];
  }
  toISOString(e) {
    return e ? this._date.toISO({ suppressMilliseconds: true, includeOffset: !this.isUnknownTimeZone }) : this._date.toISO({ includeOffset: !this.isUnknownTimeZone });
  }
  toFormat(e, t) {
    return this._date.toFormat(e, t);
  }
  toJSDate() {
    return this._date.toJSDate();
  }
  toSQLString() {
    return "timestamp '" + this._date.toFormat("yyyy-LL-dd HH:mm:ss") + "'";
  }
  toDateTime() {
    return this._date;
  }
  toNumber() {
    return this._date.toMillis();
  }
  getTime() {
    return this._date.toMillis();
  }
  toUTC() {
    return new _c(this._date.toUTC());
  }
  toLocal() {
    return new _c(this._date.toLocal());
  }
  toString() {
    return this.toISOString(true);
  }
};
function u(e) {
  if (e instanceof Zone)
    return e;
  if ("system" === e.toLowerCase())
    return "system";
  if ("utc" === e.toLowerCase())
    return "utc";
  if ("unknown" === e.toLowerCase())
    return i2.instance;
  if (/^[\+\-]?[0-9]{1,2}([:][0-9]{2})?$/.test(e)) {
    const t = FixedOffsetZone.parseSpecifier("UTC" + (e.startsWith("+") || e.startsWith("-") ? "" : "+") + e);
    if (t)
      return t;
  }
  const n = IANAZone.create(e);
  if (!n.isValid)
    throw new d(o.TimeZoneNotRecognised);
  return n;
}

export {
  c,
  u
};
//# sourceMappingURL=chunk-YAWND7HF.js.map
