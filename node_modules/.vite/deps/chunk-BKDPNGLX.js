import {
  f as f2,
  g
} from "./chunk-D5EV57FM.js";
import {
  b
} from "./chunk-PM3CFO6N.js";
import {
  $,
  H,
  K,
  P,
  U,
  bt,
  dt,
  ht
} from "./chunk-KKGVORR5.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import {
  Cn
} from "./chunk-SO6DBMQG.js";
import {
  f,
  m,
  p as p2,
  s as s4,
  v
} from "./chunk-T4XWQYGC.js";
import {
  l2 as l
} from "./chunk-TCASQSKO.js";
import {
  Z,
  o,
  r,
  t
} from "./chunk-3GSONYPC.js";
import {
  A,
  E,
  Q,
  S2 as S,
  p,
  s2 as s3
} from "./chunk-SFV6XLDZ.js";
import {
  s as s2
} from "./chunk-VBD33VNW.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/graphics/data/utils.js
var U2 = new s2({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
var M = Object.freeze({});
var O = new t2();
var F = new t2();
var N = new t2();
var _ = { esriGeometryPoint: P, esriGeometryPolyline: $, esriGeometryPolygon: H, esriGeometryMultipoint: U };
function G(e3, t5, i2, r3 = e3.hasZ, n3 = e3.hasM) {
  if (null == t5)
    return null;
  const o3 = e3.hasZ && r3, s6 = e3.hasM && n3;
  if (i2) {
    const l3 = ht(N, t5, e3.hasZ, e3.hasM, "esriGeometryPoint", i2, r3, n3);
    return P(l3, o3, s6);
  }
  return P(t5, o3, s6);
}
function P2(e3, t5, i2, r3, n3, o3, s6 = t5, l3 = i2) {
  var _a, _b, _c;
  const a = t5 && s6, m2 = i2 && l3, u2 = null != r3 ? "coords" in r3 ? r3 : r3.geometry : null;
  if (null == u2)
    return null;
  if (n3) {
    let r4 = dt(F, u2, t5, i2, e3, n3, s6, l3);
    return o3 && (r4 = ht(N, r4, a, m2, e3, o3)), ((_a = _[e3]) == null ? void 0 : _a.call(_, r4, a, m2)) ?? null;
  }
  if (o3) {
    const r4 = ht(N, u2, t5, i2, e3, o3, s6, l3);
    return ((_b = _[e3]) == null ? void 0 : _b.call(_, r4, a, m2)) ?? null;
  }
  return bt(O, u2, t5, i2, s6, l3), ((_c = _[e3]) == null ? void 0 : _c.call(_, O, a, m2)) ?? null;
}
async function v2(e3, t5, i2) {
  const { outFields: r3, orderByFields: n3, groupByFieldsForStatistics: o3, outStatistics: s6 } = e3;
  if (r3)
    for (let l3 = 0; l3 < r3.length; l3++)
      r3[l3] = r3[l3].trim();
  if (n3)
    for (let l3 = 0; l3 < n3.length; l3++)
      n3[l3] = n3[l3].trim();
  if (o3)
    for (let l3 = 0; l3 < o3.length; l3++)
      o3[l3] = o3[l3].trim();
  if (s6)
    for (let l3 = 0; l3 < s6.length; l3++)
      s6[l3].onStatisticField && (s6[l3].onStatisticField = s6[l3].onStatisticField.trim());
  return e3.geometry && !e3.outSR && (e3.outSR = e3.geometry.spatialReference), z(e3, t5, i2);
}
async function z(e3, t5, i2) {
  var _a;
  if (!e3)
    return null;
  let { where: o3 } = e3;
  if (e3.where = o3 = o3 && o3.trim(), (!o3 || /^1 *= *1$/.test(o3) || t5 && t5 === o3) && (e3.where = null), !e3.geometry)
    return e3;
  let s6 = await A2(e3);
  if (e3.distance = 0, e3.units = null, "esriSpatialRelEnvelopeIntersects" === e3.spatialRel) {
    const { spatialReference: t6 } = e3.geometry;
    s6 = l(s6), s6.spatialReference = t6;
  }
  if (s6) {
    await f2(s6.spatialReference, i2), s6 = b2(s6, i2);
    const t6 = (await b(p2(s6)))[0];
    if (null == t6)
      throw M;
    const r3 = "quantizationParameters" in e3 && ((_a = e3.quantizationParameters) == null ? void 0 : _a.tolerance) || "maxAllowableOffset" in e3 && e3.maxAllowableOffset || 0, o4 = r3 && J(s6, i2) ? { densificationStep: 8 * r3 } : void 0, l3 = t6.toJSON(), m2 = await g(l3, l3.spatialReference, i2, o4);
    if (!m2)
      throw M;
    m2.spatialReference = i2, e3.geometry = m2;
  }
  return e3;
}
function J(e3, t5) {
  if (!e3)
    return false;
  const r3 = e3.spatialReference;
  return (m(e3) || f(e3) || s4(e3)) && !S(r3, t5) && !Cn(r3, t5);
}
function b2(e3, t5) {
  const i2 = e3.spatialReference;
  return J(e3, t5) && m(e3) ? { spatialReference: i2, rings: [[[e3.xmin, e3.ymin], [e3.xmin, e3.ymax], [e3.xmax, e3.ymax], [e3.xmax, e3.ymin], [e3.xmin, e3.ymin]]] } : e3;
}
async function A2(e3) {
  const { distance: i2, units: r3 } = e3, n3 = e3.geometry;
  if (null == i2 || "vertexAttributes" in n3)
    return n3;
  const o3 = n3.spatialReference, s6 = r3 ? U2.fromJSON(r3) : Q(o3), l3 = o3 && (E(o3) || A(o3)) ? n3 : await f2(o3, p).then(() => g(n3, p));
  return (await B())(l3.spatialReference, l3, i2, s6);
}
async function B() {
  return (await import("./geometryEngineJSON-IVXHWXT4.js")).geodesicBuffer;
}
function Z2(e3) {
  return e3 && q in e3 ? JSON.parse(JSON.stringify(e3, E2)) : e3;
}
var q = "_geVersion";
var E2 = (e3, t5) => e3 !== q ? t5 : void 0;

// node_modules/@arcgis/core/geometry/support/intersects.js
function s5(s6) {
  return "mesh" === s6 ? o : Z(s6);
}

// node_modules/@arcgis/core/layers/graphics/contains.js
function n(n3, t5) {
  return n3 ? t5 ? 4 : 3 : t5 ? 3 : 2;
}
function t3(n3, t5, r3, e3) {
  return o2(n3, t5, r3, e3.coords[0], e3.coords[1]);
}
function r2(t5, r3, e3, c2, u2, f4) {
  const s6 = n(u2, f4), { coords: i2, lengths: l3 } = c2;
  if (!l3)
    return false;
  for (let n3 = 0, d = 0; n3 < l3.length; n3++, d += s6)
    if (!o2(t5, r3, e3, i2[d], i2[d + 1]))
      return false;
  return true;
}
function o2(t5, r3, o3, c2, u2) {
  if (!t5)
    return false;
  const f4 = n(r3, o3), { coords: s6, lengths: i2 } = t5;
  let l3 = false, d = 0;
  for (const n3 of i2)
    l3 = e(l3, s6, f4, d, n3, c2, u2), d += n3 * f4;
  return l3;
}
function e(n3, t5, r3, o3, e3, c2, u2) {
  let f4 = n3, s6 = o3;
  for (let i2 = o3, l3 = o3 + e3 * r3; i2 < l3; i2 += r3) {
    s6 = i2 + r3, s6 === l3 && (s6 = o3);
    const n4 = t5[i2], e4 = t5[i2 + 1], d = t5[s6], g3 = t5[s6 + 1];
    (e4 < u2 && g3 >= u2 || g3 < u2 && e4 >= u2) && n4 + (u2 - e4) / (g3 - e4) * (d - n4) < c2 && (f4 = !f4);
  }
  return f4;
}

// node_modules/@arcgis/core/layers/graphics/data/spatialQuerySupport.js
var c = "feature-store:unsupported-query";
var R = { esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "intersects", esriSpatialRelIndexIntersects: null, esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: null };
var S2 = { spatialRelationship: { esriSpatialRelIntersects: true, esriSpatialRelContains: true, esriSpatialRelWithin: true, esriSpatialRelCrosses: true, esriSpatialRelDisjoint: true, esriSpatialRelTouches: true, esriSpatialRelOverlaps: true, esriSpatialRelEnvelopeIntersects: true, esriSpatialRelIndexIntersects: false, esriSpatialRelRelation: false }, queryGeometry: { esriGeometryPoint: true, esriGeometryMultipoint: true, esriGeometryPolyline: true, esriGeometryPolygon: true, esriGeometryEnvelope: true }, layerGeometry: { esriGeometryPoint: true, esriGeometryMultipoint: true, esriGeometryPolyline: true, esriGeometryPolygon: true, esriGeometryEnvelope: false } };
function G3(e3) {
  return null != e3 && true === S2.spatialRelationship[e3];
}
function g2(e3) {
  return null != e3 && true === S2.queryGeometry[v(e3)];
}
function j(e3) {
  return null != e3 && true === S2.layerGeometry[e3];
}
function h2() {
  return import("./geometryEngineJSON-IVXHWXT4.js");
}
function v3(e3, n3, l3, y2, c2) {
  if (f(n3) && "esriGeometryPoint" === l3 && ("esriSpatialRelIntersects" === e3 || "esriSpatialRelContains" === e3)) {
    const e4 = K(new t2(), n3, false, false);
    return Promise.resolve((r3) => t3(e4, false, false, r3));
  }
  if (f(n3) && "esriGeometryMultipoint" === l3) {
    const r3 = K(new t2(), n3, false, false);
    if ("esriSpatialRelContains" === e3)
      return Promise.resolve((e4) => r2(r3, false, false, e4, y2, c2));
  }
  if (m(n3) && "esriGeometryPoint" === l3 && ("esriSpatialRelIntersects" === e3 || "esriSpatialRelContains" === e3))
    return Promise.resolve((e4) => t(n3, P2(l3, y2, c2, e4)));
  if (m(n3) && "esriGeometryMultipoint" === l3 && "esriSpatialRelContains" === e3)
    return Promise.resolve((e4) => r(n3, P2(l3, y2, c2, e4)));
  if (m(n3) && "esriSpatialRelIntersects" === e3) {
    const e4 = s5(l3);
    return Promise.resolve((r3) => e4(n3, P2(l3, y2, c2, r3)));
  }
  return h2().then((r3) => {
    const t5 = r3[R[e3]].bind(null, n3.spatialReference, n3);
    return (e4) => t5(P2(l3, y2, c2, e4));
  });
}
async function P3(r3, t5, i2) {
  const { spatialRel: s6, geometry: o3 } = r3;
  if (o3) {
    if (!G3(s6))
      throw new s(c, "Unsupported query spatial relationship", { query: r3 });
    if (s3(o3.spatialReference) && s3(i2)) {
      if (!g2(o3))
        throw new s(c, "Unsupported query geometry type", { query: r3 });
      if (!j(t5))
        throw new s(c, "Unsupported layer geometry type", { query: r3 });
      if (r3.outSR)
        return f2(r3.geometry && r3.geometry.spatialReference, r3.outSR);
    }
  }
}
function I(e3) {
  if (m(e3))
    return true;
  if (f(e3)) {
    for (const r3 of e3.rings) {
      if (5 !== r3.length)
        return false;
      if (r3[0][0] !== r3[1][0] || r3[0][0] !== r3[4][0] || r3[2][0] !== r3[3][0] || r3[0][1] !== r3[3][1] || r3[0][1] !== r3[4][1] || r3[1][1] !== r3[2][1])
        return false;
    }
    return true;
  }
  return false;
}

// node_modules/@arcgis/core/layers/graphics/data/timeSupport.js
async function t4(t5, n3) {
  if (!t5)
    return null;
  const e3 = n3.featureAdapter, { startTimeField: u2, endTimeField: l3 } = t5;
  let r3 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY;
  if (u2 && l3)
    await n3.forEach((t6) => {
      const n4 = e3.getAttribute(t6, u2), a = e3.getAttribute(t6, l3);
      null == n4 || isNaN(n4) || (r3 = Math.min(r3, n4)), null == a || isNaN(a) || (i2 = Math.max(i2, a));
    });
  else {
    const t6 = u2 || l3;
    await n3.forEach((n4) => {
      const u3 = e3.getAttribute(n4, t6);
      null == u3 || isNaN(u3) || (r3 = Math.min(r3, u3), i2 = Math.max(i2, u3));
    });
  }
  return { start: r3, end: i2 };
}
function n2(t5, n3, r3) {
  if (!n3 || !t5)
    return null;
  const { startTimeField: i2, endTimeField: a } = t5;
  if (!i2 && !a)
    return null;
  const { start: o3, end: s6 } = n3;
  return null === o3 && null === s6 ? null : void 0 === o3 && void 0 === s6 ? l2() : i2 && a ? e2(r3, i2, a, o3, s6) : u(r3, i2 || a, o3, s6);
}
function e2(t5, n3, e3, u2, l3) {
  return null != u2 && null != l3 ? (r3) => {
    const i2 = t5.getAttribute(r3, n3), a = t5.getAttribute(r3, e3);
    return (null == i2 || i2 <= l3) && (null == a || a >= u2);
  } : null != u2 ? (n4) => {
    const l4 = t5.getAttribute(n4, e3);
    return null == l4 || l4 >= u2;
  } : null != l3 ? (e4) => {
    const u3 = t5.getAttribute(e4, n3);
    return null == u3 || u3 <= l3;
  } : void 0;
}
function u(t5, n3, e3, u2) {
  return null != e3 && null != u2 && e3 === u2 ? (u3) => t5.getAttribute(u3, n3) === e3 : null != e3 && null != u2 ? (l3) => {
    const r3 = t5.getAttribute(l3, n3);
    return r3 >= e3 && r3 <= u2;
  } : null != e3 ? (u3) => t5.getAttribute(u3, n3) >= e3 : null != u2 ? (e4) => t5.getAttribute(e4, n3) <= u2 : void 0;
}
function l2() {
  return () => false;
}

export {
  M,
  G,
  P2 as P,
  v2 as v,
  z,
  Z2 as Z,
  v3 as v2,
  P3 as P2,
  I,
  t4 as t,
  n2 as n
};
//# sourceMappingURL=chunk-BKDPNGLX.js.map
