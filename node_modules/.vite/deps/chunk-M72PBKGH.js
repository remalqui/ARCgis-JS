import {
  o
} from "./chunk-APDPMAO5.js";
import {
  Z as Z2
} from "./chunk-BKDPNGLX.js";
import {
  t as t3
} from "./chunk-D5EV57FM.js";
import {
  yt
} from "./chunk-KKGVORR5.js";
import {
  t
} from "./chunk-TDPKDZC3.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import {
  Z,
  i as i2
} from "./chunk-ZBWBCN2I.js";
import {
  i
} from "./chunk-5HAVROZG.js";
import {
  n
} from "./chunk-WBSPL6CJ.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/graphics/data/optimizedFeatureQueryEngineAdapter.js
var o2 = { getObjectId: (t4) => t4.objectId, getAttributes: (t4) => t4.attributes, getAttribute: (t4, e) => t4.attributes[e], cloneWithGeometry: (t4, r) => new t(r, t4.attributes, null, t4.objectId), getGeometry: (t4) => t4.geometry, getCentroid: (e, o3) => (null == e.centroid && (e.centroid = t3(new t2(), e.geometry, o3.hasZ, o3.hasM)), e.centroid) };

// node_modules/@arcgis/core/layers/graphics/data/FeatureStore.js
var h = i2();
var m = class {
  constructor(e) {
    this.geometryInfo = e, this._boundsStore = new o(), this._featuresById = /* @__PURE__ */ new Map(), this._markedIds = /* @__PURE__ */ new Set(), this.events = new n(), this.featureAdapter = o2;
  }
  get geometryType() {
    return this.geometryInfo.geometryType;
  }
  get hasM() {
    return this.geometryInfo.hasM;
  }
  get hasZ() {
    return this.geometryInfo.hasZ;
  }
  get numFeatures() {
    return this._featuresById.size;
  }
  get fullBounds() {
    return this._boundsStore.fullBounds;
  }
  get storeStatistics() {
    let e = 0;
    return this._featuresById.forEach((t4) => {
      null != t4.geometry && t4.geometry.coords && (e += t4.geometry.coords.length);
    }), { featureCount: this._featuresById.size, vertexCount: e / (this.hasZ ? this.hasM ? 4 : 3 : this.hasM ? 3 : 2) };
  }
  getFullExtent(e) {
    if (null == this.fullBounds)
      return null;
    const [t4, s3, r, o3] = this.fullBounds;
    return { xmin: t4, ymin: s3, xmax: r, ymax: o3, spatialReference: Z2(e) };
  }
  add(e) {
    this._add(e), this._emitChanged();
  }
  addMany(e) {
    for (const t4 of e)
      this._add(t4);
    this._emitChanged();
  }
  clear() {
    this._featuresById.clear(), this._boundsStore.clear(), this._emitChanged();
  }
  removeById(e) {
    const t4 = this._featuresById.get(e);
    return t4 ? (this._remove(t4), this._emitChanged(), t4) : null;
  }
  removeManyById(e) {
    this._boundsStore.invalidateIndex();
    for (const t4 of e) {
      const e2 = this._featuresById.get(t4);
      e2 && this._remove(e2);
    }
    this._emitChanged();
  }
  forEachBounds(e, t4) {
    for (const s3 of e) {
      const e2 = this._boundsStore.get(s3.objectId);
      e2 && t4(Z(h, e2));
    }
  }
  getFeature(e) {
    return this._featuresById.get(e);
  }
  has(e) {
    return this._featuresById.has(e);
  }
  forEach(e) {
    this._featuresById.forEach((t4) => e(t4));
  }
  forEachInBounds(e, t4) {
    this._boundsStore.forEachInBounds(e, (e2) => {
      t4(this._featuresById.get(e2));
    });
  }
  startMarkingUsedFeatures() {
    this._boundsStore.invalidateIndex(), this._markedIds.clear();
  }
  sweep() {
    let e = false;
    this._featuresById.forEach((t4, s3) => {
      this._markedIds.has(s3) || (e = true, this._remove(t4));
    }), this._markedIds.clear(), e && this._emitChanged();
  }
  _emitChanged() {
    this.events.emit("changed", void 0);
  }
  _add(t4) {
    if (!t4)
      return;
    const r = t4.objectId;
    if (null == r)
      return void s.getLogger("esri.layers.graphics.data.FeatureStore").error(new s2("featurestore:invalid-feature", "feature id is missing", { feature: t4 }));
    const o3 = this._featuresById.get(r);
    let a;
    if (this._markedIds.add(r), o3 ? (t4.displayId = o3.displayId, a = this._boundsStore.get(r), this._boundsStore.delete(r)) : null != this.onFeatureAdd && this.onFeatureAdd(t4), null == t4.geometry || !t4.geometry.coords || !t4.geometry.coords.length)
      return this._boundsStore.set(r, null), void this._featuresById.set(r, t4);
    a = yt(null != a ? a : i(), t4.geometry, this.geometryInfo.hasZ, this.geometryInfo.hasM), null != a && this._boundsStore.set(r, a), this._featuresById.set(r, t4);
  }
  _remove(e) {
    null != this.onFeatureRemove && this.onFeatureRemove(e);
    const t4 = e.objectId;
    return this._markedIds.delete(t4), this._boundsStore.delete(t4), this._featuresById.delete(t4), e;
  }
};

export {
  m
};
//# sourceMappingURL=chunk-M72PBKGH.js.map
