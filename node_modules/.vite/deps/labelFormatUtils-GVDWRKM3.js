import {
  _,
  x
} from "./chunk-34QQ6GDH.js";
import {
  c as c2,
  se
} from "./chunk-7KM4XBUC.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import {
  M,
  c2 as c,
  f
} from "./chunk-CWQ6Q3PH.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-3GSONYPC.js";
import "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/labelFormatUtils.js
var s3 = s.getLogger("esri.layers.support.labelFormatUtils");
var c3 = { type: "simple", evaluate: () => null };
var f2 = { getAttribute: (e, r) => e.field(r) };
async function p(r, t, n) {
  if (!r || !r.symbol || !t)
    return c3;
  const a = r.where, o = x(r), p2 = a ? await import("./WhereClause-TU447WGJ.js") : null;
  let m;
  if ("arcade" === o.type) {
    const r2 = await c2(o.expression, n, t);
    if (null == r2)
      return c3;
    m = { type: "arcade", evaluate(t2) {
      try {
        const e = r2.evaluate({ $feature: "attributes" in t2 ? r2.repurposeFeature(t2) : t2 }, r2.services);
        if (null != e)
          return e.toString();
      } catch (n2) {
        s3.error(new s2("arcade-expression-error", "Encountered an error when evaluating label expression for feature", { error: n2, feature: t2, expression: o }));
      }
      return null;
    }, needsHydrationToEvaluate: () => null == _(o.expression) };
  } else
    m = { type: "simple", evaluate: (e) => o.expression.replaceAll(/{[^}]*}/g, (r2) => {
      const n2 = r2.slice(1, -1), a2 = t.get(n2);
      if (!a2)
        return r2;
      let o2 = null;
      if ("attributes" in e) {
        e && e.attributes && (o2 = e.attributes[a2.name]);
      } else
        o2 = e.field(a2.name);
      return null == o2 ? "" : d(o2, a2);
    }) };
  if (a) {
    let r2;
    try {
      r2 = p2.WhereClause.create(a, t);
    } catch (g) {
      return s3.error(new s2("bad-where-clause", "Encountered an error when evaluating where clause, ignoring", { where: a, error: g })), c3;
    }
    const n2 = m.evaluate;
    m.evaluate = (t2) => {
      const o2 = "attributes" in t2 ? void 0 : f2;
      try {
        if (r2.testFeature(t2, o2))
          return n2(t2);
      } catch (g) {
        s3.error(new s2("bad-where-clause", "Encountered an error when evaluating where clause for feature", { where: a, feature: t2, error: g }));
      }
      return null;
    };
  }
  return m;
}
function d(e, r) {
  if (null == e)
    return "";
  const l = r.domain;
  if (l) {
    if ("codedValue" === l.type || "coded-value" === l.type) {
      const r2 = e;
      for (const e2 of l.codedValues)
        if (e2.code === r2)
          return e2.name;
    } else if ("range" === l.type) {
      const r2 = +e, t = "range" in l ? l.range[0] : l.minValue, n = "range" in l ? l.range[1] : l.maxValue;
      if (t <= r2 && r2 <= n)
        return l.name;
    }
  }
  let i = e;
  return "date" === r.type || "esriFieldTypeDate" === r.type ? i = f(i, M("short-date")) : se(r) && (i = c(+i)), i || "";
}
export {
  p as createLabelFunction,
  d as formatField
};
//# sourceMappingURL=labelFormatUtils-GVDWRKM3.js.map
