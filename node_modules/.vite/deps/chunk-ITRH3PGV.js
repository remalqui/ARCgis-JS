import {
  r
} from "./chunk-BRDC7DKL.js";
import {
  f,
  h,
  l as l2
} from "./chunk-XN5VV437.js";
import {
  m,
  n3 as n,
  s2,
  t2 as t,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2,
  l
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  E,
  T,
  a,
  c
} from "./chunk-HNHXEGH2.js";
import {
  o
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/support/PromiseQueue.js
var n2 = class {
  constructor() {
    this._tasks = new Array(), this._running = r(false);
  }
  get length() {
    return this._tasks.length;
  }
  get running() {
    return this._running.value;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(s3) {
    for (; !s3.done && this._process(s3); )
      s3.madeProgress();
  }
  push(s3, t3, e2) {
    return this._running.value = true, new Promise((r2, n3) => this._tasks.push(new i(r2, n3, s3, t3, e2)));
  }
  unshift(s3, t3, e2) {
    return this._running.value = true, new Promise((r2, n3) => this._tasks.unshift(new i(r2, n3, s3, t3, e2)));
  }
  _process(r2) {
    var _a;
    if (0 === this._tasks.length)
      return false;
    const n3 = this._tasks.shift();
    try {
      const i2 = a(n3.signal);
      if (i2 && !n3.abortCallback)
        n3.reject(c());
      else {
        const s3 = i2 ? (_a = n3.abortCallback) == null ? void 0 : _a.call(n3, c()) : n3.callback(r2);
        T(s3) ? s3.then(n3.resolve, n3.reject) : n3.resolve(s3);
      }
    } catch (i2) {
      n3.reject(i2);
    }
    return this._running.value = this._tasks.length > 0, true;
  }
  cancelAll() {
    const s3 = c();
    for (const t3 of this._tasks)
      if (t3.abortCallback) {
        const e2 = t3.abortCallback(s3);
        t3.resolve(e2);
      } else
        t3.reject(s3);
    this._tasks.length = 0, this._running.value = false;
  }
};
var i = class {
  constructor(s3, t3, e2, r2 = void 0, n3 = void 0) {
    this.resolve = s3, this.reject = t3, this.callback = e2, this.signal = r2, this.abortCallback = n3;
  }
};

// node_modules/@arcgis/core/views/support/debugFlags.js
var t2 = class extends m {
  constructor() {
    super(...arguments), this.SCHEDULER_LOG_SLOW_TASKS = false, this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = false;
  }
};
e([y()], t2.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0), e([y()], t2.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0), t2 = e([a2("esri.views.support.DebugFlags")], t2);
var p = new t2();

// node_modules/@arcgis/core/views/support/RenderState.js
var I;
!function(I3) {
  I3[I3.ANIMATING = 0] = "ANIMATING", I3[I3.INTERACTING = 1] = "INTERACTING", I3[I3.IDLE = 2] = "IDLE";
}(I || (I = {}));

// node_modules/@arcgis/core/views/support/Scheduler.js
var g;
var I2;
!function(e2) {
  e2[e2.YIELD = 1] = "YIELD";
}(g || (g = {})), function(e2) {
  e2.RESOURCE_CONTROLLER_IMMEDIATE = "immediate", e2.RESOURCE_CONTROLLER = "schedule", e2.SLIDE = "slide", e2.STREAM_DATA_LOADER = "stream loader", e2.ELEVATION_QUERY = "elevation query", e2.TERRAIN_SURFACE = "terrain", e2.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e2.LOD_RENDERER = "LoD renderer", e2.GRAPHICS_CORE = "Graphics3D", e2.I3S_CONTROLLER = "I3S", e2.POINT_CLOUD_LAYER = "point cloud", e2.FEATURE_TILE_FETCHER = "feature fetcher", e2.OVERLAY = "overlay", e2.STAGE = "stage", e2.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e2.FILTER_VISIBILITY = "Graphics3D filter visibility", e2.SCALE_VISIBILITY = "Graphics3D scale visibility", e2.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e2.POINT_OF_INTEREST_FREQUENT = "POI frequent", e2.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e2.LABELER = "labeler", e2.FEATURE_QUERY_ENGINE = "feature query", e2.FEATURE_TILE_TREE = "feature tile tree", e2.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e2.ELEVATION_ALIGNMENT = "elevation alignment", e2.TEXT_TEXTURE_ATLAS = "text texture atlas", e2.TEXTURE_UNLOAD = "texture unload", e2.LINE_OF_SIGHT_TOOL = "line of sight tool", e2.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e2.ELEVATION_PROFILE = "elevation profile", e2.SNAPPING = "snapping", e2.SHADOW_ACCUMULATOR = "shadow accumulator", e2.CLOUDS_GENERATOR = "clouds generator", e2[e2.NONE = 0] = "NONE", e2[e2.TEST_PRIO = 1] = "TEST_PRIO";
}(I2 || (I2 = {}));
var R = 0;
var p2 = /* @__PURE__ */ new Map([[I2.RESOURCE_CONTROLLER_IMMEDIATE, R], [I2.RESOURCE_CONTROLLER, 4], [I2.SLIDE, R], [I2.STREAM_DATA_LOADER, R], [I2.ELEVATION_QUERY, R], [I2.TERRAIN_SURFACE, 1], [I2.SURFACE_GEOMETRY_UPDATES, 1], [I2.LOD_RENDERER, 2], [I2.GRAPHICS_CORE, 2], [I2.I3S_CONTROLLER, 2], [I2.POINT_CLOUD_LAYER, 2], [I2.FEATURE_TILE_FETCHER, 2], [I2.OVERLAY, 4], [I2.STAGE, 4], [I2.GRAPHICS_DECONFLICTOR, 4], [I2.FILTER_VISIBILITY, 4], [I2.SCALE_VISIBILITY, 4], [I2.FRUSTUM_VISIBILITY, 4], [I2.CLOUDS_GENERATOR, 4], [I2.POINT_OF_INTEREST_FREQUENT, 6], [I2.POINT_OF_INTEREST_INFREQUENT, 30], [I2.LABELER, 8], [I2.FEATURE_QUERY_ENGINE, 8], [I2.FEATURE_TILE_TREE, 16], [I2.FEATURE_TILE_TREE_ACTIVE, R], [I2.ELEVATION_ALIGNMENT, 12], [I2.TEXT_TEXTURE_ATLAS, 12], [I2.TEXTURE_UNLOAD, 12], [I2.LINE_OF_SIGHT_TOOL, 16], [I2.LINE_OF_SIGHT_TOOL_INTERACTIVE, R], [I2.SNAPPING, R], [I2.SHADOW_ACCUMULATOR, 30]]);
function f2(e2) {
  return p2.has(e2) ? p2.get(e2) : "number" == typeof e2 ? e2 : 1;
}
var L = n(6.5);
var A = n(1);
var b = n(30);
var S = n(1e3 / 30);
var O = n(100);
var k = 0.9;
var N;
var U;
!function(a3) {
  class n3 {
    get updating() {
      return this._updating.value;
    }
    _updatingChanged() {
      this._updating.value = this._tasks.some((e2) => e2.needsUpdate);
    }
    constructor() {
      this._updating = r(true), this._microTaskQueued = false, this._frameNumber = 0, this.performanceInfo = { total: new s2("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = new c2(), this._state = I.INTERACTING, this._tasks = new l(), this._runQueue = new l(), this._load = 0, this._idleStateCallbacks = new l(), this._idleUpdatesStartFired = false, this._forceTask = false, this._debug = false, this._debugHandle = l2(() => p.SCHEDULER_LOG_SLOW_TASKS, (e3) => this._debug = e3, h);
      for (const t3 of Object.keys(I2))
        this.performanceInfo.tasks.set(I2[t3], new s2(I2[t3]));
      const e2 = this;
      this._test = { FRAME_SAFETY_BUDGET: L, INTERACTING_BUDGET: S, IDLE_BUDGET: O, get availableBudget() {
        return e2._budget.budget;
      }, usedBudget: 0, getBudget: () => e2._budget, setBudget: (t3) => e2._budget = t3, updateTask: (e3) => this._updateTask(e3), getState: (e3) => this._getState(e3), getRuntime: (e3) => this._getRuntime(e3), frameTaskTimes: this._frameTaskTimes, resetRuntimes: () => this._resetRuntimes(), getRunning: () => this._getRunning() };
    }
    destroy() {
      this._tasks.toArray().forEach((e2) => e2.remove()), this._tasks.clear(), o(this._debugHandle), this._microTaskQueued = false, this._updatingChanged();
    }
    taskRunningChanged(e2) {
      this._updatingChanged(), e2 && this._budget.remaining > 0 && !this._microTaskQueued && (this._microTaskQueued = true, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = false, this._budget.remaining > 0 && this._schedule() && this.frame());
      }));
    }
    registerTask(e2, t3) {
      const s3 = f2(e2), i2 = new u(this, e2, t3, s3);
      return this._tasks.push(i2), this._updatingChanged(), this.performanceInfo.tasks.has(e2) || this.performanceInfo.tasks.set(e2, new s2(e2)), i2;
    }
    registerIdleStateCallbacks(e2, t3) {
      const s3 = { idleBegin: e2, idleEnd: t3 };
      this._idleStateCallbacks.push(s3), this.state === I.IDLE && this._idleUpdatesStartFired && s3.idleBegin();
      const r2 = this;
      return { remove: () => this._removeIdleStateCallbacks(s3), set idleBegin(e3) {
        r2._idleUpdatesStartFired && (s3.idleEnd(), r2._state === I.IDLE && e3()), s3.idleBegin = e3;
      }, set idleEnd(e3) {
        s3.idleEnd = e3;
      } };
    }
    get load() {
      return this._load;
    }
    set state(e2) {
      this._state !== e2 && (this._state = e2, this.state !== I.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = false, this._idleStateCallbacks.forAll((e3) => e3.idleEnd())));
    }
    get state() {
      return this._state;
    }
    updateBudget(e2) {
      this._test.usedBudget = 0, ++this._frameNumber;
      let t3 = L, s3 = e2.frameDuration, r2 = A;
      switch (this.state) {
        case I.IDLE:
          t3 = n(0), s3 = n(Math.max(O, e2.frameDuration)), r2 = b;
          break;
        case I.INTERACTING:
          s3 = n(Math.max(S, e2.frameDuration));
        case I.ANIMATING:
      }
      return s3 = n(s3 - e2.elapsedFrameTime - t3), this.state !== I.IDLE && s3 < A && !this._forceTask ? (this._forceTask = true, false) : (s3 = n(Math.max(s3, r2)), this._budget.reset(s3, this.state), this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = false, this._microTaskQueued = false, this.state) {
        case I.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = true, this._idleStateCallbacks.forAll((e2) => e2.idleBegin())), this._runIdle();
          break;
        case I.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
      this._test.usedBudget = this._budget.elapsed;
    }
    stopFrame() {
      this._budget.reset(n(0), this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(e2) {
      this._idleUpdatesStartFired && e2.idleEnd(), this._idleStateCallbacks.removeUnordered(e2);
    }
    removeTask(e2) {
      this._tasks.removeUnordered(e2), this._runQueue.removeUnordered(e2), this._updatingChanged();
    }
    _updateTask(e2) {
      this._tasks.forAll((t3) => {
        t3.name === e2 && t3.setPriority(e2);
      });
    }
    _getState(e2) {
      if (this._runQueue.some((t4) => t4.name === e2))
        return U.SCHEDULED;
      let t3 = U.IDLE;
      return this._tasks.forAll((s3) => {
        s3.name === e2 && s3.needsUpdate && (s3.schedulePriority <= 1 ? t3 = U.READY : t3 !== U.READY && (t3 = U.WAITING));
      }), t3;
    }
    _getRuntime(e2) {
      let t3 = 0;
      return this._tasks.forAll((s3) => {
        s3.name === e2 && (t3 += s3.runtime);
      }), t3;
    }
    _resetRuntimes() {
      this._tasks.forAll((e2) => e2.runtime = 0);
    }
    _getRunning() {
      const e2 = /* @__PURE__ */ new Map();
      if (this._tasks.forAll((t4) => {
        t4.needsUpdate && e2.set(t4.name, (e2.get(t4.name) || 0) + 1);
      }), 0 === e2.size)
        return null;
      let t3 = "";
      return e2.forEach((e3, s3) => {
        t3 += e3 > 1 ? ` ${e3}x ${s3}` : ` ${s3}`;
      }), t3;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const e2 = this._tasks.reduce((e3, t3) => t3.needsUpdate ? ++e3 : e3, 0);
      this._load = this._load * k + e2 * (1 - k);
    }
    _schedule() {
      for (this._runQueue.filterInPlace((e2) => !!e2.needsUpdate || (e2.schedulePriority = e2.basePriority, false)), this._tasks.forAll((e2) => {
        e2.basePriority === R && e2.needsUpdate && !this._runQueue.includes(e2) && e2.blockFrame !== this._frameNumber && this._runQueue.unshift(e2);
      }); 0 === this._runQueue.length; ) {
        let e2 = false, t3 = 0;
        if (this._tasks.forAll((s3) => {
          if (s3.needsUpdate && 0 !== s3.schedulePriority && s3.basePriority !== R && s3.blockFrame !== this._frameNumber)
            if (e2 = true, t3 = Math.max(t3, s3.basePriority), 1 === s3.schedulePriority)
              s3.schedulePriority = 0, this._runQueue.push(s3);
            else
              --s3.schedulePriority;
        }), !e2)
          return this._updatingChanged(), false;
      }
      return this._updatingChanged(), true;
    }
    _run() {
      const e2 = this._budget.now();
      this._startFrameTaskTimes();
      do {
        for (; this._runQueue.length > 0; ) {
          const r2 = this._budget.now(), i2 = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            i2.task.runTask(this._budget) === g.YIELD && (i2.blockFrame = this._frameNumber);
          } catch (s3) {
            s.getLogger("esri.views.support.Scheduler").error(`Exception in task "${i2.name}"`, s3);
          }
          !this._budget.hasProgressed && i2.blockFrame !== this._frameNumber && i2.needsUpdate && (i2.name, I2.I3S_CONTROLLER, i2.blockFrame = this._frameNumber), i2.schedulePriority = i2.basePriority;
          const a4 = this._budget.now() - r2;
          if (i2.runtime += a4, this._frameTaskTimes.set(i2.priority, this._frameTaskTimes.get(i2.priority) + a4), this._debug && a4 > 2 * this._budget.budget && console.log("Task", i2.name, "used", a4, "of max", this._budget.budget, "ms"), this._budget.remaining <= 0)
            return this._updatingChanged(), void this._recordFrameTaskTimes(this._budget.now() - e2);
        }
      } while (this._schedule());
      this._updatingChanged(), this._recordFrameTaskTimes(this._budget.now() - e2);
    }
    _startFrameTaskTimes() {
      for (const e2 of Object.keys(I2))
        this._frameTaskTimes.set(I2[e2], 0);
    }
    _recordFrameTaskTimes(e2) {
      this._frameTaskTimes.forEach((e3, t3) => this.performanceInfo.tasks.get(t3).record(e3)), this.performanceInfo.total.record(e2);
    }
    get test() {
      return this._test;
    }
  }
  a3.Scheduler = n3;
  class u {
    get task() {
      return this._task.value;
    }
    get updating() {
      return this._queue.running;
    }
    constructor(t3, s3, r2, i2) {
      this._scheduler = t3, this.name = s3, this._basePriority = i2, this.blockFrame = 0, this.runtime = 0, this._queue = new n2(), this._handles = new t(), this.schedulePriority = this._basePriority, this._task = r(null != r2 ? r2 : this._queue), this._handles.add(f(() => this.task.running, (e2) => t3.taskRunningChanged(e2)));
    }
    remove() {
      this.processQueue(C), this._scheduler.removeTask(this), this.schedule = F.schedule, this.reschedule = F.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(e2) {
      this.name = e2;
      const t3 = f2(e2);
      this._basePriority !== R && 0 === this.schedulePriority || (this.schedulePriority = t3), this._basePriority = t3;
    }
    get priority() {
      return this.name;
    }
    set priority(e2) {
      this.setPriority(e2);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(e2, t3, s3) {
      return this._queue.push(e2, t3, s3);
    }
    reschedule(e2, t3, s3) {
      return this._queue.unshift(e2, t3, s3);
    }
    processQueue(e2) {
      this._queue.runTask(e2);
    }
  }
  class c2 {
    constructor() {
      this._begin = "undefined" != typeof performance ? performance.now() : 0, this._budget = 0, this._state = I.IDLE, this._done = false, this._progressed = false, this._enabled = true;
    }
    run(e2) {
      return !this.done && (true === e2() && this.madeProgress(), true);
    }
    get done() {
      return this._done;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      return this._progressed = true, this._done = this.elapsed >= this._budget && this._enabled, this._done;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e2) {
      this._enabled = e2;
    }
    reset(e2, t3) {
      this._begin = this.now(), this._budget = e2, this._state = t3, this.resetProgress();
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    now() {
      return performance.now();
    }
    get elapsed() {
      return performance.now() - this._begin;
    }
    resetProgress() {
      this._progressed = false, this._done = false;
    }
    get hasProgressed() {
      return this._progressed;
    }
  }
  a3.Budget = c2;
}(N || (N = {})), function(e2) {
  e2.SCHEDULED = "s", e2.READY = "r", e2.WAITING = "w", e2.IDLE = "i";
}(U || (U = {}));
var C = (() => {
  const e2 = new N.Budget();
  return e2.enabled = false, e2;
})();
var P = class {
  remove() {
  }
  processQueue() {
  }
  schedule(e2, t3, s3) {
    try {
      if (a(t3)) {
        const e3 = c();
        return s3 ? Promise.resolve(s3(e3)) : Promise.reject(e3);
      }
      return E(e2(C));
    } catch (r2) {
      return Promise.reject(r2);
    }
  }
  reschedule(e2, t3, s3) {
    return this.schedule(e2, t3, s3);
  }
};
var F = new P();

export {
  I2 as I,
  C,
  F
};
//# sourceMappingURL=chunk-ITRH3PGV.js.map
