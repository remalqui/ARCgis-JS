import {
  b,
  j,
  v
} from "./chunk-TKF7C3ZA.js";
import "./chunk-56WQONSA.js";
import {
  Q,
  V,
  _,
  d,
  k,
  p as p2,
  q as q2,
  s as s2,
  z
} from "./chunk-TTCCMCQH.js";
import {
  m
} from "./chunk-AJL3PX3E.js";
import "./chunk-QOPVYP7U.js";
import {
  i
} from "./chunk-VD2BLFWE.js";
import "./chunk-BN6X2OXK.js";
import "./chunk-3TMT4LDG.js";
import "./chunk-7LLYVI2T.js";
import "./chunk-L7P4URYM.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import "./chunk-AEPMR2T7.js";
import "./chunk-EF6YPOUN.js";
import "./chunk-AYMF6OMA.js";
import "./chunk-FJXAEGHD.js";
import "./chunk-WWUAHPIM.js";
import {
  r as r3
} from "./chunk-AHAGGZUI.js";
import "./chunk-VZAEQ6CY.js";
import "./chunk-X4Y5OF5X.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-MOPR7RFH.js";
import {
  A,
  g,
  n,
  p,
  q,
  r,
  r2,
  t,
  u2 as u,
  x
} from "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import {
  a2 as a,
  l
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  e as e2
} from "./chunk-2YSHZRCT.js";
import {
  s
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/geometry/support/clipRay.js
function a2(r5) {
  return r5 ? { ray: d(r5.ray), c0: r5.c0, c1: r5.c1 } : { ray: d(), c0: 0, c1: Number.MAX_VALUE };
}
var A2 = new s2(() => a2());

// node_modules/@arcgis/core/geometry/support/frustum.js
function N() {
  return [n(), n(), n(), n(), n(), n(), n(), n()];
}
function P(T2, _4) {
  for (let O2 = 0; O2 < v3; O2++) {
    const R3 = T2[O2];
    if (R3[0] * _4[0] + R3[1] * _4[1] + R3[2] * _4[2] + R3[3] >= _4[3])
      return false;
  }
  return true;
}
var l2;
var k3;
!function(T2) {
  T2[T2.LEFT = 0] = "LEFT", T2[T2.RIGHT = 1] = "RIGHT", T2[T2.BOTTOM = 2] = "BOTTOM", T2[T2.TOP = 3] = "TOP", T2[T2.NEAR = 4] = "NEAR", T2[T2.FAR = 5] = "FAR";
}(l2 || (l2 = {})), function(T2) {
  T2[T2.NEAR_BOTTOM_LEFT = 0] = "NEAR_BOTTOM_LEFT", T2[T2.NEAR_BOTTOM_RIGHT = 1] = "NEAR_BOTTOM_RIGHT", T2[T2.NEAR_TOP_RIGHT = 2] = "NEAR_TOP_RIGHT", T2[T2.NEAR_TOP_LEFT = 3] = "NEAR_TOP_LEFT", T2[T2.FAR_BOTTOM_LEFT = 4] = "FAR_BOTTOM_LEFT", T2[T2.FAR_BOTTOM_RIGHT = 5] = "FAR_BOTTOM_RIGHT", T2[T2.FAR_TOP_RIGHT = 6] = "FAR_TOP_RIGHT", T2[T2.FAR_TOP_LEFT = 7] = "FAR_TOP_LEFT";
}(k3 || (k3 = {}));
var h3 = { bottom: [k3.FAR_BOTTOM_RIGHT, k3.NEAR_BOTTOM_RIGHT, k3.NEAR_BOTTOM_LEFT, k3.FAR_BOTTOM_LEFT], near: [k3.NEAR_BOTTOM_LEFT, k3.NEAR_BOTTOM_RIGHT, k3.NEAR_TOP_RIGHT, k3.NEAR_TOP_LEFT], far: [k3.FAR_BOTTOM_RIGHT, k3.FAR_BOTTOM_LEFT, k3.FAR_TOP_LEFT, k3.FAR_TOP_RIGHT], right: [k3.NEAR_BOTTOM_RIGHT, k3.FAR_BOTTOM_RIGHT, k3.FAR_TOP_RIGHT, k3.NEAR_TOP_RIGHT], left: [k3.FAR_BOTTOM_LEFT, k3.NEAR_BOTTOM_LEFT, k3.NEAR_TOP_LEFT, k3.FAR_TOP_LEFT], top: [k3.FAR_TOP_LEFT, k3.NEAR_TOP_LEFT, k3.NEAR_TOP_RIGHT, k3.FAR_TOP_RIGHT] };
var v3 = 6;
var b2 = [r3(-1, -1, -1, 1), r3(1, -1, -1, 1), r3(1, 1, -1, 1), r3(-1, 1, -1, 1), r3(-1, -1, 1, 1), r3(1, -1, 1, 1), r3(1, 1, 1, 1), r3(-1, 1, 1, 1)];
var y2 = new s2(a2);
var S = N();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var b3 = class _b {
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  constructor(e3, t3) {
    this.objectToBoundingSphere = e3, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new g2(), this._objectCount = 0, t3 && (void 0 !== t3.maximumObjectsPerNode && (this._maximumObjectsPerNode = t3.maximumObjectsPerNode), void 0 !== t3.maximumDepth && (this._maximumDepth = t3.maximumDepth));
  }
  destroy() {
    this._degenerateObjects.clear(), g2.clearPool(), B[0] = null, P2.prune(), H.prune();
  }
  add(e3, t3 = e3.length) {
    this._objectCount += t3, this._grow(e3, t3);
    const o2 = g2.acquire();
    for (let n2 = 0; n2 < t3; n2++) {
      const t4 = e3[n2];
      this._isDegenerate(t4) ? this._degenerateObjects.add(t4) : (o2.init(this._root), this._add(t4, o2));
    }
    g2.release(o2);
  }
  remove(e3, t3 = null) {
    this._objectCount -= e3.length;
    const o2 = g2.acquire();
    for (const n2 of e3) {
      const e4 = null != t3 ? t3 : q2(this.objectToBoundingSphere(n2), w2);
      E(e4[3]) ? (o2.init(this._root), this._remove(n2, e4, o2)) : this._degenerateObjects.delete(n2);
    }
    g2.release(o2), this._shrink();
  }
  update(e3, t3) {
    if (!E(t3[3]) && this._isDegenerate(e3))
      return;
    const o2 = R2(e3);
    this.remove(o2, t3), this.add(o2);
  }
  forEachAlongRay(e3, t3, o2) {
    const n2 = p2(e3, t3);
    this._forEachNode(this._root, (e4) => {
      if (!this._intersectsNode(n2, e4))
        return false;
      const t4 = e4.node;
      return t4.terminals.forAll((e5) => {
        this._intersectsObject(n2, e5) && o2(e5);
      }), null !== t4.residents && t4.residents.forAll((e5) => {
        this._intersectsObject(n2, e5) && o2(e5);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(e3, t3, o2, n2) {
    const i2 = p2(e3, t3);
    this._forEachNode(this._root, (e4) => {
      if (!this._intersectsNodeWithOffset(i2, e4, n2))
        return false;
      const t4 = e4.node;
      return t4.terminals.forAll((e5) => {
        this._intersectsObjectWithOffset(i2, e5, n2) && o2(e5);
      }), null !== t4.residents && t4.residents.forAll((e5) => {
        this._intersectsObjectWithOffset(i2, e5, n2) && o2(e5);
      }), true;
    });
  }
  forEach(e3) {
    this._forEachNode(this._root, (t3) => {
      const o2 = t3.node;
      return o2.terminals.forAll(e3), null !== o2.residents && o2.residents.forAll(e3), true;
    }), this._degenerateObjects.forEach(e3);
  }
  forEachDegenerateObject(e3) {
    this._degenerateObjects.forEach(e3);
  }
  findClosest(e3, t3, i2, s4 = () => true, r5 = 1 / 0) {
    let h4 = 1 / 0, a4 = 1 / 0, l3 = null;
    const u2 = T(e3, t3), c2 = (o2) => {
      if (--r5, !s4(o2))
        return;
      const n2 = this.objectToBoundingSphere(o2);
      if (!P(i2, n2))
        return;
      const u3 = z2(e3, t3, z(n2)), c3 = u3 - n2[3], m3 = u3 + n2[3];
      c3 < h4 && (h4 = c3, a4 = m3, l3 = o2);
    };
    return this._forEachNodeDepthOrdered(this._root, (s5) => {
      if (r5 <= 0 || !P(i2, s5.bounds))
        return false;
      g(v4, u2, s5.halfSize), u(v4, v4, s5.bounds);
      if (z2(e3, t3, v4) > a4)
        return false;
      const h5 = s5.node;
      return h5.terminals.forAll((e4) => c2(e4)), null !== h5.residents && h5.residents.forAll((e4) => c2(e4)), true;
    }, e3, t3), l3;
  }
  forEachInDepthRange(e3, t3, i2, s4, r5, h4, a4) {
    let l3 = -1 / 0, u2 = 1 / 0;
    const c2 = { setRange: (e4) => {
      i2 === _b.DepthOrder.FRONT_TO_BACK ? (l3 = Math.max(l3, e4.near), u2 = Math.min(u2, e4.far)) : (l3 = Math.max(l3, -e4.far), u2 = Math.min(u2, -e4.near));
    } };
    c2.setRange(s4);
    const m3 = z2(t3, i2, e3), _4 = T(t3, i2), p4 = T(t3, -i2), g3 = (e4) => {
      if (!a4(e4))
        return;
      const o2 = this.objectToBoundingSphere(e4), n2 = z(o2), s5 = z2(t3, i2, n2) - m3, _5 = s5 - o2[3], p5 = s5 + o2[3];
      _5 > u2 || p5 < l3 || !P(h4, o2) || r5(e4, c2);
    };
    this._forEachNodeDepthOrdered(this._root, (e4) => {
      if (!P(h4, e4.bounds))
        return false;
      g(v4, _4, e4.halfSize), u(v4, v4, e4.bounds);
      if (z2(t3, i2, v4) - m3 > u2)
        return false;
      g(v4, p4, e4.halfSize), u(v4, v4, e4.bounds);
      if (z2(t3, i2, v4) - m3 < l3)
        return false;
      const s5 = e4.node;
      return s5.terminals.forAll((e5) => g3(e5)), null !== s5.residents && s5.residents.forAll((e5) => g3(e5)), true;
    }, t3, i2);
  }
  forEachNode(e3) {
    this._forEachNode(this._root, (t3) => e3(t3.node, t3.bounds, t3.halfSize, t3.depth));
  }
  forEachNeighbor(e3, t3) {
    const o2 = k(t3), n2 = z(t3), s4 = (t4) => {
      const s5 = this.objectToBoundingSphere(t4), r6 = k(s5), h5 = o2 + r6;
      return !(p(z(s5), n2) - h5 * h5 <= 0) || e3(t4);
    };
    let r5 = true;
    const h4 = (e4) => {
      r5 && (r5 = s4(e4));
    };
    this._forEachNode(this._root, (e4) => {
      const t4 = k(e4.bounds), s5 = o2 + t4;
      if (p(z(e4.bounds), n2) - s5 * s5 > 0)
        return false;
      const a4 = e4.node;
      return a4.terminals.forAll(h4), r5 && null !== a4.residents && a4.residents.forAll(h4), r5;
    }), r5 && this.forEachDegenerateObject(h4);
  }
  _intersectsNode(e3, t3) {
    return j2(t3.bounds, 2 * -t3.halfSize, C), j2(t3.bounds, 2 * t3.halfSize, y3), i(e3.origin, e3.direction, C, y3);
  }
  _intersectsNodeWithOffset(e3, t3, o2) {
    return j2(t3.bounds, 2 * -t3.halfSize, C), j2(t3.bounds, 2 * t3.halfSize, y3), o2.applyToMinMax(C, y3), i(e3.origin, e3.direction, C, y3);
  }
  _intersectsObject(e3, t3) {
    const o2 = this.objectToBoundingSphere(t3);
    return !(o2[3] > 0) || V(o2, e3);
  }
  _intersectsObjectWithOffset(e3, t3, o2) {
    const n2 = this.objectToBoundingSphere(t3);
    return !(n2[3] > 0) || V(o2.applyToBoundingSphere(n2), e3);
  }
  _forEachNode(e3, t3) {
    let o2 = g2.acquire().init(e3);
    const n2 = [o2];
    for (; 0 !== n2.length; ) {
      if (o2 = n2.pop(), t3(o2) && !o2.isLeaf())
        for (let e4 = 0; e4 < o2.node.children.length; e4++) {
          o2.node.children[e4] && n2.push(g2.acquire().init(o2).advance(e4));
        }
      g2.release(o2);
    }
  }
  _forEachNodeDepthOrdered(e3, t3, o2, n2 = _b.DepthOrder.FRONT_TO_BACK) {
    let i2 = g2.acquire().init(e3);
    const s4 = [i2];
    for (N2(o2, n2, K); 0 !== s4.length; ) {
      if (i2 = s4.pop(), t3(i2) && !i2.isLeaf())
        for (let e4 = 7; e4 >= 0; --e4) {
          const t4 = K[e4];
          i2.node.children[t4] && s4.push(g2.acquire().init(i2).advance(t4));
        }
      g2.release(i2);
    }
  }
  _remove(e3, t3, o2) {
    P2.clear();
    const n2 = o2.advanceTo(t3, (e4, t4) => {
      P2.push(e4.node), P2.push(t4);
    }) ? o2.node.terminals : o2.node.residents;
    if (n2.removeUnordered(e3), 0 === n2.length)
      for (let i2 = P2.length - 2; i2 >= 0; i2 -= 2) {
        const e4 = P2.data[i2], t4 = P2.data[i2 + 1];
        if (!this._purge(e4, t4))
          break;
      }
  }
  _nodeIsEmpty(e3) {
    if (0 !== e3.terminals.length)
      return false;
    if (null !== e3.residents)
      return 0 === e3.residents.length;
    for (let t3 = 0; t3 < e3.children.length; t3++)
      if (e3.children[t3])
        return false;
    return true;
  }
  _purge(e3, o2) {
    return o2 >= 0 && (e3.children[o2] = null), !!this._nodeIsEmpty(e3) && (null === e3.residents && (e3.residents = new l({ shrink: true })), true);
  }
  _add(e3, t3) {
    t3.advanceTo(this.objectToBoundingSphere(e3)) ? t3.node.terminals.push(e3) : (t3.node.residents.push(e3), t3.node.residents.length > this._maximumObjectsPerNode && t3.depth < this._maximumDepth && this._split(t3));
  }
  _split(e3) {
    const t3 = e3.node.residents;
    e3.node.residents = null;
    for (let o2 = 0; o2 < t3.length; o2++) {
      const n2 = g2.acquire().init(e3);
      this._add(t3.at(o2), n2), g2.release(n2);
    }
  }
  _grow(e3, t3) {
    if (0 !== t3 && (x2(e3, t3, (e4) => this.objectToBoundingSphere(e4), k4), E(k4[3]) && !this._fitsInsideTree(k4)))
      if (this._nodeIsEmpty(this._root.node))
        q2(k4, this._root.bounds), this._root.halfSize = 1.25 * this._root.bounds[3], this._root.updateBoundsRadiusFromHalfSize();
      else {
        const e4 = this._rootBoundsForRootAsSubNode(k4);
        this._placingRootViolatesMaxDepth(e4) ? this._rebuildTree(k4, e4) : this._growRootAsSubNode(e4), g2.release(e4);
      }
  }
  _rebuildTree(e3, t3) {
    r2(q3, t3.bounds), q3[3] = t3.halfSize, x2([e3, q3], 2, (e4) => e4, I);
    const o2 = g2.acquire().init(this._root);
    this._root.initFrom(null, I, I[3]), this._root.increaseHalfSize(1.25), this._forEachNode(o2, (e4) => (this.add(e4.node.terminals.data, e4.node.terminals.length), null !== e4.node.residents && this.add(e4.node.residents.data, e4.node.residents.length), true)), g2.release(o2);
  }
  _placingRootViolatesMaxDepth(e3) {
    const t3 = Math.log(e3.halfSize / this._root.halfSize) * Math.LOG2E;
    let o2 = 0;
    return this._forEachNode(this._root, (e4) => (o2 = Math.max(o2, e4.depth), o2 + t3 <= this._maximumDepth)), o2 + t3 > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(e3) {
    const t3 = e3[3], o2 = e3;
    let n2 = -1 / 0;
    const i2 = this._root.bounds, s4 = this._root.halfSize;
    for (let h4 = 0; h4 < 3; h4++) {
      const e4 = i2[h4] - s4 - (o2[h4] - t3), r6 = o2[h4] + t3 - (i2[h4] + s4), a4 = Math.max(0, Math.ceil(e4 / (2 * s4))), d2 = Math.max(0, Math.ceil(r6 / (2 * s4))) + 1, l3 = 2 ** Math.ceil(Math.log(a4 + d2) * Math.LOG2E);
      n2 = Math.max(n2, l3), L[h4].min = a4, L[h4].max = d2;
    }
    for (let h4 = 0; h4 < 3; h4++) {
      let e4 = L[h4].min, t4 = L[h4].max;
      const o3 = (n2 - (e4 + t4)) / 2;
      e4 += Math.ceil(o3), t4 += Math.floor(o3);
      const r6 = i2[h4] - s4 - e4 * s4 * 2;
      F[h4] = r6 + (t4 + e4) * s4;
    }
    const r5 = n2 * s4;
    return F[3] = r5 * A3, g2.acquire().initFrom(null, F, r5, 0);
  }
  _growRootAsSubNode(e3) {
    const t3 = this._root.node;
    r2(k4, this._root.bounds), k4[3] = this._root.halfSize, this._root.init(e3), e3.advanceTo(k4, null, true), e3.node.children = t3.children, e3.node.residents = t3.residents, e3.node.terminals = t3.terminals;
  }
  _shrink() {
    for (; ; ) {
      const e3 = this._findShrinkIndex();
      if (-1 === e3)
        break;
      this._root.advance(e3), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf())
      return -1;
    let e3 = null;
    const t3 = this._root.node.children;
    let o2 = 0, n2 = 0;
    for (; n2 < t3.length && null == e3; )
      o2 = n2++, e3 = t3[o2];
    for (; n2 < t3.length; )
      if (t3[n2++])
        return -1;
    return o2;
  }
  _isDegenerate(e3) {
    return !E(this.objectToBoundingSphere(e3)[3]);
  }
  _fitsInsideTree(e3) {
    const t3 = this._root.bounds, o2 = this._root.halfSize;
    return e3[3] <= o2 && e3[0] >= t3[0] - o2 && e3[0] <= t3[0] + o2 && e3[1] >= t3[1] - o2 && e3[1] <= t3[1] + o2 && e3[2] >= t3[2] - o2 && e3[2] <= t3[2] + o2;
  }
  toJSON() {
    const { maximumDepth: e3, maximumObjectsPerNode: t3, _objectCount: o2 } = this, n2 = this._nodeToJSON(this._root.node);
    return { maximumDepth: e3, maximumObjectsPerNode: t3, objectCount: o2, root: { bounds: this._root.bounds, halfSize: this._root.halfSize, depth: this._root.depth, node: n2 } };
  }
  _nodeToJSON(e3) {
    var _a, _b2;
    const t3 = e3.children.map((e4) => e4 ? this._nodeToJSON(e4) : null), o2 = (_a = e3.residents) == null ? void 0 : _a.map((e4) => this.objectToBoundingSphere(e4)), n2 = (_b2 = e3.terminals) == null ? void 0 : _b2.map((e4) => this.objectToBoundingSphere(e4));
    return { children: t3, residents: o2, terminals: n2 };
  }
  static fromJSON(e3) {
    const t3 = new _b((e4) => e4, { maximumDepth: e3.maximumDepth, maximumObjectsPerNode: e3.maximumObjectsPerNode });
    return t3._objectCount = e3.objectCount, t3._root.initFrom(e3.root.node, e3.root.bounds, e3.root.halfSize, e3.root.depth), t3;
  }
};
var g2 = class _g {
  constructor() {
    this.bounds = _(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(e3) {
    return this.initFrom(e3.node, e3.bounds, e3.halfSize, e3.depth);
  }
  initFrom(e3, t3, o2, n2 = this.depth) {
    return this.node = null != e3 ? e3 : _g.createEmptyNode(), null != t3 && q2(t3, this.bounds), this.halfSize = o2, this.depth = n2, this;
  }
  increaseHalfSize(e3) {
    this.halfSize *= e3, this.updateBoundsRadiusFromHalfSize();
  }
  updateBoundsRadiusFromHalfSize() {
    this.bounds[3] = this.halfSize * A3;
  }
  advance(e3) {
    let t3 = this.node.children[e3];
    t3 || (t3 = _g.createEmptyNode(), this.node.children[e3] = t3), this.node = t3, this.halfSize /= 2, this.depth++;
    const o2 = M[e3];
    return this.bounds[0] += o2[0] * this.halfSize, this.bounds[1] += o2[1] * this.halfSize, this.bounds[2] += o2[2] * this.halfSize, this.updateBoundsRadiusFromHalfSize(), this;
  }
  advanceTo(e3, t3, o2 = false) {
    for (; ; ) {
      if (this.isTerminalFor(e3))
        return t3 && t3(this, -1), true;
      if (this.isLeaf()) {
        if (!o2)
          return t3 && t3(this, -1), false;
        this.node.residents = null;
      }
      const n2 = this._childIndex(e3);
      t3 && t3(this, n2), this.advance(n2);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(e3) {
    return e3[3] > this.halfSize / 2;
  }
  _childIndex(e3) {
    const t3 = this.bounds;
    return (t3[0] < e3[0] ? 1 : 0) + (t3[1] < e3[1] ? 2 : 0) + (t3[2] < e3[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new l({ shrink: true }), residents: new l({ shrink: true }) };
  }
  static acquire() {
    return _g._pool.acquire();
  }
  static release(e3) {
    _g._pool.release(e3);
  }
  static clearPool() {
    _g._pool.prune();
  }
};
function S2(e3, t3) {
  e3[0] = Math.min(e3[0], t3[0] - t3[3]), e3[1] = Math.min(e3[1], t3[1] - t3[3]), e3[2] = Math.min(e3[2], t3[2] - t3[3]);
}
function O(e3, t3) {
  e3[0] = Math.max(e3[0], t3[0] + t3[3]), e3[1] = Math.max(e3[1], t3[1] + t3[3]), e3[2] = Math.max(e3[2], t3[2] + t3[3]);
}
function j2(e3, t3, o2) {
  o2[0] = e3[0] + t3, o2[1] = e3[1] + t3, o2[2] = e3[2] + t3;
}
function x2(e3, t3, o2, n2) {
  if (1 === t3) {
    const t4 = o2(e3[0]);
    q2(t4, n2);
  } else {
    C[0] = 1 / 0, C[1] = 1 / 0, C[2] = 1 / 0, y3[0] = -1 / 0, y3[1] = -1 / 0, y3[2] = -1 / 0;
    for (let n3 = 0; n3 < t3; n3++) {
      const t4 = o2(e3[n3]);
      E(t4[3]) && (S2(C, t4), O(y3, t4));
    }
    A(n2, C, y3, 0.5), n2[3] = Math.max(y3[0] - C[0], y3[1] - C[1], y3[2] - C[2]) / 2;
  }
}
function N2(e3, t3, o2) {
  if (!H.length)
    for (let n2 = 0; n2 < 8; ++n2)
      H.push({ index: 0, distance: 0 });
  for (let n2 = 0; n2 < 8; ++n2) {
    const o3 = M[n2];
    H.data[n2].index = n2, H.data[n2].distance = z2(e3, t3, o3);
  }
  H.sort((e4, t4) => e4.distance - t4.distance);
  for (let n2 = 0; n2 < 8; ++n2)
    o2[n2] = H.data[n2].index;
}
function T(e3, t3) {
  let o2, n2 = 1 / 0;
  for (let i2 = 0; i2 < 8; ++i2) {
    const s4 = z2(e3, t3, D2[i2]);
    s4 < n2 && (n2 = s4, o2 = D2[i2]);
  }
  return o2;
}
function z2(e3, t3, o2) {
  return t3 * (e3[0] * o2[0] + e3[1] * o2[1] + e3[2] * o2[2]);
}
function E(e3) {
  return !isNaN(e3) && e3 !== -1 / 0 && e3 !== 1 / 0 && e3 > 0;
}
g2._pool = new e2(g2), function(e3) {
  var t3;
  (t3 = e3.DepthOrder || (e3.DepthOrder = {}))[t3.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", t3[t3.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(b3 || (b3 = {}));
var M = [r(-1, -1, -1), r(1, -1, -1), r(-1, 1, -1), r(1, 1, -1), r(-1, -1, 1), r(1, -1, 1), r(-1, 1, 1), r(1, 1, 1)];
var D2 = [r(-1, -1, -1), r(-1, -1, 1), r(-1, 1, -1), r(-1, 1, 1), r(1, -1, -1), r(1, -1, 1), r(1, 1, -1), r(1, 1, 1)];
var A3 = Math.sqrt(3);
var B = [null];
function R2(e3) {
  return B[0] = e3, B;
}
var F = _();
var v4 = n();
var C = n();
var y3 = n();
var P2 = new l();
var w2 = _();
var k4 = _();
var q3 = _();
var I = _();
var L = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var H = new l();
var K = [0, 0, 0, 0, 0, 0, 0, 0];
var W = b3;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/sceneLayerSnappingUtils.js
var t2 = 1e3;
function a3(t3, a4, e3) {
  const i2 = _(), m3 = z(i2);
  return q(m3, m3, t3, 0.5), q(m3, m3, a4, 0.5), i2[3] = x(m3, t3), u(m3, m3, e3), i2;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js
var _3 = class {
  constructor() {
    this._idToComponent = /* @__PURE__ */ new Map(), this._components = new W((e3) => e3.bounds), this._edges = new W((e3) => e3.bounds), this._tmpLineSegment = v(), this._tmpP1 = n(), this._tmpP2 = n(), this._tmpP3 = n(), this.remoteClient = null;
  }
  async fetchCandidates(e3, s4) {
    await Promise.resolve(), s(s4), await this._ensureEdgeLocations(e3, s4);
    const o2 = [];
    return this._edges.forEachNeighbor((t3) => (this._addCandidates(e3, t3, o2), o2.length < t2), e3.bounds), { result: { candidates: o2 } };
  }
  async _ensureEdgeLocations(e3, t3) {
    const s4 = [];
    if (this._components.forEachNeighbor((e4) => {
      if (null == e4.info) {
        const { id: t4, uid: o3 } = e4;
        s4.push({ id: t4, uid: o3 });
      }
      return true;
    }, e3.bounds), !s4.length)
      return;
    const o2 = { components: s4 }, n2 = await this.remoteClient.invoke("fetchAllEdgeLocations", o2, t3 ?? {});
    for (const i2 of n2.components)
      this._setFetchEdgeLocations(i2);
  }
  async add(e3) {
    const t3 = new b4(e3.id, e3.bounds);
    return this._idToComponent.set(t3.id, t3), this._components.add([t3]), { result: {} };
  }
  async remove(e3) {
    const t3 = this._idToComponent.get(e3.id);
    if (t3) {
      const e4 = [];
      this._edges.forEachNeighbor((s4) => (s4.component === t3 && e4.push(s4), true), t3.bounds), this._edges.remove(e4), this._components.remove([t3]), this._idToComponent.delete(t3.id);
    }
    return { result: {} };
  }
  _setFetchEdgeLocations(e3) {
    const t3 = this._idToComponent.get(e3.id);
    if (null == t3 || e3.uid !== t3.uid)
      return;
    const s4 = m.createView(e3.locations), o2 = new Array(s4.count), n2 = n(), r5 = n();
    for (let i2 = 0; i2 < s4.count; i2++) {
      s4.position0.getVec(i2, n2), s4.position1.getVec(i2, r5);
      const d3 = a3(n2, r5, e3.origin), c3 = new j3(t3, i2, d3);
      o2[i2] = c3;
    }
    this._edges.add(o2);
    const { objectIds: d2, origin: c2 } = e3;
    t3.info = { locations: s4, objectIds: d2, origin: c2 };
  }
  _addCandidates(e3, t3, s4) {
    const { info: n2 } = t3.component, { origin: i2, objectIds: r5 } = n2, d2 = n2.locations, c2 = d2.position0.getVec(t3.index, this._tmpP1), a4 = d2.position1.getVec(t3.index, this._tmpP2);
    u(c2, c2, i2), u(a4, a4, i2);
    const p4 = r5[d2.componentIndex.get(t3.index)];
    this._addEdgeCandidate(e3, p4, c2, a4, s4), this._addVertexCandidate(e3, p4, c2, s4), this._addVertexCandidate(e3, p4, a4, s4);
  }
  _addEdgeCandidate(e3, t3, s4, o2, i2) {
    if (!e3.returnEdge)
      return;
    const d2 = z(e3.bounds), h4 = b(s4, o2, this._tmpLineSegment), m3 = j(h4, d2, this._tmpP3);
    Q(e3.bounds, m3) && i2.push({ type: "edge", objectId: t3, target: t(m3), distance: x(d2, m3), start: t(s4), end: t(o2) });
  }
  _addVertexCandidate(e3, t3, s4, o2) {
    if (!e3.returnVertex)
      return;
    const i2 = z(e3.bounds);
    Q(e3.bounds, s4) && o2.push({ type: "vertex", objectId: t3, target: t(s4), distance: x(i2, s4) });
  }
};
_3 = e([a("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], _3);
var f2 = _3;
var b4 = class _b {
  constructor(e3, t3) {
    this.id = e3, this.bounds = t3, this.info = null, this.uid = ++_b.uid;
  }
};
b4.uid = 0;
var j3 = class {
  constructor(e3, t3, s4) {
    this.component = e3, this.index = t3, this.bounds = s4;
  }
};
export {
  f2 as default
};
//# sourceMappingURL=SceneLayerSnappingSourceWorker-6T3GMV24.js.map
