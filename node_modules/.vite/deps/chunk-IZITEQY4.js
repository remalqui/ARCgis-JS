import {
  d as d3,
  l as l2
} from "./chunk-ROAORTI3.js";
import {
  L,
  c,
  e,
  h as h3,
  l,
  m,
  n,
  o,
  p as p3,
  s as s3,
  t,
  u as u3
} from "./chunk-NGH54QS3.js";
import {
  d as d2,
  g,
  h,
  h2,
  p as p2
} from "./chunk-ZEKM2THG.js";
import {
  p,
  y
} from "./chunk-2735WBYK.js";
import {
  j as j3
} from "./chunk-OCIERVFA.js";
import {
  d,
  j as j2
} from "./chunk-VFQINJTY.js";
import {
  u as u2
} from "./chunk-EIE3W25Z.js";
import {
  a
} from "./chunk-LQVUN6IS.js";
import {
  j
} from "./chunk-HNHXEGH2.js";
import {
  u
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/symbols/support/previewSymbol3D.js
var D = t.size;
var O = t.maxSize;
var C = t.maxOutlineSize;
var R = t.lineWidth;
var E = t.tallSymbolWidth;
function I(e2) {
  const t2 = e2.outline, s4 = null != e2.material ? e2.material.color : null, a2 = null != s4 ? s4.toHex() : null;
  if (null == t2 || "pattern" in t2 && null != t2.pattern && "style" === t2.pattern.type && "none" === t2.pattern.style)
    return "fill" === e2.type && "#ffffff" === a2 ? { color: "#bdc3c7", width: 0.75 } : null;
  const l3 = u2(t2.size) || 0;
  return { color: "rgba(" + (null != t2.color ? t2.color.toRgba() : "255,255,255,1") + ")", width: Math.min(l3, C), style: "pattern" in t2 && null != t2.pattern && "style" === t2.pattern.type ? d2(t2.pattern.style) : null, join: "butt", cap: "patternCap" in t2 ? t2.patternCap : "butt" };
}
async function Z(t2, s4) {
  var _a, _b, _c;
  if ((_a = t2.thumbnail) == null ? void 0 : _a.url)
    return t2.thumbnail.url;
  if ("icon" === s4.type) {
    const e2 = (_b = s4 == null ? void 0 : s4.resource) == null ? void 0 : _b.href;
    if (e2)
      return h2(s4);
  }
  const a2 = a("esri/images/Legend/legend3dsymboldefault.png");
  if (t2.styleOrigin && (t2.styleOrigin.styleName || t2.styleOrigin.styleUrl)) {
    const e2 = await j3(t2.styleOrigin, { portal: t2.styleOrigin.portal }, "webRef").catch(() => null);
    if (e2 && "thumbnail" in e2 && ((_c = e2.thumbnail) == null ? void 0 : _c.url))
      return e2.thumbnail.url;
  }
  return a2;
}
function q(e2, a2 = 1) {
  const l3 = e2.a, r = y(e2), n2 = r.h, o2 = r.s / a2, i = 100 - (100 - r.v) / a2, { r: c2, g: p4, b: u4 } = p({ h: n2, s: o2, v: i });
  return [c2, p4, u4, l3];
}
function H(e2) {
  return "water" === e2.type ? null == e2.color ? null : e2.color : null == e2.material || null == e2.material.color ? null : e2.material.color;
}
function N(e2, t2 = 0) {
  const s4 = H(e2);
  if (!s4) {
    if ("fill" === e2.type)
      return null;
    const s5 = g.r, a3 = h3(s5, t2);
    return [a3, a3, a3, 100];
  }
  const a2 = s4.toRgba();
  for (let l3 = 0; l3 < 3; l3++)
    a2[l3] = h3(a2[l3], t2);
  return a2;
}
async function T(t2, s4) {
  const a2 = t2.style;
  if ("none" === a2)
    return null;
  return { type: "pattern", x: 0, y: 0, src: await h(a(`esri/symbols/patterns/${a2}.png`), s4.toCss(true)), width: 5, height: 5 };
}
function W(e2) {
  return e2.outline ? I(e2) : { color: "rgba(0, 0, 0, 1)", width: 1.5 };
}
function $(e2, t2) {
  const s4 = H(e2);
  if (!s4)
    return null;
  let a2 = "rgba(";
  return a2 += h3(s4.r, t2) + ",", a2 += h3(s4.g, t2) + ",", a2 += h3(s4.b, t2) + ",", a2 + s4.a + ");";
}
function A(e2, t2) {
  const s4 = $(e2, t2);
  if (!s4)
    return {};
  if ("pattern" in e2 && null != e2.pattern && "style" === e2.pattern.type && "none" === e2.pattern.style)
    return null;
  return { color: s4, width: Math.min(e2.size ? u2(e2.size) : 0.75, C), style: "pattern" in e2 && null != e2.pattern && "style" === e2.pattern.type ? d2(e2.pattern.style) : null, cap: "cap" in e2 ? e2.cap : null, join: "join" in e2 ? "miter" === e2.join ? u2(2) : e2.join : null };
}
function B(e2, t2, s4) {
  const a2 = null != s4 ? 0.75 * s4 : 0;
  return { type: "linear", x1: a2 ? 0.25 * a2 : 0, y1: a2 ? 0.5 * a2 : 0, x2: a2 || 4, y2: a2 ? 0.5 * a2 : 4, colors: [{ color: e2, offset: 0 }, { color: t2, offset: 1 }] };
}
function F(e2) {
  const t2 = e2.depth, s4 = e2.height, a2 = e2.width;
  return 0 !== a2 && 0 !== t2 && 0 !== s4 && a2 === t2 && null != a2 && null != s4 && a2 < s4;
}
function G(e2, t2, s4) {
  const a2 = [];
  if (!e2)
    return a2;
  switch (e2.type) {
    case "icon": {
      const s5 = 0, l3 = 0, r = t2, n2 = t2;
      switch (e2.resource && e2.resource.primitive || j2) {
        case "circle":
          a2.push({ shape: { type: "circle", cx: 0, cy: 0, r: 0.5 * t2 }, fill: N(e2, 0), stroke: I(e2) });
          break;
        case "square":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, n2] }, { command: "L", values: [s5, l3] }, { command: "L", values: [r, l3] }, { command: "L", values: [r, n2] }, { command: "Z", values: [] }] }, fill: N(e2, 0), stroke: I(e2) });
          break;
        case "triangle":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, n2] }, { command: "L", values: [0.5 * r, l3] }, { command: "L", values: [r, n2] }, { command: "Z", values: [] }] }, fill: N(e2, 0), stroke: I(e2) });
          break;
        case "cross":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [0.5 * r, l3] }, { command: "L", values: [0.5 * r, n2] }, { command: "M", values: [s5, 0.5 * n2] }, { command: "L", values: [r, 0.5 * n2] }] }, stroke: W(e2) });
          break;
        case "x":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, l3] }, { command: "L", values: [r, n2] }, { command: "M", values: [r, l3] }, { command: "L", values: [s5, n2] }] }, stroke: W(e2) });
          break;
        case "kite":
          a2.push({ shape: { type: "path", path: [{ command: "M", values: [s5, 0.5 * n2] }, { command: "L", values: [0.5 * r, l3] }, { command: "L", values: [r, 0.5 * n2] }, { command: "L", values: [0.5 * r, n2] }, { command: "Z", values: [] }] }, fill: N(e2, 0), stroke: I(e2) });
      }
      break;
    }
    case "object":
      switch (e2.resource && e2.resource.primitive || d) {
        case "cone": {
          const l3 = B(N(e2, 0), N(e2, -0.6), s4 ? E : t2), r = l(t2, s4);
          a2.push({ shape: r[0], fill: l3 }), a2.push({ shape: r[1], fill: l3 });
          break;
        }
        case "inverted-cone": {
          const s5 = N(e2, 0), l3 = B(s5, N(e2, -0.6), t2), r = o(t2);
          a2.push({ shape: r[0], fill: l3 }), a2.push({ shape: r[1], fill: s5 });
          break;
        }
        case "cube": {
          const l3 = p3(t2, s4);
          a2.push({ shape: l3[0], fill: N(e2, 0) }), a2.push({ shape: l3[1], fill: N(e2, -0.3) }), a2.push({ shape: l3[2], fill: N(e2, -0.5) });
          break;
        }
        case "cylinder": {
          const l3 = B(N(e2, 0), N(e2, -0.6), s4 ? E : t2), r = L(t2, s4);
          a2.push({ shape: r[0], fill: l3 }), a2.push({ shape: r[1], fill: l3 }), a2.push({ shape: r[2], fill: N(e2, 0) });
          break;
        }
        case "diamond": {
          const s5 = s3(t2);
          a2.push({ shape: s5[0], fill: N(e2, -0.3) }), a2.push({ shape: s5[1], fill: N(e2, 0) }), a2.push({ shape: s5[2], fill: N(e2, -0.3) }), a2.push({ shape: s5[3], fill: N(e2, -0.7) });
          break;
        }
        case "sphere": {
          const s5 = B(N(e2, 0), N(e2, -0.6));
          s5.x1 = 0, s5.y1 = 0, s5.x2 = 0.25 * t2, s5.y2 = 0.25 * t2, a2.push({ shape: { type: "circle", cx: 0, cy: 0, r: 0.5 * t2 }, fill: s5 });
          break;
        }
        case "tetrahedron": {
          const s5 = u3(t2);
          a2.push({ shape: s5[0], fill: N(e2, -0.3) }), a2.push({ shape: s5[1], fill: N(e2, 0) }), a2.push({ shape: s5[2], fill: N(e2, -0.6) });
          break;
        }
      }
      break;
  }
  return a2;
}
function J(e2) {
  const t2 = "number" == typeof (e2 == null ? void 0 : e2.size) ? e2 == null ? void 0 : e2.size : null;
  return t2 ? u2(t2) : null;
}
function K(e2) {
  return "icon" === e2.type ? "multiply" : "tint";
}
function Q(e2, t2) {
  const s4 = J(t2), a2 = (t2 == null ? void 0 : t2.maxSize) ? u2(t2.maxSize) : null, r = (t2 == null ? void 0 : t2.disableUpsampling) ?? false, i = e2.symbolLayers, c2 = [];
  let p4 = 0, u4 = 0;
  const h4 = i.at(-1);
  let m2;
  return h4 && "icon" === h4.type && (m2 = h4.size && u2(h4.size)), i.forEach((l3) => {
    var _a;
    if ("icon" !== l3.type && "object" !== l3.type)
      return;
    const n2 = "icon" === l3.type ? l3.size && u2(l3.size) : 0, i2 = s4 || n2 ? Math.ceil(Math.min(s4 || n2, a2 || O)) : D;
    if (l3 && l3.resource && l3.resource.href) {
      const t3 = Z(e2, l3).then((e3) => {
        const t4 = l3.get("material.color"), s5 = K(l3);
        return d3(e3, i2, t4, s5, r);
      }).then((e3) => {
        const t4 = e3.width, s5 = e3.height;
        return p4 = Math.max(p4, t4), u4 = Math.max(u4, s5), [{ shape: { type: "image", x: 0, y: 0, width: t4, height: s5, src: e3.url }, fill: null, stroke: null }];
      });
      c2.push(t3);
    } else {
      let e3 = i2;
      "icon" === l3.type && m2 && s4 && (e3 = i2 * (n2 / m2));
      const a3 = "tall" === (t2 == null ? void 0 : t2.symbolConfig) || ((_a = t2 == null ? void 0 : t2.symbolConfig) == null ? void 0 : _a.isTall) || "object" === l3.type && F(l3);
      p4 = Math.max(p4, a3 ? E : e3), u4 = Math.max(u4, e3), c2.push(Promise.resolve(G(l3, e3, a3)));
    }
  }), j(c2).then((e3) => {
    const s5 = [];
    return e3.forEach((e4) => {
      e4.value ? s5.push(e4.value) : e4.error && s.getLogger("esri.symbols.support.previewSymbol3D").warn("error while building swatchInfo!", e4.error);
    }), l2(s5, [p4, u4], { node: t2 && t2.node, scale: false, opacity: t2 && t2.opacity, ariaLabel: t2 == null ? void 0 : t2.ariaLabel });
  });
}
function V(e2, t2) {
  const s4 = e2.symbolLayers, a2 = [], l3 = p2(e2), r = J(t2), n2 = (t2 && t2.maxSize ? u2(t2.maxSize) : null) || C;
  let i, c2 = 0, p4 = 0;
  return s4.forEach((e3, t3) => {
    if (!e3)
      return;
    if ("line" !== e3.type && "path" !== e3.type)
      return;
    const s5 = [];
    switch (e3.type) {
      case "line": {
        const a3 = A(e3, 0);
        if (null == a3)
          break;
        const l4 = a3 && a3.width || 0;
        0 === t3 && (i = l4);
        const o2 = Math.min(r || l4, n2), u4 = 0 === t3 ? o2 : r ? o2 * (l4 / i) : o2, h4 = u4 > R / 2 ? 2 * u4 : R;
        p4 = Math.max(p4, u4), c2 = Math.max(c2, h4), a3.width = u4, s5.push({ shape: { type: "path", path: [{ command: "M", values: [0, 0.5 * p4] }, { command: "L", values: [c2, 0.5 * p4] }] }, stroke: a3 });
        break;
      }
      case "path": {
        const t4 = Math.min(r || D, n2), a3 = N(e3, 0), l4 = N(e3, -0.2), o2 = $(e3, -0.4), i2 = o2 ? { color: o2, width: 1 } : {};
        if ("quad" === e3.profile) {
          const t5 = e3.width, r2 = e3.height, n3 = m(t5 && r2 ? t5 / r2 : 1, 0 === r2, 0 === t5), o3 = { ...i2, join: "bevel" };
          s5.push({ shape: n3[0], fill: l4, stroke: o3 }), s5.push({ shape: n3[1], fill: l4, stroke: o3 }), s5.push({ shape: n3[2], fill: a3, stroke: o3 });
        } else
          s5.push({ shape: e.pathSymbol3DLayer[0], fill: l4, stroke: i2 }), s5.push({ shape: e.pathSymbol3DLayer[1], fill: a3, stroke: i2 });
        p4 = Math.max(p4, t4), c2 = p4;
      }
    }
    a2.push(s5);
  }), Promise.resolve(l2(a2, [c2, p4], { node: t2 && t2.node, scale: l3, opacity: t2 && t2.opacity, ariaLabel: t2 == null ? void 0 : t2.ariaLabel }));
}
async function X(e2, t2) {
  const s4 = "mesh-3d" === e2.type, a2 = e2.symbolLayers, l3 = J(t2), n2 = t2 && t2.maxSize ? u2(t2.maxSize) : null, i = l3 || D, c2 = [];
  let p4 = 0, u4 = 0, h4 = false;
  for (let o2 = 0; o2 < a2.length; o2++) {
    const e3 = a2.at(o2), t3 = [];
    if (s4 && "fill" !== e3.type)
      continue;
    const l4 = e.fill[0];
    switch (e3.type) {
      case "fill": {
        const a3 = I(e3), r = Math.min(i, n2 || O);
        p4 = Math.max(p4, r), u4 = Math.max(u4, r), h4 = true;
        let o3 = N(e3, 0);
        const c3 = "pattern" in e3 ? e3.pattern : null, m2 = H(e3);
        !s4 && null != c3 && "style" === c3.type && "solid" !== c3.style && m2 && (o3 = await T(c3, m2)), t3.push({ shape: l4, fill: o3, stroke: a3 });
        break;
      }
      case "line": {
        const s5 = A(e3, 0);
        if (null == s5)
          break;
        const a3 = { stroke: s5, shape: l4 };
        p4 = Math.max(p4, D), u4 = Math.max(u4, D), t3.push(a3);
        break;
      }
      case "extrude": {
        const s5 = { join: "round", width: 1, ...A(e3, -0.4) }, a3 = N(e3, 0), l5 = N(e3, -0.2), r = Math.min(i, n2 || O), o3 = c(r);
        s5.width = 1, t3.push({ shape: o3[0], fill: l5, stroke: s5 }), t3.push({ shape: o3[1], fill: l5, stroke: s5 }), t3.push({ shape: o3[2], fill: a3, stroke: s5 });
        const c3 = D, h5 = 0.7 * D + 0.5 * r;
        p4 = Math.max(p4, c3), u4 = Math.max(u4, h5);
        break;
      }
      case "water": {
        const s5 = u(H(e3)), a3 = q(s5), l5 = q(s5, 2), o3 = q(s5, 3), c3 = n();
        h4 = true, t3.push({ shape: c3[0], fill: a3 }), t3.push({ shape: c3[1], fill: l5 }), t3.push({ shape: c3[2], fill: o3 });
        const m2 = Math.min(i, n2 || O);
        p4 = Math.max(p4, m2), u4 = Math.max(u4, m2);
        break;
      }
    }
    c2.push(t3);
  }
  return l2(c2, [p4, u4], { node: t2 && t2.node, scale: h4, opacity: t2 && t2.opacity, ariaLabel: t2 == null ? void 0 : t2.ariaLabel });
}
function Y(e2, t2) {
  if (0 === e2.symbolLayers.length)
    return Promise.reject(new s2("symbolPreview: renderPreviewHTML3D", "No symbolLayers in the symbol."));
  switch (e2.type) {
    case "point-3d":
      return Q(e2, t2);
    case "line-3d":
      return V(e2, t2);
    case "polygon-3d":
    case "mesh-3d":
      return X(e2, t2);
  }
  return Promise.reject(new s2("symbolPreview: swatchInfo3D", "symbol not supported."));
}

export {
  N,
  T,
  J,
  Y
};
//# sourceMappingURL=chunk-IZITEQY4.js.map
