import {
  l
} from "./chunk-R2HXL6HT.js";
import {
  e
} from "./chunk-2PAQQUAG.js";
import {
  b
} from "./chunk-X4Y5OF5X.js";
import {
  E,
  i
} from "./chunk-5HAVROZG.js";

// node_modules/@arcgis/core/views/2d/tiling/TileCache.js
var t = class {
  constructor(e2, t2, i3) {
    this.maxSize = e2, this._tileInfoView = t2, this._removedFunc = i3, this._tilePerId = /* @__PURE__ */ new Map(), this._tileKeysPerLevel = [];
  }
  clear() {
    this._tilePerId.clear(), this._tileKeysPerLevel = [];
  }
  has(e2) {
    return this._tilePerId.has(e2);
  }
  get(e2) {
    return this._tilePerId.get(e2);
  }
  pop(e2) {
    const t2 = this._tilePerId.get(e2);
    if (!t2)
      return;
    const r2 = t2.key.level, s = this._tileKeysPerLevel[r2];
    i2(this._tilePerId, e2);
    for (let i3 = 0; i3 < s.length; i3++)
      if (s[i3].id === e2) {
        s.splice(i3, 1);
        break;
      }
    return t2.visible = true, t2;
  }
  add(e2) {
    e2.visible = false;
    const t2 = e2.key, i3 = t2.id;
    if (this._tilePerId.has(i3))
      return;
    this._tilePerId.set(i3, e2);
    const r2 = t2.level;
    this._tileKeysPerLevel[r2] || (this._tileKeysPerLevel[r2] = []), this._tileKeysPerLevel[r2].push(t2);
  }
  prune(e2, t2, i3) {
    let r2 = this._tilePerId.size;
    if (r2 <= this.maxSize)
      return;
    let s = this._tileKeysPerLevel.length - 1;
    for (; r2 > this.maxSize && s >= 0; )
      s !== e2 && (r2 = this._pruneAroundCenterTile(r2, t2, i3, s)), s--;
    r2 > this.maxSize && (r2 = this._pruneAroundCenterTile(r2, t2, i3, e2));
  }
  _pruneAroundCenterTile(t2, i3, r2, s) {
    const l2 = this._tileKeysPerLevel[s];
    if (!l2 || 0 === l2.length)
      return t2;
    const { size: n, origin: h2 } = this._tileInfoView.tileInfo, o2 = r2 * n[0], _ = r2 * n[1], d = [0, 0], u = [0, 0];
    for (l2.sort((t3, r3) => (d[0] = h2.x + o2 * (t3.col + 0.5), d[1] = h2.y - _ * (t3.row + 0.5), u[0] = h2.x + o2 * (r3.col + 0.5), u[1] = h2.y - _ * (r3.row + 0.5), b(d, i3) - b(u, i3))); l2.length > 0; ) {
      const e2 = l2.pop();
      if (this._removeTile(e2.id), --t2 === this.maxSize)
        break;
    }
    return t2;
  }
  _removeTile(e2) {
    const t2 = this._tilePerId.get(e2);
    this._removedFunc && t2 && this._removedFunc(t2), i2(this._tilePerId, e2);
  }
};
function i2(e2, t2) {
  e2.delete(t2);
}

// node_modules/@arcgis/core/views/2d/tiling/TileStrategy.js
var o = new e(0, 0, 0, 0);
var h = /* @__PURE__ */ new Map();
var a = [];
var c = [];
var r = class {
  constructor(e2) {
    this._previousScale = Number.POSITIVE_INFINITY, this.cachePolicy = "keep", this.coveragePolicy = "closest", this.resampling = true, this.tileIndex = /* @__PURE__ */ new Map(), this.tiles = [], this.buffer = 192, this.acquireTile = e2.acquireTile, this.releaseTile = e2.releaseTile, this.tileInfoView = e2.tileInfoView, null != e2.resampling && (this.resampling = e2.resampling), e2.cachePolicy && (this.cachePolicy = e2.cachePolicy), e2.coveragePolicy && (this.coveragePolicy = e2.coveragePolicy), null != e2.buffer && (this.buffer = e2.buffer), e2.cacheSize && (this._tileCache = new t(e2.cacheSize, this.tileInfoView, (e3) => {
      this.releaseTile(e3);
    }));
  }
  destroy() {
    this.tileIndex.clear();
  }
  update(e2) {
    var _a, _b;
    const { resampling: i3, tileIndex: t2 } = this, { scale: l2, center: r2, resolution: n } = e2.state, { minScale: f, maxScale: d } = this.tileInfoView, u = !e2.stationary && l2 > this._previousScale;
    if (this._previousScale = l2, !i3 && (l2 > f || l2 < d))
      return this.tiles.length = 0, void this.clear();
    const p = this.tileInfoView.getTileCoverage(e2.state, this.buffer, this.resampling, this.coveragePolicy);
    if (!p)
      return this.tiles.length = 0, void this.clear();
    const { spans: y, lodInfo: g } = p, { level: I } = g;
    this.tiles.length = 0, t2.forEach((e3) => e3.visible = true);
    let v = 0, m = 0;
    if (y.length > 0)
      for (const { row: s, colFrom: a2, colTo: c2 } of y)
        for (let e3 = a2; e3 <= c2; e3++) {
          v++;
          const i4 = o.set(I, s, g.normalizeCol(e3), g.getWorldForColumn(e3)).id;
          let l3 = t2.get(i4);
          if (l3)
            l3.isReady ? (h.set(i4, l3), m++) : u || this._addParentTile(i4, h);
          else {
            if ((_a = this._tileCache) == null ? void 0 : _a.has(i4)) {
              if (l3 = this._tileCache.pop(i4), this.tileIndex.set(i4, l3), l3.isReady) {
                h.set(i4, l3), m++;
                continue;
              }
            } else
              l3 = this.acquireTile(o), this.tileIndex.set(i4, l3);
            u || this._addParentTile(i4, h);
          }
        }
    const T = m === v;
    for (const [s, _] of t2) {
      if (h.has(s))
        continue;
      o.set(s);
      const e3 = this.tileInfoView.intersects(p, o), i4 = "purge" === this.cachePolicy ? o.level !== I : o.level > I;
      !e3 || !u && T ? !i4 && e3 || a.push(_) : _.isReady ? i4 && "purge" === this.cachePolicy && this._hasReadyAncestor(o, I) ? a.push(_) : c.push(_) : i4 && a.push(_);
    }
    for (const s of c)
      s.isReady && h.set(s.key.id, s);
    for (const s of a)
      this._tileCache ? this._tileCache.add(s) : this.releaseTile(s), t2.delete(s.key.id);
    for (const s of h.values())
      this.tiles.push(s);
    for (const s of t2.values())
      h.has(s.key.id) || (s.visible = false);
    (_b = this._tileCache) == null ? void 0 : _b.prune(I, r2, n), l.pool.release(p), c.length = 0, a.length = 0, h.clear();
  }
  clear() {
    const { tileIndex: e2 } = this;
    for (const i3 of e2.values())
      this.releaseTile(i3);
    e2.clear();
  }
  refresh(e2) {
    var _a;
    for (const i3 of this.tileIndex.values())
      this.tiles.includes(i3) ? e2(i3) : a.push(i3);
    for (const i3 of a)
      this.releaseTile(i3), this.tileIndex.delete(i3.key.id);
    (_a = this._tileCache) == null ? void 0 : _a.clear();
  }
  updateCacheSize(e2) {
    this._tileCache && (this._tileCache.maxSize = e2);
  }
  _addParentTile(e2, i3) {
    var _a;
    let t2 = e2, s = null;
    for (; t2 = this.tileInfoView.getTileParentId(t2), t2; )
      if (this.tileIndex.has(t2)) {
        if (s = this.tileIndex.get(t2), s == null ? void 0 : s.isReady) {
          i3.has(s.key.id) || i3.set(s.key.id, s);
          break;
        }
      } else if (((_a = this._tileCache) == null ? void 0 : _a.has(t2)) && (s = this._tileCache.pop(t2), this.tileIndex.set(t2, s), s == null ? void 0 : s.isReady)) {
        i3.has(s.key.id) || i3.set(s.key.id, s);
        break;
      }
  }
  _hasReadyAncestor(t2, s) {
    const l2 = i();
    this.tileInfoView.getTileBounds(l2, t2, true);
    for (const o2 of this.tileIndex.values())
      if (o2.isReady && o2.key.level >= s && o2.key.level < t2.level) {
        const t3 = i();
        if (this.tileInfoView.getTileBounds(t3, o2.key, true), E(t3, l2))
          return true;
      }
    return false;
  }
};

export {
  r
};
//# sourceMappingURL=chunk-4YNW7QZY.js.map
