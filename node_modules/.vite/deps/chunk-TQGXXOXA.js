import {
  f,
  l,
  m,
  s,
  u
} from "./chunk-T4XWQYGC.js";

// node_modules/@arcgis/core/geometry/support/quantizationUtils.js
var i = (n, t, e) => [t, e];
var o = (n, t, e) => [t, e, n[2]];
var a = (n, t, e) => [t, e, n[2], n[3]];
function m2(n) {
  if (!n)
    return null;
  return { originPosition: "upper-left" === n.originPosition ? "upperLeft" : "lower-left" === n.originPosition ? "lowerLeft" : n.originPosition, scale: n.tolerance ? [n.tolerance, n.tolerance] : [1, 1], translate: null != n.extent ? [n.extent.xmin, n.extent.ymax] : [0, 0] };
}
function s2({ scale: n, translate: t }, e) {
  return Math.round((e - t[0]) / n[0]);
}
function f2({ scale: n, translate: t }, e) {
  return Math.round((t[1] - e) / n[1]);
}
function x(n, t, e) {
  const r = [];
  let u2, l2, i2, o2;
  for (let a2 = 0; a2 < e.length; a2++) {
    const m3 = e[a2];
    a2 > 0 ? (i2 = s2(n, m3[0]), o2 = f2(n, m3[1]), i2 === u2 && o2 === l2 || (r.push(t(m3, i2 - u2, o2 - l2)), u2 = i2, l2 = o2)) : (u2 = s2(n, m3[0]), l2 = f2(n, m3[1]), r.push(t(m3, u2, l2)));
  }
  return r.length > 0 ? r : null;
}
function I(n, t, e, r) {
  return x(n, e ? r ? a : o : r ? o : i, t);
}
function g(n, t, e, r) {
  const u2 = [], l2 = e ? r ? a : o : r ? o : i;
  for (let i2 = 0; i2 < t.length; i2++) {
    const e2 = x(n, l2, t[i2]);
    e2 && e2.length >= 3 && u2.push(e2);
  }
  return u2.length ? u2 : null;
}
function N(n, t, e, r) {
  const u2 = [], l2 = e ? r ? a : o : r ? o : i;
  for (let i2 = 0; i2 < t.length; i2++) {
    const e2 = x(n, l2, t[i2]);
    e2 && e2.length >= 2 && u2.push(e2);
  }
  return u2.length ? u2 : null;
}
function p({ scale: n, translate: t }, e) {
  return e * n[0] + t[0];
}
function y({ scale: n, translate: t }, e) {
  return t[1] - e * n[1];
}
function z(n, t, e) {
  const r = new Array(e.length);
  if (!e.length)
    return r;
  const [u2, l2] = n.scale;
  let i2 = p(n, e[0][0]), o2 = y(n, e[0][1]);
  r[0] = t(e[0], i2, o2);
  for (let a2 = 1; a2 < e.length; a2++) {
    const n2 = e[a2];
    i2 += n2[0] * u2, o2 -= n2[1] * l2, r[a2] = t(n2, i2, o2);
  }
  return r;
}
function T(n, t, e) {
  const r = new Array(e.length);
  for (let u2 = 0; u2 < e.length; u2++)
    r[u2] = z(n, t, e[u2]);
  return r;
}
function E(n, t, e, r) {
  return z(n, e ? r ? a : o : r ? o : i, t);
}
function P(n, t, e, r) {
  return T(n, e ? r ? a : o : r ? o : i, t);
}
function b(n, t, e, r) {
  return T(n, e ? r ? a : o : r ? o : i, t);
}
function w(n, t, e, r, u2) {
  return t.xmin = s2(n, e.xmin), t.ymin = f2(n, e.ymin), t.xmax = s2(n, e.xmax), t.ymax = f2(n, e.ymax), t !== e && (r && (t.zmin = e.zmin, t.zmax = e.zmax), u2 && (t.mmin = e.mmin, t.mmax = e.mmax)), t;
}
function G(n, t, e, r, u2) {
  return t.points = I(n, e.points, r, u2) ?? [], t;
}
function L(n, t, e, r, u2) {
  return t.x = s2(n, e.x), t.y = f2(n, e.y), t !== e && (r && (t.z = e.z), u2 && (t.m = e.m)), t;
}
function O(n, t, e, r, u2) {
  const l2 = g(n, e.rings, r, u2);
  return l2 ? (t.rings = l2, t) : null;
}
function S(n, t, e, r, u2) {
  const l2 = N(n, e.paths, r, u2);
  return l2 ? (t.paths = l2, t) : null;
}
function d(l2, i2) {
  return l2 && i2 ? l(i2) ? L(l2, {}, i2, false, false) : s(i2) ? S(l2, {}, i2, false, false) : f(i2) ? O(l2, {}, i2, false, false) : u(i2) ? G(l2, {}, i2, false, false) : m(i2) ? w(l2, {}, i2, false, false) : null : null;
}
function U(n, t, e, r, u2) {
  return null != e && (t.points = E(n, e.points, r, u2)), t;
}
function k(n, t, e, r, u2) {
  return null == e || (t.x = p(n, e.x), t.y = y(n, e.y), t !== e && (r && (t.z = e.z), u2 && (t.m = e.m))), t;
}
function q(n, t, e, r, u2) {
  return null != e && (t.rings = b(n, e.rings, r, u2)), t;
}
function v(n, t, e, r, u2) {
  return null != e && (t.paths = P(n, e.paths, r, u2)), t;
}

export {
  m2 as m,
  L,
  d,
  U,
  k,
  q,
  v
};
//# sourceMappingURL=chunk-TQGXXOXA.js.map
