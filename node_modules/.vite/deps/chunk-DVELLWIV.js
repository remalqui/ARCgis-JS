import {
  n as n2,
  o,
  r as r4,
  t as t2
} from "./chunk-OP5PHDH5.js";
import {
  r as r3
} from "./chunk-6ETVGJDF.js";
import {
  i as i3,
  y
} from "./chunk-L7P4URYM.js";
import {
  C,
  D,
  E as E2,
  L as L2
} from "./chunk-BCDDCNQ2.js";
import {
  x as x2
} from "./chunk-2CQBXY7G.js";
import {
  e as e2
} from "./chunk-AEPMR2T7.js";
import {
  e as e3
} from "./chunk-GXWNOUDM.js";
import {
  e,
  r as r2
} from "./chunk-AYMF6OMA.js";
import {
  A,
  B,
  E,
  F,
  L,
  O,
  V,
  c as c2,
  d,
  g,
  i as i2,
  q,
  u,
  w,
  x
} from "./chunk-FJXAEGHD.js";
import {
  b,
  c,
  f as f2,
  i,
  p
} from "./chunk-KTSEQWMB.js";
import {
  n
} from "./chunk-4CZO65BK.js";
import {
  _
} from "./chunk-UKJF25H6.js";
import {
  r
} from "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  _ as _2,
  nt,
  ot,
  tt
} from "./chunk-O3CHVGVF.js";
import {
  P,
  f,
  s as s4
} from "./chunk-HNHXEGH2.js";
import {
  s2,
  s3
} from "./chunk-W2N7YT6I.js";
import {
  U,
  h2 as h,
  l,
  s2 as s,
  t2 as t
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/chunks/vec42.js
function t3(t9, r8, f7) {
  if (t9.count !== r8.count)
    return void e3.error("source and destination buffers need to have the same number of elements");
  const n7 = t9.count, o8 = f7[0], u6 = f7[1], s7 = f7[2], d3 = f7[3], a2 = f7[4], i7 = f7[5], c5 = f7[6], p3 = f7[7], l6 = f7[8], m3 = f7[9], y2 = f7[10], B2 = f7[11], h2 = f7[12], S = f7[13], b2 = f7[14], g2 = f7[15], M = t9.typedBuffer, v = t9.typedBufferStride, _3 = r8.typedBuffer, j2 = r8.typedBufferStride;
  for (let e7 = 0; e7 < n7; e7++) {
    const t10 = e7 * v, r9 = e7 * j2, f8 = _3[r9], n8 = _3[r9 + 1], w2 = _3[r9 + 2], z2 = _3[r9 + 3];
    M[t10] = o8 * f8 + a2 * n8 + l6 * w2 + h2 * z2, M[t10 + 1] = u6 * f8 + i7 * n8 + m3 * w2 + S * z2, M[t10 + 2] = s7 * f8 + c5 * n8 + y2 * w2 + b2 * z2, M[t10 + 3] = d3 * f8 + p3 * n8 + B2 * w2 + g2 * z2;
  }
}
function r5(e7, t9, r8) {
  f3(e7.typedBuffer, t9.typedBuffer, r8, e7.typedBufferStride, t9.typedBufferStride);
}
function f3(t9, r8, f7, n7 = 4, o8 = n7) {
  if (t9.length / n7 != r8.length / o8)
    return void e3.error("source and destination buffers need to have the same number of elements");
  const u6 = t9.length / n7, s7 = f7[0], d3 = f7[1], a2 = f7[2], i7 = f7[3], c5 = f7[4], p3 = f7[5], l6 = f7[6], m3 = f7[7], y2 = f7[8];
  let B2 = 0, h2 = 0;
  for (let e7 = 0; e7 < u6; e7++) {
    const e8 = r8[B2], f8 = r8[B2 + 1], u7 = r8[B2 + 2], S = r8[B2 + 3];
    t9[h2] = s7 * e8 + i7 * f8 + l6 * u7, t9[h2 + 1] = d3 * e8 + c5 * f8 + m3 * u7, t9[h2 + 2] = a2 * e8 + p3 * f8 + y2 * u7, t9[h2 + 3] = S, B2 += o8, h2 += n7;
  }
}
function n3(e7, t9) {
  const r8 = Math.min(e7.count, t9.count), f7 = e7.typedBuffer, n7 = e7.typedBufferStride, o8 = t9.typedBuffer, u6 = t9.typedBufferStride;
  for (let s7 = 0; s7 < r8; s7++) {
    const e8 = s7 * n7, t10 = s7 * u6, r9 = o8[t10], d3 = o8[t10 + 1], a2 = o8[t10 + 2], i7 = r9 * r9 + d3 * d3 + a2 * a2;
    if (i7 > 0) {
      const t11 = 1 / Math.sqrt(i7);
      f7[e8] = t11 * r9, f7[e8 + 1] = t11 * d3, f7[e8 + 2] = t11 * a2;
    }
  }
}
function o2(e7, t9, r8) {
  u2(e7.typedBuffer, t9, r8, e7.typedBufferStride);
}
function u2(e7, t9, r8, f7 = 4) {
  const n7 = Math.min(e7.length / f7, t9.count), o8 = t9.typedBuffer, u6 = t9.typedBufferStride;
  let s7 = 0, d3 = 0;
  for (let a2 = 0; a2 < n7; a2++)
    e7[d3] = r8 * o8[s7], e7[d3 + 1] = r8 * o8[s7 + 1], e7[d3 + 2] = r8 * o8[s7 + 2], e7[d3 + 3] = r8 * o8[s7 + 3], s7 += u6, d3 += f7;
}
var s5 = Object.freeze(Object.defineProperty({ __proto__: null, normalize: n3, scale: u2, scaleView: o2, transformMat3: f3, transformMat3View: r5, transformMat4: t3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec22.js
function o3(e7, t9) {
  n4(e7.typedBuffer, t9.typedBuffer, e7.typedBufferStride, t9.typedBufferStride);
}
function n4(o8, n7, l6 = 2, u6 = l6) {
  const i7 = n7.length / 2;
  let a2 = 0, d3 = 0;
  if (s(n7) || U(n7)) {
    for (let e7 = 0; e7 < i7; ++e7)
      o8[a2] = n7[d3], o8[a2 + 1] = n7[d3 + 1], a2 += l6, d3 += u6;
    return;
  }
  const c5 = h(n7);
  if (l(n7))
    for (let e7 = 0; e7 < i7; ++e7)
      o8[a2] = Math.max(n7[d3] / c5, -1), o8[a2 + 1] = Math.max(n7[d3 + 1] / c5, -1), a2 += l6, d3 += u6;
  else
    for (let e7 = 0; e7 < i7; ++e7)
      o8[a2] = n7[d3] / c5, o8[a2 + 1] = n7[d3 + 1] / c5, a2 += l6, d3 += u6;
}
function l2(e7, t9, r8, f7) {
  const o8 = e7.typedBuffer, n7 = e7.typedBufferStride, l6 = (f7 == null ? void 0 : f7.count) ?? e7.count;
  let u6 = ((f7 == null ? void 0 : f7.dstIndex) ?? 0) * n7;
  for (let i7 = 0; i7 < l6; ++i7)
    o8[u6] = t9, o8[u6 + 1] = r8, u6 += n7;
}
var u3 = Object.freeze(Object.defineProperty({ __proto__: null, fill: l2, normalizeIntegerBuffer: n4, normalizeIntegerBufferView: o3 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec33.js
function e4(e7, f7) {
  t4(e7.typedBuffer, f7.typedBuffer, e7.typedBufferStride, f7.typedBufferStride);
}
function t4(e7, t9, f7 = 3, o8 = f7) {
  const r8 = t9.length / o8;
  let n7 = 0, u6 = 0;
  for (let c5 = 0; c5 < r8; ++c5)
    e7[n7] = t9[u6], e7[n7 + 1] = t9[u6 + 1], e7[n7 + 2] = t9[u6 + 2], n7 += f7, u6 += o8;
}
function f4(e7, t9, f7, o8, r8) {
  const n7 = e7.typedBuffer, u6 = e7.typedBufferStride, c5 = (r8 == null ? void 0 : r8.count) ?? e7.count;
  let d3 = ((r8 == null ? void 0 : r8.dstIndex) ?? 0) * u6;
  for (let l6 = 0; l6 < c5; ++l6)
    n7[d3] = t9, n7[d3 + 1] = f7, n7[d3 + 2] = o8, d3 += u6;
}
var o4 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t4, copyView: e4, fill: f4 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/vec43.js
function e5(e7, f7) {
  t5(e7.typedBuffer, f7, e7.typedBufferStride);
}
function t5(e7, t9, f7 = 4) {
  const o8 = t9.typedBuffer, r8 = t9.typedBufferStride, n7 = t9.count;
  let u6 = 0, c5 = 0;
  for (let d3 = 0; d3 < n7; ++d3)
    e7[u6] = o8[c5], e7[u6 + 1] = o8[c5 + 1], e7[u6 + 2] = o8[c5 + 2], e7[u6 + 3] = o8[c5 + 3], u6 += f7, c5 += r8;
}
function f5(e7, t9, f7, o8, r8, n7) {
  const u6 = e7.typedBuffer, c5 = e7.typedBufferStride, d3 = (n7 == null ? void 0 : n7.count) ?? e7.count;
  let l6 = ((n7 == null ? void 0 : n7.dstIndex) ?? 0) * c5;
  for (let p3 = 0; p3 < d3; ++p3)
    u6[l6] = t9, u6[l6 + 1] = f7, u6[l6 + 2] = o8, u6[l6 + 3] = r8, l6 += c5;
}
var o5 = Object.freeze(Object.defineProperty({ __proto__: null, copy: t5, copyView: e5, fill: f5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/glTF/DefaultLoadingContext.js
var n5 = class {
  constructor(r8) {
    this._streamDataRequester = r8;
  }
  async loadJSON(r8, e7) {
    return this._load("json", r8, e7);
  }
  async loadBinary(r8, e7) {
    return tt(r8) ? (s4(e7), nt(r8)) : this._load("binary", r8, e7);
  }
  async loadImage(r8, e7) {
    return this._load("image", r8, e7);
  }
  async _load(a2, o8, i7) {
    if (null == this._streamDataRequester)
      return (await j(o8, { responseType: m[a2] })).data;
    const n7 = await _(this._streamDataRequester.request(o8, a2, i7));
    if (true === n7.ok)
      return n7.value;
    throw f(n7.error), new s3("", `Request for resource failed: ${n7.error}`);
  }
};
var m = { image: "image", binary: "array-buffer", json: "json", "image+type": void 0 };

// node_modules/@arcgis/core/views/3d/glTF/LoaderResult.js
function r6(e7 = {}) {
  return { color: [1, 1, 1], opacity: 1, alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false, castShadows: true, receiveShadows: true, receiveAmbientOcclustion: true, textureColor: null, textureNormal: null, textureOcclusion: null, textureEmissive: null, textureMetallicRoughness: null, colorTextureTransform: null, normalTextureTransform: null, occlusionTextureTransform: null, emissiveTextureTransform: null, metallicRoughnessTextureTransform: null, emissiveFactor: [0, 0, 0], metallicFactor: 1, roughnessFactor: 1, colorMixMode: "multiply", ...e7 };
}
function l3(r8, l6 = {}) {
  return { data: r8, parameters: { wrap: { s: D.REPEAT, t: D.REPEAT, ...l6.wrap }, noUnpackFlip: true, mipmap: false, ...l6 } };
}

// node_modules/@arcgis/core/chunks/scalar.js
function e6(e7, t9) {
  const o8 = e7.count;
  t9 || (t9 = new e7.TypedArrayConstructor(o8));
  for (let r8 = 0; r8 < o8; r8++)
    t9[r8] = e7.get(r8);
  return t9;
}
var t6 = Object.freeze(Object.defineProperty({ __proto__: null, makeDense: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/views/3d/glTF/internal/BinaryStreamReader.js
var t7 = class {
  constructor(t9) {
    this._data = t9, this._offset4 = 0, this._dataUint32 = new Uint32Array(this._data, 0, Math.floor(this._data.byteLength / 4));
  }
  readUint32() {
    const t9 = this._offset4;
    return this._offset4 += 1, this._dataUint32[t9];
  }
  readUint8Array(t9) {
    const s7 = 4 * this._offset4;
    return this._offset4 += t9 / 4, new Uint8Array(this._data, s7, t9);
  }
  remainingBytes() {
    return this._data.byteLength - 4 * this._offset4;
  }
};

// node_modules/@arcgis/core/views/3d/glTF/internal/enums.js
var A2;
var E3;
!function(A3) {
  A3.SCALAR = "SCALAR", A3.VEC2 = "VEC2", A3.VEC3 = "VEC3", A3.VEC4 = "VEC4", A3.MAT2 = "MAT2", A3.MAT3 = "MAT3", A3.MAT4 = "MAT4";
}(A2 || (A2 = {})), function(A3) {
  A3[A3.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", A3[A3.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(E3 || (E3 = {}));

// node_modules/@arcgis/core/views/3d/glTF/internal/fillDefaults.js
var t8 = { baseColorFactor: [1, 1, 1, 1], metallicFactor: 1, roughnessFactor: 1 };
var a = { pbrMetallicRoughness: t8, emissiveFactor: [0, 0, 0], alphaMode: "OPAQUE", alphaCutoff: 0.5, doubleSided: false };
var l4 = { ESRI_externalColorMixMode: "tint" };
var i4 = (e7 = {}) => {
  const o8 = { ...t8, ...e7.pbrMetallicRoughness }, r8 = s6({ ...l4, ...e7.extras });
  return { ...a, ...e7, pbrMetallicRoughness: o8, extras: r8 };
};
function s6(o8) {
  switch (o8.ESRI_externalColorMixMode) {
    case "multiply":
    case "tint":
    case "ignore":
    case "replace":
      break;
    default:
      n(o8.ESRI_externalColorMixMode), o8.ESRI_externalColorMixMode = "tint";
  }
  return o8;
}
var n6 = { magFilter: L2.LINEAR, minFilter: L2.LINEAR_MIPMAP_LINEAR, wrapS: D.REPEAT, wrapT: D.REPEAT };
var c3 = (e7) => ({ ...n6, ...e7 });

// node_modules/@arcgis/core/views/3d/glTF/internal/pathUtils.js
function r7(r8) {
  let e7, t9;
  return r8.replace(/^(.*\/)?([^/]*)$/, (r9, a2, i7) => (e7 = a2 || "", t9 = i7 || "", "")), { dirPart: e7, filePart: t9 };
}

// node_modules/@arcgis/core/views/3d/glTF/internal/Resource.js
var K = { MAGIC: 1179937895, CHUNK_TYPE_JSON: 1313821514, CHUNK_TYPE_BIN: 5130562, MIN_HEADER_LENGTH: 20 };
var Y = class _Y {
  constructor(t9, r8, o8, n7) {
    if (this._context = t9, this.uri = r8, this.json = o8, this._glbBuffer = n7, this._bufferLoaders = /* @__PURE__ */ new Map(), this._textureLoaders = /* @__PURE__ */ new Map(), this._textureCache = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._nodeParentMap = /* @__PURE__ */ new Map(), this._nodeTransformCache = /* @__PURE__ */ new Map(), this._supportedExtensions = ["KHR_texture_basisu"], this._baseUri = r7(this.uri).dirPart, this._checkVersionSupported(), this._checkRequiredExtensionsSupported(), null == o8.scenes)
      throw new s3("gltf-loader-unsupported-feature", "Scenes must be defined.");
    if (null == o8.meshes)
      throw new s3("gltf-loader-unsupported-feature", "Meshes must be defined");
    if (null == o8.nodes)
      throw new s3("gltf-loader-unsupported-feature", "Nodes must be defined.");
    this._computeNodeParents();
  }
  static async load(e7, t9, r8) {
    if (tt(t9)) {
      const r9 = ot(t9);
      if (r9 && "model/gltf-binary" !== r9.mediaType)
        try {
          const o10 = JSON.parse(r9.isBase64 ? atob(r9.data) : r9.data);
          return new _Y(e7, t9, o10);
        } catch {
        }
      const o9 = nt(t9);
      if (_Y._isGLBData(o9))
        return this._fromGLBData(e7, t9, o9);
    }
    if (t9.endsWith(".gltf")) {
      const o9 = await e7.loadJSON(t9, r8);
      return new _Y(e7, t9, o9);
    }
    const o8 = await e7.loadBinary(t9, r8);
    if (_Y._isGLBData(o8))
      return this._fromGLBData(e7, t9, o8);
    const i7 = await e7.loadJSON(t9, r8);
    return new _Y(e7, t9, i7);
  }
  static _isGLBData(e7) {
    if (null == e7)
      return false;
    const t9 = new t7(e7);
    return t9.remainingBytes() >= 4 && t9.readUint32() === K.MAGIC;
  }
  static async _fromGLBData(e7, t9, r8) {
    const o8 = await _Y._parseGLBData(r8);
    return new _Y(e7, t9, o8.json, o8.binaryData);
  }
  static async _parseGLBData(r8) {
    const o8 = new t7(r8);
    if (o8.remainingBytes() < 12)
      throw new s3("gltf-loader-error", "GLB binary data is insufficiently large.");
    const n7 = o8.readUint32(), s7 = o8.readUint32(), a2 = o8.readUint32();
    if (n7 !== K.MAGIC)
      throw new s3("gltf-loader-error", "Magic first 4 bytes do not fit to expected GLB value.");
    if (r8.byteLength < a2)
      throw new s3("gltf-loader-error", "GLB binary data is smaller than header specifies.");
    if (2 !== s7)
      throw new s3("gltf-loader-unsupported-feature", "An unsupported GLB container version was detected. Only version 2 is supported.");
    let i7, u6, f7 = 0;
    for (; o8.remainingBytes() >= 8; ) {
      const r9 = o8.readUint32(), n8 = o8.readUint32();
      if (0 === f7) {
        if (n8 !== K.CHUNK_TYPE_JSON)
          throw new s3("gltf-loader-error", "First GLB chunk must be JSON.");
        if (r9 < 0)
          throw new s3("gltf-loader-error", "No JSON data found.");
        i7 = await r4(o8.readUint8Array(r9));
      } else if (1 === f7) {
        if (n8 !== K.CHUNK_TYPE_BIN)
          throw new s3("gltf-loader-unsupported-feature", "Second GLB chunk expected to be BIN.");
        u6 = o8.readUint8Array(r9);
      } else
        s2.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] More than 2 GLB chunks detected. Skipping.");
      f7 += 1;
    }
    if (!i7)
      throw new s3("gltf-loader-error", "No GLB JSON chunk detected.");
    return { json: i7, binaryData: u6 };
  }
  async getBuffer(t9, r8) {
    const o8 = this.json.buffers[t9];
    if (null == o8.uri) {
      if (null == this._glbBuffer)
        throw new s3("gltf-loader-error", "GLB buffer not present");
      return this._glbBuffer;
    }
    const n7 = await this._getBufferLoader(t9, r8);
    if (n7.byteLength !== o8.byteLength)
      throw new s3("gltf-loader-error", "Buffer byte lengths should match.");
    return n7;
  }
  async _getBufferLoader(e7, t9) {
    const r8 = this._bufferLoaders.get(e7);
    if (r8)
      return r8;
    const o8 = this.json.buffers[e7].uri, n7 = this._context.loadBinary(this._resolveUri(o8), t9).then((e8) => new Uint8Array(e8));
    return this._bufferLoaders.set(e7, n7), n7;
  }
  async getAccessor(t9, r8) {
    if (!this.json.accessors)
      throw new s3("gltf-loader-unsupported-feature", "Accessors missing.");
    const o8 = this.json.accessors[t9];
    if (null == (o8 == null ? void 0 : o8.bufferView))
      throw new s3("gltf-loader-unsupported-feature", "Some accessor does not specify a bufferView.");
    if (o8.type in [A2.MAT2, A2.MAT3, A2.MAT4])
      throw new s3("gltf-loader-unsupported-feature", `AttributeType ${o8.type} is not supported`);
    const n7 = this.json.bufferViews[o8.bufferView], s7 = await this.getBuffer(n7.buffer, r8), a2 = X[o8.type], i7 = W[o8.componentType], u6 = a2 * i7, f7 = n7.byteStride || u6;
    return { raw: s7.buffer, byteStride: f7, byteOffset: s7.byteOffset + (n7.byteOffset || 0) + (o8.byteOffset || 0), entryCount: o8.count, isDenselyPacked: f7 === u6, componentCount: a2, componentByteSize: i7, componentType: o8.componentType, min: o8.min, max: o8.max, normalized: !!o8.normalized };
  }
  async getIndexData(e7, t9) {
    if (null == e7.indices)
      return;
    const r8 = await this.getAccessor(e7.indices, t9);
    if (r8.isDenselyPacked)
      switch (r8.componentType) {
        case C.UNSIGNED_BYTE:
          return new Uint8Array(r8.raw, r8.byteOffset, r8.entryCount);
        case C.UNSIGNED_SHORT:
          return new Uint16Array(r8.raw, r8.byteOffset, r8.entryCount);
        case C.UNSIGNED_INT:
          return new Uint32Array(r8.raw, r8.byteOffset, r8.entryCount);
      }
    else
      switch (r8.componentType) {
        case C.UNSIGNED_BYTE:
          return e6(this._wrapAccessor(d, r8));
        case C.UNSIGNED_SHORT:
          return e6(this._wrapAccessor(g, r8));
        case C.UNSIGNED_INT:
          return e6(this._wrapAccessor(B, r8));
      }
  }
  async getPositionData(t9, r8) {
    if (null == t9.attributes.POSITION)
      throw new s3("gltf-loader-unsupported-feature", "No POSITION vertex data found.");
    const o8 = await this.getAccessor(t9.attributes.POSITION, r8);
    if (o8.componentType !== C.FLOAT)
      throw new s3("gltf-loader-unsupported-feature", "Expected type FLOAT for POSITION vertex attribute, but found " + C[o8.componentType]);
    if (3 !== o8.componentCount)
      throw new s3("gltf-loader-unsupported-feature", "POSITION vertex attribute must have 3 components, but found " + o8.componentCount.toFixed());
    return this._wrapAccessor(i2, o8);
  }
  async getNormalData(t9, r8) {
    if (null == t9.attributes.NORMAL)
      throw new s3("gltf-loader-error", "No NORMAL vertex data found.");
    const o8 = await this.getAccessor(t9.attributes.NORMAL, r8);
    if (o8.componentType !== C.FLOAT)
      throw new s3("gltf-loader-unsupported-feature", "Expected type FLOAT for NORMAL vertex attribute, but found " + C[o8.componentType]);
    if (3 !== o8.componentCount)
      throw new s3("gltf-loader-unsupported-feature", "NORMAL vertex attribute must have 3 components, but found " + o8.componentCount.toFixed());
    return this._wrapAccessor(i2, o8);
  }
  async getTangentData(t9, r8) {
    if (null == t9.attributes.TANGENT)
      throw new s3("gltf-loader-error", "No TANGENT vertex data found.");
    const o8 = await this.getAccessor(t9.attributes.TANGENT, r8);
    if (o8.componentType !== C.FLOAT)
      throw new s3("gltf-loader-unsupported-feature", "Expected type FLOAT for TANGENT vertex attribute, but found " + C[o8.componentType]);
    if (4 !== o8.componentCount)
      throw new s3("gltf-loader-unsupported-feature", "TANGENT vertex attribute must have 4 components, but found " + o8.componentCount.toFixed());
    return new c2(o8.raw, o8.byteOffset, o8.byteStride, o8.byteOffset + o8.byteStride * o8.entryCount);
  }
  async getTextureCoordinates(t9, r8) {
    if (null == t9.attributes.TEXCOORD_0)
      throw new s3("gltf-loader-error", "No TEXCOORD_0 vertex data found.");
    const o8 = await this.getAccessor(t9.attributes.TEXCOORD_0, r8);
    if (2 !== o8.componentCount)
      throw new s3("gltf-loader-unsupported-feature", "TEXCOORD_0 vertex attribute must have 2 components, but found " + o8.componentCount.toFixed());
    if (o8.componentType === C.FLOAT)
      return this._wrapAccessor(u, o8);
    if (!o8.normalized)
      throw new s3("gltf-loader-unsupported-feature", "Integer component types are only supported for a normalized accessor for TEXCOORD_0.");
    return $(o8);
  }
  async getVertexColors(t9, r8) {
    if (null == t9.attributes.COLOR_0)
      throw new s3("gltf-loader-error", "No COLOR_0 vertex data found.");
    const o8 = await this.getAccessor(t9.attributes.COLOR_0, r8);
    if (4 !== o8.componentCount && 3 !== o8.componentCount)
      throw new s3("gltf-loader-unsupported-feature", "COLOR_0 attribute must have 3 or 4 components, but found " + o8.componentCount.toFixed());
    if (4 === o8.componentCount) {
      if (o8.componentType === C.FLOAT)
        return this._wrapAccessor(c2, o8);
      if (o8.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(x, o8);
      if (o8.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(L, o8);
    } else if (3 === o8.componentCount) {
      if (o8.componentType === C.FLOAT)
        return this._wrapAccessor(i2, o8);
      if (o8.componentType === C.UNSIGNED_BYTE)
        return this._wrapAccessor(O, o8);
      if (o8.componentType === C.UNSIGNED_SHORT)
        return this._wrapAccessor(E, o8);
    }
    throw new s3("gltf-loader-unsupported-feature", "Unsupported component type for COLOR_0 attribute: " + C[o8.componentType]);
  }
  hasPositions(e7) {
    return void 0 !== e7.attributes.POSITION;
  }
  hasNormals(e7) {
    return void 0 !== e7.attributes.NORMAL;
  }
  hasVertexColors(e7) {
    return void 0 !== e7.attributes.COLOR_0;
  }
  hasTextureCoordinates(e7) {
    return void 0 !== e7.attributes.TEXCOORD_0;
  }
  hasTangents(e7) {
    return void 0 !== e7.attributes.TANGENT;
  }
  async getMaterial(e7, t9, r8) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    let o8 = e7.material ? this._materialCache.get(e7.material) : void 0;
    if (!o8) {
      const n7 = null != e7.material ? i4(this.json.materials[e7.material]) : i4(), s7 = n7.pbrMetallicRoughness, a2 = this.hasVertexColors(e7), i7 = this.getTexture(s7.baseColorTexture, t9), u6 = this.getTexture(n7.normalTexture, t9), f7 = r8 ? this.getTexture(n7.occlusionTexture, t9) : void 0, c5 = r8 ? this.getTexture(n7.emissiveTexture, t9) : void 0, d3 = r8 ? this.getTexture(s7.metallicRoughnessTexture, t9) : void 0, l6 = null != e7.material ? e7.material : -1;
      o8 = { alphaMode: n7.alphaMode, alphaCutoff: n7.alphaCutoff, color: s7.baseColorFactor, doubleSided: !!n7.doubleSided, colorTexture: await i7, normalTexture: await u6, name: n7.name, id: l6, occlusionTexture: await f7, emissiveTexture: await c5, emissiveFactor: n7.emissiveFactor, metallicFactor: s7.metallicFactor, roughnessFactor: s7.roughnessFactor, metallicRoughnessTexture: await d3, hasVertexColors: a2, ESRI_externalColorMixMode: n7.extras.ESRI_externalColorMixMode, colorTextureTransform: (_b = (_a = s7 == null ? void 0 : s7.baseColorTexture) == null ? void 0 : _a.extensions) == null ? void 0 : _b.KHR_texture_transform, normalTextureTransform: (_d = (_c = n7.normalTexture) == null ? void 0 : _c.extensions) == null ? void 0 : _d.KHR_texture_transform, occlusionTextureTransform: (_f = (_e = n7.occlusionTexture) == null ? void 0 : _e.extensions) == null ? void 0 : _f.KHR_texture_transform, emissiveTextureTransform: (_h = (_g = n7.emissiveTexture) == null ? void 0 : _g.extensions) == null ? void 0 : _h.KHR_texture_transform, metallicRoughnessTextureTransform: (_j = (_i = s7 == null ? void 0 : s7.metallicRoughnessTexture) == null ? void 0 : _i.extensions) == null ? void 0 : _j.KHR_texture_transform };
    }
    return o8;
  }
  async getTexture(t9, o8) {
    if (!t9)
      return;
    if (0 !== (t9.texCoord || 0))
      throw new s3("gltf-loader-unsupported-feature", "Only TEXCOORD with index 0 is supported.");
    const n7 = t9.index, s7 = this.json.textures[n7], a2 = c3(null != s7.sampler ? this.json.samplers[s7.sampler] : {}), i7 = this._getTextureSourceId(s7), u6 = this.json.images[i7], f7 = await this._loadTextureImageData(n7, s7, o8);
    return r(this._textureCache, n7, () => {
      const t10 = (e7) => 33071 === e7 || 33648 === e7 || 10497 === e7, r8 = (t11) => {
        throw new s3("gltf-loader-error", `Unexpected TextureSampler WrapMode: ${t11}`);
      };
      return { data: f7, wrapS: t10(a2.wrapS) ? a2.wrapS : r8(a2.wrapS), wrapT: t10(a2.wrapT) ? a2.wrapT : r8(a2.wrapT), minFilter: a2.minFilter, name: u6.name, id: n7 };
    });
  }
  getNodeTransform(e7) {
    if (void 0 === e7)
      return q2;
    let t9 = this._nodeTransformCache.get(e7);
    if (!t9) {
      const r8 = this.getNodeTransform(this._getNodeParent(e7)), o8 = this.json.nodes[e7];
      o8.matrix ? t9 = c(e(), r8, o8.matrix) : o8.translation || o8.rotation || o8.scale ? (t9 = r2(r8), o8.translation && i(t9, t9, o8.translation), o8.rotation && (z[3] = x2(z, o8.rotation), b(t9, t9, z[3], z)), o8.scale && f2(t9, t9, o8.scale)) : t9 = r2(r8), this._nodeTransformCache.set(e7, t9);
    }
    return t9;
  }
  _wrapAccessor(e7, t9) {
    return new e7(t9.raw, t9.byteOffset, t9.byteStride, t9.byteOffset + t9.byteStride * (t9.entryCount - 1) + t9.componentByteSize * t9.componentCount);
  }
  _resolveUri(e7) {
    return _2(e7, this._baseUri);
  }
  _getNodeParent(e7) {
    return this._nodeParentMap.get(e7);
  }
  _checkVersionSupported() {
    const e7 = r3.parse(this.json.asset.version, "glTF");
    J.validate(e7);
  }
  _checkRequiredExtensionsSupported() {
    const t9 = this.json;
    if (t9.extensionsRequired) {
      if (!t9.extensionsRequired.every((e7) => this._supportedExtensions.includes(e7)))
        throw new s3("gltf-loader-unsupported-feature", "gltf loader was not able to load unsupported feature. Required extensions: " + t9.extensionsRequired.join(", "));
    }
  }
  _computeNodeParents() {
    this.json.nodes.forEach((e7, t9) => {
      e7.children && e7.children.forEach((e8) => {
        this._nodeParentMap.set(e8, t9);
      });
    });
  }
  async _loadTextureImageData(e7, t9, r8) {
    const o8 = this._textureLoaders.get(e7);
    if (o8)
      return o8;
    const n7 = this._createTextureLoader(t9, r8);
    return this._textureLoaders.set(e7, n7), n7;
  }
  _getTextureSourceId(t9) {
    if (void 0 !== t9.extensions && null !== t9.extensions.KHR_texture_basisu)
      return t9.extensions.KHR_texture_basisu.source;
    if (null !== t9.source)
      return t9.source;
    throw new s3("gltf-loader-unsupported-feature", "Source is expected to be defined for a texture. It can also be omitted in favour of an KHR_texture_basisu extension tag.");
  }
  async _createTextureLoader(t9, r8) {
    const o8 = this._getTextureSourceId(t9), n7 = this.json.images[o8];
    if (n7.uri) {
      if (n7.uri.endsWith(".ktx2")) {
        const e7 = await this._context.loadBinary(this._resolveUri(n7.uri), r8);
        return new n2(new Uint8Array(e7));
      }
      return this._context.loadImage(this._resolveUri(n7.uri), r8);
    }
    if (null == n7.bufferView)
      throw new s3("gltf-loader-unsupported-feature", "Image bufferView must be defined.");
    if (null == n7.mimeType)
      throw new s3("gltf-loader-unsupported-feature", "Image mimeType must be defined.");
    const s7 = this.json.bufferViews[n7.bufferView], a2 = await this.getBuffer(s7.buffer, r8);
    if (null != s7.byteStride)
      throw new s3("gltf-loader-unsupported-feature", "byteStride not supported for image buffer");
    const i7 = a2.byteOffset + (s7.byteOffset || 0);
    return o(new Uint8Array(a2.buffer, i7, s7.byteLength), n7.mimeType);
  }
  async getLoadedBuffersSize() {
    if (this._glbBuffer)
      return this._glbBuffer.byteLength;
    const e7 = await P(Array.from(this._bufferLoaders.values())), t9 = await P(Array.from(this._textureLoaders.values()));
    return e7.reduce((e8, t10) => e8 + ((t10 == null ? void 0 : t10.byteLength) ?? 0), 0) + t9.reduce((e8, t10) => e8 + (t10 ? t2(t10) ? t10.data.byteLength : t10.width * t10.height * 4 : 0), 0);
  }
};
var q2 = p(e(), Math.PI / 2);
var J = new r3(2, 0, "glTF");
var z = e2();
var X = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var W = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.FLOAT]: 4, [C.INT]: 4, [C.UNSIGNED_INT]: 4 };
function $(e7) {
  switch (e7.componentType) {
    case C.BYTE:
      return new V(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.UNSIGNED_BYTE:
      return new A(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.SHORT:
      return new q(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.UNSIGNED_SHORT:
      return new w(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.UNSIGNED_INT:
      return new F(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
    case C.FLOAT:
      return new u(e7.raw, e7.byteOffset, e7.byteStride, e7.byteOffset + e7.byteStride * e7.entryCount);
  }
}

// node_modules/@arcgis/core/views/3d/glTF/loader.js
var i5 = 0;
async function l5(t9, r8, a2 = {}, l6 = true) {
  const m3 = await Y.load(t9, r8, a2), p3 = "gltf_" + i5++, T = { lods: [], materials: /* @__PURE__ */ new Map(), textures: /* @__PURE__ */ new Map(), meta: u4(m3) }, f7 = !(!m3.json.asset.extras || "symbolResource" !== m3.json.asset.extras.ESRI_type), x3 = /* @__PURE__ */ new Map();
  await c4(m3, async (t10, r9, s7, i7) => {
    const u6 = x3.get(s7) ?? 0;
    x3.set(s7, u6 + 1);
    const c5 = void 0 !== t10.mode ? t10.mode : E2.TRIANGLES, f8 = c5 === E2.TRIANGLES || c5 === E2.TRIANGLE_STRIP || c5 === E2.TRIANGLE_FAN ? c5 : null;
    if (null == f8)
      return void s2.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Unsupported primitive mode (" + E2[c5] + "). Skipping primitive.");
    if (!m3.hasPositions(t10))
      return void s2.getLogger("esri.views.3d.glTF").warn("Skipping primitive without POSITION vertex attribute.");
    const g3 = m3.getPositionData(t10, a2), h2 = m3.getMaterial(t10, a2, l6), v = m3.hasNormals(t10) ? m3.getNormalData(t10, a2) : null, w2 = m3.hasTangents(t10) ? m3.getTangentData(t10, a2) : null, R = m3.hasTextureCoordinates(t10) ? m3.getTextureCoordinates(t10, a2) : null, S = m3.hasVertexColors(t10) ? m3.getVertexColors(t10, a2) : null, _3 = m3.getIndexData(t10, a2), E4 = { transform: r2(r9), attributes: { position: await g3, normal: v ? await v : null, texCoord0: R ? await R : null, color: S ? await S : null, tangent: w2 ? await w2 : null }, indices: await _3, primitiveType: f8, material: d2(T, await h2, p3) };
    let I = null;
    null != T.meta && null != T.meta.ESRI_lod && "screenSpaceRadius" === T.meta.ESRI_lod.metric && (I = T.meta.ESRI_lod.thresholds[s7]), T.lods[s7] = T.lods[s7] || { parts: [], name: i7, lodThreshold: I }, T.lods[s7].parts[u6] = E4;
  });
  for (const e7 of T.lods)
    e7.parts = e7.parts.filter((e8) => !!e8);
  const g2 = await m3.getLoadedBuffersSize();
  return { model: T, meta: { isEsriSymbolResource: f7, uri: m3.uri }, customMeta: {}, size: g2 };
}
function u4(e7) {
  const o8 = e7.json;
  let t9 = null;
  return o8.nodes.forEach((e8) => {
    const o9 = e8.extras;
    null != o9 && (o9.ESRI_proxyEllipsoid || o9.ESRI_lod) && (t9 = o9);
  }), t9;
}
async function c4(o8, t9) {
  const r8 = o8.json, s7 = r8.scenes[r8.scene || 0].nodes, a2 = s7.length > 1, n7 = [];
  for (const e7 of s7) {
    const o9 = r8.nodes[e7];
    if (n7.push(i7(e7, 0)), m2(o9) && !a2) {
      o9.extensions.MSFT_lod.ids.forEach((e8, o10) => i7(e8, o10 + 1));
    }
  }
  async function i7(s8, a3) {
    const l6 = r8.nodes[s8], u6 = o8.getNodeTransform(s8);
    if (null != l6.weights && s2.getLogger("esri.views.3d.glTF").warn("[Unsupported Feature] Morph targets are not supported."), null != l6.mesh) {
      const e7 = r8.meshes[l6.mesh];
      for (const o9 of e7.primitives)
        n7.push(t9(o9, u6, a3, e7.name));
    }
    for (const e7 of l6.children || [])
      n7.push(i7(e7, a3));
  }
  await Promise.all(n7);
}
function m2(e7) {
  return e7.extensions && e7.extensions.MSFT_lod && Array.isArray(e7.extensions.MSFT_lod.ids);
}
function d2(e7, o8, s7) {
  const a2 = (o9) => {
    const t9 = `${s7}_tex_${o9 && o9.id}${o9 && o9.name ? "_" + o9.name : ""}`;
    if (o9 && !e7.textures.has(t9)) {
      const s8 = l3(o9.data, { wrap: { s: o9.wrapS, t: o9.wrapT }, mipmap: p2.includes(o9.minFilter), noUnpackFlip: true });
      e7.textures.set(t9, s8);
    }
    return t9;
  }, n7 = `${s7}_mat_${o8.id}_${o8.name}`;
  if (!e7.materials.has(n7)) {
    const r8 = r6({ color: [o8.color[0], o8.color[1], o8.color[2]], opacity: o8.color[3], alphaMode: o8.alphaMode, alphaCutoff: o8.alphaCutoff, doubleSided: o8.doubleSided, colorMixMode: o8.ESRI_externalColorMixMode, textureColor: o8.colorTexture ? a2(o8.colorTexture) : void 0, textureNormal: o8.normalTexture ? a2(o8.normalTexture) : void 0, textureOcclusion: o8.occlusionTexture ? a2(o8.occlusionTexture) : void 0, textureEmissive: o8.emissiveTexture ? a2(o8.emissiveTexture) : void 0, textureMetallicRoughness: o8.metallicRoughnessTexture ? a2(o8.metallicRoughnessTexture) : void 0, emissiveFactor: [o8.emissiveFactor[0], o8.emissiveFactor[1], o8.emissiveFactor[2]], colorTextureTransform: o8.colorTextureTransform, normalTextureTransform: o8.normalTextureTransform, occlusionTextureTransform: o8.occlusionTextureTransform, emissiveTextureTransform: o8.emissiveTextureTransform, metallicRoughnessTextureTransform: o8.metallicRoughnessTextureTransform, metallicFactor: o8.metallicFactor, roughnessFactor: o8.roughnessFactor });
    e7.materials.set(n7, r8);
  }
  return n7;
}
var p2 = [L2.LINEAR_MIPMAP_LINEAR, L2.LINEAR_MIPMAP_NEAREST];

// node_modules/@arcgis/core/views/3d/glTF/internal/indexUtils.js
function o6(r8, t9) {
  switch (t9) {
    case E2.TRIANGLES:
      return f6(r8);
    case E2.TRIANGLE_STRIP:
      return u5(r8);
    case E2.TRIANGLE_FAN:
      return i6(r8);
  }
}
function f6(e7) {
  return "number" == typeof e7 ? y(e7) : t(e7) ? new Uint16Array(e7) : e7;
}
function u5(r8) {
  const t9 = "number" == typeof r8 ? r8 : r8.length;
  if (t9 < 3)
    return [];
  const n7 = t9 - 2, o8 = i3(3 * n7);
  if ("number" == typeof r8) {
    let r9 = 0;
    for (let t10 = 0; t10 < n7; t10 += 1)
      t10 % 2 == 0 ? (o8[r9++] = t10, o8[r9++] = t10 + 1, o8[r9++] = t10 + 2) : (o8[r9++] = t10 + 1, o8[r9++] = t10, o8[r9++] = t10 + 2);
  } else {
    let t10 = 0;
    for (let e7 = 0; e7 < n7; e7 += 1)
      e7 % 2 == 0 ? (o8[t10++] = r8[e7], o8[t10++] = r8[e7 + 1], o8[t10++] = r8[e7 + 2]) : (o8[t10++] = r8[e7 + 1], o8[t10++] = r8[e7], o8[t10++] = r8[e7 + 2]);
  }
  return o8;
}
function i6(r8) {
  const t9 = "number" == typeof r8 ? r8 : r8.length;
  if (t9 < 3)
    return new Uint16Array(0);
  const e7 = t9 - 2, n7 = e7 <= 65536 ? new Uint16Array(3 * e7) : new Uint32Array(3 * e7);
  if ("number" == typeof r8) {
    let r9 = 0;
    for (let t10 = 0; t10 < e7; ++t10)
      n7[r9++] = 0, n7[r9++] = t10 + 1, n7[r9++] = t10 + 2;
    return n7;
  }
  const o8 = r8[0];
  let f7 = r8[1], u6 = 0;
  for (let i7 = 0; i7 < e7; ++i7) {
    const t10 = r8[i7 + 2];
    n7[u6++] = o8, n7[u6++] = f7, n7[u6++] = t10, f7 = t10;
  }
  return n7;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/DefaultMaterial_COLOR_GAMMA.js
var o7 = 2.1;

export {
  r5 as r,
  f3 as f,
  n3 as n,
  o2 as o,
  u2 as u,
  o3 as o2,
  n4 as n2,
  l2 as l,
  e4 as e,
  t4 as t,
  f4 as f2,
  e5 as e2,
  t5 as t2,
  f5 as f3,
  n5 as n3,
  l5 as l2,
  o6 as o3,
  o7 as o4
};
//# sourceMappingURL=chunk-DVELLWIV.js.map
