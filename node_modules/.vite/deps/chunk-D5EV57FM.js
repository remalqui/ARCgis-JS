import {
  t
} from "./chunk-SO7CVIZK.js";
import {
  Rn,
  en
} from "./chunk-SO6DBMQG.js";
import {
  A,
  M,
  S2 as S,
  s2 as s,
  x,
  y
} from "./chunk-SFV6XLDZ.js";
import {
  R
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/layers/graphics/data/projectionSupport.js
var l = [0, 0];
function h(s2, t3) {
  if (!t3)
    return null;
  if ("x" in t3) {
    const e2 = { x: 0, y: 0 };
    return [e2.x, e2.y] = s2(t3.x, t3.y, l), null != t3.z && (e2.z = t3.z), null != t3.m && (e2.m = t3.m), e2;
  }
  if ("xmin" in t3) {
    const e2 = { xmin: 0, ymin: 0, xmax: 0, ymax: 0 };
    return [e2.xmin, e2.ymin] = s2(t3.xmin, t3.ymin, l), [e2.xmax, e2.ymax] = s2(t3.xmax, t3.ymax, l), t3.hasZ && (e2.zmin = t3.zmin, e2.zmax = t3.zmax, e2.hasZ = true), t3.hasM && (e2.mmin = t3.mmin, e2.mmax = t3.mmax, e2.hasM = true), e2;
  }
  return "rings" in t3 ? { rings: c(t3.rings, s2), hasM: t3.hasM, hasZ: t3.hasZ } : "paths" in t3 ? { paths: c(t3.paths, s2), hasM: t3.hasM, hasZ: t3.hasZ } : "points" in t3 ? { points: p(t3.points, s2), hasM: t3.hasM, hasZ: t3.hasZ } : null;
}
function c(s2, t3) {
  const e2 = [];
  for (const n2 of s2)
    e2.push(p(n2, t3));
  return e2;
}
function p(s2, t3) {
  const e2 = [];
  for (const n2 of s2) {
    const s3 = t3(n2[0], n2[1], [0, 0]);
    e2.push(s3), n2.length > 2 && s3.push(n2[2]), n2.length > 3 && s3.push(n2[3]);
  }
  return e2;
}
async function f(e2, n2) {
  if (!e2 || !n2)
    return;
  const r2 = Array.isArray(e2) ? e2.map((s2) => null != s2.geometry ? s2.geometry.spatialReference : null).filter(R) : [e2];
  await Rn(r2.map((s2) => ({ source: s2, dest: n2 })));
}
var x2 = h.bind(null, M);
var y2 = h.bind(null, y);
function g(s2, t3, a, m) {
  if (!s2)
    return s2;
  if (a || (a = t3, t3 = s2.spatialReference), !s(t3) || !s(a) || S(t3, a))
    return s2;
  if (x(t3, a)) {
    const t4 = A(a) ? x2(s2) : y2(s2);
    return t4.spatialReference = a, t4;
  }
  return en(t, [s2], t3, a, null, m)[0];
}
var _ = class {
  constructor() {
    this._jobs = [], this._timer = null, this._process = this._process.bind(this);
  }
  async push(s2, t3, e2) {
    if (!s2 || !s2.length || !t3 || !e2 || S(t3, e2))
      return s2;
    const n2 = { geometries: s2, inSpatialReference: t3, outSpatialReference: e2, resolve: null };
    return this._jobs.push(n2), new Promise((s3) => {
      n2.resolve = s3, null === this._timer && (this._timer = setTimeout(this._process, 10));
    });
  }
  _process() {
    this._timer = null;
    const s2 = this._jobs.shift();
    if (!s2)
      return;
    const { geometries: t3, inSpatialReference: r2, outSpatialReference: i, resolve: a } = s2;
    x(r2, i) ? A(i) ? a(t3.map(x2)) : a(t3.map(y2)) : a(en(t, t3, r2, i, null, null)), this._jobs.length > 0 && (this._timer = setTimeout(this._process, 10));
  }
};
var j = new _();
function M2(s2, t3, e2) {
  return j.push(s2, t3, e2);
}

// node_modules/@arcgis/core/layers/graphics/centroid.js
function n(n2, t3) {
  return n2 ? t3 ? 4 : 3 : t3 ? 3 : 2;
}
function t2(t3, I2, o2, u2, l3) {
  if (null == I2 || !I2.lengths.length)
    return null;
  const N = "upperLeft" === (l3 == null ? void 0 : l3.originPosition) ? -1 : 1;
  t3.lengths.length && (t3.lengths.length = 0), t3.coords.length && (t3.coords.length = 0);
  const s2 = t3.coords, c2 = [], f2 = o2 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY], { lengths: T, coords: i } = I2, h2 = n(o2, u2);
  let g2 = 0;
  for (const n2 of T) {
    const t4 = e(f2, i, g2, n2, o2, u2, N);
    t4 && c2.push(t4), g2 += n2 * h2;
  }
  if (c2.sort((n2, t4) => {
    let e2 = N * n2[2] - N * t4[2];
    return 0 === e2 && o2 && (e2 = n2[4] - t4[4]), e2;
  }), c2.length) {
    let n2 = 6 * c2[0][2];
    s2[0] = c2[0][0] / n2, s2[1] = c2[0][1] / n2, o2 && (n2 = 6 * c2[0][4], s2[2] = 0 !== n2 ? c2[0][3] / n2 : 0), (s2[0] < f2[0] || s2[0] > f2[1] || s2[1] < f2[2] || s2[1] > f2[3] || o2 && (s2[2] < f2[4] || s2[2] > f2[5])) && (s2.length = 0);
  }
  if (!s2.length) {
    const n2 = I2.lengths[0] ? r(i, 0, T[0], o2, u2) : null;
    if (!n2)
      return null;
    s2[0] = n2[0], s2[1] = n2[1], o2 && n2.length > 2 && (s2[2] = n2[2]);
  }
  return t3;
}
function e(t3, e2, r2, I2, o2, u2, l3 = 1) {
  const N = n(o2, u2);
  let s2 = r2, c2 = r2 + N, f2 = 0, T = 0, i = 0, h2 = 0, g2 = 0;
  for (let n2 = 0, b = I2 - 1; n2 < b; n2++, s2 += N, c2 += N) {
    const n3 = e2[s2], r3 = e2[s2 + 1], I3 = e2[s2 + 2], u3 = e2[c2], l4 = e2[c2 + 1], N2 = e2[c2 + 2];
    let E2 = n3 * l4 - u3 * r3;
    h2 += E2, f2 += (n3 + u3) * E2, T += (r3 + l4) * E2, o2 && (E2 = n3 * N2 - u3 * I3, i += (I3 + N2) * E2, g2 += E2), n3 < t3[0] && (t3[0] = n3), n3 > t3[1] && (t3[1] = n3), r3 < t3[2] && (t3[2] = r3), r3 > t3[3] && (t3[3] = r3), o2 && (I3 < t3[4] && (t3[4] = I3), I3 > t3[5] && (t3[5] = I3));
  }
  if (h2 * l3 > 0 && (h2 *= -1), g2 * l3 > 0 && (g2 *= -1), !h2)
    return null;
  const E = [f2, T, 0.5 * h2];
  return o2 && (E[3] = i, E[4] = 0.5 * g2), E;
}
function r(t3, e2, r2, N, s2) {
  const c2 = n(N, s2);
  let f2 = e2, T = e2 + c2, i = 0, h2 = 0, g2 = 0, E = 0;
  for (let n2 = 0, b = r2 - 1; n2 < b; n2++, f2 += c2, T += c2) {
    const n3 = t3[f2], e3 = t3[f2 + 1], r3 = t3[f2 + 2], s3 = t3[T], c3 = t3[T + 1], b2 = t3[T + 2], m = N ? o(n3, e3, r3, s3, c3, b2) : I(n3, e3, s3, c3);
    if (m)
      if (i += m, N) {
        const t4 = l2(n3, e3, r3, s3, c3, b2);
        h2 += m * t4[0], g2 += m * t4[1], E += m * t4[2];
      } else {
        const t4 = u(n3, e3, s3, c3);
        h2 += m * t4[0], g2 += m * t4[1];
      }
  }
  return i > 0 ? N ? [h2 / i, g2 / i, E / i] : [h2 / i, g2 / i] : r2 > 0 ? N ? [t3[e2], t3[e2 + 1], t3[e2 + 2]] : [t3[e2], t3[e2 + 1]] : null;
}
function I(n2, t3, e2, r2) {
  const I2 = e2 - n2, o2 = r2 - t3;
  return Math.sqrt(I2 * I2 + o2 * o2);
}
function o(n2, t3, e2, r2, I2, o2) {
  const u2 = r2 - n2, l3 = I2 - t3, N = o2 - e2;
  return Math.sqrt(u2 * u2 + l3 * l3 + N * N);
}
function u(n2, t3, e2, r2) {
  return [n2 + 0.5 * (e2 - n2), t3 + 0.5 * (r2 - t3)];
}
function l2(n2, t3, e2, r2, I2, o2) {
  return [n2 + 0.5 * (r2 - n2), t3 + 0.5 * (I2 - t3), e2 + 0.5 * (o2 - e2)];
}

export {
  t2 as t,
  f,
  g,
  M2 as M
};
//# sourceMappingURL=chunk-D5EV57FM.js.map
