import {
  e as e2,
  l,
  s,
  u as u2
} from "./chunk-CEAO27ON.js";
import {
  A
} from "./chunk-CIYZZPIM.js";
import {
  a as a2,
  c,
  r
} from "./chunk-SXL2EDR4.js";
import {
  Ae,
  B,
  Ne,
  Pe,
  Q,
  fe,
  je,
  ke,
  me,
  oe,
  q,
  v,
  ye,
  z
} from "./chunk-RFI4CCAC.js";
import {
  e,
  t
} from "./chunk-FJYIB7HF.js";
import {
  p as p2
} from "./chunk-T4XWQYGC.js";
import {
  j,
  m2 as m,
  u
} from "./chunk-TCASQSKO.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  H,
  p2 as p,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import {
  a2 as a
} from "./chunk-MH2LNFJK.js";

// node_modules/@arcgis/core/arcade/functions/geomsync.js
var Z = null;
function E(e3) {
  return 0 === a.indexOf("4.") ? j.fromExtent(e3) : new j({ spatialReference: e3.spatialReference, rings: [[[e3.xmin, e3.ymin], [e3.xmin, e3.ymax], [e3.xmax, e3.ymax], [e3.xmax, e3.ymin], [e3.xmin, e3.ymin]]] });
}
function z2(n) {
  Z = n;
}
function C(n, e3) {
  if ("polygon" !== n.type && "polyline" !== n.type && "extent" !== n.type)
    return 0;
  let t2 = 1;
  if (n.spatialReference.vcsWkid || n.spatialReference.latestVcsWkid) {
    t2 = s(n.spatialReference) / H(n.spatialReference);
  }
  let r2 = 0;
  if ("polyline" === n.type)
    for (const a3 of n.paths)
      for (let n2 = 1; n2 < a3.length; n2++)
        r2 += e2(a3[n2], a3[n2 - 1], t2);
  else if ("polygon" === n.type)
    for (const a3 of n.rings) {
      for (let n2 = 1; n2 < a3.length; n2++)
        r2 += e2(a3[n2], a3[n2 - 1], t2);
      (a3[0][0] !== a3[a3.length - 1][0] || a3[0][1] !== a3[a3.length - 1][1] || void 0 !== a3[0][2] && a3[0][2] !== a3[a3.length - 1][2]) && (r2 += e2(a3[0], a3[a3.length - 1], t2));
    }
  else
    "extent" === n.type && (r2 += 2 * e2([n.xmin, n.ymin, 0], [n.xmax, n.ymin, 0], t2), r2 += 2 * e2([n.xmin, n.ymin, 0], [n.xmin, n.ymax, 0], t2), r2 *= 2, r2 += 4 * Math.abs(v(n.zmax, 0) * t2 - v(n.zmin, 0) * t2));
  const i = new m({ hasZ: false, hasM: false, spatialReference: n.spatialReference, paths: [[0, 0], [0, r2]] });
  return Z.planarLength(i, e3);
}
function q2(n, y) {
  function I(n2, e3, t2) {
    if (Q(t2, 2, 2, n2, e3), t2[0] instanceof p && t2[1] instanceof p)
      ;
    else if (t2[0] instanceof p && null === t2[1])
      ;
    else if (t2[1] instanceof p && null === t2[0])
      ;
    else if (null !== t2[0] || null !== t2[1])
      throw new t(n2, e.InvalidParameter, e3);
  }
  n.disjoint = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null === a3[0] || null === a3[1] || Z.disjoint(a3[0], a3[1])));
  }, n.intersects = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null !== a3[0] && null !== a3[1] && Z.intersects(a3[0], a3[1])));
  }, n.touches = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null !== a3[0] && null !== a3[1] && Z.touches(a3[0], a3[1])));
  }, n.crosses = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null !== a3[0] && null !== a3[1] && Z.crosses(a3[0], a3[1])));
  }, n.within = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null !== a3[0] && null !== a3[1] && Z.within(a3[0], a3[1])));
  }, n.contains = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null !== a3[0] && null !== a3[1] && Z.contains(a3[0], a3[1])));
  }, n.overlaps = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null !== a3[0] && null !== a3[1] && Z.overlaps(a3[0], a3[1])));
  }, n.equals = function(n2, e3) {
    return y(n2, e3, (t2, r2, i) => (Q(i, 2, 2, n2, e3), i[0] === i[1] || (i[0] instanceof p && i[1] instanceof p ? Z.equals(i[0], i[1]) : !(!B(i[0]) || !B(i[1])) && i[0].equals(i[1]))));
  }, n.relate = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 3, 3, n2, e3), l2[0] instanceof p && l2[1] instanceof p)
        return Z.relate(l2[0], l2[1], oe(l2[2]));
      if (l2[0] instanceof p && null === l2[1])
        return false;
      if (l2[1] instanceof p && null === l2[0])
        return false;
      if (null === l2[0] && null === l2[1])
        return false;
      throw new t(n2, e.InvalidParameter, e3);
    });
  }, n.intersection = function(n2, e3) {
    return y(n2, e3, (t2, r2, a3) => (a3 = Ne(a3), I(n2, e3, a3), null === a3[0] || null === a3[1] ? null : Z.intersect(a3[0], a3[1])));
  }, n.union = function(n2, t2) {
    return y(n2, t2, (r2, a3, l2) => {
      const o = [];
      if (0 === (l2 = Ne(l2)).length)
        throw new t(n2, e.WrongNumberOfParameters, t2);
      if (1 === l2.length)
        if (z(l2[0])) {
          const e3 = Ne(l2[0]);
          for (let r3 = 0; r3 < e3.length; r3++)
            if (null !== e3[r3]) {
              if (!(e3[r3] instanceof p))
                throw new t(n2, e.InvalidParameter, t2);
              o.push(e3[r3]);
            }
        } else {
          if (!q(l2[0])) {
            if (l2[0] instanceof p)
              return ye(c(l2[0]), n2.spatialReference);
            if (null === l2[0])
              return null;
            throw new t(n2, e.InvalidParameter, t2);
          }
          {
            const e3 = Ne(l2[0].toArray());
            for (let r3 = 0; r3 < e3.length; r3++)
              if (null !== e3[r3]) {
                if (!(e3[r3] instanceof p))
                  throw new t(n2, e.InvalidParameter, t2);
                o.push(e3[r3]);
              }
          }
        }
      else
        for (let e3 = 0; e3 < l2.length; e3++)
          if (null !== l2[e3]) {
            if (!(l2[e3] instanceof p))
              throw new t(n2, e.InvalidParameter, t2);
            o.push(l2[e3]);
          }
      return 0 === o.length ? null : Z.union(o);
    });
  }, n.difference = function(n2, t2) {
    return y(n2, t2, (r2, a3, l2) => (l2 = Ne(l2), I(n2, t2, l2), null !== l2[0] && null === l2[1] ? c(l2[0]) : null === l2[0] ? null : Z.difference(l2[0], l2[1])));
  }, n.symmetricdifference = function(n2, t2) {
    return y(n2, t2, (r2, a3, l2) => (l2 = Ne(l2), I(n2, t2, l2), null === l2[0] && null === l2[1] ? null : null === l2[0] ? c(l2[1]) : null === l2[1] ? c(l2[0]) : Z.symmetricDifference(l2[0], l2[1])));
  }, n.clip = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 2, n2, e3), !(l2[1] instanceof M) && null !== l2[1])
        throw new t(n2, e.InvalidParameter, e3);
      if (null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return null === l2[1] ? null : Z.clip(l2[0], l2[1]);
    });
  }, n.cut = function(n2, t2) {
    return y(n2, t2, (r2, l2, o) => {
      if (o = Ne(o), Q(o, 2, 2, n2, t2), !(o[1] instanceof m) && null !== o[1])
        throw new t(n2, e.InvalidParameter, t2);
      if (null === o[0])
        return [];
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, t2);
      return null === o[1] ? [c(o[0])] : Z.cut(o[0], o[1]);
    });
  }, n.area = function(n2, e3) {
    return y(n2, e3, (r2, l2, o) => {
      if (Q(o, 1, 2, n2, e3), null === (o = Ne(o))[0])
        return 0;
      if (z(o[0]) || q(o[0])) {
        const e4 = ke(o[0], n2.spatialReference);
        return null === e4 ? 0 : Z.planarArea(e4, r(v(o[1], -1)));
      }
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.planarArea(o[0], r(v(o[1], -1)));
    });
  }, n.areageodetic = function(n2, e3) {
    return y(n2, e3, (r2, l2, o) => {
      if (Q(o, 1, 2, n2, e3), null === (o = Ne(o))[0])
        return 0;
      if (z(o[0]) || q(o[0])) {
        const e4 = ke(o[0], n2.spatialReference);
        return null === e4 ? 0 : Z.geodesicArea(e4, r(v(o[1], -1)));
      }
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.geodesicArea(o[0], r(v(o[1], -1)));
    });
  }, n.length = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      if (Q(o, 1, 2, n2, e3), null === (o = Ne(o))[0])
        return 0;
      if (z(o[0]) || q(o[0])) {
        const e4 = je(o[0], n2.spatialReference);
        return null === e4 ? 0 : Z.planarLength(e4, a2(v(o[1], -1)));
      }
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.planarLength(o[0], a2(v(o[1], -1)));
    });
  }, n.length3d = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      if (Q(o, 1, 2, n2, e3), null === (o = Ne(o))[0])
        return 0;
      if (z(o[0]) || q(o[0])) {
        const e4 = je(o[0], n2.spatialReference);
        return null === e4 ? 0 : true === e4.hasZ ? C(e4, a2(v(o[1], -1))) : Z.planarLength(e4, a2(v(o[1], -1)));
      }
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return true === o[0].hasZ ? C(o[0], a2(v(o[1], -1))) : Z.planarLength(o[0], a2(v(o[1], -1)));
    });
  }, n.lengthgeodetic = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      if (Q(o, 1, 2, n2, e3), null === (o = Ne(o))[0])
        return 0;
      if (z(o[0]) || q(o[0])) {
        const e4 = je(o[0], n2.spatialReference);
        return null === e4 ? 0 : Z.geodesicLength(e4, a2(v(o[1], -1)));
      }
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.geodesicLength(o[0], a2(v(o[1], -1)));
    });
  }, n.distance = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      o = Ne(o), Q(o, 2, 3, n2, e3);
      let s2 = o[0];
      (z(o[0]) || q(o[0])) && (s2 = Ae(o[0], n2.spatialReference));
      let c2 = o[1];
      if ((z(o[1]) || q(o[1])) && (c2 = Ae(o[1], n2.spatialReference)), !(s2 instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      if (!(c2 instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.distance(s2, c2, a2(v(o[2], -1)));
    });
  }, n.distancegeodetic = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      o = Ne(o), Q(o, 2, 3, n2, e3);
      const f = o[0], u3 = o[1];
      if (!(f instanceof x))
        throw new t(n2, e.InvalidParameter, e3);
      if (!(u3 instanceof x))
        throw new t(n2, e.InvalidParameter, e3);
      const s2 = new m({ paths: [], spatialReference: f.spatialReference });
      return s2.addPath([f, u3]), Z.geodesicLength(s2, a2(v(o[2], -1)));
    });
  }, n.densify = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      if (o = Ne(o), Q(o, 2, 3, n2, e3), null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      const f = fe(o[1]);
      if (isNaN(f))
        throw new t(n2, e.InvalidParameter, e3);
      if (f <= 0)
        throw new t(n2, e.InvalidParameter, e3);
      return o[0] instanceof j || o[0] instanceof m ? Z.densify(o[0], f, a2(v(o[2], -1))) : o[0] instanceof M ? Z.densify(E(o[0]), f, a2(v(o[2], -1))) : o[0];
    });
  }, n.densifygeodetic = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      if (o = Ne(o), Q(o, 2, 3, n2, e3), null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      const f = fe(o[1]);
      if (isNaN(f))
        throw new t(n2, e.InvalidParameter, e3);
      if (f <= 0)
        throw new t(n2, e.InvalidParameter, e3);
      return o[0] instanceof j || o[0] instanceof m ? Z.geodesicDensify(o[0], f, a2(v(o[2], -1))) : o[0] instanceof M ? Z.geodesicDensify(E(o[0]), f, a2(v(o[2], -1))) : o[0];
    });
  }, n.generalize = function(n2, e3) {
    return y(n2, e3, (t2, l2, o) => {
      if (o = Ne(o), Q(o, 2, 4, n2, e3), null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      const f = fe(o[1]);
      if (isNaN(f))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.generalize(o[0], f, me(v(o[2], true)), a2(v(o[3], -1)));
    });
  }, n.buffer = function(n2, t2) {
    return y(n2, t2, (l2, o, f) => {
      if (f = Ne(f), Q(f, 2, 3, n2, t2), null === f[0])
        return null;
      if (!(f[0] instanceof p))
        throw new t(n2, e.InvalidParameter, t2);
      const u3 = fe(f[1]);
      if (isNaN(u3))
        throw new t(n2, e.InvalidParameter, t2);
      return 0 === u3 ? c(f[0]) : Z.buffer(f[0], u3, a2(v(f[2], -1)));
    });
  }, n.buffergeodetic = function(n2, t2) {
    return y(n2, t2, (l2, o, f) => {
      if (f = Ne(f), Q(f, 2, 3, n2, t2), null === f[0])
        return null;
      if (!(f[0] instanceof p))
        throw new t(n2, e.InvalidParameter, t2);
      const u3 = fe(f[1]);
      if (isNaN(u3))
        throw new t(n2, e.InvalidParameter, t2);
      return 0 === u3 ? c(f[0]) : Z.geodesicBuffer(f[0], u3, a2(v(f[2], -1)));
    });
  }, n.offset = function(n2, e3) {
    return y(n2, e3, (t2, l2, f) => {
      if (f = Ne(f), Q(f, 2, 6, n2, e3), null === f[0])
        return null;
      if (!(f[0] instanceof j || f[0] instanceof m))
        throw new t(n2, e.InvalidParameter, e3);
      const u3 = fe(f[1]);
      if (isNaN(u3))
        throw new t(n2, e.InvalidParameter, e3);
      const s2 = fe(v(f[4], 10));
      if (isNaN(s2))
        throw new t(n2, e.InvalidParameter, e3);
      const c2 = fe(v(f[5], 0));
      if (isNaN(c2))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.offset(f[0], u3, a2(v(f[2], -1)), oe(v(f[3], "round")).toLowerCase(), s2, c2);
    });
  }, n.rotate = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      l2 = Ne(l2), Q(l2, 2, 3, n2, e3);
      let o = l2[0];
      if (null === o)
        return null;
      if (!(o instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      o instanceof M && (o = j.fromExtent(o));
      const f = fe(l2[1]);
      if (isNaN(f))
        throw new t(n2, e.InvalidParameter, e3);
      const u3 = v(l2[2], null);
      if (null === u3)
        return Z.rotate(o, f);
      if (u3 instanceof x)
        return Z.rotate(o, f, u3);
      throw new t(n2, e.InvalidParameter, e3);
    });
  }, n.centroid = function(n2, t2) {
    return y(n2, t2, (r2, l2, o) => {
      if (o = Ne(o), Q(o, 1, 1, n2, t2), null === o[0])
        return null;
      let c2 = o[0];
      if ((z(o[0]) || q(o[0])) && (c2 = Ae(o[0], n2.spatialReference)), null === c2)
        return null;
      if (!(c2 instanceof p))
        throw new t(n2, e.InvalidParameter, t2);
      return c2 instanceof x ? ye(c(o[0]), n2.spatialReference) : c2 instanceof j ? c2.centroid : c2 instanceof m ? l(c2) : c2 instanceof u ? u2(c2) : c2 instanceof M ? c2.center : null;
    });
  }, n.multiparttosinglepart = function(n2, t2) {
    return y(n2, t2, (r2, l2, o) => {
      o = Ne(o), Q(o, 1, 1, n2, t2);
      const f = [];
      if (null === o[0])
        return null;
      if (!(o[0] instanceof p))
        throw new t(n2, e.InvalidParameter, t2);
      if (o[0] instanceof x)
        return [ye(c(o[0]), n2.spatialReference)];
      if (o[0] instanceof M)
        return [ye(c(o[0]), n2.spatialReference)];
      const u3 = Z.simplify(o[0]);
      if (u3 instanceof j) {
        const n3 = [], e3 = [];
        for (let t3 = 0; t3 < u3.rings.length; t3++)
          if (u3.isClockwise(u3.rings[t3])) {
            const e4 = p2({ rings: [u3.rings[t3]], hasZ: true === u3.hasZ, hasM: true === u3.hasM, spatialReference: u3.spatialReference.toJSON() });
            n3.push(e4);
          } else
            e3.push({ ring: u3.rings[t3], pt: u3.getPoint(t3, 0) });
        for (let t3 = 0; t3 < e3.length; t3++)
          for (let r3 = 0; r3 < n3.length; r3++)
            if (n3[r3].contains(e3[t3].pt)) {
              n3[r3].addRing(e3[t3].ring);
              break;
            }
        return n3;
      }
      if (u3 instanceof m) {
        const n3 = [];
        for (let e3 = 0; e3 < u3.paths.length; e3++) {
          const t3 = p2({ paths: [u3.paths[e3]], hasZ: true === u3.hasZ, hasM: true === u3.hasM, spatialReference: u3.spatialReference.toJSON() });
          n3.push(t3);
        }
        return n3;
      }
      if (o[0] instanceof u) {
        const t3 = ye(c(o[0]), n2.spatialReference);
        for (let n3 = 0; n3 < t3.points.length; n3++)
          f.push(t3.getPoint(n3));
        return f;
      }
      return null;
    });
  }, n.issimple = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 1, 1, n2, e3), null === l2[0])
        return true;
      if (!(l2[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.isSimple(l2[0]);
    });
  }, n.simplify = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 1, 1, n2, e3), null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.simplify(l2[0]);
    });
  }, n.convexhull = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 1, 1, n2, e3), null === l2[0])
        return null;
      if (!(l2[0] instanceof p))
        throw new t(n2, e.InvalidParameter, e3);
      return Z.convexHull(l2[0]);
    });
  }, n.nearestcoordinate = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 2, n2, e3), !(l2[0] instanceof p || null === l2[0]))
        throw new t(n2, e.InvalidParameter, e3);
      if (!(l2[1] instanceof x || null === l2[1]))
        throw new t(n2, e.InvalidParameter, e3);
      if (null === l2[0] || null === l2[1])
        return null;
      const o = Z.nearestCoordinate(l2[0], l2[1]);
      return null === o || o.isEmpty ? null : A.convertObjectToArcadeDictionary({ coordinate: o.coordinate, distance: o.distance }, Pe(n2), false, true);
    });
  }, n.nearestvertex = function(n2, e3) {
    return y(n2, e3, (t2, r2, l2) => {
      if (l2 = Ne(l2), Q(l2, 2, 2, n2, e3), !(l2[0] instanceof p || null === l2[0]))
        throw new t(n2, e.InvalidParameter, e3);
      if (!(l2[1] instanceof x || null === l2[1]))
        throw new t(n2, e.InvalidParameter, e3);
      if (null === l2[0] || null === l2[1])
        return null;
      const o = Z.nearestVertex(l2[0], l2[1]);
      return null === o || o.isEmpty ? null : A.convertObjectToArcadeDictionary({ coordinate: o.coordinate, distance: o.distance }, Pe(n2), false, true);
    });
  };
}

export {
  z2 as z,
  q2 as q
};
//# sourceMappingURL=chunk-GJPI2PF4.js.map
