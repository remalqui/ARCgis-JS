import {
  a2 as a,
  a3 as a2,
  d
} from "./chunk-NIVA4TPD.js";
import {
  I,
  c,
  e,
  l,
  w
} from "./chunk-TYYAH2P4.js";
import {
  n as n2,
  r
} from "./chunk-U3JB4DA4.js";
import "./chunk-NU5WEWCI.js";
import "./chunk-UIVGJZCT.js";
import "./chunk-BN6X2OXK.js";
import {
  S
} from "./chunk-2CQBXY7G.js";
import "./chunk-AEPMR2T7.js";
import "./chunk-EF6YPOUN.js";
import {
  yn
} from "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import {
  E
} from "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-3GSONYPC.js";
import {
  f
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import {
  R,
  n2 as n
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/3d/layers/i3s/PointCloudWorkerUtil.js
function i(t, n3, l2, s) {
  const { rendererJSON: i2, isRGBRenderer: u2 } = t;
  let c4 = null, a4 = null;
  if (n3 && u2)
    c4 = n3;
  else if (n3 && "pointCloudUniqueValueRenderer" === (i2 == null ? void 0 : i2.type)) {
    a4 = a2.fromJSON(i2);
    const e2 = a4.colorUniqueValueInfos;
    c4 = new Uint8Array(3 * s);
    const r2 = d2(a4.fieldTransformType);
    for (let o = 0; o < s; o++) {
      const t2 = (r2 ? r2(n3[o]) : n3[o]) + "";
      for (let r3 = 0; r3 < e2.length; r3++)
        if (e2[r3].values.includes(t2)) {
          c4[3 * o] = e2[r3].color.r, c4[3 * o + 1] = e2[r3].color.g, c4[3 * o + 2] = e2[r3].color.b;
          break;
        }
    }
  } else if (n3 && "pointCloudStretchRenderer" === (i2 == null ? void 0 : i2.type)) {
    a4 = a.fromJSON(i2);
    const e2 = a4.stops;
    c4 = new Uint8Array(3 * s);
    const o = d2(a4.fieldTransformType);
    for (let r2 = 0; r2 < s; r2++) {
      const t2 = o ? o(n3[r2]) : n3[r2], l3 = e2.length - 1;
      if (t2 < e2[0].value)
        c4[3 * r2] = e2[0].color.r, c4[3 * r2 + 1] = e2[0].color.g, c4[3 * r2 + 2] = e2[0].color.b;
      else if (t2 >= e2[l3].value)
        c4[3 * r2] = e2[l3].color.r, c4[3 * r2 + 1] = e2[l3].color.g, c4[3 * r2 + 2] = e2[l3].color.b;
      else
        for (let o2 = 1; o2 < e2.length; o2++)
          if (t2 < e2[o2].value) {
            const n4 = (t2 - e2[o2 - 1].value) / (e2[o2].value - e2[o2 - 1].value);
            c4[3 * r2] = e2[o2].color.r * n4 + e2[o2 - 1].color.r * (1 - n4), c4[3 * r2 + 1] = e2[o2].color.g * n4 + e2[o2 - 1].color.g * (1 - n4), c4[3 * r2 + 2] = e2[o2].color.b * n4 + e2[o2 - 1].color.b * (1 - n4);
            break;
          }
    }
  } else if (n3 && "pointCloudClassBreaksRenderer" === (i2 == null ? void 0 : i2.type)) {
    a4 = d.fromJSON(i2);
    const r2 = a4.colorClassBreakInfos;
    c4 = new Uint8Array(3 * s);
    const o = d2(a4.fieldTransformType);
    for (let e2 = 0; e2 < s; e2++) {
      const t2 = o ? o(n3[e2]) : n3[e2];
      for (let o2 = 0; o2 < r2.length; o2++)
        if (t2 >= r2[o2].minValue && t2 <= r2[o2].maxValue) {
          c4[3 * e2] = r2[o2].color.r, c4[3 * e2 + 1] = r2[o2].color.g, c4[3 * e2 + 2] = r2[o2].color.b;
          break;
        }
    }
  } else
    c4 = new Uint8Array(3 * s).fill(255);
  if (l2 && a4 && a4.colorModulation) {
    const e2 = a4.colorModulation.minValue, r2 = a4.colorModulation.maxValue, o = 0.3;
    for (let t2 = 0; t2 < s; t2++) {
      const n4 = l2[t2], s2 = n4 >= r2 ? 1 : n4 <= e2 ? o : o + (1 - o) * (n4 - e2) / (r2 - e2);
      c4[3 * t2] = s2 * c4[3 * t2], c4[3 * t2 + 1] = s2 * c4[3 * t2 + 1], c4[3 * t2 + 2] = s2 * c4[3 * t2 + 2];
    }
  }
  return c4;
}
function u(e2, r2) {
  if (null == e2.encoding || "" === e2.encoding) {
    const o = w(r2, e2);
    if (null == o.vertexAttributes.position)
      return;
    const l2 = l(r2, o.vertexAttributes.position), s = o.header.fields, i2 = [s.offsetX, s.offsetY, s.offsetZ], u2 = [s.scaleX, s.scaleY, s.scaleZ], c4 = l2.length / 3, a4 = new Float64Array(3 * c4);
    for (let e3 = 0; e3 < c4; e3++)
      a4[3 * e3] = l2[3 * e3] * u2[0] + i2[0], a4[3 * e3 + 1] = l2[3 * e3 + 1] * u2[1] + i2[1], a4[3 * e3 + 2] = l2[3 * e3 + 2] * u2[2] + i2[2];
    return a4;
  }
  if ("lepcc-xyz" === e2.encoding)
    return c(r2).result;
}
function c2(e2, r2, o) {
  return null != e2 && e2.attributeInfo.useElevation ? r2 ? a3(r2, o) : null : null != e2 && e2.attributeInfo.storageInfo ? I(e2.attributeInfo.storageInfo, e2.buffer, o) : null;
}
function a3(e2, r2) {
  const o = new Float64Array(r2);
  for (let t = 0; t < r2; t++)
    o[t] = e2[3 * t + 2];
  return o;
}
function f2(e2, r2, o, t, n3) {
  const l2 = e2.length / 3;
  let s = 0;
  for (let i2 = 0; i2 < l2; i2++) {
    let l3 = true;
    for (let e3 = 0; e3 < t.length && l3; e3++) {
      const { filterJSON: r3 } = t[e3], o2 = n3[e3].values[i2];
      switch (r3.type) {
        case "pointCloudValueFilter": {
          const e4 = "exclude" === r3.mode;
          r3.values.includes(o2) === e4 && (l3 = false);
          break;
        }
        case "pointCloudBitfieldFilter": {
          const e4 = p(r3.requiredSetBits), t2 = p(r3.requiredClearBits);
          (o2 & e4) === e4 && 0 == (o2 & t2) || (l3 = false);
          break;
        }
        case "pointCloudReturnFilter": {
          const e4 = 15 & o2, t2 = o2 >>> 4 & 15, n4 = t2 > 1, s2 = 1 === e4, i3 = e4 === t2;
          let u2 = false;
          for (const o3 of r3.includedReturns)
            if ("last" === o3 && i3 || "firstOfMany" === o3 && s2 && n4 || "lastOfMany" === o3 && i3 && n4 || "single" === o3 && !n4) {
              u2 = true;
              break;
            }
          u2 || (l3 = false);
          break;
        }
      }
    }
    l3 && (o[s] = i2, e2[3 * s] = e2[3 * i2], e2[3 * s + 1] = e2[3 * i2 + 1], e2[3 * s + 2] = e2[3 * i2 + 2], r2[3 * s] = r2[3 * i2], r2[3 * s + 1] = r2[3 * i2 + 1], r2[3 * s + 2] = r2[3 * i2 + 2], s++);
  }
  return s;
}
function d2(e2) {
  switch (e2) {
    default:
    case null:
    case "none":
      return (e3) => e3;
    case "low-four-bit":
      return (e3) => 15 & e3;
    case "high-four-bit":
      return (e3) => (240 & e3) >> 4;
    case "absolute-value":
      return (e3) => Math.abs(e3);
    case "modulo-ten":
      return (e3) => e3 % 10;
  }
}
function p(e2) {
  let r2 = 0;
  for (const o of e2 || [])
    r2 |= 1 << o;
  return r2;
}

// node_modules/@arcgis/core/views/3d/layers/PointCloudWorker.js
var c3 = class {
  transform(t) {
    const e2 = this._transform(t), a4 = [e2.points.buffer, e2.rgb.buffer];
    null != e2.pointIdFilterMap && a4.push(e2.pointIdFilterMap.buffer);
    for (const o of e2.attributes)
      "buffer" in o.values && n(o.values.buffer) && o.values.buffer !== e2.rgb.buffer && a4.push(o.values.buffer);
    return Promise.resolve({ result: e2, transferList: a4 });
  }
  _transform(r2) {
    const e2 = u(r2.schema, r2.geometryBuffer);
    let a4 = e2.length / 3, o = null;
    const n3 = new Array(), f3 = c2(r2.primaryAttributeData, e2, a4);
    null != r2.primaryAttributeData && f3 && n3.push({ attributeInfo: r2.primaryAttributeData.attributeInfo, values: f3 });
    const i2 = c2(r2.modulationAttributeData, e2, a4);
    null != r2.modulationAttributeData && i2 && n3.push({ attributeInfo: r2.modulationAttributeData.attributeInfo, values: i2 });
    let c4 = i(r2.rendererInfo, f3, i2, a4);
    if (r2.filterInfo && r2.filterInfo.length > 0 && null != r2.filterAttributesData) {
      const f4 = r2.filterAttributesData.filter(R).map((t) => {
        const r3 = c2(t, e2, a4), o2 = { attributeInfo: t.attributeInfo, values: r3 };
        return n3.push(o2), o2;
      });
      o = new Uint32Array(a4), a4 = f2(e2, c4, o, r2.filterInfo, f4);
    }
    for (const t of r2.userAttributesData) {
      const r3 = c2(t, e2, a4);
      n3.push({ attributeInfo: t.attributeInfo, values: r3 });
    }
    3 * a4 < c4.length && (c4 = new Uint8Array(c4.buffer.slice(0, 3 * a4))), this._applyElevationOffsetInPlace(e2, a4, r2.elevationOffset);
    const p3 = this._transformCoordinates(e2, a4, r2.obb, f.fromJSON(r2.inSR), f.fromJSON(r2.outSR));
    return { obb: r2.obb, points: p3, rgb: c4, attributes: n3, pointIdFilterMap: o };
  }
  _transformCoordinates(t, r2, a4, s, u2) {
    if (!yn(t, s, 0, t, u2, 0, r2))
      throw new Error("Can't reproject");
    const l2 = r(a4.center[0], a4.center[1], a4.center[2]), b = n2(), m = n2();
    S(p2, a4.quaternion);
    const c4 = new Float32Array(3 * r2);
    for (let e2 = 0; e2 < r2; e2++)
      b[0] = t[3 * e2] - l2[0], b[1] = t[3 * e2 + 1] - l2[1], b[2] = t[3 * e2 + 2] - l2[2], E(m, b, p2), a4.halfSize[0] = Math.max(a4.halfSize[0], Math.abs(m[0])), a4.halfSize[1] = Math.max(a4.halfSize[1], Math.abs(m[1])), a4.halfSize[2] = Math.max(a4.halfSize[2], Math.abs(m[2])), c4[3 * e2] = b[0], c4[3 * e2 + 1] = b[1], c4[3 * e2 + 2] = b[2];
    return c4;
  }
  _applyElevationOffsetInPlace(t, r2, e2) {
    if (0 !== e2)
      for (let a4 = 0; a4 < r2; a4++)
        t[3 * a4 + 2] += e2;
  }
};
var p2 = e();
function h() {
  return new c3();
}
export {
  h as default
};
//# sourceMappingURL=PointCloudWorker-HV4DTS4D.js.map
