import {
  n as n5,
  r as r5
} from "./chunk-C7U2SKSO.js";
import {
  c as c3
} from "./chunk-NVZXNBIH.js";
import {
  S as S2,
  V,
  a as a4,
  g,
  i as i3,
  l,
  s as s5
} from "./chunk-GTENSI4J.js";
import {
  e as e6,
  t as t5
} from "./chunk-ZL3HOHNK.js";
import {
  c as c4,
  i as i5,
  r as r3
} from "./chunk-ZO32FGGH.js";
import {
  e as e5,
  t as t3
} from "./chunk-CSLWFQJE.js";
import {
  f,
  p
} from "./chunk-XP6ESZGI.js";
import {
  G,
  R as R2,
  k,
  o as o5,
  t as t2
} from "./chunk-3VTULECI.js";
import {
  w as w2,
  x
} from "./chunk-A4HFWKMU.js";
import {
  e as e3,
  i as i4,
  o as o3
} from "./chunk-TDXHXKUI.js";
import {
  C as C2,
  N,
  O,
  P,
  U,
  Z,
  b as b2,
  f as f2,
  w as w3
} from "./chunk-PJP6JTP7.js";
import {
  a as a3,
  c as c2,
  i as i7,
  n as n3,
  o as o4,
  r as r4,
  s as s4
} from "./chunk-IVABPLLZ.js";
import {
  E,
  S
} from "./chunk-TBHRKIAA.js";
import {
  o as o2
} from "./chunk-BBJLFBMQ.js";
import {
  $,
  a as a2,
  ae,
  b,
  be,
  c,
  ce,
  de,
  fe,
  ge,
  h,
  i as i2,
  je,
  ke,
  le,
  me,
  ne,
  pe,
  q,
  ue,
  ve,
  w,
  we,
  xe,
  ye
} from "./chunk-JSMUQBPG.js";
import {
  r,
  s as s3,
  y
} from "./chunk-FHYNSVC4.js";
import {
  e
} from "./chunk-LREUW66K.js";
import {
  t
} from "./chunk-M5UHI5WR.js";
import {
  n as n2
} from "./chunk-QNFDBY7V.js";
import {
  e as e4,
  h as h2,
  i as i6,
  n
} from "./chunk-EL72ISXP.js";
import {
  n as n4,
  t as t4
} from "./chunk-5KLICR5E.js";
import {
  e as e2
} from "./chunk-2PAQQUAG.js";
import {
  r as r2,
  z
} from "./chunk-X4Y5OF5X.js";
import {
  o,
  u
} from "./chunk-EIE3W25Z.js";
import {
  n as n6
} from "./chunk-7KM4XBUC.js";
import {
  i
} from "./chunk-MOPR7RFH.js";
import {
  C,
  a,
  d
} from "./chunk-HNHXEGH2.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  R
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/heuristics.js
var i8 = /* @__PURE__ */ new Map();
function t6(r13, t10, c11) {
  const { indicesPerRecord: s8, multiplier: o11, verticesPerRecord: d10 } = i8.get(r13);
  return { recordBytes: c11 * de * Uint32Array.BYTES_PER_ELEMENT, indexBytes: o11 * s8 * c11 * Uint32Array.BYTES_PER_ELEMENT, vertexBytes: o11 * d10 * c11 * t10 };
}
i8.set(E.MARKER, { multiplier: 1, indicesPerRecord: 6, verticesPerRecord: 4 }), i8.set(E.LINE, { multiplier: 1, indicesPerRecord: 24, verticesPerRecord: 8 }), i8.set(E.FILL, { multiplier: 1, indicesPerRecord: 10, verticesPerRecord: 10 }), i8.set(E.TEXT, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 }), i8.set(E.LABEL, { multiplier: 8, indicesPerRecord: 6, verticesPerRecord: 4 });

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t7 = 1.25;
var e7 = class {
  get length() {
    return this._pos;
  }
  constructor(t10, e11) {
    this._pos = 0;
    const r13 = e11 ? this._roundToNearest(e11, t10.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(r13), this._buffer = new t10(this._array), this._ctor = t10, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t10, e11) {
    const r13 = Math.round(t10);
    return 1 === e11 ? r13 : r13 + (e11 - r13 % e11);
  }
  _ensureSize(e11) {
    if (this._pos + e11 >= this._buffer.length) {
      const r13 = this._roundToNearest((this._array.byteLength + e11 * this._buffer.BYTES_PER_ELEMENT) * t7, this._buffer.BYTES_PER_ELEMENT), s8 = new ArrayBuffer(r13), i15 = new this._ctor(s8);
      i15.set(this._buffer, 0), this._array = s8, this._buffer = i15, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t10) {
    this._ensureSize(t10);
  }
  writeF32(t10) {
    this._ensureSize(1);
    const e11 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t10, this._pos++, e11;
  }
  push(t10) {
    this._ensureSize(1);
    const e11 = this._pos;
    return this._buffer[this._pos++] = t10, e11;
  }
  writeFixed(t10) {
    this._buffer[this._pos++] = t10;
  }
  setValue(t10, e11) {
    this._buffer[t10] = e11;
  }
  i1616Add(t10, e11, r13) {
    this._i16View[2 * t10] += e11, this._i16View[2 * t10 + 1] += r13;
  }
  getValue(t10) {
    return this._buffer[t10];
  }
  incr(t10) {
    if (this._buffer.length < t10)
      throw new Error("Increment index overflows the target buffer");
    this._buffer[t10]++;
  }
  decr(t10) {
    this._buffer[t10]--;
  }
  writeRegion(t10) {
    this._ensureSize(t10.length);
    const e11 = this._pos;
    return this._buffer.set(t10, this._pos), this._pos += t10.length, e11;
  }
  writeManyFrom(t10, e11, r13) {
    this._ensureSize(r13 - e11);
    for (let s8 = e11; s8 !== r13; s8++)
      this.writeFixed(t10._buffer[s8]);
  }
  buffer() {
    const t10 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t10;
  }
  toArray() {
    return [...this._buffer];
  }
  seek(t10) {
    this._pos = t10;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var r6 = class {
  constructor(e11, r13, i15) {
    this._start = { index: 0, vertex: 0 };
    const h7 = t6(e11, r13, i15), c11 = r13 / 4;
    this.geometryType = e11, this._records = new e7(Int32Array, h7.recordBytes), this._indices = new e7(Uint32Array, h7.indexBytes), this._vertices = new e7(Uint32Array, h7.vertexBytes), this._metrics = new e7(Float32Array, 0), this._strideInt = c11;
  }
  serialize(e11) {
    const t10 = this._records.buffer(), s8 = this._indices.buffer(), r13 = this._vertices.buffer(), i15 = this._metrics.length ? this._metrics.buffer() : null, h7 = 4 * this._strideInt;
    return e11.push(t10, s8, r13), { stride: h7, records: t10, indices: s8, vertices: r13, metrics: i15 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get recordCount() {
    return this._records.length / de;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(e11) {
    this._vertices.ensureSize(e11);
  }
  indexEnsureSize(e11) {
    this._indices.ensureSize(e11);
  }
  recordStart() {
    this._start.index = this._indices.length, this._start.vertex = this._vertices.length;
  }
  recordEnd(e11, t10, s8, r13, i15, h7, c11, n11) {
    this._records.push(e11), this._records.push(t10 ?? 0), this._records.push(s8), this._records.push(r13), this._records.push(i15), this._records.push(h7), this._records.push(c11), this._records.writeF32(n11);
  }
  writeIndex(e11) {
    this._indices.push(e11);
  }
  writeVertex(e11) {
    this._vertices.push(e11);
  }
  writeVertexF32(e11) {
    this._vertices.writeF32(e11);
  }
  copyLastFrom(t10, s8, r13) {
    const i15 = t10._records.length - de, h7 = t10._records.getValue(i15), c11 = t10._records.getValue(i15 + 1), n11 = t10._records.getValue(i15 + 2), _5 = t10._records.getValue(i15 + 4), d10 = t10._records.getValue(i15 + 6), o11 = t10._records.getValue(i15 + 7), u10 = this._vertices.length, l6 = (t10._start.vertex - this._vertices.length) / this._strideInt, g7 = this._indices.length, p10 = this.vertexCount;
    for (let e11 = t10._start.index; e11 !== t10._indices.length; e11++) {
      const s9 = t10._indices.getValue(e11);
      this._indices.push(s9 - l6);
    }
    for (let e11 = t10._start.vertex; e11 !== t10._vertices.length; e11++) {
      const s9 = t10._vertices.getValue(e11);
      this._vertices.push(s9);
    }
    for (let e11 = u10; e11 <= this._vertices.length; e11 += this._strideInt)
      this._vertices.i1616Add(e11, s8, r13);
    this._records.push(h7), this._records.push(c11), this._records.push(n11), this._records.push(g7), this._records.push(_5), this._records.push(p10), this._records.push(d10), this._records.push(o11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var u2 = 1;
var c5 = 2;
var o6 = 4;
var _ = 8;
var l2 = 16;
var d2 = 32;
var g2 = 64;
var p2 = 128;
function x2(e11) {
  switch (e11) {
    case u2:
    case _:
    case d2:
      return -1;
    case c5:
    case g2:
      return 0;
    case o6:
    case l2:
    case p2:
      return 1;
  }
}
function m(e11) {
  switch (e11) {
    case u2:
    case c5:
    case o6:
      return -1;
    case _:
    case l2:
      return 0;
    case d2:
    case g2:
    case p2:
      return 1;
  }
}
var f3 = u2 | _ | d2;
var y2 = o6 | l2 | p2;
var w4 = u2 | c5 | o6;
var v = d2 | g2 | p2;
var E2 = class {
  constructor(e11, t10, r13, i15, s8, n11 = 0) {
    this._hasAggregate = false, this.hasRecords = false, this._data = { self: /* @__PURE__ */ new Map(), neighbors: new Array() }, this._version = 0, this._current = { geometryType: 0, writer: null, overlaps: 0, start: 0, insertAfter: 0, sortKey: 0, id: 0, materialKey: 0, indexStart: 0, vertStart: 0, isDotDensity: false, bufferingEnabled: false, metricBoxLenPointer: 0 }, this.hint = t10, this.tileKey = e11, this._hasAggregate = i15, this._pixelBufferEnabled = s8, this._version = n11, this._symbologyType = r13;
  }
  get hasAggregates() {
    return this._hasAggregate;
  }
  get hasPixelBufferEnabled() {
    return this._pixelBufferEnabled;
  }
  serialize(t10) {
    const r13 = [];
    return r13.push(this._serializeTileVertexData(this.tileKey, this.tileKey, this._data.self)), this._data.neighbors.forEach((i15, s8) => {
      const n11 = 1 << s8, a10 = x2(n11), u10 = m(n11), c11 = o2(new e2(this.tileKey), a10, u10, t10), o11 = this._serializeTileVertexData(this.tileKey, c11.id, i15.vertexData);
      o11.message.bufferIds = i15.displayIds, r13.push(o11);
    }), r13;
  }
  _serializeTileVertexData(e11, t10, r13) {
    var _a, _b, _c, _d, _e;
    const i15 = new Array();
    return { message: { tileKeyOrigin: e11, tileKey: t10, data: { [E.MARKER]: (_a = r13.get(E.MARKER)) == null ? void 0 : _a.serialize(i15), [E.FILL]: (_b = r13.get(E.FILL)) == null ? void 0 : _b.serialize(i15), [E.LINE]: (_c = r13.get(E.LINE)) == null ? void 0 : _c.serialize(i15), [E.TEXT]: (_d = r13.get(E.TEXT)) == null ? void 0 : _d.serialize(i15), [E.LABEL]: (_e = r13.get(E.LABEL)) == null ? void 0 : _e.serialize(i15) }, version: this._version }, transferList: i15 };
  }
  featureStart(e11, t10) {
    this._current.insertAfter = e11, this._current.sortKey = t10;
  }
  featureEnd() {
  }
  recordStart(e11, t10, r13, i15) {
    this._current.writer = this._getVertexWriter(r13), this._current.overlaps = 0, this._current.indexStart = this._current.writer.indexCount, this._current.vertStart = this._current.writer.vertexCount, this._current.bufferingEnabled = i15, this._current.id = e11, this._current.materialKey = t10, this._current.geometryType = r13, this._current.isDotDensity = false, this._current.writer.recordStart();
  }
  recordCount() {
    return this._current.writer.recordCount;
  }
  vertexCount() {
    return this._current.writer.vertexCount;
  }
  indexCount() {
    return this._current.writer.indexCount;
  }
  vertexEnsureSize(e11) {
    this._current.writer.vertexEnsureSize(e11);
  }
  indexEnsureSize(e11) {
    this._current.writer.indexEnsureSize(e11);
  }
  vertexBounds(e11, t10, r13, i15) {
    this._current.bufferingEnabled && this._addOverlap(e11, t10, r13, i15);
  }
  vertexWrite(e11) {
    this._current.writer.writeVertex(e11);
  }
  vertexWriteF32(e11) {
    this._current.writer.writeVertexF32(e11);
  }
  vertexEnd() {
  }
  vertexWriter() {
    return this._current.writer.vertexWriter;
  }
  indexWrite(e11) {
    this._current.writer.writeIndex(e11);
  }
  indexWriter() {
    return this._current.writer.indexWriter;
  }
  metricWriter() {
    return this._current.writer.metricWriter;
  }
  metricStart(e11, t10, r13, n11, a10, h7, u10, c11) {
    this._current.writer = this._getVertexWriter(E.LABEL);
    const o11 = this._current.writer.metricWriter;
    o11.push(f(e11)), o11.push(t10), o11.push(r13), o11.push(n11), o11.push(a10), o11.push(h7), o11.push(u10), o11.push(c11), o11.push(255), this._current.metricBoxLenPointer = o11.push(0);
  }
  metricEnd() {
    const e11 = this._current.writer.metricWriter;
    0 === e11.getValue(this._current.metricBoxLenPointer) && e11.seek(e11.length - 10);
  }
  metricBoxWrite(e11, t10, r13, i15) {
    const s8 = this._current.writer.metricWriter;
    s8.incr(this._current.metricBoxLenPointer), s8.push(0), s8.push(0), s8.push(e11), s8.push(t10), s8.push(r13), s8.push(i15);
  }
  recordEnd() {
    const e11 = this._current.vertStart, r13 = this._current.writer.vertexCount - e11;
    if (!r13)
      return false;
    this.hasRecords = true;
    const i15 = this._current.indexStart, h7 = this._current.writer.indexCount - i15;
    if (this._current.writer.recordEnd(this._current.id, this._current.materialKey, this._current.insertAfter, i15, h7, e11, r13, this._current.sortKey), !this._pixelBufferEnabled || this._hasAggregate || 0 === this._current.overlaps || this._current.geometryType === E.LABEL)
      return true;
    const u10 = this._current.writer;
    for (let s8 = 0; s8 < 8; s8++) {
      const e12 = 1 << s8;
      if (!!(this._current.overlaps & e12)) {
        this._data.neighbors[s8] || (this._data.neighbors[s8] = { vertexData: /* @__PURE__ */ new Map(), displayIds: /* @__PURE__ */ new Set() });
        const r14 = this._data.neighbors[s8], i16 = this._current.geometryType;
        if (!r14.vertexData.has(i16)) {
          const e13 = R2(i16, this._symbologyType).geometry, s9 = new r6(i16, e13, fe);
          r14.vertexData.set(i16, s9);
        }
        const h8 = r14.vertexData.get(this._current.geometryType), c11 = 8, o11 = 512 * -x2(e12) * c11, _5 = 512 * -m(e12) * c11;
        h8 == null ? void 0 : h8.copyLastFrom(u10, o11, _5), r14.displayIds.add(this._current.id);
      }
    }
    return true;
  }
  _addOverlap(e11, t10, i15, s8) {
    const n11 = 255 ^ ((e11 < 0 + i15 ? y2 : e11 >= c - i15 ? f3 : y2 | f3) | (t10 < 0 + s8 ? v : t10 >= c - s8 ? w4 : v | w4));
    this._current.overlaps |= n11;
  }
  _getVertexWriter(e11) {
    if (!this._data.self.has(e11)) {
      const t10 = this._data.self, r13 = R2(e11, this._symbologyType).geometry;
      t10.set(e11, new r6(e11, r13, this.hint.records));
    }
    return this._data.self.get(e11);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/textUtils.js
function n7(n11) {
  if (null == n11)
    return [];
  const r13 = new Array(n11.length);
  for (let t10 = 0; t10 < n11.length; t10++)
    r13[t10] = n11.charCodeAt(t10);
  return r13;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/util.js
var n8 = 0;
var o7 = 100;
function t8(n11, o11, t10) {
  return n11[0] = o11[0] - t10[0], n11[1] = o11[1] - t10[1], n11;
}
function i9(n11, o11) {
  return Math.sqrt(n11 * n11 + o11 * o11);
}
function r7(n11) {
  const o11 = i9(n11[0], n11[1]);
  n11[0] /= o11, n11[1] /= o11;
}
function u3(n11, o11) {
  return i9(n11[0] - o11[0], n11[1] - o11[1]);
}
function c6(n11 = 2) {
  return 1 / Math.max(n11, 1);
}
function v2(t10, i15) {
  return [!!(t10 == null ? void 0 : t10.minScale) && i15.scaleToZoom(t10.minScale) || n8, !!(t10 == null ? void 0 : t10.maxScale) && i15.scaleToZoom(t10.maxScale) || o7];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e8(e11, t10, r13, i15, u10, o11, l6) {
  D = 0;
  const f9 = (i15 - r13) * o11, p10 = u10 && u10.length, c11 = p10 ? (u10[0] - r13) * o11 : f9;
  let v6, s8, h7, d10, Z4, a10 = n9(t10, r13, i15, 0, c11, o11, true);
  if (a10 && a10.next !== a10.prev) {
    if (p10 && (a10 = y3(t10, r13, i15, u10, a10, o11)), f9 > 80 * o11) {
      v6 = h7 = t10[0 + r13 * o11], s8 = d10 = t10[1 + r13 * o11];
      for (let e12 = o11; e12 < c11; e12 += o11) {
        const n11 = t10[e12 + r13 * o11], x10 = t10[e12 + 1 + r13 * o11];
        v6 = Math.min(v6, n11), s8 = Math.min(s8, x10), h7 = Math.max(h7, n11), d10 = Math.max(d10, x10);
      }
      Z4 = Math.max(h7 - v6, d10 - s8), Z4 = 0 !== Z4 ? 1 / Z4 : 0;
    }
    x3(a10, e11, o11, v6, s8, Z4, l6, 0);
  }
}
function n9(e11, n11, t10, x10, r13, i15, l6) {
  let y10;
  if (l6 === Z2(e11, n11, t10, x10, r13, i15) > 0)
    for (let o11 = x10; o11 < r13; o11 += i15)
      y10 = u4(o11 + n11 * i15, e11[o11 + n11 * i15], e11[o11 + 1 + n11 * i15], y10);
  else
    for (let o11 = r13 - i15; o11 >= x10; o11 -= i15)
      y10 = u4(o11 + n11 * i15, e11[o11 + n11 * i15], e11[o11 + 1 + n11 * i15], y10);
  return y10 && M(y10, y10.next) && (o8(y10), y10 = y10.next), y10;
}
function t9(e11, n11 = e11) {
  if (!e11)
    return e11;
  let t10, x10 = e11;
  do {
    if (t10 = false, x10.steiner || !M(x10, x10.next) && 0 !== s6(x10.prev, x10, x10.next))
      x10 = x10.next;
    else {
      if (o8(x10), x10 = n11 = x10.prev, x10 === x10.next)
        break;
      t10 = true;
    }
  } while (t10 || x10 !== n11);
  return n11;
}
function x3(e11, n11, u10, l6, y10, f9, p10, v6) {
  if (!e11)
    return;
  !v6 && f9 && (e11 = c7(e11, l6, y10, f9));
  let s8 = e11;
  for (; e11.prev !== e11.next; ) {
    const c11 = e11.prev, h7 = e11.next;
    if (f9 ? i10(e11, l6, y10, f9) : r8(e11))
      n11.push(c11.index / u10 + p10), n11.push(e11.index / u10 + p10), n11.push(h7.index / u10 + p10), o8(e11), e11 = h7.next, s8 = h7.next;
    else if ((e11 = h7) === s8) {
      v6 ? 1 === v6 ? x3(e11 = b3(e11, n11, u10, p10), n11, u10, l6, y10, f9, p10, 2) : 2 === v6 && g3(e11, n11, u10, l6, y10, f9, p10) : x3(t9(e11), n11, u10, l6, y10, f9, p10, 1);
      break;
    }
  }
}
function r8(e11) {
  const n11 = e11.prev, t10 = e11, x10 = e11.next;
  if (s6(n11, t10, x10) >= 0)
    return false;
  let r13 = e11.next.next;
  const i15 = r13;
  let u10 = 0;
  for (; r13 !== e11.prev && (0 === u10 || r13 !== i15); ) {
    if (u10++, a5(n11.x, n11.y, t10.x, t10.y, x10.x, x10.y, r13.x, r13.y) && s6(r13.prev, r13, r13.next) >= 0)
      return false;
    r13 = r13.next;
  }
  return true;
}
function i10(e11, n11, t10, x10) {
  const r13 = e11.prev, i15 = e11, u10 = e11.next;
  if (s6(r13, i15, u10) >= 0)
    return false;
  const o11 = r13.x < i15.x ? r13.x < u10.x ? r13.x : u10.x : i15.x < u10.x ? i15.x : u10.x, l6 = r13.y < i15.y ? r13.y < u10.y ? r13.y : u10.y : i15.y < u10.y ? i15.y : u10.y, y10 = r13.x > i15.x ? r13.x > u10.x ? r13.x : u10.x : i15.x > u10.x ? i15.x : u10.x, f9 = r13.y > i15.y ? r13.y > u10.y ? r13.y : u10.y : i15.y > u10.y ? i15.y : u10.y, p10 = z2(o11, l6, n11, t10, x10), c11 = z2(y10, f9, n11, t10, x10);
  let v6 = e11.prevZ, h7 = e11.nextZ;
  for (; v6 && v6.z >= p10 && h7 && h7.z <= c11; ) {
    if (v6 !== e11.prev && v6 !== e11.next && a5(r13.x, r13.y, i15.x, i15.y, u10.x, u10.y, v6.x, v6.y) && s6(v6.prev, v6, v6.next) >= 0)
      return false;
    if (v6 = v6.prevZ, h7 !== e11.prev && h7 !== e11.next && a5(r13.x, r13.y, i15.x, i15.y, u10.x, u10.y, h7.x, h7.y) && s6(h7.prev, h7, h7.next) >= 0)
      return false;
    h7 = h7.nextZ;
  }
  for (; v6 && v6.z >= p10; ) {
    if (v6 !== e11.prev && v6 !== e11.next && a5(r13.x, r13.y, i15.x, i15.y, u10.x, u10.y, v6.x, v6.y) && s6(v6.prev, v6, v6.next) >= 0)
      return false;
    v6 = v6.prevZ;
  }
  for (; h7 && h7.z <= c11; ) {
    if (h7 !== e11.prev && h7 !== e11.next && a5(r13.x, r13.y, i15.x, i15.y, u10.x, u10.y, h7.x, h7.y) && s6(h7.prev, h7, h7.next) >= 0)
      return false;
    h7 = h7.nextZ;
  }
  return true;
}
function u4(e11, n11, t10, x10) {
  const r13 = q2.create(e11, n11, t10);
  return x10 ? (r13.next = x10.next, r13.prev = x10, x10.next.prev = r13, x10.next = r13) : (r13.prev = r13, r13.next = r13), r13;
}
function o8(e11) {
  e11.next.prev = e11.prev, e11.prev.next = e11.next, e11.prevZ && (e11.prevZ.nextZ = e11.nextZ), e11.nextZ && (e11.nextZ.prevZ = e11.prevZ);
}
function l3(e11) {
  let n11 = e11, t10 = e11;
  do {
    (n11.x < t10.x || n11.x === t10.x && n11.y < t10.y) && (t10 = n11), n11 = n11.next;
  } while (n11 !== e11);
  return t10;
}
function y3(e11, t10, x10, r13, i15, u10) {
  const o11 = new Array();
  for (let y10 = 0, f9 = r13.length; y10 < f9; y10++) {
    const i16 = n9(e11, t10, x10, r13[y10] * u10, y10 < f9 - 1 ? r13[y10 + 1] * u10 : x10 * u10, u10, false);
    i16 === i16.next && (i16.steiner = true), o11.push(l3(i16));
  }
  o11.sort(m2);
  for (const n11 of o11)
    i15 = f4(n11, i15);
  return i15;
}
function f4(e11, n11) {
  const x10 = p3(e11, n11);
  if (!x10)
    return n11;
  const r13 = j(x10, e11);
  return t9(r13, r13.next), t9(x10, x10.next);
}
function p3(e11, n11) {
  let t10 = n11;
  const x10 = e11.x, r13 = e11.y;
  let i15, u10 = -1 / 0;
  do {
    if (r13 <= t10.y && r13 >= t10.next.y && t10.next.y !== t10.y) {
      const e12 = t10.x + (r13 - t10.y) * (t10.next.x - t10.x) / (t10.next.y - t10.y);
      if (e12 <= x10 && e12 > u10) {
        if (u10 = e12, e12 === x10) {
          if (r13 === t10.y)
            return t10;
          if (r13 === t10.next.y)
            return t10.next;
        }
        i15 = t10.x < t10.next.x ? t10 : t10.next;
      }
    }
    t10 = t10.next;
  } while (t10 !== n11);
  if (!i15)
    return null;
  if (x10 === u10)
    return i15.prev;
  const o11 = i15, l6 = i15.x, y10 = i15.y;
  let f9, p10 = 1 / 0;
  for (t10 = i15.next; t10 !== o11; )
    x10 >= t10.x && t10.x >= l6 && x10 !== t10.x && a5(r13 < y10 ? x10 : u10, r13, l6, y10, r13 < y10 ? u10 : x10, r13, t10.x, t10.y) && (f9 = Math.abs(r13 - t10.y) / (x10 - t10.x), (f9 < p10 || f9 === p10 && t10.x > i15.x) && w5(t10, e11) && (i15 = t10, p10 = f9)), t10 = t10.next;
  return i15;
}
function c7(e11, n11, t10, x10) {
  let r13;
  for (; r13 !== e11; r13 = r13.next) {
    if (r13 = r13 || e11, null === r13.z && (r13.z = z2(r13.x, r13.y, n11, t10, x10)), r13.prev.next !== r13 || r13.next.prev !== r13)
      return r13.prev.next = r13, r13.next.prev = r13, c7(e11, n11, t10, x10);
    r13.prevZ = r13.prev, r13.nextZ = r13.next;
  }
  return e11.prevZ.nextZ = null, e11.prevZ = null, v3(e11);
}
function v3(e11) {
  let n11, t10 = 1;
  for (; ; ) {
    let x10, r13 = e11;
    e11 = null, n11 = null;
    let i15 = 0;
    for (; r13; ) {
      i15++, x10 = r13;
      let u10 = 0;
      for (; u10 < t10 && x10; u10++)
        x10 = x10.nextZ;
      let o11 = t10;
      for (; u10 > 0 || o11 > 0 && x10; ) {
        let t11;
        0 === u10 ? (t11 = x10, x10 = x10.nextZ, o11--) : 0 !== o11 && x10 ? r13.z <= x10.z ? (t11 = r13, r13 = r13.nextZ, u10--) : (t11 = x10, x10 = x10.nextZ, o11--) : (t11 = r13, r13 = r13.nextZ, u10--), n11 ? n11.nextZ = t11 : e11 = t11, t11.prevZ = n11, n11 = t11;
      }
      r13 = x10;
    }
    if (n11.nextZ = null, t10 *= 2, i15 < 2)
      return e11;
  }
}
function s6(e11, n11, t10) {
  return (n11.y - e11.y) * (t10.x - n11.x) - (n11.x - e11.x) * (t10.y - n11.y);
}
function h3(e11, n11, t10, x10) {
  return !!(M(e11, n11) && M(t10, x10) || M(e11, x10) && M(t10, n11)) || s6(e11, n11, t10) > 0 != s6(e11, n11, x10) > 0 && s6(t10, x10, e11) > 0 != s6(t10, x10, n11) > 0;
}
function d3(e11, n11) {
  let t10 = e11;
  do {
    if (t10.index !== e11.index && t10.next.index !== e11.index && t10.index !== n11.index && t10.next.index !== n11.index && h3(t10, t10.next, e11, n11))
      return true;
    t10 = t10.next;
  } while (t10 !== e11);
  return false;
}
function Z2(e11, n11, t10, x10, r13, i15) {
  let u10 = 0;
  for (let o11 = x10, l6 = r13 - i15; o11 < r13; o11 += i15)
    u10 += (e11[l6 + n11 * i15] - e11[o11 + n11 * i15]) * (e11[o11 + 1 + n11 * i15] + e11[l6 + 1 + n11 * i15]), l6 = o11;
  return u10;
}
function a5(e11, n11, t10, x10, r13, i15, u10, o11) {
  return (r13 - u10) * (n11 - o11) - (e11 - u10) * (i15 - o11) >= 0 && (e11 - u10) * (x10 - o11) - (t10 - u10) * (n11 - o11) >= 0 && (t10 - u10) * (i15 - o11) - (r13 - u10) * (x10 - o11) >= 0;
}
function w5(e11, n11) {
  return s6(e11.prev, e11, e11.next) < 0 ? s6(e11, n11, e11.next) >= 0 && s6(e11, e11.prev, n11) >= 0 : s6(e11, n11, e11.prev) < 0 || s6(e11, e11.next, n11) < 0;
}
function z2(e11, n11, t10, x10, r13) {
  return (e11 = 1431655765 & ((e11 = 858993459 & ((e11 = 252645135 & ((e11 = 16711935 & ((e11 = 32767 * (e11 - t10) * r13) | e11 << 8)) | e11 << 4)) | e11 << 2)) | e11 << 1)) | (n11 = 1431655765 & ((n11 = 858993459 & ((n11 = 252645135 & ((n11 = 16711935 & ((n11 = 32767 * (n11 - x10) * r13) | n11 << 8)) | n11 << 4)) | n11 << 2)) | n11 << 1)) << 1;
}
function M(e11, n11) {
  return e11.x === n11.x && e11.y === n11.y;
}
function m2(e11, n11) {
  return e11.x - n11.x;
}
function b3(e11, n11, t10, x10) {
  let r13 = e11;
  do {
    const i15 = r13.prev, u10 = r13.next.next;
    !M(i15, u10) && h3(i15, r13, r13.next, u10) && w5(i15, u10) && w5(u10, i15) && (n11.push(i15.index / t10 + x10), n11.push(r13.index / t10 + x10), n11.push(u10.index / t10 + x10), o8(r13), o8(r13.next), r13 = e11 = u10), r13 = r13.next;
  } while (r13 !== e11);
  return r13;
}
function g3(e11, n11, r13, i15, u10, o11, l6) {
  let y10 = e11;
  do {
    let e12 = y10.next.next;
    for (; e12 !== y10.prev; ) {
      if (y10.index !== e12.index && k2(y10, e12)) {
        let f9 = j(y10, e12);
        return y10 = t9(y10, y10.next), f9 = t9(f9, f9.next), x3(y10, n11, r13, i15, u10, o11, l6, 0), void x3(f9, n11, r13, i15, u10, o11, l6, 0);
      }
      e12 = e12.next;
    }
    y10 = y10.next;
  } while (y10 !== e11);
}
function k2(e11, n11) {
  return e11.next.index !== n11.index && e11.prev.index !== n11.index && !d3(e11, n11) && w5(e11, n11) && w5(n11, e11) && A(e11, n11);
}
function A(e11, n11) {
  let t10 = e11, x10 = false;
  const r13 = (e11.x + n11.x) / 2, i15 = (e11.y + n11.y) / 2;
  do {
    t10.y > i15 != t10.next.y > i15 && t10.next.y !== t10.y && r13 < (t10.next.x - t10.x) * (i15 - t10.y) / (t10.next.y - t10.y) + t10.x && (x10 = !x10), t10 = t10.next;
  } while (t10 !== e11);
  return x10;
}
function j(e11, n11) {
  const t10 = q2.create(e11.index, e11.x, e11.y), x10 = q2.create(n11.index, n11.x, n11.y), r13 = e11.next, i15 = n11.prev;
  return e11.next = n11, n11.prev = e11, t10.next = r13, r13.prev = t10, x10.next = t10, t10.prev = x10, i15.next = x10, x10.prev = i15, x10;
}
var q2 = class _q {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e11, n11, t10) {
    const x10 = D < B.length ? B[D++] : new _q();
    return x10.index = e11, x10.x = n11, x10.y = t10, x10.prev = null, x10.next = null, x10.z = null, x10.prevZ = null, x10.nextZ = null, x10.steiner = false, x10;
  }
};
var B = new Array();
var C3 = 8096;
var D = 0;
for (let E4 = 0; E4 < C3; E4++)
  B.push(new q2());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var i12 = 1e-5;
var f5 = new e5(0, 0, 0, 1, 0);
var u5 = new e5(0, 0, 0, 1, 0);
function c8(t10, e11, n11) {
  let o11 = 0;
  for (let r13 = 1; r13 < n11; r13++) {
    const n12 = t10[2 * (e11 + r13 - 1)], s8 = t10[2 * (e11 + r13 - 1) + 1];
    o11 += (t10[2 * (e11 + r13)] - n12) * (t10[2 * (e11 + r13) + 1] + s8);
  }
  return o11;
}
function h4(t10, e11, n11, o11, r13) {
  let s8 = 0;
  const l6 = 2;
  for (let i15 = n11; i15 < o11; i15 += 3) {
    const n12 = (t10[i15] - r13) * l6, o12 = (t10[i15 + 1] - r13) * l6, f9 = (t10[i15 + 2] - r13) * l6;
    s8 += Math.abs((e11[n12] - e11[f9]) * (e11[o12 + 1] - e11[n12 + 1]) - (e11[n12] - e11[o12]) * (e11[f9 + 1] - e11[n12 + 1]));
  }
  return s8;
}
function a6(t10, e11) {
  const { coords: n11, lengths: o11, hasIndeterminateRingOrder: r13 } = e11, s8 = 0, f9 = t10;
  if (r13)
    return false;
  let u10 = 0;
  for (let a10 = 0; a10 < o11.length; ) {
    let t11 = a10, e12 = o11[a10], r14 = c8(n11, u10, e12);
    const g7 = [];
    for (; ++t11 < o11.length; ) {
      const s9 = o11[t11], l6 = c8(n11, u10 + e12, s9);
      if (!(l6 > 0))
        break;
      r14 += l6, g7.push(u10 + e12), e12 += s9;
    }
    const p10 = f9.length;
    e8(f9, n11, u10, u10 + e12, g7, 2, s8);
    const m6 = h4(f9, n11, p10, f9.length, s8), d10 = Math.abs(r14);
    if (Math.abs((m6 - d10) / Math.max(1e-7, d10)) > i12)
      return f9.length = 0, false;
    a10 = t11, u10 += e12;
  }
  return true;
}
function p4(t10) {
  const { coords: n11, lengths: o11 } = t10, { buffer: r13 } = r3(n11, o11);
  return r13;
}
function m3(t10, e11, n11) {
  let o11 = 0;
  for (let r13 = 0; r13 < t10.lengths.length; r13++) {
    const s8 = t10.lengths[r13];
    for (let r14 = 0; r14 < s8; r14++) {
      const s9 = t10.coords[2 * (r14 + o11)], l6 = t10.coords[2 * (r14 + o11) + 1];
      if (s9 < e11 || s9 > n11 || l6 < e11 || l6 > n11)
        return true;
    }
    o11 += s8;
  }
  return false;
}
function d4(t10, e11) {
  if (null == t10)
    return null;
  if (!m3(t10, -128, c + 128))
    return t10;
  f5.setPixelMargin(e11), f5.reset(t3.Polygon);
  let n11 = 0;
  for (let o11 = 0; o11 < t10.lengths.length; o11++) {
    const e12 = t10.lengths[o11];
    let r13 = t10.coords[2 * (0 + n11)], s8 = t10.coords[2 * (0 + n11) + 1];
    f5.moveTo(r13, s8);
    for (let o12 = 1; o12 < e12; o12++)
      r13 = t10.coords[2 * (o12 + n11)], s8 = t10.coords[2 * (o12 + n11) + 1], f5.lineTo(r13, s8);
    f5.close(), n11 += e12;
  }
  const l6 = f5.result(false);
  if (!l6)
    return null;
  const i15 = [], u10 = [];
  for (const o11 of l6) {
    let t11 = 0;
    for (const e12 of o11)
      u10.push(e12.x), u10.push(e12.y), t11++;
    i15.push(t11);
  }
  return new t(i15, u10);
}
function x4(t10, e11) {
  u5.setPixelMargin(e11);
  const n11 = u5, r13 = -e11, l6 = c + e11;
  let i15 = [], f9 = false;
  if (!t10.nextPath())
    return null;
  let c11 = true;
  for (; c11; ) {
    t10.seekPathStart();
    const e12 = [];
    if (!t10.numPoints)
      return null;
    n11.reset(t3.LineString), t10.nextPoint();
    let s8 = t10.x, u10 = t10.y;
    if (f9)
      n11.moveTo(s8, u10);
    else {
      if (s8 < r13 || s8 > l6 || u10 < r13 || u10 > l6) {
        f9 = true;
        continue;
      }
      e12.push({ x: s8, y: u10 });
    }
    let h7 = false;
    for (; t10.nextPoint(); )
      if (s8 = t10.x, u10 = t10.y, f9)
        n11.lineTo(s8, u10);
      else {
        if (s8 < r13 || s8 > l6 || u10 < r13 || u10 > l6) {
          h7 = true;
          break;
        }
        e12.push({ x: s8, y: u10 });
      }
    if (h7)
      f9 = true;
    else {
      if (f9) {
        const t11 = n11.resultWithStarts();
        if (t11)
          for (const e13 of t11)
            i15.push(e13);
      } else
        i15.push({ line: e12, start: 0 });
      c11 = t10.nextPath(), f9 = false;
    }
  }
  return i15 = i15.filter((t11) => t11.line.length > 1), 0 === i15.length ? null : i15;
}
f5.setExtent(c), u5.setExtent(c);

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseLineTemplate.js
var d5 = 8;
var x5 = 16;
var f6 = 65535;
var p5 = (r13) => class extends r13 {
  constructor(...e11) {
    super(...e11), this.tessellationProperties = {}, this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0 }, this.geometryType = E.LINE;
  }
  writeGeometry(e11, t10, i15, r14) {
    this._writeGeometry(e11, t10, i15, r14);
  }
  _initializeTessellator(e11) {
    const i15 = C2.load(this._materialKey), r14 = w3.load(this._materialKey), s8 = this._tessellationOptions, h7 = i15.vvSizeFieldStops || i15.vvSizeMinMaxValue || i15.vvSizeScaleStops || i15.vvSizeUnitValue, m6 = this.tessellationProperties._halfWidth < $ && !e11 && !h7;
    this.tessellationProperties.minMaxZoom = this._minMaxZoom, s8.wrapDistance = f6, s8.textured = this._isDashed || this._hasPattern, s8.offset = this.tessellationProperties.offset, s8.halfWidth = this.tessellationProperties._halfWidth;
    const d10 = m6 ? 0 : 1, x10 = O(r14) ? v4 : _2;
    this._lineTessellator = new c4(x10(this.tessellationProperties, d10, d10), u6(this.tessellationProperties), m6);
  }
  _write(e11, t10, i15, r14) {
    const s8 = "esriGeometryPoint" === t10.geometryType;
    e11.recordStart(t10.getDisplayId(), this._materialKey, this.geometryType, s8), this._writeGeometry(e11, t10, r14, s8), e11.recordEnd();
  }
  _writeGeometry(t10, i15, r14, s8) {
    const o11 = r14 || a4.fromFeatureSetReaderCIM(i15);
    if (!o11)
      return;
    const n11 = this._getLines(o11, s8);
    null != n11 && this._writeVertices(t10, i15, n11);
  }
  _getLines(e11, t10) {
    return x4(e11, t10 ? 256 : 16);
  }
  _writeVertices(e11, t10, i15) {
    const r14 = t10.getDisplayId(), s8 = e11.vertexCount(), o11 = this.tessellationProperties, h7 = this._tessellationOptions;
    o11.out = e11, o11.id = r14, o11.indexCount = 0, o11.vertexCount = 0, o11.offset = s8, h7.capType = this._capType, h7.joinType = this._joinType;
    const m6 = w3.load(this._materialKey);
    this.tessellationProperties.key = O(m6) ? m6 : C2.load(this._materialKey);
    for (const { line: n11, start: l6 } of i15)
      h7.initialDistance = l6 % f6, this._lineTessellator.tessellate(n11, h7);
  }
};
var _2 = (e11, t10, i15) => (o11, n11, l6, a10, h7, m6, f9, p10, _5, v6, u10) => {
  const W = w2(u10, Math.ceil(x5 * e11._halfWidth)), c11 = x(Math.round(x5 * f9), Math.round(x5 * p10), Math.round(x5 * _5), Math.round(x5 * v6)), y10 = x(x5 * h7, x5 * m6, 0, e11._bitset), M3 = e11.out;
  return M3.vertexBounds(o11, n11, t10, i15), M3.vertexWrite(w2(d5 * o11, d5 * n11)), M3.vertexWrite(e11.id), M3.vertexWrite(e11._fillColor), M3.vertexWrite(c11), M3.vertexWrite(W), M3.vertexWrite(e11._tl), M3.vertexWrite(e11._br), M3.vertexWrite(y10), M3.vertexWrite(w2(Math.ceil(x5 * e11._halfReferenceWidth), 0)), M3.vertexWrite(e11.minMaxZoom), M3.vertexEnd(), e11.offset + e11.vertexCount++;
};
var v4 = (e11, t10, i15) => (o11, n11, l6, a10, m6, f9, p10, _5, v6, u10, W) => {
  const c11 = w2(x5 * e11._halfWidth, x5 * e11._halfReferenceWidth), y10 = x(x5 * p10 + 128, x5 * _5 + 128, x5 * v6 + 128, x5 * u10 + 128), M3 = e11.out, C6 = e11._bitset << 24 | e11.id;
  M3.vertexBounds(o11, n11, t10, i15), M3.vertexWrite(w2(d5 * o11, d5 * n11)), M3.vertexWrite(C6), M3.vertexWrite(e11._fillColor);
  const P4 = b2(e11.key);
  return P4 || (M3.vertexWrite(0), M3.vertexWrite(0)), M3.vertexWrite(0), M3.vertexWrite(c11), M3.vertexWrite(y10), P4 || M3.vertexWrite(e11.minMaxZoom), M3.vertexEnd(), e11.offset + e11.vertexCount++;
};
var u6 = (e11) => (t10, i15, r13) => {
  const s8 = e11.out;
  s8.indexWrite(t10), s8.indexWrite(i15), s8.indexWrite(r13), e11.indexCount += 3;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMeshTemplate.js
var r9 = class {
  constructor() {
    this._materialKey = null;
  }
  bindFeature(e11, t10, r13) {
  }
  write(r13, s8, i15, f9) {
    if (this._effects && this._effects.length > 0) {
      let i16 = a4.fromFeatureSetReaderCIM(s8);
      if (i16) {
        i16.invertY();
        const e11 = l.executeEffects(this._effects, i16, r13.tileKey, f9.geometryEngine);
        for (; i16 = e11.next(); )
          i16.invertY(), this._write(r13, s8, f9, i16);
      }
    } else
      this._write(r13, s8, f9);
  }
  _write(e11, t10, r13, s8) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLineTemplate.js
var K = class _K extends p5(r9) {
  constructor(e11, t10, i15, r13, s8, o11, p10, f9, d10, y10, S5, _5, j4, g7, w9, K3, P4, x10, b5, O2) {
    super();
    const T = C2.load(e11);
    t10 && (T.sdf = t10.sdf, T.pattern = true, T.textureBinding = t10.textureBinding), this._capType = r13, this._joinType = s8, this._miterLimitCosine = c6(o11), this.tessellationProperties._fillColor = p10, this.tessellationProperties._tl = f9, this.tessellationProperties._br = d10, this._hasPattern = y10, this._isDashed = S5, this._zOrder = P4, this._effects = x10 || null, this._minMaxZoom = w2(Math.round(b5 * me), Math.round(O2 * me)), this._materialKey = T.data;
    const M3 = (j4 ? pe : 0) | (g7 ? ke : 0) | (_5 ? je : 0) | (w9 ? ge : 0);
    this.tessellationProperties._bitset = M3, this.tessellationProperties._halfWidth = 0.5 * i15, this.tessellationProperties._halfReferenceWidth = 0.5 * K3, this.tessellationProperties.offset = 0, this._initializeTessellator(false);
  }
  static fromCIMLine(e11, r13, l6) {
    const n11 = e11.color, a10 = e11.scaleFactor || 1, m6 = !!e11.dashTemplate;
    let c11 = e11.cap;
    m6 && c11 === e3.ROUND && (c11 = e3.SQUARE);
    const p10 = e11.join, f9 = u(e11.width) * a10, u10 = u(e11.referenceWidth), d10 = u(e11.miterLimit), y10 = n11 && t2(n11) || 0, [L4, _5] = v2(e11.scaleInfo, l6), j4 = false;
    if (!r13)
      return new _K(e11.materialKey, r13, f9, c11, p10, d10, y10, 0, 0, false, m6, e11.scaleDash ?? false, e11.colorLocked ?? false, j4, e11.sampleAlphaOnly, u10, e11.zOrder, e11.effects, L4, _5);
    const { rect: g7, width: w9, height: P4 } = r13, x10 = g7.x + ae, b5 = g7.y + ae, O2 = x10 + w9, T = b5 + P4, M3 = w2(x10, b5), W = w2(O2, T), z6 = false;
    return new _K(e11.materialKey, r13, f9, c11, p10, d10, y10, M3, W, true, m6, e11.scaleDash ?? false, e11.colorLocked ?? false, z6, e11.sampleAlphaOnly, u10, e11.zOrder, e11.effects, L4, _5);
  }
  static fromFillOutline(e11) {
    var _a;
    const t10 = w3.load(e11.materialKey);
    return O(t10) && e11.outline && "esriSLSSolid" === ((_a = e11.outline) == null ? void 0 : _a.style) ? _K.fromSimpleLine({ hash: "", materialKey: e11.materialKey, ...e11.outline }, null, true) : null;
  }
  static fromSimpleLine(e11, i15, s8 = false) {
    const { color: l6 } = e11, n11 = "esriSLSSolid" !== e11.style && "esriSLSNull" !== e11.style, a10 = k(e11.cap || "round"), m6 = G(e11.join || "round");
    let c11 = l6 && "esriSLSNull" !== e11.style && o5(l6) || 0;
    "esriSLSNull" === e11.style && (c11 = 0);
    const u10 = u(e11.width), d10 = e11.miterLimit;
    if (!i15)
      return new _K(e11.materialKey, i15, u10, a10, m6, d10, c11, 0, 0, false, n11, true, false, s8, false, u10, 0, null, n8, o7);
    const { rect: y10, width: L4, height: S5 } = i15, g7 = y10.x + ae, w9 = y10.y + ae, P4 = g7 + L4, x10 = w9 + S5, b5 = w2(g7, w9), O2 = w2(P4, x10);
    return new _K(e11.materialKey, i15, u10, a10, m6, d10, c11, b5, O2, true, n11, true, false, s8, false, u10, 0, null, n8, o7);
  }
  static fromPictureLineSymbol(t10, i15, r13, s8) {
    return s.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate").error("PictureLineSymbol support does not exist!"), null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseFillTemplate.js
var y4 = 100;
var p6 = 1;
var x6 = (x10) => class extends x10 {
  constructor(...t10) {
    super(...t10), this.forceLibtess = false, this._bitset = 0, this._lineTemplate = null, this.geometryType = E.FILL;
  }
  _maybeAddLineTemplate(e11) {
    this._lineTemplate = K.fromFillOutline(e11);
  }
  _write(e11, t10, r13, i15) {
    const l6 = "esriGeometryPoint" === t10.geometryType, n11 = w3.load(this._materialKey);
    e11.recordStart(t10.getDisplayId(), this._materialKey, this.geometryType, l6), this._writeGeometry(e11, t10, n11, i15, l6), O(n11) && null != this._lineTemplate && this._lineTemplate.writeGeometry(e11, t10, i15, l6), e11.recordEnd();
  }
  _writeGeometry(e11, t10, r13, i15, s8) {
    const o11 = this._getGeometry(t10, i15, s8);
    if (null == o11)
      return;
    const l6 = [];
    if (!(o11.maxLength > y4) && !this.forceLibtess && a6(l6, o11))
      return void (l6.length && this._writeVertices(e11, t10, o11.coords, o11.lengths, r13, l6));
    const a10 = p4(o11);
    this._writeVertices(e11, t10, a10, [a10.length / 2], r13);
  }
  _writeVertex(e11, i15, s8, o11, n11, m6) {
    const a10 = w2(p6 * o11, p6 * n11);
    if (e11.vertexBounds(o11, n11, 0, 0), e11.vertexWrite(a10), e11.vertexWrite(i15), s8.symbologyType === S.DOT_DENSITY)
      e11.vertexWriteF32(1 / Math.abs(m6.readGeometryArea()));
    else {
      e11.vertexWrite(this.fillColor);
      const t10 = b2(s8);
      t10 || (e11.vertexWrite(this.tl), e11.vertexWrite(this.br)), e11.vertexWrite(this.aux21), e11.vertexWrite(this.aux22), e11.vertexWrite(this.aux3), t10 || e11.vertexWrite(this._minMaxZoom);
    }
  }
  _writeVertices(e11, t10, r13, s8, o11, l6) {
    const n11 = t10.getDisplayId(), m6 = this._bitset << 24 | n11, a10 = s8.reduce((e12, t11) => e12 + t11), h7 = R2(o11.geometryType, o11.symbologyType).geometry / 4, y10 = e11.vertexCount();
    e11.vertexEnsureSize(h7 * a10);
    let p10 = 0;
    if (l6)
      for (const i15 of l6) {
        const s9 = r13[2 * i15], l7 = r13[2 * i15 + 1];
        this._writeVertex(e11, m6, o11, s9, l7, t10), p10++;
      }
    else
      for (let i15 = 0; i15 < r13.length; i15 += 2) {
        const s9 = Math.round(r13[i15]), l7 = Math.round(r13[i15 + 1]);
        this._writeVertex(e11, m6, o11, s9, l7, t10), p10++;
      }
    e11.indexEnsureSize(p10);
    for (let i15 = 0; i15 < p10; i15++)
      e11.indexWrite(i15 + y10);
  }
  _getGeometry(e11, t10, r13) {
    const i15 = (t10 == null ? void 0 : t10.asOptimized()) || e11.readGeometryForDisplay();
    if (!i15)
      return null;
    return d4(i15, r13 ? 256 : 8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMeshTemplate.js
var i13 = s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");
var r10 = class extends r9 {
  constructor(e11) {
    super(), this._ongoingMaterialRequestMap = /* @__PURE__ */ new Map(), this._materialCache = /* @__PURE__ */ new Map(), this._dynamicPropertyMap = /* @__PURE__ */ new Map(), this._cimLayer = e11;
  }
  async analyze(e11, s8, r13, n11, l6) {
    if (l6 && 0 === l6.length)
      return null;
    const o11 = l6 && l6.length > 0, m6 = s8.readLegacyFeature(), c11 = s8.getObjectId(), h7 = this._materialCache, u10 = this._cimLayer.materialHash;
    if (!u10)
      return i13.error("A Dynamic mesh template must have a material hash value or function!"), null;
    const p10 = "function" == typeof u10 ? u10(m6, r13, n11, c11) : u10, g7 = h7.get(p10);
    if (null != g7)
      return g7;
    const y10 = this._ongoingMaterialRequestMap.get(p10);
    if (y10)
      return y10;
    const M3 = this._cimLayer, d10 = V(M3.cim, this._cimLayer.materialOverrides);
    d10.mosaicHash = p10;
    const { type: f9, url: _5 } = M3, b5 = { cim: d10, type: f9, mosaicHash: p10, url: _5, size: null, dashTemplate: null, text: null, fontName: null, objectId: c11, animatedSymbolProperties: null };
    switch (f9) {
      case "marker":
        b5.size = t5(M3.size, m6, r13, n11), b5.animatedSymbolProperties = t5(M3.animatedSymbolProperties, m6, r13, n11);
        break;
      case "line":
        b5.dashTemplate = M3.dashTemplate;
        break;
      case "text":
        b5.text = t5(M3.text, m6, r13, n11), b5.fontName = t5(M3.fontName, m6, r13, n11);
    }
    const L4 = e11.getMosaicItem(b5, l6).then((e12) => (o11 || (this._ongoingMaterialRequestMap.delete(p10), h7.set(p10, e12)), e12)).catch((e12) => (this._ongoingMaterialRequestMap.delete(p10), i13.error(".analyze()", e12.message), null));
    return o11 || this._ongoingMaterialRequestMap.set(p10, L4), L4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Result.js
function e9(e11, n11) {
  if (e11 && "name" in e11) {
    const o11 = e11;
    return n11 && n11.error(new s2(o11.name, o11.message, o11.details)), false;
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicFillTemplate.js
var j2 = class _j extends x6(r10) {
  constructor(l6, h7, n11) {
    var _a;
    if (super(l6), this._minMaxZoom = w2(Math.round(h7 * me), Math.round(n11 * me)), e6(l6.color)) {
      const t10 = (t11, e11, i15) => {
        const o11 = l6.color(t11, e11, i15);
        return o11 && t2(o11) || 0;
      };
      this._dynamicPropertyMap.set("fillColor", t10);
    } else {
      const t10 = l6.color;
      this.fillColor = t10 && t2(t10) || 0;
    }
    const c11 = "CIMMarkerPlacementInsidePolygon" === ((_a = l6.cim.placement) == null ? void 0 : _a.type) && l6.cim.placement.shiftOddRows ? 2 : 1, f9 = l6.height;
    if (e6(f9)) {
      const t10 = (t11, e11, s8) => f9(t11, e11, s8) * c11;
      this._dynamicPropertyMap.set("_height", t10);
    } else
      this._height = (f9 || 0) * c11;
    const y10 = l6.offsetX;
    if (e6(y10)) {
      const e11 = (e12, s8, i15) => u(y10(e12, s8, i15));
      this._dynamicPropertyMap.set("_offsetX", e11);
    } else
      this._offsetX = u(y10 || 0);
    const d10 = l6.offsetY;
    if (e6(d10)) {
      const e11 = (e12, s8, i15) => u(-d10(e12, s8, i15));
      this._dynamicPropertyMap.set("_offsetY", e11);
    } else
      this._offsetY = u(-d10 || 0);
    const u10 = l6.scaleX;
    e6(u10) ? this._dynamicPropertyMap.set("_scaleX", u10) : this._scaleX = u10 || 1;
    const M3 = l6.angle;
    if (e6(M3)) {
      const t10 = (t11, e11, s8) => c3(M3(t11, e11, s8));
      this._dynamicPropertyMap.set("_angle", t10);
    } else
      this._angle = c3(M3) || 0;
    if (null != l6.effects) {
      const t10 = l6.effects;
      e6(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._cimFillLayer = l6, this._bitset = (l6.colorLocked ? pe : 0) | (l6.applyRandomOffset ? ue : 0) | (l6.sampleAlphaOnly ? ge : 0) | (l6.hasUnresolvedReplacementColor ? ve : 0), this._fillMaterialKey = l6.materialKey;
  }
  static fromCIMFill(t10, e11) {
    const [s8, i15] = v2(t10.scaleInfo, e11);
    return new _j(t10, s8, i15);
  }
  bindFeature(e11, s8, i15) {
    const o11 = e11.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t10, e12) => {
      this[e12] = t10(o11, s8, i15);
    });
    const r13 = w3.load(this._fillMaterialKey), a10 = this._materialCache, m6 = (0, this._cimFillLayer.materialHash)(o11, s8, i15), p10 = a10.get(m6);
    let u10 = null;
    if (p10 && e9(p10.spriteMosaicItem) && (u10 = p10.spriteMosaicItem), u10) {
      const { rect: e12, width: s9, height: i16 } = u10, o12 = e12.x + ae, a11 = e12.y + ae, m7 = o12 + s9, p11 = a11 + i16;
      let d10 = u(this._height);
      d10 <= 0 && (d10 = p11 - a11), d10 < i2 && (d10 *= h, this._bitset |= ye), d10 = Math.round(d10);
      let M3 = u(this._height / i16 * s9);
      M3 <= 0 && (M3 = m7 - o12), M3 < i2 && (M3 *= h, this._bitset |= be), M3 = Math.round(M3);
      const g7 = this._scaleX, x10 = 1;
      this.tl = w2(o12, a11), this.br = w2(m7, p11), this.aux21 = w2(M3, d10), this.aux22 = w2(this._offsetX, this._offsetY), this.aux3 = x(g7 * h, x10 * h, this._angle, 0), r13.sdf = u10.sdf, r13.pattern = true, r13.textureBinding = u10.textureBinding;
    } else
      this.tl = 0, this.br = 0, this.aux21 = 0, this.aux22 = 0, this.aux3 = 0, r13.sdf = false, r13.pattern = false, r13.textureBinding = 0;
    this._materialKey = r13.data;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicLineTemplate.js
var d6 = class _d extends p5(r10) {
  constructor(a10, n11, m6) {
    super(a10), this._minMaxZoom = w2(Math.round(n11 * me), Math.round(m6 * me)), this._cimLineLayer = a10;
    let p10 = 0;
    e6(a10.width) || (p10 = 0.5 * u(a10.width));
    const _5 = (i15, s8, r13) => e6(a10.width) ? 0.5 * u(a10.width(i15, s8, r13)) : p10;
    this._dynamicPropertyMap.set("_halfWidth", _5), e6(a10.cap) ? this._dynamicPropertyMap.set("_capType", a10.cap) : this._capType = a10.cap, e6(a10.join) ? this._dynamicPropertyMap.set("_joinType", a10.join) : this._joinType = a10.join;
    const f9 = a10.color;
    if (e6(f9)) {
      const t10 = (t11, e11, s8) => t2(f9(t11, e11, s8));
      this._dynamicPropertyMap.set("_fillColor", t10);
    } else
      this._fillColor = f9 && t2(f9) || 0;
    const d10 = a10.miterLimit;
    if (e6(d10)) {
      const t10 = (t11, e11, i15) => c6(d10(t11, e11, i15));
      this._dynamicPropertyMap.set("_miterLimitCosine", t10);
    } else
      this._miterLimitCosine = c6(d10);
    if (null != a10.effects) {
      const t10 = a10.effects;
      e6(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    this._scaleFactor = a10.scaleFactor || 1, this._isDashed = null != a10.dashTemplate;
    const y10 = a10.colorLocked ? pe : 0, P4 = a10.scaleDash ? je : 0, u10 = a10.sampleAlphaOnly ? ge : 0;
    this.tessellationProperties._bitset = y10 | P4 | u10, this._materialKey = a10.materialKey, this._initializeTessellator(true);
  }
  static fromCIMLine(t10, e11) {
    const [i15, s8] = v2(t10.scaleInfo, e11);
    return new _d(t10, i15, s8);
  }
  bindFeature(t10, e11, i15) {
    const s8 = t10.readLegacyFeature();
    this._dynamicPropertyMap.forEach((t11, r14) => {
      this[r14] = t11(s8, e11, i15);
    }), this._halfWidth *= this._scaleFactor;
    const r13 = this._materialCache, o11 = (0, this._cimLineLayer.materialHash)(s8, e11, i15), l6 = r13.get(o11);
    let c11 = null;
    if (l6 && e9(l6.spriteMosaicItem) && (c11 = l6.spriteMosaicItem), c11) {
      this._hasPattern = true;
      const { rect: t11, width: e12, height: i16 } = c11, s9 = t11.x + ae, r14 = t11.y + ae, o12 = s9 + e12, l7 = r14 + i16;
      this.tessellationProperties._tl = w2(s9, r14), this.tessellationProperties._br = w2(o12, l7);
    } else
      this._hasPattern = false, this.tessellationProperties._tl = 0, this.tessellationProperties._br = 0;
    this.tessellationProperties._fillColor = this._fillColor, this.tessellationProperties._halfWidth = this._halfWidth, this.tessellationProperties.offset = 0, this.tessellationProperties._halfReferenceWidth = this.tessellationProperties._halfWidth;
    const m6 = C2.load(this._materialKey);
    c11 && (m6.sdf = c11.sdf, m6.pattern = true, m6.textureBinding = c11.textureBinding), this._materialKey = m6.data;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e10 = class {
  static getPlacement(e11, r13, n11, s8, c11, o11) {
    const a10 = g(n11);
    if (!a10)
      return null;
    -1 === r13 && e11.invertY();
    return a10.execute(e11, n11, s8, c11, o11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseMarkerTemplate.js
var g4 = 3.14159265359 / 180;
var u7 = 8;
var y5 = (y10) => class extends y10 {
  constructor(...t10) {
    super(...t10), this.angle = 0, this.xOffset = 0, this.yOffset = 0, this.width = 0, this.height = 0, this.boundsType = "square", this._anchorX = 0, this._anchorY = 0, this._computedWidth = 0, this._computedHeight = 0, this._allowBorrowing = true, this._vertexBoundsScaleX = 1, this._vertexBoundsScaleY = 1, this.geometryType = E.MARKER;
  }
  _write(t10, e11, i15, r13) {
    const s8 = e11.getDisplayId();
    t10.recordStart(s8, this._materialKey, this.geometryType, true), this._writeGeometry(t10, e11, s8, i15, r13), t10.recordEnd();
  }
  _writeGeometry(t10, e11, i15, r13, s8) {
    if (null != this._markerPlacement)
      return this._writePlacedMarkers(t10, e11, r13, s8);
    if (this._allowBorrowing = true, !s8 && "esriGeometryPoint" === e11.geometryType) {
      const r14 = e11.getX(), s9 = e11.getY();
      if (!t10.hasAggregates && t10.hasPixelBufferEnabled && (r14 < 0 || r14 >= 513 || s9 < 0 || s9 >= 513))
        return;
      return this._writeVertices(t10, i15, this._getPos(r14, s9), r14, s9);
    }
    const o11 = s8 ? s8.asOptimized() : "esriGeometryPolygon" === e11.geometryType ? e11.readCentroid() : e11.readGeometryForDisplay();
    if (null != o11) {
      if (o11.isPoint) {
        const [e12, r14] = o11.coords;
        if (!t10.hasAggregates && t10.hasPixelBufferEnabled && (e12 < 0 || e12 >= 512 || r14 < 0 || r14 >= 512))
          return;
        return this._writeVertices(t10, i15, this._getPos(e12, r14), e12, r14);
      }
      o11.forEachVertex((e12, r14) => {
        const s9 = 2 * c;
        e12 < -s9 || e12 >= s9 || r14 < -s9 || r14 >= s9 || this._writeVertices(t10, i15, this._getPos(e12, r14), e12, r14);
      });
    }
  }
  _writePlacedMarkers(e11, i15, r13, s8) {
    const h7 = s8 || a4.fromFeatureSetReaderCIM(i15);
    if (!h7)
      return;
    const n11 = -1, a10 = e10.getPlacement(h7, n11, this._markerPlacement, u(1), e11.tileKey, r13.geometryEngine);
    if (!a10)
      return;
    this._allowBorrowing = "esriGeometryPolygon" !== i15.geometryType;
    const _5 = i15.getDisplayId(), l6 = n4(), c11 = n2(), d10 = -128, v6 = 640;
    let W = a10.next();
    for (; null != W; ) {
      const t10 = W.tx, i16 = -W.ty;
      t10 >= d10 && t10 <= v6 && i16 >= d10 && i16 <= v6 && (this._applyTransformation(c11, l6, -W.getAngle() / g4), this._writeVertices(e11, _5, this._getPos(t10, i16), t10, i16)), W = a10.next();
    }
  }
  _writeVertices(t10, e11, i15, r13, s8) {
    const o11 = N.load(this._materialKey);
    return o11.symbologyType === S.HEATMAP ? this._writeHeatmapVertices(t10, e11, i15) : this._writeMarkerVertices(t10, e11, o11, i15, r13, s8);
  }
  _writeMarkerVertices(t10, e11, i15, r13, s8, o11) {
    const h7 = i15.vvRotation, n11 = t10.vertexCount();
    let a10 = this._computedWidth * this._vertexBoundsScaleX, x10 = this._computedHeight * this._vertexBoundsScaleY;
    if (this.angle) {
      const t11 = Math.max(a10, x10);
      a10 = t11, x10 = t11;
    }
    if (h7) {
      const t11 = Math.max(this.xOffset, this.yOffset);
      a10 += t11, x10 += t11;
    }
    this._allowBorrowing && t10.vertexBounds(s8 + this.xOffset, o11 - this.yOffset, a10, x10), t10.vertexWrite(r13), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(this._texUpperLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(this._texUpperRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(this._texBottomLeft), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), t10.vertexWrite(r13), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(this._texBottomRight), t10.vertexWrite(this._bitestAndDistRatio), t10.vertexWrite(e11), t10.vertexWrite(this._fillColor), t10.vertexWrite(this._outlineColor), t10.vertexWrite(this._sizeOutlineWidth), t10.vertexWrite(this._minMaxZoom), t10.vertexEnd(), this._writeIndices(t10, n11);
  }
  _writeHeatmapVertices(t10, e11, i15) {
    const r13 = t10.vertexCount();
    t10.vertexWrite(i15), t10.vertexWrite(this._offsetUpperLeft), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i15), t10.vertexWrite(this._offsetUpperRight), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i15), t10.vertexWrite(this._offsetBottomLeft), t10.vertexWrite(e11), t10.vertexEnd(), t10.vertexWrite(i15), t10.vertexWrite(this._offsetBottomRight), t10.vertexWrite(e11), t10.vertexEnd(), this._writeIndices(t10, r13);
  }
  _writeIndices(t10, e11) {
    t10.indexWrite(e11 + 0), t10.indexWrite(e11 + 1), t10.indexWrite(e11 + 2), t10.indexWrite(e11 + 1), t10.indexWrite(e11 + 3), t10.indexWrite(e11 + 2);
  }
  _applyTransformation(t10, o11, x10 = 0) {
    x10 ? h2(t10, g4 * x10) : n(t10), i6(t10, t10, t4(this.xOffset, -this.yOffset)), this.angle && e4(t10, t10, g4 * this.angle);
    const f9 = this._computedWidth, m6 = this._computedHeight, _5 = -(0.5 + this._anchorX) * f9, l6 = -(0.5 - this._anchorY) * m6;
    r2(o11, _5, l6), z(o11, o11, t10), this._offsetUpperLeft = w2(16 * o11[0], 16 * o11[1]), r2(o11, _5 + f9, l6), z(o11, o11, t10), this._offsetUpperRight = w2(16 * o11[0], 16 * o11[1]), r2(o11, _5, l6 + m6), z(o11, o11, t10), this._offsetBottomLeft = w2(16 * o11[0], 16 * o11[1]), r2(o11, _5 + f9, l6 + m6), z(o11, o11, t10), this._offsetBottomRight = w2(16 * o11[0], 16 * o11[1]);
  }
  _computeSize(t10, e11, i15, r13, s8, o11, h7, n11) {
    const a10 = t10 * i15, x10 = e11 * i15;
    if (!!o11.sdf && !h7) {
      const i16 = n11 && t10 > e11 ? a10 : t10, s9 = e11, o12 = r13 + 2 * 1;
      t10 = Math.min(i16 + o12, a10), e11 = Math.min(s9 + o12, x10);
    } else
      t10 = a10, e11 = x10;
    const f9 = ce / Math.max(a10, x10), m6 = 0.5 * (a10 - t10) * f9, l6 = 0.5 * (x10 - e11) * f9, d10 = o11.rect.x + ae + m6, v6 = o11.rect.y + ae + l6, p10 = d10 + o11.width - 2 * m6, g7 = v6 + o11.height - 2 * l6, u10 = Math.floor(d10), y11 = Math.floor(v6), w9 = Math.ceil(p10), M3 = Math.ceil(g7);
    t10 *= (w9 - u10) / (p10 - d10), e11 *= (M3 - y11) / (g7 - v6), this._texUpperLeft = w2(u10, y11), this._texUpperRight = w2(w9, y11), this._texBottomLeft = w2(u10, M3), this._texBottomRight = w2(w9, M3), this._anchorX *= a10 / t10, this._anchorY *= x10 / e11, t10 *= s8, e11 *= s8, this._computedWidth = t10, this._computedHeight = e11;
  }
  _getPos(t10, e11) {
    return w2(Math.round(u7 * t10), Math.round(u7 * e11));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicMarkerTemplate.js
var k3 = n4();
var P2 = n2();
var L = class _L extends y5(r10) {
  constructor(t10, e11, i15) {
    super(t10), this._cimMarkerLayer = t10, this._minMaxZoom = w2(Math.round(e11 * me), Math.round(i15 * me));
    const r13 = t10.color;
    if (e6(r13)) {
      const t11 = (t12, e12, s8) => t2(r13(t12, e12, s8));
      this._dynamicPropertyMap.set("_fillColor", t11);
    } else
      this._fillColor = t2(r13);
    const y10 = t10.outlineColor;
    if (e6(y10)) {
      const t11 = (t12, e12, s8) => t2(y10(t12, e12, s8));
      this._dynamicPropertyMap.set("_outlineColor", t11);
    } else
      this._outlineColor = t2(y10);
    const p10 = t10.size;
    if (e6(p10)) {
      const t11 = (t12, e12, i16) => u(p10(t12, e12, i16));
      this._dynamicPropertyMap.set("_size", t11);
    } else
      this._size = u(p10) || 0;
    const M3 = t10.scaleX;
    e6(M3) ? this._dynamicPropertyMap.set("_scaleX", M3) : this._scaleX = M3;
    const d10 = t10.offsetX;
    if (e6(d10)) {
      const t11 = (t12, e12, i16) => u(d10(t12, e12, i16));
      this._dynamicPropertyMap.set("xOffset", t11);
    } else
      this.xOffset = u(d10) || 0;
    const u10 = t10.offsetY;
    if (e6(u10)) {
      const t11 = (t12, e12, i16) => u(u10(t12, e12, i16));
      this._dynamicPropertyMap.set("yOffset", t11);
    } else
      this.yOffset = u(u10) || 0;
    const g7 = t10.outlineWidth;
    if (e6(g7)) {
      const t11 = (t12, e12, i16) => u(g7(t12, e12, i16));
      this._dynamicPropertyMap.set("_outlineWidth", t11);
    } else
      this._outlineWidth = u(g7) || 0;
    const k6 = t10.rotation;
    if (e6(k6) ? this._dynamicPropertyMap.set("_angle", k6) : this._angle = k6 || 0, null != t10.effects) {
      const e12 = t10.effects;
      e6(e12) ? this._dynamicPropertyMap.set("_effects", e12) : this._effects = e12;
    }
    if (null != t10.markerPlacement) {
      const e12 = t10.markerPlacement;
      e6(e12) ? this._dynamicPropertyMap.set("_markerPlacement", e12) : this._markerPlacement = e12;
    }
    this._scaleFactor = t10.scaleFactor ?? 1, this._bitSet = (t10.alignment === i4.MAP ? ne : le) | (t10.colorLocked ? pe : 0) | (t10.scaleSymbolsProportionally ? xe : 0), this._materialKey = t10.materialKey;
  }
  static fromCIMMarker(t10, e11) {
    const [s8, i15] = v2(t10.scaleInfo, e11);
    return new _L(t10, s8, i15);
  }
  bindFeature(i15, r13, o11) {
    const a10 = i15.readLegacyFeature(), n11 = i15.getObjectId();
    this._dynamicPropertyMap.forEach((t10, e11) => {
      this[e11] = t10(a10, r13, o11);
    });
    const c11 = this._cimMarkerLayer.materialHash, h7 = "function" == typeof c11 ? c11(a10, r13, o11, n11) : c11, m6 = this._materialCache.get(h7);
    if (!m6 || !e9(m6.spriteMosaicItem) || !m6.spriteMosaicItem)
      return void s.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate").error(new s2("mapview-cim", "Encountered an error when binding feature"));
    const l6 = m6.spriteMosaicItem, f9 = this._cimMarkerLayer.sizeRatio, M3 = l6.width / l6.height * this._scaleX, d10 = N.load(this._materialKey);
    d10.sdf = l6.sdf, d10.pattern = true, d10.textureBinding = l6.textureBinding, this._materialKey = d10.data;
    const u10 = this._cimMarkerLayer.rotateClockwise ? this._angle : -this._angle, L4 = this._size, j4 = L4 * M3, b5 = this.xOffset, z6 = this.yOffset;
    this.xOffset *= this._scaleFactor, this.yOffset *= this._scaleFactor;
    const x10 = this._cimMarkerLayer.scaleSymbolsProportionally && this._cimMarkerLayer.frameHeight ? this._size / u(this._cimMarkerLayer.frameHeight) : 1, O2 = this._outlineWidth * x10, w9 = u(this._cimMarkerLayer.referenceSize);
    let C6 = 0, W = 0;
    const F2 = this._cimMarkerLayer.anchorPoint;
    F2 && (this._cimMarkerLayer.isAbsoluteAnchorPoint ? this._size && (C6 = u(F2.x) / (this._size * M3), W = u(F2.y) / this._size) : (C6 = F2.x, W = F2.y)), this._anchorX = C6, this._anchorY = W, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * j4), 255)), Math.round(Math.min(Math.sqrt(128 * L4), 255)), Math.round(Math.min(Math.sqrt(128 * O2), 255)), Math.round(Math.min(Math.sqrt(128 * w9), 255))), this.angle = u10;
    const S5 = Math.round(64 * f9);
    this._bitestAndDistRatio = w2(this._bitSet, S5), this._computeSize(j4, L4, f9, O2, this._scaleFactor, l6, d10.hasSizeVV(), true), this._applyTransformation(P2, k3), this.xOffset = b5, this.yOffset = z6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLBaseTextTemplate.js
var a7 = 8;
var x7 = w2(4, 4);
var _3 = w2(16, 4);
var c9 = w2(4, 2);
var l4 = w2(4, 6);
var u8 = [c9, c9, l4, l4];
var g5 = [c9, l4, c9, l4];
var m4 = [l4, l4, x7, x7];
var f7 = [x7, x7, l4, l4];
var y6 = [l4, x7, l4, x7];
var p7 = [x7, l4, x7, l4];
var w6 = (x10) => class extends x10 {
  constructor(...e11) {
    super(...e11), this._isCIM = false, this._vertexBoundsScale = 1, this.geometryType = E.TEXT, this._aux = x(0, 0, this._referenceSize, this._bitset);
  }
  bindTextInfo(e11, t10) {
    e11 && e11.length ? this._shapingInfo = S2(e11, t10, { scale: this._scale, angle: this._angle, xOffset: this._xOffset, yOffset: this._yOffset, hAlign: this._xAlignD, vAlign: this._yAlignD, maxLineWidth: Math.max(32, Math.min(this._lineWidth, 512)), lineHeight: w * Math.max(0.25, Math.min(this._lineHeight, 4)), decoration: this._decoration, isCIM: this._isCIM, hasBackground: !!this._backgroundColor, borderLineSize: this._borderLineSize }) : this._shapingInfo = null;
  }
  _write(e11, t10, r13, i15) {
    const o11 = t10.getDisplayId();
    this._writeGeometry(e11, t10, o11, r13, i15);
  }
  _writeGeometry(e11, t10, r13, i15, o11) {
    const s8 = this._shapingInfo;
    if (null == s8)
      return;
    if (this._textPlacement)
      return this._writePlacedText(e11, r13, s8, i15, t10, o11);
    const n11 = o11 ? o11.asOptimized() : "esriGeometryPolygon" === t10.geometryType ? t10.readCentroid() : t10.readGeometryForDisplay();
    if (null != n11) {
      if (n11.isPoint) {
        const [t11, i16] = n11.coords;
        if (!e11.hasAggregates && e11.hasPixelBufferEnabled && (t11 < 0 || t11 >= 512 || i16 < 0 || i16 >= 512))
          return;
        return this._writeGlyphs(e11, r13, { x: t11, y: i16 }, s8);
      }
      n11.forEachVertex((t11, i16) => this._writeGlyphs(e11, r13, { x: t11, y: i16 }, s8));
    }
  }
  _writePlacedText(i15, o11, s8, n11, h7, d10) {
    const a10 = this._textPlacement, x11 = d10 || a4.fromFeatureSetReaderCIM(h7);
    if (!x11)
      return;
    const _5 = -1, c11 = e10.getPlacement(x11, _5, a10, u(1), i15.tileKey, n11.geometryEngine);
    if (!c11)
      return;
    const l6 = s8.bounds, u10 = Math.sqrt(l6.height * l6.height + l6.width * l6.width);
    let g7, m6, f9;
    for (; g7 = c11.next(); )
      if (m6 = g7.tx, f9 = -g7.ty, m6 + u10 >= 0 && m6 - u10 < 512 && f9 + u10 >= 0 && f9 - u10 < 512) {
        const e11 = -g7.getAngle();
        s8.setRotation(e11), this._writeGlyphs(i15, o11, { x: m6, y: f9 }, s8), s8.setRotation(-e11);
      }
  }
  _writeGlyphs(e11, t10, r13, i15) {
    const o11 = U.load(this._materialKey), s8 = w2(Math.round(a7 * r13.x), Math.round(a7 * r13.y)), d10 = this._vertexBoundsScale, { bounds: x11, background: _5, glyphs: c11 } = i15;
    c11.length > 0 && (this._borderLineColor || this._backgroundColor) && (o11.textureBinding = c11[0].textureBinding, e11.recordStart(t10, o11.data, this.geometryType, true), this._writeBackgroundGeometry(e11, t10, r13, x11, _5), e11.recordEnd());
    const l6 = 2 * Math.max(x11.width, x11.height);
    for (const n11 of i15.glyphs)
      o11.textureBinding = n11.textureBinding, e11.recordStart(t10, o11.data, this.geometryType, true), e11.vertexBounds(r13.x + x11.x + this._xOffset, r13.y + x11.y - this._yOffset, l6 * d10, l6 * d10), this._writeVertices(e11, t10, s8, n11), e11.recordEnd();
  }
  _writeGlyph(e11, t10, r13, i15, o11) {
    const s8 = U.load(this._materialKey), d10 = w2(Math.round(a7 * r13), Math.round(a7 * i15));
    s8.textureBinding = o11.textureBinding, e11.recordStart(t10, s8.data, this.geometryType, true);
    const x11 = o11.bounds, _5 = this._vertexBoundsScale;
    e11.vertexBounds(r13 + x11.x * _5, i15 + x11.y * _5, x11.width * _5, x11.height * _5), this._writeVertices(e11, t10, d10, o11), e11.recordEnd();
  }
  _writeVertices(e11, t10, r13, i15) {
    const o11 = e11.vertexCount();
    this._writeVertexCommon(e11, t10, r13, i15), e11.vertexWrite(i15.offsets.upperLeft), e11.vertexWrite(i15.texcoords.upperLeft), e11.vertexEnd(), this._writeVertexCommon(e11, t10, r13, i15), e11.vertexWrite(i15.offsets.upperRight), e11.vertexWrite(i15.texcoords.upperRight), e11.vertexEnd(), this._writeVertexCommon(e11, t10, r13, i15), e11.vertexWrite(i15.offsets.lowerLeft), e11.vertexWrite(i15.texcoords.lowerLeft), e11.vertexEnd(), this._writeVertexCommon(e11, t10, r13, i15), e11.vertexWrite(i15.offsets.lowerRight), e11.vertexWrite(i15.texcoords.lowerRight), e11.vertexEnd(), e11.indexWrite(o11 + 0), e11.indexWrite(o11 + 1), e11.indexWrite(o11 + 2), e11.indexWrite(o11 + 1), e11.indexWrite(o11 + 3), e11.indexWrite(o11 + 2);
  }
  _writeVertexCommon(e11, t10, r13, i15) {
    const o11 = this._color, n11 = this._haloColor, h7 = x(0, 0, this._referenceSize, this._bitset), d10 = x(0, 0, this._size, this._haloSize);
    e11.vertexWrite(r13), e11.vertexWrite(t10), e11.vertexWrite(o11), e11.vertexWrite(n11), e11.vertexWrite(d10), e11.vertexWrite(h7), e11.vertexWrite(this._minMaxZoom);
  }
  _writeBackgroundVertex(e11, t10, r13, i15, o11, n11) {
    const h7 = x(0, 1, this._referenceSize, this._bitset), d10 = x(0, 0, this._size, this._haloSize), a10 = x(0, 0, 0, 0);
    e11.vertexWrite(r13), e11.vertexWrite(t10), e11.vertexWrite(i15), e11.vertexWrite(a10), e11.vertexWrite(d10), e11.vertexWrite(h7), e11.vertexWrite(this._minMaxZoom), e11.vertexWrite(o11), e11.vertexWrite(n11), e11.vertexEnd();
  }
  _writeBackgroundQuad(e11, t10, r13, i15, o11, s8) {
    const n11 = e11.vertexCount();
    this._writeBackgroundVertex(e11, t10, r13, i15, o11.upperLeft, s8[0]), this._writeBackgroundVertex(e11, t10, r13, i15, o11.upperRight, s8[1]), this._writeBackgroundVertex(e11, t10, r13, i15, o11.lowerLeft, s8[2]), this._writeBackgroundVertex(e11, t10, r13, i15, o11.lowerRight, s8[3]), e11.indexWrite(n11 + 0), e11.indexWrite(n11 + 1), e11.indexWrite(n11 + 2), e11.indexWrite(n11 + 1), e11.indexWrite(n11 + 3), e11.indexWrite(n11 + 2);
  }
  _writeBackgroundGeometry(e11, t10, r13, i15, o11) {
    const s8 = w2(Math.round(a7 * r13.x), Math.round(a7 * r13.y)), { x: h7, y: d10, width: x11, height: c11 } = i15, l6 = 2 * Math.max(x11, c11);
    if (e11.vertexBounds(r13.x + h7 + this._xOffset, r13.y + d10 - this._yOffset, l6 * this._vertexBoundsScale, l6 * this._vertexBoundsScale), this._backgroundColor) {
      const r14 = [_3, _3, _3, _3];
      this._writeBackgroundQuad(e11, t10, s8, this._backgroundColor, o11.main, r14);
    }
    if (this._borderLineColor || this._backgroundColor) {
      const r14 = !!this._borderLineColor && !!this._borderLineSize && this._borderLineSize > 0, [i16, n11, h8, d11, a10] = r14 ? [u8, u8, g5, g5, this._borderLineColor] : [m4, f7, y6, p7, this._backgroundColor];
      this._writeBackgroundQuad(e11, t10, s8, a10, o11.top, i16), this._writeBackgroundQuad(e11, t10, s8, a10, o11.bot, n11), this._writeBackgroundQuad(e11, t10, s8, a10, o11.left, h8), this._writeBackgroundQuad(e11, t10, s8, a10, o11.right, d11);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLDynamicTextTemplate.js
var y7 = 5;
function p8(t10, e11, i15, s8) {
  return "string" == typeof t10.text ? t10.text : "function" == typeof t10.text ? t10.text(e11, i15, s8) ?? "" : "";
}
var d7 = class _d extends w6(r10) {
  constructor(s8, o11, n11) {
    super(s8), this._horizontalAlignment = "center", this._verticalAlignment = "middle", this._textToGlyphs = /* @__PURE__ */ new Map(), this._minMaxZoom = w2(Math.round(o11 * me), Math.round(n11 * me));
    const c11 = s8.scaleFactor || 1;
    this._cimTextLayer = s8;
    const m6 = s8.color;
    if (e6(m6)) {
      const t10 = (t11, e11, i15) => t2(m6(t11, e11, i15));
      this._dynamicPropertyMap.set("_color", t10);
    } else
      this._color = t2(m6);
    const _5 = s8.outlineColor;
    if (e6(_5)) {
      const t10 = (t11, e11, i15) => t2(_5(t11, e11, i15));
      this._dynamicPropertyMap.set("_haloColor", t10);
    } else
      this._haloColor = t2(_5);
    let f9;
    e6(s8.size) || (f9 = Math.min(Math.round(u(s8.size * s8.sizeRatio)), 127));
    const p10 = (e11, o12, r13) => e6(s8.size) ? Math.min(Math.round(u(s8.size(e11, o12, r13) * s8.sizeRatio)), 127) : f9;
    if (this._dynamicPropertyMap.set("_size", p10), e6(s8.outlineSize)) {
      const e11 = (e12, i15, o12) => Math.min(Math.floor(y7 * u(s8.outlineSize(e12, i15, o12) * s8.sizeRatio)), 127);
      this._dynamicPropertyMap.set("_haloSize", e11);
    } else
      this._haloSize = Math.min(Math.floor(y7 * u(s8.outlineSize * s8.sizeRatio)), 127);
    let d10;
    e6(s8.offsetX) || (d10 = Math.round(u(s8.offsetX * s8.sizeRatio)));
    const M3 = (e11, o12, r13) => e6(s8.offsetX) ? Math.round(u(s8.offsetX(e11, o12, r13) * s8.sizeRatio)) : d10;
    let u10;
    this._dynamicPropertyMap.set("_xOffset", M3), e6(s8.offsetY) || (u10 = Math.round(u(s8.offsetY * s8.sizeRatio)));
    const g7 = (e11, o12, r13) => e6(s8.offsetY) ? Math.round(u(s8.offsetY(e11, o12, r13) * s8.sizeRatio)) : u10;
    if (this._dynamicPropertyMap.set("_yOffset", g7), e6(s8.angle) ? this._dynamicPropertyMap.set("_angle", s8.angle) : this._angle = s8.angle, e6(s8.horizontalAlignment) ? this._dynamicPropertyMap.set("_horizontalAlignment", s8.horizontalAlignment) : this._horizontalAlignment = s8.horizontalAlignment, e6(s8.verticalAlignment) ? this._dynamicPropertyMap.set("_verticalAlignment", s8.verticalAlignment) : this._verticalAlignment = s8.verticalAlignment, null != s8.effects) {
      const t10 = s8.effects;
      e6(t10) ? this._dynamicPropertyMap.set("_effects", t10) : this._effects = t10;
    }
    if (null != s8.markerPlacement) {
      const t10 = s8.markerPlacement;
      e6(t10) ? this._dynamicPropertyMap.set("_markerPlacement", t10) : this._textPlacement = t10;
    }
    e6(s8.text) ? this._dynamicPropertyMap.set("_text", s8.text) : this._text = s8.text, this._backgroundColor = s8.backgroundColor && t2(s8.backgroundColor), this._borderLineColor = s8.borderLineColor && t2(s8.borderLineColor), this._borderLineSize = s8.borderLineWidth, this._scaleFactor = c11;
    const z6 = Math.min(Math.round(u(s8.referenceSize * s8.sizeRatio)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * z6)), this._materialKey = s8.materialKey;
    const x10 = P.load(this._materialKey);
    x10.sdf = true, this._bitset = (s8.alignment === i4.MAP ? 1 : 0) | (s8.colorLocked ? 1 : 0) << 1, this._materialKey = x10.data, this._decoration = "none", this._lineHeight = 1, this._lineWidth = 512, this._isCIM = true;
  }
  static fromCIMText(t10, e11) {
    const [i15, s8] = v2(t10.scaleInfo, e11);
    return new _d(t10, i15, s8);
  }
  async analyze(t10, e11, i15, s8) {
    const o11 = e11.readLegacyFeature(), r13 = p8(this._cimTextLayer, o11, i15, s8), n11 = await super.analyze(t10, e11, i15, s8, n7(r13));
    return n11 && n11.glyphMosaicItems && this._textToGlyphs.set(r13, n11.glyphMosaicItems), n11;
  }
  bindFeature(t10, e11, i15) {
    const r13 = t10.readLegacyFeature();
    if (this._dynamicPropertyMap.forEach((t11, s8) => {
      this[s8] = t11(r13, e11, i15);
    }), !this._text || 0 === this._text.length)
      return void (this._shapingInfo = null);
    this._size *= this._scaleFactor, this._scale = this._size / b, this._xOffset *= this._scaleFactor, this._yOffset *= this._scaleFactor, this._xAlignD = r4(this._horizontalAlignment ?? "center"), this._yAlignD = n3(this._verticalAlignment ?? "baseline");
    const a10 = this._textToGlyphs.get(this._text) ?? [];
    this.bindTextInfo(a10, false);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLFillTemplate.js
var K2 = class _K extends x6(r9) {
  constructor(t10, e11, l6, o11, r13, i15, s8, a10, n11, m6, c11, f9, d10, u10, M3, j4) {
    super(), this._effects = u10 || void 0;
    const w9 = w3.load(t10);
    e11 && (w9.sdf = e11.sdf, w9.pattern = true, w9.textureBinding = e11.textureBinding), this.fillColor = l6, this.tl = o11, this.br = r13, this.aux21 = w2(i15, s8), this.aux22 = w2(a10, n11), this.aux3 = x(m6, c11, f9, 0), this._bitset = d10, this._minMaxZoom = w2(Math.round(M3 * me), Math.round(j4 * me)), this._materialKey = w9.data;
  }
  static fromCIMFill(e11, h7, d10) {
    const y10 = e11.color, x10 = y10 && t2(y10) || 0, j4 = e11.materialKey, [w9, g7] = v2(e11.scaleInfo, d10);
    let F2 = (e11.colorLocked ? pe : 0) | (e11.applyRandomOffset ? ue : 0) | (e11.sampleAlphaOnly ? ge : 0) | (e11.hasUnresolvedReplacementColor ? ve : 0);
    if (!h7)
      return new _K(j4, null, x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, F2, e11.effects, w9, g7);
    const { rect: _5, width: b5, height: L4 } = h7, C6 = e11.scaleX || 1, T = _5.x + ae, A3 = _5.y + ae, B3 = T + b5, G3 = A3 + L4, I = u(e11.height);
    let R3 = C6 * I;
    "CIMHatchFill" === e11.cim.type && (R3 *= b5 / L4);
    let S5 = I;
    S5 <= 0 && (S5 = G3 - A3), S5 < i2 && (S5 *= h, F2 |= ye), S5 = Math.round(S5);
    let U2 = R3;
    U2 <= 0 && (U2 = B3 - T), U2 < i2 && (U2 *= h, F2 |= be), U2 = Math.round(U2);
    const v6 = u(e11.offsetX || 0), O2 = u(-e11.offsetY || 0), W = w2(T, A3), X = w2(B3, G3);
    return new _K(j4, h7, x10, W, X, U2, S5, v6, O2, h, h, c3(e11.angle), F2, e11.effects, w9, g7);
  }
  static fromSimpleFill(t10, l6, r13 = false) {
    const { color: i15 } = t10, s8 = i15 && "esriSFSNull" !== t10.style && o5(i15) || 0;
    let h7 = r13 ? pe : 0;
    const d10 = t10.materialKey;
    let u10;
    if (l6) {
      const { rect: t11, width: e11, height: o11, pixelRatio: r14 } = l6, i16 = t11.x + ae, y10 = t11.y + ae, x10 = i16 + e11, M3 = y10 + o11, g7 = w2(i16, y10), F2 = w2(x10, M3);
      let _5 = e11 / r14;
      _5 < i2 && (_5 *= h, h7 |= be), _5 = Math.round(_5);
      let b5 = o11 / r14;
      b5 < i2 && (b5 *= h, h7 |= ye), b5 = Math.round(b5), u10 = new _K(d10, l6, s8, g7, F2, _5, b5, 0, 0, h, h, 0, h7, null, n8, o7);
    } else
      u10 = new _K(d10, null, s8, 0, 0, 0, 0, 0, 0, 0, 0, 0, h7, null, n8, o7);
    return u10._maybeAddLineTemplate(t10), u10;
  }
  static fromPictureFill(e11, l6, r13 = false) {
    const i15 = a2, { rect: s8, width: h7, height: u10 } = l6, y10 = s8.x + ae, x10 = s8.y + ae, M3 = y10 + h7, g7 = x10 + u10, F2 = w2(y10, x10), _5 = w2(M3, g7);
    let b5 = r13 ? pe : 0, L4 = u(e11.width);
    L4 < i2 && (L4 *= h, b5 |= be), L4 = Math.round(L4);
    let C6 = u(e11.height);
    C6 < i2 && (C6 *= h, b5 |= ye), C6 = Math.round(C6);
    const T = u(e11.xoffset), A3 = u(-e11.yoffset), B3 = e11.materialKey, G3 = new _K(B3, l6, i15, F2, _5, L4, C6, T, A3, h * e11.xscale, h * e11.yscale, 0, b5, null, n8, o7);
    return G3._maybeAddLineTemplate(e11), G3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLMarkerTemplate.js
var z3 = class _z extends y5(r9) {
  constructor(t10, r13, s8, a10, d10, p10, y10, V2, _5, g7, z6, b5, k6, w9, B3, j4, C6, P4, v6, E4, T, A3, L4, R3) {
    super(), this.angle = a10, this.height = y10, this.width = p10, this.xOffset = r13 * v6, this.yOffset = s8 * v6, this._markerPlacement = E4 || void 0, this._effects = T || void 0, this._anchorX = j4, this._anchorY = C6, this._minMaxZoom = w2(Math.round(A3 * me), Math.round(L4 * me));
    const K3 = (w9 === i4.MAP ? ne : le) | (z6 ? pe : 0) | (k6 ? we : 0) | (b5 ? xe : 0), W = B3 && B3.sdf, X = N.load(t10);
    X.sdf = W, X.pattern = true, X.textureBinding = B3.textureBinding, this._materialKey = X.data, this._fillColor = d10, this._outlineColor = _5, this._sizeOutlineWidth = x(Math.round(Math.min(Math.sqrt(128 * p10), 255)), Math.round(Math.min(Math.sqrt(128 * y10), 255)), Math.round(Math.min(Math.sqrt(128 * g7), 255)), Math.round(Math.min(Math.sqrt(128 * V2), 255))), X.symbologyType === S.PIE_CHART ? (p10 *= P4 * v6, y10 *= P4 * v6, this._computedWidth = p10, this._computedHeight = y10, this._texUpperLeft = w2(0, 1), this._texUpperRight = w2(1, 1), this._texBottomLeft = w2(0, 0), this._texBottomRight = w2(1, 0)) : this._computeSize(p10, y10, P4, g7, v6, B3, X.hasSizeVV(), R3);
    const q3 = Math.round(64 * P4);
    this._bitestAndDistRatio = w2(K3, q3);
    const Y = n4(), H = n2();
    this._applyTransformation(H, Y);
  }
  static fromCIMMarker(e11, o11, r13) {
    const a10 = o11 && o11.width || 1, n11 = o11 && o11.height || 1, l6 = e11.size, h7 = a10 / n11 * e11.scaleX, m6 = e11.scaleSymbolsProportionally && e11.frameHeight ? l6 / e11.frameHeight : 1, c11 = t2(e11.color), u10 = t2(e11.outlineColor), d10 = u(l6), f9 = d10 * h7, M3 = u(e11.offsetX || 0), S5 = u(e11.offsetY || 0), x10 = u(e11.outlineWidth || 0) * m6, y10 = e11.alignment || i4.SCREEN, V2 = u(e11.referenceSize), [_5, g7] = v2(e11.scaleInfo, r13);
    let b5 = e11.rotation || 0;
    e11.rotateClockwise || (b5 = -b5);
    let k6 = 0, w9 = 0;
    const B3 = e11.anchorPoint;
    B3 && (e11.isAbsoluteAnchorPoint ? l6 && (k6 = B3.x / (l6 * h7), w9 = B3.y / l6) : (k6 = B3.x, w9 = B3.y));
    const j4 = new _z(e11.materialKey, M3, S5, b5, c11, f9, d10, V2, u10, x10, e11.colorLocked, e11.scaleSymbolsProportionally, false, y10, o11, k6, w9, e11.sizeRatio, e11.scaleFactor ?? 1, e11.markerPlacement, e11.effects, _5, g7, true);
    return j4._vertexBoundsScaleX = e11.maxVVSize ? e11.maxVVSize / f9 : 1, j4._vertexBoundsScaleY = e11.maxVVSize ? e11.maxVVSize / d10 : 1, j4;
  }
  static fromPictureMarker(e11, o11) {
    const r13 = Math.round(u(e11.width)), s8 = Math.round(u(e11.height)), a10 = a2, n11 = Math.round(u(e11.xoffset || 0)), l6 = Math.round(u(e11.yoffset || 0)), h7 = new _z(e11.materialKey, n11, l6, e11.angle, a10, r13, s8, s8, 0, 0, false, false, false, i4.SCREEN, o11, 0, 0, 1, 1, null, null, n8, o7, false);
    return h7._vertexBoundsScaleX = e11.maxVVSize ? e11.maxVVSize / e11.width : 1, h7._vertexBoundsScaleY = e11.maxVVSize ? e11.maxVVSize / e11.height : 1, h7;
  }
  static fromSimpleMarker(e11, o11) {
    const r13 = e11.style, s8 = o5(e11.color), n11 = Math.round(u(e11.size));
    let l6 = n11;
    "esriSMSTriangle" === r13 && (l6 *= o11.height / o11.width);
    const h7 = Math.round(u(e11.xoffset || 0)), m6 = Math.round(u(e11.yoffset || 0)), c11 = e11.outline, u10 = 0 | ((c11 == null ? void 0 : c11.color) && o5(c11.color)), d10 = 0 | ((c11 == null ? void 0 : c11.width) && Math.round(u(c11.width))), f9 = new _z(e11.materialKey, h7, m6, e11.angle ?? 0, s8, n11, l6, l6, u10, d10, false, false, "esriSMSCross" === r13 || "esriSMSX" === r13, i4.SCREEN, o11, 0, 0, 2, 1, null, null, n8, o7, false);
    return f9.boundsType = "esriSMSCircle" === r13 ? "circle" : "square", f9._vertexBoundsScaleX = e11.maxVVSize ? e11.maxVVSize / e11.size : 1, f9._vertexBoundsScaleY = e11.maxVVSize ? e11.maxVVSize / e11.size : 1, f9;
  }
  static fromLineSymbolMarker(e11, o11) {
    const s8 = o5(e11.color), n11 = 6, l6 = Math.round(u(n11 * e11.lineWidth)), h7 = l6, m6 = "cross" === e11.style || "x" === e11.style;
    let c11;
    switch (e11.placement) {
      case "begin-end":
        c11 = o3.Both;
        break;
      case "begin":
        c11 = o3.JustBegin;
        break;
      case "end":
        c11 = o3.JustEnd;
        break;
      default:
        c11 = o3.None;
    }
    const u10 = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: c11, offsetAlongLine: 0 }, d10 = new _z(e11.materialKey, 0, 0, 0, s8, l6, h7, h7 / n11, s8, m6 ? Math.round(u(e11.lineWidth)) : 0, false, false, m6, i4.MAP, o11, 0, 0, 2, 1, u10, null, n8, o7, false);
    return d10.boundsType = "circle" === e11.style ? "circle" : "square", d10;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTextTemplate.js
var z4 = 5;
var g6 = class _g extends w6(r9) {
  constructor(e11, l6, a10, d10, _5, u10, b5, x10, g7, C6, M3, p10, S5, j4, L4, y10, T, V2, k6, A3, v6, I, K3, R3) {
    super(), this._xOffset = u(S5), this._yOffset = u(j4), this._decoration = C6 || "none", this._backgroundColor = I, this._borderLineColor = K3, this._borderLineSize = R3, this._color = _5, this._haloColor = u10, this._haloSize = Math.min(Math.floor(z4 * u(o(a10))), 127), this._size = Math.min(Math.round(u(l6)), 127);
    const W = Math.min(Math.round(u(d10 || l6)), 127);
    this._referenceSize = Math.round(Math.sqrt(256 * W)), this._scale = this._size / b, this._angle = p10, this._justify = s4(b5 || "center"), this._xAlignD = r4(b5 || "center"), this._yAlignD = n3(x10 || "baseline"), this._baseline = "baseline" === (x10 || "baseline"), this._bitset = (g7 === i4.MAP ? 1 : 0) | (M3 ? 1 : 0) << 1;
    const B3 = U.load(e11);
    B3.sdf = true, this._materialKey = B3.data, this._lineWidth = u(L4) || 512, this._lineHeight = y10 || 1, this._textPlacement = T, this._effects = V2, this._isCIM = k6 ?? false, this._minMaxZoom = w2(Math.round(A3 * me), Math.round(v6 * me));
  }
  static fromText(o11, t10) {
    var _a, _b;
    const r13 = (_a = o11.font) == null ? void 0 : _a.size, n11 = new _g(o11.materialKey, r13, o11.haloSize || 0, r13, o11.color && o5(o11.color) || 0, o11.haloColor && o5(o11.haloColor) || 0, o11.horizontalAlignment, o11.verticalAlignment, i4.SCREEN, (_b = o11.font) == null ? void 0 : _b.decoration, false, o11.angle || 0, o11.xoffset || 0, o11.yoffset || 0, o11.lineWidth || 0, o11.lineHeight || 0, null, null, false, n8, o7, o11.backgroundColor && o5(o11.backgroundColor), o11.borderLineColor && o5(o11.borderLineColor), o11.borderLineSize), [, s8] = i3(o11.text);
    return n11.bindTextInfo(t10 ?? [], s8), n11._vertexBoundsScale = o11.maxVVSize && r13 ? o11.maxVVSize / r13 : 1, n11;
  }
  static fromCIMText(o11, t10, i15) {
    const r13 = o11.scaleFactor || 1, n11 = o11.size * o11.sizeRatio * r13, [s8, l6] = v2(o11.scaleInfo, i15), m6 = new _g(o11.materialKey, n11, o11.outlineSize * o11.sizeRatio, o11.referenceSize, t2(o11.color), t2(o11.outlineColor), o11.horizontalAlignment, o11.verticalAlignment, o11.alignment, o11.decoration, o11.colorLocked ?? false, o11.angle, o11.offsetX * o11.sizeRatio * r13, o11.offsetY * o11.sizeRatio * r13, 512, 1, o11.markerPlacement, o11.effects, true, s8, l6, o11.backgroundColor ? t2(o11.backgroundColor) : void 0, o11.borderLineColor ? t2(o11.borderLineColor) : void 0, o11.borderLineWidth), [, h7] = i3(o11.text);
    return m6.bindTextInfo(t10, h7), m6._vertexBoundsScale = o11.maxVVSize ? o11.maxVVSize / n11 : 1, m6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Lock.js
var r11 = class {
  constructor() {
    this._resolver = null;
  }
  isHeld() {
    return !!this._resolver;
  }
  async acquire() {
    this._resolver ? (await this._resolver.promise, await this.acquire()) : this._resolver = C();
  }
  release() {
    const e11 = this._resolver;
    this._resolver = null, e11 == null ? void 0 : e11.resolve();
  }
};
async function s7(e11, r13, s8) {
  try {
    await e11.acquire(), await r13(s8), e11.release();
  } catch (t10) {
    throw e11.release(), t10;
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLTemplateStore.js
var S3 = s.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore");
var w7 = { sortKey: null, templates: new Array() };
var k4 = { isOutline: false, placement: null, symbologyType: S.DEFAULT, vvFlags: 0 };
var C4 = { ...r, hash: JSON.stringify(r), materialKey: f2(E.MARKER, k4) };
var L2 = { ...s3, hash: JSON.stringify(s3), materialKey: f2(E.LINE, k4) };
var b4 = { ...y, hash: JSON.stringify(y), materialKey: f2(E.FILL, k4) };
function E3(e11, t10) {
  const r13 = e11.length;
  return e11.push(null), t10.then((t11) => e11[r13] = t11), e11;
}
function G2(e11) {
  return null != e11 && !!(1 & e11);
}
function j3(e11) {
  return "worker:port-closed" === e11.name;
}
var x8 = class {
  constructor(e11, t10) {
    this._idCounter = 1, this._templateIdCounter = 1, this._idToTemplateGroup = /* @__PURE__ */ new Map(), this._symbolToTemplate = /* @__PURE__ */ new Map(), this._fetchQueue = [], this._idToResolver = /* @__PURE__ */ new Map(), this._cimTemplateCache = /* @__PURE__ */ new Map(), this._cimAnalyses = [], this._lock = new r11(), this._fetchResource = e11, this._tileInfo = t10;
  }
  get _markerError() {
    return this._errorTemplates.marker[0];
  }
  get _fillError() {
    return this._errorTemplates.fill[0];
  }
  get _lineError() {
    return this._errorTemplates.line[0];
  }
  get _textError() {
    return this._errorTemplates.line[0];
  }
  createTemplateGroup(e11, t10, r13 = null) {
    this._initErrorTemplates();
    const s8 = e11.hash, i15 = this._symbolToTemplate.get(s8);
    if (null != i15)
      return i15;
    const a10 = new Array(), o11 = { sortKey: r13, templates: a10 };
    t10 && this._createMeshTemplates(a10, t10, true), this._createMeshTemplates(a10, e11, false);
    const l6 = this._createGroupId("expanded-cim" === e11.type && F(e11));
    return this._idToTemplateGroup.set(l6, o11), this._symbolToTemplate.set(s8, l6), l6;
  }
  getTemplateGroup(e11) {
    return this._idToTemplateGroup.get(e11) ?? w7;
  }
  getDynamicTemplateGroup(e11) {
    return this._idToTemplateGroup.has(e11) ? (G2(e11) || S3.error("mapview-template-store", `Id ${e11} does not refer to a dynamic template`), this._idToTemplateGroup.get(e11)) : w7;
  }
  getMosaicItem(e11, t10) {
    const r13 = this._createTemplateId(), s8 = new Promise((e12) => this._idToResolver.set(r13, e12));
    return this._fetchQueue.push({ symbol: e11, id: r13, glyphIds: t10 }), s8;
  }
  finalize(e11) {
    return this._fetchQueue.length || this._lock.isHeld() ? s7(this._lock, this._fetchAllQueuedResources.bind(this), e11) : Promise.resolve();
  }
  _initErrorTemplates() {
    this._errorTemplates || (this._errorTemplates = { fill: this._createMeshTemplates([], b4, false), marker: this._createMeshTemplates([], C4, false), line: this._createMeshTemplates([], L2, false) });
  }
  _fetchAllQueuedResources(t10) {
    if (!this._fetchQueue.length)
      return Promise.resolve();
    const s8 = this._fetchQueue, i15 = this._cimAnalyses;
    return this._fetchQueue = [], this._cimAnalyses = [], Promise.all(i15).then(() => this._fetchResource(s8, t10).then((e11) => {
      for (const { id: t11, mosaicItem: r13 } of e11) {
        this._idToResolver.get(t11)(r13), this._idToResolver.delete(t11);
      }
    })).catch((t11) => {
      d(t11) ? this._fetchQueue = this._fetchQueue.concat(s8) : j3(t11) || S3.error(new s2("mapview-template-store", "Unable to fetch requested texture resources", t11));
    });
  }
  _createGroupId(e11) {
    return this._idCounter++ << 1 | (e11 ? 1 : 0);
  }
  _createTemplateId() {
    return this._templateIdCounter++;
  }
  async _createSMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S3) ? z3.fromSimpleMarker(e11, t10) : this._markerError;
  }
  async _createPMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S3) ? z3.fromPictureMarker(e11, t10) : this._markerError;
  }
  async _createSFS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S3) ? K2.fromSimpleFill(e11, r13, t10) : this._fillError;
  }
  async _createPFS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S3) ? K2.fromPictureFill(e11, r13, t10) : this._fillError;
  }
  async _createSLS(e11, t10) {
    const { spriteMosaicItem: r13 } = await this.getMosaicItem(e11);
    return e9(r13, S3) ? K.fromSimpleLine(e11, r13) : this._lineError;
  }
  async _createLMS(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(e11);
    return e9(t10, S3) ? z3.fromLineSymbolMarker(e11, t10) : this._markerError;
  }
  async _createTS(e11) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(e11);
    return g6.fromText(e11, t10 ?? []);
  }
  async _createCIMText(e11) {
    const { glyphMosaicItems: t10 } = await this.getMosaicItem(n5(e11), n7(e11.text));
    return e9(t10, S3) ? g6.fromCIMText(e11, t10, this._tileInfo) : this._textError;
  }
  async _createCIMFill(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(n5(e11));
    return e9(t10, S3) ? K2.fromCIMFill(e11, t10, this._tileInfo) : this._fillError;
  }
  async _createCIMLine(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(n5(e11));
    return e9(t10, S3) ? K.fromCIMLine(e11, t10, this._tileInfo) : this._lineError;
  }
  async _createCIMMarker(e11) {
    const { spriteMosaicItem: t10 } = await this.getMosaicItem(n5(e11));
    return e9(t10, S3) ? z3.fromCIMMarker(e11, t10, this._tileInfo) : this._markerError;
  }
  async _createCIM(e11) {
    const t10 = e11.templateHash;
    let r13 = this._cimTemplateCache.get(t10);
    if (null != r13)
      return r13;
    switch (e11.type) {
      case "marker":
        r13 = await this._createCIMMarker(e11);
        break;
      case "line":
        r13 = await this._createCIMLine(e11);
        break;
      case "fill":
        r13 = await this._createCIMFill(e11);
        break;
      case "text":
        r13 = await this._createCIMText(e11);
    }
    return this._cimTemplateCache.set(t10, r13), r13;
  }
  async _createDynamicCIM(e11) {
    const t10 = e11.templateHash;
    let r13 = this._cimTemplateCache.get(t10);
    if (null != r13)
      return r13;
    switch (e11.type) {
      case "marker":
        r13 = L.fromCIMMarker(e11, this._tileInfo);
        break;
      case "line":
        r13 = d6.fromCIMLine(e11, this._tileInfo);
        break;
      case "fill":
        r13 = j2.fromCIMFill(e11, this._tileInfo);
        break;
      case "text":
        r13 = d7.fromCIMText(e11, this._tileInfo);
    }
    return this._cimTemplateCache.set(t10, r13), r13;
  }
  _createPrimitiveMeshTemplates(e11, t10, r13) {
    switch (t10.type) {
      case "esriSMS":
        return E3(e11, this._createSMS(t10));
      case "esriPMS":
        return E3(e11, this._createPMS(t10));
      case "esriSFS":
        return E3(e11, this._createSFS(t10, r13));
      case "line-marker":
        return E3(e11, this._createLMS(t10));
      case "esriPFS":
        return E3(e11, this._createPFS(t10, r13));
      case "esriSLS":
        return E3(e11, this._createSLS(t10, false));
      case "esriTS":
        return E3(e11, this._createTS(t10));
      default:
        return S3.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"), e11;
    }
  }
  _createMeshTemplates(e11, t10, r13) {
    if (t10.type.includes("3d"))
      return S3.error("3D symbols are not supported with MapView"), e11;
    if ("expanded-cim" === t10.type) {
      for (const r14 of t10.layers)
        "function" == typeof r14.materialHash ? E3(e11, this._createDynamicCIM(r14)) : E3(e11, this._createCIM(r14));
      return e11;
    }
    if ("composite-symbol" === t10.type) {
      for (const s8 of t10.layers)
        this._createPrimitiveMeshTemplates(e11, s8, r13);
      return e11;
    }
    return "cim" === t10.type || "label" === t10.type || "web-style" === t10.type ? e11 : this._createPrimitiveMeshTemplates(e11, t10, r13);
  }
};
var F = (e11) => {
  if (!e11.layers)
    return false;
  for (const t10 of e11.layers)
    if ("function" == typeof t10.materialHash)
      return true;
  return false;
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function n10(t10, e11) {
  return t10[e11 + 1];
}
function i14(t10) {
  return t10.length - 1;
}
function r12(t10) {
  let e11 = 0;
  for (let s8 = 0; s8 < i14(t10); s8++)
    e11 += h5(t10, s8);
  return e11;
}
function h5(t10, e11, s8 = 1) {
  const [i15, r13] = n10(t10, e11);
  return Math.sqrt(i15 * i15 + r13 * r13) * s8;
}
var a8 = class _a {
  constructor(t10, e11, s8, n11, i15) {
    this._segments = t10, this._index = e11, this._distance = s8, this._xStart = n11, this._yStart = i15, this._done = false;
  }
  static create(t10) {
    return new _a(t10, 0, 0, t10[0][0], t10[0][1]);
  }
  clone() {
    return new _a(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t10) {
    return this._index === t10._index || t10._index === this._index - 1 && (0 === this._distance || 1 === t10._distance) || t10._index === this._index + 1 && (1 === this._distance || 0 === t10._distance);
  }
  leq(t10) {
    return this._index < t10._index || this._index === t10._index && this._distance <= t10._distance;
  }
  geq(t10) {
    return this._index > t10._index || this._index === t10._index && this._distance >= t10._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t10 = this.dy, e11 = (0 * t10 + -1 * -this.dx) / (1 * this.length);
    let s8 = Math.acos(e11);
    return t10 > 0 && (s8 = 2 * Math.PI - s8), s8;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t10, dy: e11 } = this;
    return Math.sqrt(t10 * t10 + e11 * e11);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < i14(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t10, e11) {
    const s8 = this.backwardLength;
    if (t10 <= s8)
      return this._distance = (s8 - t10) / this.length, this;
    let n11 = this.backwardLength;
    for (; this.prev(); ) {
      if (n11 + this.length > t10)
        return this._seekBackwards(t10 - n11);
      n11 += this.length;
    }
    return this._distance = 0, e11 ? this : null;
  }
  seek(t10, e11 = false) {
    if (t10 < 0)
      return this._seekBackwards(Math.abs(t10), e11);
    if (t10 <= this.remainingLength)
      return this._distance = (this.backwardLength + t10) / this.length, this;
    let s8 = this.remainingLength;
    for (; this.next(); ) {
      if (s8 + this.length > t10)
        return this.seek(t10 - s8, e11);
      s8 += this.length;
    }
    return this._distance = 1, e11 ? this : null;
  }
};
function d8(t10, e11, s8, n11 = true) {
  const i15 = r12(t10), h7 = a8.create(t10), d10 = i15 / 2;
  if (!n11)
    return h7.seek(d10), void s8(h7.clone(), 0, d10 + 0 * e11, i15);
  const c11 = Math.max((i15 - e11) / 2, 0), u10 = Math.floor(c11 / e11), o11 = d10 - u10 * e11;
  h7.seek(o11);
  for (let r13 = -u10; r13 <= u10; r13++)
    h7.x < 512 && h7.x >= 0 && h7.y < 512 && h7.y >= 0 && s8(h7.clone(), r13, d10 + r13 * e11, i15), h7.seek(e11);
}
function o9(t10, e11) {
  const s8 = e11;
  for (let n11 = 0; n11 < t10.length; n11++) {
    let e12 = t10[n11];
    _4(e12, s8);
    const i15 = [];
    i15.push(e12[0]);
    for (let t11 = 1; t11 < e12.length; t11++) {
      const [s9, n12] = e12[t11 - 1], [r13, h7] = e12[t11], a10 = Math.round(r13 - s9), d10 = Math.round(h7 - n12);
      i15.push([a10, d10]);
    }
    t10[n11] = i15, e12 = i15;
  }
  return t10;
}
function _4(n11, i15) {
  const r13 = 1e-6;
  if (i15 <= 0)
    return;
  const h7 = n11.length;
  if (h7 < 3)
    return;
  const a10 = [];
  let d10 = 0;
  a10.push(0);
  for (let e11 = 1; e11 < h7; e11++)
    d10 += u3(n11[e11], n11[e11 - 1]), a10.push(d10);
  i15 = Math.min(i15, 0.2 * d10);
  const c11 = [];
  c11.push(n11[0][0]), c11.push(n11[0][1]);
  const u10 = n11[h7 - 1][0], o11 = n11[h7 - 1][1], _5 = t8([0, 0], n11[0], n11[1]);
  r7(_5), n11[0][0] += i15 * _5[0], n11[0][1] += i15 * _5[1], t8(_5, n11[h7 - 1], n11[h7 - 2]), r7(_5), n11[h7 - 1][0] += i15 * _5[0], n11[h7 - 1][1] += i15 * _5[1];
  for (let t10 = 1; t10 < h7; t10++)
    a10[t10] += i15;
  a10[h7 - 1] += i15;
  const l6 = 0.5 * i15;
  for (let t10 = 1; t10 < h7 - 1; t10++) {
    let e11 = 0, s8 = 0, d11 = 0;
    for (let h8 = t10 - 1; h8 >= 0 && !(a10[h8 + 1] < a10[t10] - l6); h8--) {
      const c12 = l6 + a10[h8 + 1] - a10[t10], u11 = a10[h8 + 1] - a10[h8], o12 = a10[t10] - a10[h8] < l6 ? 1 : c12 / u11;
      if (Math.abs(o12) < r13)
        break;
      const _6 = o12 * o12, g7 = o12 * c12 - 0.5 * _6 * u11, x10 = o12 * u11 / i15, f9 = n11[h8 + 1], y10 = n11[h8][0] - f9[0], k6 = n11[h8][1] - f9[1];
      e11 += x10 / g7 * (f9[0] * o12 * c12 + 0.5 * _6 * (c12 * y10 - u11 * f9[0]) - _6 * o12 * u11 * y10 / 3), s8 += x10 / g7 * (f9[1] * o12 * c12 + 0.5 * _6 * (c12 * k6 - u11 * f9[1]) - _6 * o12 * u11 * k6 / 3), d11 += x10;
    }
    for (let c12 = t10 + 1; c12 < h7 && !(a10[c12 - 1] > a10[t10] + l6); c12++) {
      const h8 = l6 - a10[c12 - 1] + a10[t10], u11 = a10[c12] - a10[c12 - 1], o12 = a10[c12] - a10[t10] < l6 ? 1 : h8 / u11;
      if (Math.abs(o12) < r13)
        break;
      const _6 = o12 * o12, g7 = o12 * h8 - 0.5 * _6 * u11, x10 = o12 * u11 / i15, f9 = n11[c12 - 1], y10 = n11[c12][0] - f9[0], k6 = n11[c12][1] - f9[1];
      e11 += x10 / g7 * (f9[0] * o12 * h8 + 0.5 * _6 * (h8 * y10 - u11 * f9[0]) - _6 * o12 * u11 * y10 / 3), s8 += x10 / g7 * (f9[1] * o12 * h8 + 0.5 * _6 * (h8 * k6 - u11 * f9[1]) - _6 * o12 * u11 * k6 / 3), d11 += x10;
    }
    c11.push(e11 / d11), c11.push(s8 / d11);
  }
  c11.push(u10), c11.push(o11);
  for (let t10 = 0, e11 = 0; t10 < h7; t10++)
    n11[t10][0] = c11[e11++], n11[t10][1] = c11[e11++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/WGLLabelTemplate.js
var y8 = s.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate");
var x9 = (t10, i15 = "mapview-labeling") => y8.error(new s2(i15, t10));
var L3 = 1;
var S4 = 0;
var v5 = 4;
var P3 = 25;
function w8(e11, t10) {
  const o11 = !!e11.minScale && t10.scaleToZoom(e11.minScale) || 0;
  return i(o11, 0, 25.5);
}
function M2(e11, t10) {
  const o11 = !!e11.maxScale && t10.scaleToZoom(e11.maxScale) || 255;
  return i(o11, 0, 25.5);
}
function Z3(e11) {
  const t10 = /* @__PURE__ */ new Map();
  return (i15) => (t10.has(i15) || t10.set(i15, e11(i15)), t10.get(i15));
}
var k5 = Z3((e11) => {
  let t10 = 0;
  if (0 === e11)
    return 1 / 0;
  for (; !(e11 % 2); )
    t10++, e11 /= 2;
  return t10;
});
var A2 = (e11) => Math.floor(127 * e11 + 127);
var B2 = (e11) => Math.floor(10 * e11);
var z5 = (e11) => Math.round(e11 * (254 / 360));
var C5 = class _C extends g6 {
  constructor(e11, t10, i15, r13) {
    var _a, _b, _c;
    super(e11, (_a = i15.font) == null ? void 0 : _a.size, i15.haloSize || 0, (_b = i15.font) == null ? void 0 : _b.size, i15.color && o5(i15.color) || 0, i15.haloColor && o5(i15.haloColor) || 0, i15.horizontalAlignment, i15.verticalAlignment, i7(t10.labelPlacement) ? i4.MAP : i4.SCREEN, (_c = i15.font) == null ? void 0 : _c.decoration, false, i15.angle || 0, i15.xoffset, i15.yoffset, i15.lineWidth, i15.lineHeight, null, null, false, null, null, i15.backgroundColor && o5(i15.backgroundColor), i15.borderLineColor && o5(i15.borderLineColor), i15.borderLineSize), this._outLineLabelAngle = 0, this._refPlacementPadding = 0, this._refPlacementDirX = 0, this._refPlacementDirY = 0, this._refOffsetX = 0, this._refOffsetY = 0, this._zoomLevel = 0, this.geometryType = E.LABEL, this._allowOverrun = t10.allowOverrun ?? false, this._repeatLabel = t10.repeatLabel ?? true, this._labelPosition = t10.labelPosition ?? "curved";
    const n11 = w8(t10, r13), h7 = M2(t10, r13), c11 = t10.labelPlacement, [d10, u10] = a3(c11);
    this._xAlignD = d10, this._yAlignD = u10, this._minZoom = n11, this._maxZoom = h7, this._minBackgroundZoom = n11, this._maxBackgroundZoom = h7, this._refPlacementPadding = u(i15.haloSize) + q, this._repeatLabelDistance = t10.repeatLabelDistance ? u(t10.repeatLabelDistance) : 128;
    const p10 = Z.load(e11);
    p10.sdf = true, this._materialKey = p10.data;
  }
  static fromLabelClass(e11, t10) {
    if ("esriServerLinePlacementCenterAlong" === e11.labelPlacement) {
      const t11 = e11.symbol;
      t11.xoffset = 0, t11.yoffset = 0, t11.angle = 0, t11.font.decoration = "none";
    }
    return new _C(e11.materialKey, e11, e11.symbol, t10);
  }
  get _shapedBox() {
    return this._shapingInfo.bounds;
  }
  setZoomLevel(e11) {
    this._zoomLevel = e11;
  }
  bindReferenceTemplate(e11) {
    let t10 = c2(this._xAlignD), i15 = o4(this._yAlignD);
    if (this._refOffsetX = 0, this._refOffsetY = 0, null == e11)
      return void (this._refSymbolAndPlacementOffset = x(0, 0, A2(t10), A2(i15)));
    if ("circle" === e11.boundsType && (t10 || i15)) {
      const e12 = Math.sqrt(t10 * t10 + i15 * i15);
      t10 /= e12, i15 /= e12;
    }
    const o11 = Math.max(e11.height, e11.width), r13 = this._refPlacementPadding * v5;
    this._refSymbolAndPlacementOffset = x(r13, o11, A2(t10), A2(i15)), this._referenceSize = o11, this._refPlacementDirX = t10, this._refPlacementDirY = i15, this._refOffsetX = e11.xOffset, this._refOffsetY = e11.yOffset;
  }
  _write(e11, t10) {
    if (null == this._shapingInfo)
      return;
    const i15 = this._shapingInfo, o11 = t10.getDisplayId(), r13 = "esriGeometryPolygon" === t10.geometryType ? t10.readLegacyCentroid() : t10.readLegacyGeometry();
    if (r13)
      switch (this._current = { out: e11, inId: o11, inShaping: i15, zoomLevel: this._zoomLevel }, "esriGeometryPolyline" === t10.geometryType && "curved" === this._labelPosition && (this._borderLineColor || this._backgroundColor) && y8.warnOnce("TextSymbol properties 'borderLineColor', 'borderLineSize', and 'backgroundColor' are not supported in curved labels"), t10.geometryType) {
        case "esriGeometryPolyline":
          this._placeLineLabels(r13);
          break;
        case "esriGeometryPoint":
        case "esriGeometryPolygon":
          this._placePointLabels(r13);
          break;
        default:
          x9(`Geometry of type ${t10.geometryType} is not supported`);
      }
  }
  _isVisible(e11, t10) {
    const i15 = B2(this._current.zoomLevel);
    return B2(e11) <= i15 && i15 <= B2(t10);
  }
  _placePointLabels(e11) {
    const { out: t10, inId: i15, inShaping: o11 } = this._current;
    this._writeGlyphs(t10, i15, e11, o11);
  }
  _placeLineLabels(e11) {
    const t10 = o9(e11.paths, this._current.inShaping.bounds.width), i15 = this._placeSubdivGlyphs.bind(this), o11 = (this._shapedBox.width + this._repeatLabelDistance) / (1 << L3);
    for (const r13 of t10)
      d8(r13, o11, i15, this._repeatLabel);
  }
  _placeSubdivGlyphs(e11, t10, i15, o11) {
    const r13 = k5(t10), n11 = this._shapedBox.width / (1 << L3), s8 = Math.sqrt(this._repeatLabelDistance) / (1 << L3), a10 = Math.min(i15, o11 - i15), l6 = this._current.inShaping.isMultiline ? P3 : Math.log2(a10 / (s8 + n11 / 2)), h7 = 0 === t10 ? l6 : Math.min(r13, l6), c11 = Math.max(this._minZoom, this._current.zoomLevel + L3 - h7), m6 = this._current.zoomLevel - c11, _5 = this._shapedBox.width / 2 * 2 ** m6;
    this._current.inShaping.isMultiline ? 0 === t10 && this._placeStraight(e11, c11) : this._allowOverrun && m6 < 0 ? this._placeStraightAlong(e11, this._minZoom) : "parallel" === this._labelPosition ? this._placeStraightAlong(e11, c11) : "curved" === this._labelPosition && this._placeCurved(e11, c11, _5);
  }
  _placeStraight(e11, t10) {
    const { out: i15, inId: o11, inShaping: r13 } = this._current, n11 = Math.ceil(e11.angle * (180 / Math.PI) % 360), s8 = Math.ceil((e11.angle * (180 / Math.PI) + 180) % 360);
    this._outLineLabelAngle = z5(n11), this._writeGlyphs(i15, o11, e11, r13, t10), this._outLineLabelAngle = z5(s8), this._writeGlyphs(i15, o11, e11, r13, t10);
  }
  _placeCurved(e11, t10, i15) {
    const { out: o11, inId: r13 } = this._current;
    o11.metricStart(r13, t10, e11.x, e11.y, 0, 0, 0, 0);
    const n11 = e11.clone(), s8 = e11.angle * (180 / Math.PI) % 360, a10 = (e11.angle * (180 / Math.PI) + 180) % 360;
    this._outLineLabelAngle = z5(s8), this._placeFirst(n11, t10, 1), this._placeBack(e11, n11, t10, i15, 1), this._placeForward(e11, n11, t10, i15, 1), this._outLineLabelAngle = z5(a10), this._placeFirst(n11, t10, 0), this._placeBack(e11, n11, t10, i15, 0), this._placeForward(e11, n11, t10, i15, 0), o11.metricEnd();
  }
  _placeStraightAlong(e11, t10) {
    const { out: i15, inId: o11, inShaping: s8 } = this._current;
    i15.metricStart(o11, t10, e11.x, e11.y, 0, 0, 0, 0);
    const a10 = e11.clone(), l6 = e11.angle * (180 / Math.PI) % 360, h7 = (e11.angle * (180 / Math.PI) + 180) % 360, c11 = s8.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor);
    if (this._maxBackgroundZoom = P3, this._minBackgroundZoom = Math.max(t10, 0), c11) {
      const t11 = Z.load(this._materialKey);
      t11.textureBinding = s8.glyphs[0].textureBinding;
      const a11 = h2(n2(), -e11.angle), [c12, m6] = s8.shapeBackground(a11);
      this._outLineLabelAngle = z5(l6), i15.recordStart(o11, t11.data, this.geometryType, true), this._writeBackgroundGeometry(i15, o11, e11, c12, m6), i15.recordEnd(), this._outLineLabelAngle = z5(h7), i15.recordStart(o11, t11.data, this.geometryType, true), this._writeBackgroundGeometry(i15, o11, e11, c12, m6), i15.recordEnd();
    }
    this._outLineLabelAngle = z5(l6), this._placeFirst(a10, t10, 1, true), this._outLineLabelAngle = z5(h7), this._placeFirst(a10, t10, 0, true), i15.metricEnd();
  }
  _placeBack(e11, t10, i15, o11, r13) {
    const n11 = e11.clone();
    let s8 = e11.backwardLength + S4;
    for (; n11.prev() && !(s8 >= o11); )
      this._placeOnSegment(n11, t10, s8, i15, -1, r13), s8 += n11.length + S4;
  }
  _placeForward(e11, t10, i15, o11, r13) {
    const n11 = e11.clone();
    let s8 = e11.remainingLength + S4;
    for (; n11.next() && !(s8 >= o11); )
      this._placeOnSegment(n11, t10, s8, i15, 1, r13), s8 += n11.length + S4;
  }
  _placeFirst(e11, t10, i15, o11 = false) {
    const r13 = e11, n11 = this._current.inShaping, s8 = n11.glyphs, a10 = this._current.zoomLevel, { out: l6, inId: h7 } = this._current;
    for (const c11 of s8) {
      const s9 = c11.x > n11.bounds.x ? i15 : 1 - i15, m6 = s9 * e11.remainingLength + (1 - s9) * e11.backwardLength, _5 = Math.abs(c11.x + c11.width / 2 - n11.bounds.x), g7 = Math.max(0, a10 + Math.log2(_5 / (m6 + S4))), d10 = Math.max(t10, o11 ? 0 : g7);
      if (c11.maxZoom = P3, c11.angle = e11.angle + (1 - i15) * Math.PI, c11.minZoom = d10, this._writeGlyph(l6, h7, r13.x, r13.y, c11), i15 && this._isVisible(c11.minZoom, c11.maxZoom)) {
        const e12 = c11.bounds;
        l6.metricBoxWrite(e12.center[0], e12.center[1], e12.width, e12.height);
      }
    }
  }
  _placeOnSegment(e11, t10, i15, o11, r13, n11) {
    const s8 = this._current.inShaping.glyphs, { out: a10, inId: l6 } = this._current, h7 = this._current.inShaping, c11 = this._current.zoomLevel, m6 = e11.dx / e11.length, _5 = e11.dy / e11.length, g7 = { x: e11.x + i15 * -r13 * m6, y: e11.y + i15 * -r13 * _5 };
    for (const d10 of s8) {
      const s9 = d10.x > h7.bounds.x ? n11 : 1 - n11;
      if (!(s9 && 1 === r13 || !s9 && -1 === r13))
        continue;
      const m7 = Math.abs(d10.x + d10.width / 2 - h7.bounds.x), _6 = Math.max(0, c11 + Math.log2(m7 / i15) - 0.1), f9 = Math.max(o11, c11 + Math.log2(m7 / (i15 + e11.length + S4)));
      if (0 !== _6 && (d10.angle = e11.angle + (1 - n11) * Math.PI, d10.minZoom = f9, d10.maxZoom = _6, this._writeGlyph(a10, l6, g7.x, g7.y, d10), n11 && this._isVisible(d10.minZoom, d10.maxZoom))) {
        const i16 = d10.bounds, o12 = e11.x - t10.x, r14 = e11.y - t10.y;
        a10.metricBoxWrite(i16.center[0] + o12, i16.center[1] + r14, i16.width, i16.height);
      }
    }
  }
  _writeGlyphs(e11, t10, i15, o11, r13 = this._minZoom) {
    if (i15.x < 0 || i15.x >= 512 || i15.y < 0 || i15.y >= 512)
      return;
    if (o11.glyphs.length > 0 && (this._borderLineColor || this._backgroundColor)) {
      const r14 = Z.load(this._materialKey);
      r14.textureBinding = o11.glyphs[0].textureBinding, e11.recordStart(t10, r14.data, this.geometryType, true), this._writeBackgroundGeometry(e11, t10, i15, o11.bounds, o11.background), e11.recordEnd();
    }
    const n11 = i15.x + this._refOffsetX, s8 = i15.y - this._refOffsetY;
    for (const c11 of o11.glyphs)
      c11.minZoom = r13, c11.maxZoom = this._maxZoom, this._writeGlyph(e11, t10, n11, s8, c11);
    const a10 = this._refPlacementDirX, l6 = this._refPlacementDirY, h7 = o11.boundsT;
    e11.metricStart(t10, r13, n11, s8, a10, l6, this._referenceSize, this._materialKey), e11.metricBoxWrite(h7.center[0], h7.center[1], h7.width, h7.height), e11.metricEnd();
  }
  _writeVertexCommon(e11, t10, i15, o11) {
    const r13 = this._color, n11 = this._haloColor, s8 = x(0, 0, this._size, this._haloSize), a10 = Math.max(o11.minZoom, this._minZoom), l6 = Math.min(o11.maxZoom, this._maxZoom), h7 = x(B2(a10), B2(l6), this._outLineLabelAngle, 0);
    e11.vertexWrite(i15), e11.vertexWrite(t10), e11.vertexWrite(r13), e11.vertexWrite(n11), e11.vertexWrite(s8), e11.vertexWrite(this._refSymbolAndPlacementOffset), e11.vertexWrite(h7);
  }
  _writeBackgroundVertex(e11, t10, i15, o11, r13, n11) {
    const s8 = x(0, 0, this._size, this._haloSize), a10 = x(0, 0, 0, 0), l6 = x(B2(this._minBackgroundZoom), B2(this._maxBackgroundZoom), this._outLineLabelAngle, 1);
    e11.vertexWrite(i15), e11.vertexWrite(t10), e11.vertexWrite(o11), e11.vertexWrite(a10), e11.vertexWrite(s8), e11.vertexWrite(this._refSymbolAndPlacementOffset), e11.vertexWrite(l6), e11.vertexWrite(r13), e11.vertexWrite(n11), e11.vertexEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/WGLMeshFactory.js
var a9 = class {
  constructor(e11, s8, r13) {
    this._loadPromise = i5(), this._geometryType = e11, this._idField = s8, this._templateStore = r13;
  }
  update(e11, t10) {
    null != e11.mesh.labels && (this._labelTemplates = this._createLabelTemplates(e11.mesh.labels, t10)), this._schema = e11;
  }
  _createLabelTemplates(e11, t10) {
    const s8 = /* @__PURE__ */ new Map();
    if ("simple" === e11.type) {
      for (const l6 of e11.classes) {
        const e12 = C5.fromLabelClass(l6, t10);
        s8.set(l6.index, e12);
      }
      return s8;
    }
    for (const l6 in e11.classes) {
      const i15 = e11.classes[l6];
      for (const e12 of i15) {
        const l7 = C5.fromLabelClass(e12, t10);
        s8.set(e12.index, l7);
      }
    }
    return s8;
  }
  get templates() {
    return this._templateStore;
  }
  async analyze(t10, r13, l6, a10, o11, n11, m6) {
    if (a(m6))
      return;
    let p10;
    "dictionary" === (l6 == null ? void 0 : l6.type) && (p10 = await l6.analyze(this._idField, t10.copy(), r13, o11, n11, m6));
    let f9 = 0;
    for (; t10.next(); ) {
      let e11 = null;
      if (e11 = p10 ? p10[f9++] : null != a10 && p(t10.getDisplayId()) && 1 !== t10.readAttribute("cluster_count") ? a10.match(this._idField, t10, this._geometryType, o11, n11) : l6.match(this._idField, t10, this._geometryType, o11, n11), t10.setGroupId(e11), G2(e11)) {
        const s8 = this._templateStore.getDynamicTemplateGroup(e11).templates;
        for (const e12 of s8)
          e12 && e12.analyze && e12.analyze(this._templateStore, t10, o11, n11);
      }
    }
    return await this._loadPromise, this._templateStore.finalize(m6);
  }
  async analyzeGraphics(t10, s8, r13, l6, a10, o11) {
    if (a(o11))
      return;
    const n11 = t10.getCursor();
    for (r13 && await r13.analyze(this._idField, n11.copy(), s8, l6, a10, o11); n11.next(); ) {
      let e11 = n11.getGroupId();
      if (null != e11 && -1 !== e11 || (e11 = r13 == null ? void 0 : r13.match(this._idField, n11, n11.geometryType, l6, a10), n11.setGroupId(e11)), G2(e11)) {
        const t11 = this._templateStore.getDynamicTemplateGroup(e11).templates;
        for (const e12 of t11)
          e12 && e12.analyze && e12.analyze(this._templateStore, n11, l6, a10);
      }
      n11.setGroupId(e11);
    }
    return await this._loadPromise, this._templateStore.finalize(o11);
  }
  writeGraphic(e11, t10, s8, r13) {
    const l6 = t10.getGroupId(), a10 = t10.getDisplayId(), o11 = this._templateStore.getTemplateGroup(l6);
    if (e11.featureStart(t10.insertAfter, 0), null != a10) {
      if (G2(l6))
        for (const e12 of o11.templates)
          e12 && e12.bindFeature(t10, null, null);
      if (o11) {
        for (const l7 of o11.templates)
          l7 && l7.write(e11, t10, s8, r13);
        e11.featureEnd();
      }
    }
  }
  writeCursor(e11, t10, s8, r13, l6, a10, o11) {
    const n11 = t10.getGroupId(), m6 = t10.getDisplayId(), p10 = this._templateStore.getTemplateGroup(n11), f9 = p10.templates, u10 = this._getSortKeyValue(t10, p10);
    if (e11.featureStart(0, u10), null != m6 && f9) {
      if (G2(n11))
        for (const e12 of f9)
          e12.bindFeature(t10, s8, r13);
      for (const s9 of f9)
        s9.write(e11, t10, l6, o11);
      if (null != a10 && e11.hasRecords) {
        const s9 = a10 && this._findLabelRef(f9);
        this._writeLabels(e11, t10, a10, s9, l6, o11);
      }
      e11.featureEnd();
    }
  }
  _getSortKeyValue(e11, t10) {
    const s8 = this._schema.mesh.sortKey;
    if (null == s8)
      return 0;
    let r13 = 0;
    return r13 = true === s8.byRenderer && null != t10.sortKey ? t10.sortKey : null != s8.fieldIndex ? e11.getComputedNumericAtIndex(s8.fieldIndex) : null != s8.field ? e11.readAttribute(s8.field) : e11.readAttribute(this._idField), r13 *= "asc" === s8.order ? 1 : -1, null == r13 || isNaN(r13) ? 0 : r13;
  }
  _findLabelRef(e11) {
    for (const t10 of e11)
      if (t10 instanceof z3)
        return t10;
    return null;
  }
  _writeLabels(e11, t10, s8, r13, l6, i15) {
    for (const a10 of s8)
      if (null != a10 && a10) {
        const { glyphs: s9, rtl: o11, index: n11 } = a10, m6 = this._labelTemplates.get(n11);
        if (!m6)
          continue;
        m6.setZoomLevel(l6), m6.bindReferenceTemplate(r13), m6.bindTextInfo(s9, o11), m6.write(e11, t10, null, i15);
      }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var l5 = s.getLogger("esri/views/2d/engine/webgl/util/Matcher");
async function o10(e11, t10, s8, r13) {
  switch (e11.type) {
    case "simple":
    case "heatmap":
      return u9.fromBasicRenderer(e11, t10, s8, r13);
    case "map":
      return d9.fromUVRenderer(e11, t10, s8, r13);
    case "interval":
      return m5.fromCBRenderer(e11, t10, s8, r13);
    case "dictionary":
      return y9.fromDictionaryRenderer(e11, t10, s8, r13);
    case "pie-chart":
      return c10.fromPieChartRenderer(e11, t10, s8, r13);
    case "subtype":
      return c10.fromSubtypes(e11, t10, s8, r13);
  }
}
var u9 = class _u {
  constructor() {
    this.type = "feature", this._defaultResult = null;
  }
  static async fromBasicRenderer(e11, t10, s8, r13) {
    const i15 = new _u();
    if (e11.symbol) {
      const a10 = await r5(e11.symbol, s8, r13), l6 = t10.createTemplateGroup(a10, null);
      i15.setDefault(l6);
    }
    return i15;
  }
  static async fromPieChartRenderer(e11, t10, s8, r13) {
    const i15 = new _u();
    if (e11.markerSymbol) {
      const a10 = await r5(e11.markerSymbol, s8, r13);
      let l6;
      e11.fillSymbol && (l6 = await r5(e11.fillSymbol, s8, r13));
      const o11 = t10.createTemplateGroup(a10, l6);
      i15.setDefault(o11);
    }
    return i15;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(e11) {
    this._defaultResult = e11;
  }
  match(e11, t10, s8, r13, i15) {
    return this.getDefault();
  }
  async analyze(e11, t10, s8, r13, i15, a10) {
    return null;
  }
};
var c10 = class _c extends u9 {
  constructor(e11, t10) {
    super(), this._subMatchers = e11, this._subtypeField = t10;
  }
  static async fromSubtypes(e11, t10, s8, r13) {
    const i15 = /* @__PURE__ */ new Map(), a10 = [];
    for (const n11 in e11.renderers) {
      const l6 = parseInt(n11, 10), u10 = o10(e11.renderers[n11], t10, s8, r13).then((e12) => i15.set(l6, e12));
      a10.push(u10);
    }
    return await Promise.all(a10), new _c(i15, e11.subtypeField);
  }
  match(e11, t10, s8, r13, i15) {
    const a10 = t10.readAttribute(this._subtypeField), n11 = this._subMatchers.get(a10);
    return n11 ? n11.match(e11, t10, s8, r13, i15) : null;
  }
};
var m5 = class _m extends u9 {
  constructor(e11, t10, s8, r13) {
    super(), this.type = "interval", this._intervals = [], this._isMaxInclusive = t10, this._fieldIndex = r13, this._field = e11, this._normalizationInfo = s8;
  }
  static async fromCBRenderer(e11, t10, s8, r13) {
    const { isMaxInclusive: i15, normalizationField: a10, normalizationTotal: l6, normalizationType: o11 } = e11, u10 = e11.field, c11 = new _m(u10, i15, { normalizationField: a10, normalizationTotal: l6, normalizationType: o11 }, e11.fieldIndex), d10 = await r5(e11.backgroundFillSymbol, s8, r13);
    await Promise.all(e11.intervals.map(async (e12) => {
      const i16 = await r5(e12.symbol, s8, r13), a11 = await t10.createTemplateGroup(i16, d10), l7 = { min: e12.min, max: e12.max };
      c11.add(l7, a11);
    }));
    const h7 = await r5(e11.defaultSymbol, s8, r13);
    if (h7) {
      const e12 = await t10.createTemplateGroup(h7, d10);
      c11.setDefault(e12);
    }
    return c11;
  }
  add(e11, t10) {
    this._intervals.push({ interval: e11, result: t10 }), this._intervals.sort((e12, t11) => e12.interval.min - t11.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  match(e11, t10, s8, r13, i15) {
    if (null == this._fieldIndex && !this._field)
      return this.getDefault();
    const a10 = null != this._fieldIndex ? t10.getComputedNumericAtIndex(this._fieldIndex) : this._getValueFromField(t10);
    if (null == a10 || isNaN(a10) || a10 === 1 / 0 || a10 === -1 / 0)
      return this.getDefault();
    for (let n11 = 0; n11 < this._intervals.length; n11++) {
      const { interval: e12, result: t11 } = this._intervals[n11], s9 = a10 >= e12.min, r14 = this._isMaxInclusive ? a10 <= e12.max : a10 < e12.max;
      if (s9 && r14)
        return t11;
    }
    return this.getDefault();
  }
  _needsNormalization() {
    const e11 = this._normalizationInfo;
    return e11 && (e11.normalizationField || e11.normalizationTotal || e11.normalizationType);
  }
  _getValueFromField(e11) {
    const t10 = e11.readAttribute(this._field);
    if (!this._needsNormalization() || null == t10)
      return t10;
    const { normalizationField: s8, normalizationTotal: r13, normalizationType: i15 } = this._normalizationInfo, a10 = e11.readAttribute(s8) ?? 1;
    if (i15)
      switch (i15) {
        case "esriNormalizeByField":
          return a10 ? t10 / a10 : void 0;
        case "esriNormalizeByLog":
          return Math.log(t10) * Math.LOG10E;
        case "esriNormalizeByPercentOfTotal":
          return t10 / r13 * 100;
        default:
          return void l5.error(`Found unknown normalization type: ${i15}`);
      }
    else
      l5.error("Normalization is required, but no type was set!");
  }
};
var d9 = class _d extends u9 {
  constructor(e11, t10, s8) {
    super(), this.type = "map", this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fieldsIndex = s8, this._fields = e11, this._seperator = t10 || "";
  }
  static async fromUVRenderer(e11, t10, s8, r13) {
    const i15 = e11.fieldDelimiter, a10 = [e11.field];
    e11.field2 && a10.push(e11.field2), e11.field3 && a10.push(e11.field3);
    const l6 = await r5(e11.backgroundFillSymbol, s8, r13), o11 = new _d(a10, i15, e11.fieldIndex);
    await Promise.all(e11.map.map(async (e12, i16) => {
      const a11 = await r5(e12.symbol, s8, r13), u11 = i16 + 1, c11 = await t10.createTemplateGroup(a11, l6, u11);
      "<Null>" === e12.value ? o11.setNullResult(c11) : o11.add(e12.value, c11);
    }));
    const u10 = await r5(e11.defaultSymbol, s8, r13);
    if (u10) {
      const e12 = Number.MAX_SAFE_INTEGER, s9 = await t10.createTemplateGroup(u10, l6, e12);
      o11.setDefault(s9);
    }
    return o11;
  }
  setNullResult(e11) {
    this._nullResult = e11;
  }
  add(e11, t10) {
    this._resultsMap.set(e11.toString(), t10);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  match(e11, t10, s8, r13, i15) {
    if (null == this._fieldsIndex && !this._fields)
      return this.getDefault();
    const a10 = null != this._fieldsIndex ? t10.getComputedStringAtIndex(this._fieldsIndex) : this._getValueFromFields(t10);
    if (null !== this._nullResult && (null == a10 || "" === a10 || "<Null>" === a10))
      return this._nullResult;
    if (null == a10)
      return this.getDefault();
    const n11 = a10.toString();
    return this._resultsMap.has(n11) ? this._resultsMap.get(n11) : this.getDefault();
  }
  _getValueFromFields(e11) {
    const t10 = [];
    for (const s8 of this._fields) {
      const r13 = e11.readAttribute(s8);
      null == r13 || "" === r13 ? t10.push("<Null>") : t10.push(r13);
    }
    return t10.join(this._seperator);
  }
};
async function h6(e11, t10) {
  const s8 = e11 || 1;
  if ("number" == typeof s8)
    return (e12, t11, r14) => s8;
  const r13 = await n6(s8, t10.spatialReference, t10.fields);
  return (e12, s9, i15) => s5(r13, e12, { $view: i15 }, t10.geometryType, s9) || 1;
}
var f8;
async function p9() {
  return f8 || (f8 = import("./createSymbolSchema-344EML44.js")), f8;
}
var y9 = class _y extends u9 {
  constructor(e11, t10, s8, i15, a10, n11) {
    super(), this.type = "dictionary", this._groupIdCache = new e(100), this._loader = e11, this._fieldMap = e11.fieldMap, this._symbolFields = e11.getSymbolFields(), this._templates = t10, this._info = s8, this._scaleFn = i15, this._schemaUtilsModule = a10, this._symbolOptions = n11;
  }
  static async fromDictionaryRenderer(e11, t10, s8, r13) {
    const [{ DictionaryLoader: i15 }, a10] = await Promise.all([import("./DictionaryLoader-SCPNWAJZ.js"), p9()]), n11 = new i15(e11.url, e11.config, e11.fieldMap);
    await n11.fetchResources({ spatialReference: s8.spatialReference, fields: s8.fields });
    const l6 = await h6(e11.scaleExpression, s8);
    return new _y(n11, t10, s8, l6, a10, e11.symbolOptions);
  }
  async _analyzeFeature(e11, s8, r13, i15, a10) {
    const o11 = e11.readLegacyFeature(), u10 = this._scaleFn(o11, r13, i15), c11 = this._attributeHash(o11) + "-" + u10, m6 = this._groupIdCache.get(c11);
    if (m6)
      return m6;
    const d10 = { ...i15, spatialReference: this._info.spatialReference, abortOptions: a10, fields: this._info.fields }, h7 = await this._loader.getSymbolAsync(o11, d10), f9 = this._schemaUtilsModule.createSymbolSchema(h7, this._symbolOptions), p10 = r5(f9, this._info, s8, a10).then((e12) => {
      if ("expanded-cim" !== (e12 == null ? void 0 : e12.type))
        return l5.error(new s2("mapview-bad-type", `Found unexpected type ${e12 == null ? void 0 : e12.type} in dictionary response`)), null;
      e12.hash += "-" + u10;
      for (const t10 of e12.layers)
        t10.scaleFactor = u10, t10.templateHash += "-" + u10;
      return this._templates.createTemplateGroup(e12, null);
    });
    return this._groupIdCache.put(c11, p10, 1), p10;
  }
  async analyze(t10, s8, r13, i15, a10, n11) {
    const l6 = s8.getCursor(), o11 = [];
    for (; l6.next(); )
      o11.push(this._analyzeFeature(l6, r13, i15, a10, n11));
    return Promise.all(o11).then((t11) => t11.filter(R));
  }
  match(e11, t10, s8, r13, i15) {
    return null;
  }
  _attributeHash(e11) {
    var _a;
    let t10 = "";
    for (const s8 of this._symbolFields) {
      const r13 = (_a = this._fieldMap) == null ? void 0 : _a[s8];
      r13 && (t10 += e11.attributes[r13] + "-");
    }
    return t10;
  }
};

export {
  e7 as e,
  E2 as E,
  e9 as e2,
  n7 as n,
  x8 as x,
  a9 as a,
  o10 as o
};
//# sourceMappingURL=chunk-4BRWSSYR.js.map
