import {
  o2 as o,
  r
} from "./chunk-SFV6XLDZ.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  n
} from "./chunk-DWOEYHKS.js";

// node_modules/@arcgis/core/core/timeUtils.js
var e2 = { milliseconds: 1, seconds: 1e3, minutes: 6e4, hours: 36e5, days: 864e5, weeks: 6048e5, months: 26784e5, years: 31536e6, decades: 31536e7, centuries: 31536e8 };
var t = { milliseconds: { getter: "getMilliseconds", setter: "setMilliseconds", multiplier: 1 }, seconds: { getter: "getSeconds", setter: "setSeconds", multiplier: 1 }, minutes: { getter: "getMinutes", setter: "setMinutes", multiplier: 1 }, hours: { getter: "getHours", setter: "setHours", multiplier: 1 }, days: { getter: "getDate", setter: "setDate", multiplier: 1 }, weeks: { getter: "getDate", setter: "setDate", multiplier: 7 }, months: { getter: "getMonth", setter: "setMonth", multiplier: 1 }, years: { getter: "getFullYear", setter: "setFullYear", multiplier: 1 }, decades: { getter: "getFullYear", setter: "setFullYear", multiplier: 10 }, centuries: { getter: "getFullYear", setter: "setFullYear", multiplier: 100 } };
function s(e3, t2) {
  const s2 = new Date(e3, t2 + 1, 1);
  return s2.setDate(0), s2.getDate();
}
function n2(e3, n3, r2) {
  const l3 = new Date(e3.getTime());
  if (n3 && r2) {
    const e4 = t[r2], { getter: u2, setter: i, multiplier: a2 } = e4;
    if ("months" === r2) {
      const e5 = s(l3.getFullYear(), l3.getMonth() + n3);
      l3.getDate() > e5 && l3.setDate(e5);
    }
    l3[i](l3[u2]() + n3 * a2);
  }
  return l3;
}
function l2(e3, t2) {
  switch (t2) {
    case "milliseconds":
      return new Date(e3.getTime());
    case "seconds":
      return new Date(e3.getFullYear(), e3.getMonth(), e3.getDate(), e3.getHours(), e3.getMinutes(), e3.getSeconds());
    case "minutes":
      return new Date(e3.getFullYear(), e3.getMonth(), e3.getDate(), e3.getHours(), e3.getMinutes());
    case "hours":
      return new Date(e3.getFullYear(), e3.getMonth(), e3.getDate(), e3.getHours());
    case "days":
      return new Date(e3.getFullYear(), e3.getMonth(), e3.getDate());
    case "weeks":
      return new Date(e3.getFullYear(), e3.getMonth(), e3.getDate() - e3.getDay());
    case "months":
      return new Date(e3.getFullYear(), e3.getMonth(), 1);
    case "years":
      return new Date(e3.getFullYear(), 0, 1);
    case "decades":
      return new Date(e3.getFullYear() - e3.getFullYear() % 10, 0, 1);
    case "centuries":
      return new Date(e3.getFullYear() - e3.getFullYear() % 100, 0, 1);
    default:
      return /* @__PURE__ */ new Date();
  }
}
function g(t2, s2, n3) {
  if (0 === t2)
    return 0;
  return t2 * e2[s2] / e2[n3];
}

// node_modules/@arcgis/core/TimeExtent.js
var u;
var m = u = class extends l {
  static get allTime() {
    return p;
  }
  static get empty() {
    return d;
  }
  constructor(t2) {
    super(t2), this.end = null, this.start = null;
  }
  readEnd(t2, e3) {
    return null != e3.end ? new Date(e3.end) : null;
  }
  writeEnd(t2, e3) {
    e3.end = t2 ? t2.getTime() : null;
  }
  get isAllTime() {
    return this.equals(u.allTime);
  }
  get isEmpty() {
    return this.equals(u.empty);
  }
  readStart(t2, e3) {
    return null != e3.start ? new Date(e3.start) : null;
  }
  writeStart(t2, e3) {
    e3.start = t2 ? t2.getTime() : null;
  }
  clone() {
    return new u({ end: this.end, start: this.start });
  }
  equals(t2) {
    if (!t2)
      return false;
    const e3 = null != this.start ? this.start.getTime() : this.start, r2 = null != this.end ? this.end.getTime() : this.end, s2 = null != t2.start ? t2.start.getTime() : t2.start, n3 = null != t2.end ? t2.end.getTime() : t2.end;
    return e3 === s2 && r2 === n3;
  }
  expandTo(t2) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const e3 = n(this.start, (e4) => l2(e4, t2)), i = n(this.end, (e4) => {
      const r2 = l2(e4, t2);
      return e4.getTime() === r2.getTime() ? r2 : n2(r2, 1, t2);
    });
    return new u({ start: e3, end: i });
  }
  intersection(t2) {
    var _a, _b, _c, _d;
    if (!t2)
      return this.clone();
    if (this.isEmpty || t2.isEmpty)
      return u.empty;
    if (this.isAllTime)
      return t2.clone();
    if (t2.isAllTime)
      return this.clone();
    const e3 = ((_a = this.start) == null ? void 0 : _a.getTime()) ?? -1 / 0, r2 = ((_b = this.end) == null ? void 0 : _b.getTime()) ?? 1 / 0, s2 = ((_c = t2.start) == null ? void 0 : _c.getTime()) ?? -1 / 0, n3 = ((_d = t2.end) == null ? void 0 : _d.getTime()) ?? 1 / 0;
    let i, l3;
    if (s2 >= e3 && s2 <= r2 ? i = s2 : e3 >= s2 && e3 <= n3 && (i = e3), r2 >= s2 && r2 <= n3 ? l3 = r2 : n3 >= e3 && n3 <= r2 && (l3 = n3), null != i && null != l3 && !isNaN(i) && !isNaN(l3)) {
      const t3 = new u();
      return t3.start = i === -1 / 0 ? null : new Date(i), t3.end = l3 === 1 / 0 ? null : new Date(l3), t3;
    }
    return u.empty;
  }
  offset(t2, e3) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const r2 = new u(), { start: s2, end: i } = this;
    return null != s2 && (r2.start = n2(s2, t2, e3)), null != i && (r2.end = n2(i, t2, e3)), r2;
  }
  union(t2) {
    if (!t2 || t2.isEmpty)
      return this.clone();
    if (this.isEmpty)
      return t2.clone();
    if (this.isAllTime || t2.isAllTime)
      return p.clone();
    const e3 = null != this.start && null != t2.start ? new Date(Math.min(this.start.getTime(), t2.start.getTime())) : null, r2 = null != this.end && null != t2.end ? new Date(Math.max(this.end.getTime(), t2.end.getTime())) : null;
    return new u({ start: e3, end: r2 });
  }
};
e([y({ type: Date, json: { write: { allowNull: true } } })], m.prototype, "end", void 0), e([o("end")], m.prototype, "readEnd", null), e([r("end")], m.prototype, "writeEnd", null), e([y({ readOnly: true, json: { read: false } })], m.prototype, "isAllTime", null), e([y({ readOnly: true, json: { read: false } })], m.prototype, "isEmpty", null), e([y({ type: Date, json: { write: { allowNull: true } } })], m.prototype, "start", void 0), e([o("start")], m.prototype, "readStart", null), e([r("start")], m.prototype, "writeStart", null), m = u = e([a("esri.TimeExtent")], m);
var p = new m();
var d = new m({ start: void 0, end: void 0 });
var c = m;

export {
  n2 as n,
  g,
  c
};
//# sourceMappingURL=chunk-42RWGG3D.js.map
