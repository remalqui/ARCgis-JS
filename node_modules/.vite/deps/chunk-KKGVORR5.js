import {
  e
} from "./chunk-WTKN55TU.js";
import {
  t
} from "./chunk-TDPKDZC3.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import {
  d,
  q
} from "./chunk-ZBWBCN2I.js";
import {
  f,
  l,
  s as s3,
  u
} from "./chunk-T4XWQYGC.js";
import {
  a
} from "./chunk-5HAVROZG.js";
import {
  r
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js
function d2(t3, e2) {
  return t3 ? e2 ? 4 : 3 : e2 ? 3 : 2;
}
var m = s.getLogger("esri.layers.graphics.featureConversionUtils");
var g = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0, esriGeometryEnvelope: 0 };
var y = (t3, e2, o, n, r2, s4) => {
  t3[o] = r2, t3[o + 1] = s4;
};
var p = (t3, e2, o, n, r2, s4) => {
  t3[o] = r2, t3[o + 1] = s4, t3[o + 2] = e2[n + 2];
};
var I = (t3, e2, o, n, r2, s4) => {
  t3[o] = r2, t3[o + 1] = s4, t3[o + 2] = e2[n + 3];
};
var b = (t3, e2, o, n, r2, s4) => {
  t3[o] = r2, t3[o + 1] = s4, t3[o + 2] = e2[n + 2], t3[o + 3] = e2[n + 3];
};
function w(t3, e2, o, n) {
  if (t3) {
    if (o)
      return e2 && n ? b : p;
    if (e2 && n)
      return I;
  } else if (e2 && n)
    return p;
  return y;
}
function M({ scale: t3, translate: e2 }, o) {
  return Math.round((o - e2[0]) / t3[0]);
}
function N({ scale: t3, translate: e2 }, o) {
  return Math.round((e2[1] - o) / t3[1]);
}
function F({ scale: t3, translate: e2 }, o, n) {
  return o * t3[n] + e2[n];
}
function P(t3, e2, o) {
  return t3 ? e2 ? o ? z(t3) : Z(t3) : o ? v(t3) : x(t3) : null;
}
function x(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1] };
}
function j(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3;
}
function Z(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], z: e2[2] };
}
function k(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.z, t3;
}
function v(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], m: e2[2] };
}
function E(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.m, t3;
}
function z(t3) {
  const e2 = t3.coords;
  return { x: e2[0], y: e2[1], z: e2[2], m: e2[3] };
}
function S(t3, e2) {
  return t3.coords[0] = e2.x, t3.coords[1] = e2.y, t3.coords[2] = e2.z, t3.coords[3] = e2.m, t3;
}
function V(t3, e2, o, n) {
  let r2 = x;
  o && n ? r2 = z : o ? r2 = Z : n && (r2 = v);
  for (const s4 of e2) {
    const { geometry: e3, attributes: o2 } = s4, n2 = null != e3 ? r2(e3) : null;
    t3.push({ attributes: o2, geometry: n2 });
  }
  return t3;
}
function Y(t3, e2) {
  return t3 && e2 ? S : t3 ? k : e2 ? E : j;
}
function _(t3, e2, o, n, r2) {
  const s4 = Y(o, n);
  for (const { geometry: u2, attributes: l2 } of e2) {
    const e3 = null != u2 ? s4(new t2(), u2) : null;
    t3.push(new t(e3, l2, null, r2 ? l2[r2] : void 0));
  }
  return t3;
}
function L(t3, e2, o = Y(null != e2.z, null != e2.m)) {
  return o(t3, e2);
}
function O(t3, e2, o, n) {
  for (const { geometry: r2, attributes: s4 } of e2)
    t3.push({ attributes: s4, geometry: null != r2 ? U(r2, o, n) : null });
  return t3;
}
function U(t3, e2, o) {
  if (null == t3)
    return null;
  const n = d2(e2, o), r2 = [];
  for (let s4 = 0; s4 < t3.coords.length; s4 += n) {
    const e3 = [];
    for (let o2 = 0; o2 < n; o2++)
      e3.push(t3.coords[s4 + o2]);
    r2.push(e3);
  }
  return e2 ? o ? { points: r2, hasZ: e2, hasM: o } : { points: r2, hasZ: e2 } : o ? { points: r2, hasM: o } : { points: r2 };
}
function A(t3, e2, o, n, r2) {
  const s4 = d2(o, n);
  for (const { geometry: u2, attributes: l2 } of e2) {
    const e3 = null != u2 ? q2(new t2(), u2, s4) : null;
    t3.push(new t(e3, l2, null, r2 ? l2[r2] : void 0));
  }
  return t3;
}
function q2(t3, e2, o = d2(e2.hasZ, e2.hasM)) {
  t3.lengths[0] = e2.points.length;
  const n = t3.coords;
  let r2 = 0;
  for (const s4 of e2.points)
    for (let t4 = 0; t4 < o; t4++)
      n[r2++] = s4[t4];
  return t3;
}
function R(t3, e2, o, n) {
  for (const { geometry: r2, attributes: s4 } of e2)
    t3.push({ attributes: s4, geometry: null != r2 ? $(r2, o, n) : null });
  return t3;
}
function $(t3, e2, o) {
  if (!t3)
    return null;
  const n = d2(e2, o), { coords: r2, lengths: s4 } = t3, u2 = [];
  let l2 = 0;
  for (const c of s4) {
    const t4 = [];
    for (let e3 = 0; e3 < c; e3++) {
      const e4 = [];
      for (let t5 = 0; t5 < n; t5++)
        e4.push(r2[l2++]);
      t4.push(e4);
    }
    u2.push(t4);
  }
  return e2 ? o ? { paths: u2, hasZ: e2, hasM: o } : { paths: u2, hasZ: e2 } : o ? { paths: u2, hasM: o } : { paths: u2 };
}
function B(t3, e2, o, n, r2) {
  const s4 = d2(o, n);
  for (const { geometry: u2, attributes: l2 } of e2) {
    const e3 = null != u2 ? C(new t2(), u2, s4) : null;
    t3.push(new t(e3, l2, null, r2 ? l2[r2] : void 0));
  }
  return t3;
}
function C(t3, e2, o = d2(e2.hasZ, e2.hasM)) {
  const { lengths: n, coords: r2 } = t3;
  let s4 = 0;
  for (const u2 of e2.paths) {
    for (const t4 of u2)
      for (let e3 = 0; e3 < o; e3++)
        r2[s4++] = t4[e3];
    n.push(u2.length);
  }
  return t3;
}
function D(t3, e2, o, n) {
  for (const { geometry: r2, attributes: s4, centroid: u2 } of e2) {
    const e3 = null != r2 ? H(r2, o, n) : null;
    if (null != u2) {
      const o2 = x(u2);
      t3.push({ attributes: s4, centroid: o2, geometry: e3 });
    } else
      t3.push({ attributes: s4, geometry: e3 });
  }
  return t3;
}
function H(t3, e2, o) {
  if (!t3)
    return null;
  const n = d2(e2, o), { coords: r2, lengths: s4 } = t3, u2 = [];
  let l2 = 0;
  for (const c of s4) {
    const t4 = [];
    for (let e3 = 0; e3 < c; e3++) {
      const e4 = [];
      for (let t5 = 0; t5 < n; t5++)
        e4.push(r2[l2++]);
      t4.push(e4);
    }
    u2.push(t4);
  }
  return e2 ? o ? { rings: u2, hasZ: e2, hasM: o } : { rings: u2, hasZ: e2 } : o ? { rings: u2, hasM: o } : { rings: u2 };
}
function J(t3, e2, o, n, r2) {
  for (const { geometry: s4, centroid: u2, attributes: l2 } of e2) {
    const e3 = null != s4 ? K(new t2(), s4, o, n) : null, c = r2 ? l2[r2] : void 0;
    null != u2 ? t3.push(new t(e3, l2, j(new t2(), u2), c)) : t3.push(new t(e3, l2, null, c));
  }
  return t3;
}
function K(t3, e2, o = e2.hasZ, n = e2.hasM) {
  return Q(t3, e2.rings, o, n);
}
function Q(t3, e2, o, n) {
  const r2 = d2(o, n), { lengths: s4, coords: u2 } = t3;
  let l2 = 0;
  Ft(t3);
  for (const c of e2) {
    for (const t4 of c)
      for (let e3 = 0; e3 < r2; e3++)
        u2[l2++] = t4[e3];
    s4.push(c.length);
  }
  return t3;
}
var W = [];
var X = [];
function tt(t3, e2, o, n, r2) {
  W[0] = t3;
  const [s4] = et(X, W, e2, o, n, r2);
  return Pt(W), Pt(X), s4;
}
function et(e2, o, n, r2, s4, u2) {
  if (Pt(e2), !n) {
    for (const t3 of o) {
      const o2 = u2 ? t3.attributes[u2] : void 0;
      e2.push(new t(null, t3.attributes, null, o2));
    }
    return e2;
  }
  switch (n) {
    case "esriGeometryPoint":
      return _(e2, o, r2, s4, u2);
    case "esriGeometryMultipoint":
      return A(e2, o, r2, s4, u2);
    case "esriGeometryPolyline":
      return B(e2, o, r2, s4, u2);
    case "esriGeometryPolygon":
      return J(e2, o, r2, s4, u2);
    default:
      m.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`)), Pt(e2);
  }
  return e2;
}
function ot(e2, o, n, r2, s4, u2) {
  const l2 = e2.length;
  switch (n) {
    case "esriGeometryPoint":
      _(e2, o, r2, s4, u2);
      break;
    case "esriGeometryMultipoint":
      A(e2, o, r2, s4, u2);
      break;
    case "esriGeometryPolyline":
      B(e2, o, r2, s4, u2);
      break;
    case "esriGeometryPolygon":
      J(e2, o, r2, s4, u2);
      break;
    default:
      m.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`));
  }
  for (let t3 = 0; t3 < o.length; t3++)
    e2[t3 + l2].geometryType = n, e2[t3 + l2].insertAfter = o[t3].insertAfter, e2[t3 + l2].groupId = o[t3].groupId;
  return e2;
}
function nt(t3, e2, o, n) {
  X[0] = t3, lt(W, X, e2, o, n);
  const r2 = W[0];
  return Pt(W), Pt(X), r2;
}
function rt(e2, o, n) {
  if (null == e2)
    return null;
  const r2 = new t2();
  if ("hasZ" in e2 && null == o && (o = e2.hasZ), "hasM" in e2 && null == n && (n = e2.hasM), l(e2)) {
    return Y(null != o ? o : null != e2.z, null != n ? n : null != e2.m)(r2, e2);
  }
  return f(e2) ? K(r2, e2, o, n) : s3(e2) ? C(r2, e2, d2(o, n)) : u(e2) ? q2(r2, e2, d2(o, n)) : void m.error("convertFromGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${e2}'`));
}
function st(e2, o, n, r2) {
  const s4 = e2 && ("coords" in e2 ? e2 : e2.geometry);
  if (null == s4)
    return null;
  switch (o) {
    case "esriGeometryPoint": {
      let t3 = x;
      return n && r2 ? t3 = z : n ? t3 = Z : r2 && (t3 = v), t3(s4);
    }
    case "esriGeometryMultipoint":
      return U(s4, n, r2);
    case "esriGeometryPolyline":
      return $(s4, n, r2);
    case "esriGeometryPolygon":
      return H(s4, n, r2);
    default:
      return m.error("convertToGeometry:unknown-geometry", new s2(`Unable to parse unknown geometry type '${o}'`)), null;
  }
}
function ut(t3, e2) {
  for (const o of e2)
    t3.push({ attributes: o.attributes });
  return t3;
}
function lt(e2, o, n, r2, s4) {
  if (Pt(e2), null == n)
    return ut(e2, o);
  switch (n) {
    case "esriGeometryPoint":
      return V(e2, o, r2, s4);
    case "esriGeometryMultipoint":
      return O(e2, o, r2, s4);
    case "esriGeometryPolyline":
      return R(e2, o, r2, s4);
    case "esriGeometryPolygon":
      return D(e2, o, r2, s4);
    default:
      m.error("convertToFeatureSet:unknown-geometry", new s2(`Unable to parse unknown geometry type '${n}'`));
  }
  return e2;
}
function ct(t3) {
  const { objectIdFieldName: e2, spatialReference: o, transform: n, fields: r2, hasM: s4, hasZ: u2, features: l2, geometryType: c, exceededTransferLimit: i, uniqueIdField: f2, queryGeometry: a2, queryGeometryType: h } = t3, d3 = { features: lt([], l2, c, u2, s4), fields: r2, geometryType: c, objectIdFieldName: e2, spatialReference: o, uniqueIdField: f2, queryGeometry: st(a2, h, false, false) };
  return n && (d3.transform = n), i && (d3.exceededTransferLimit = i), s4 && (d3.hasM = s4), u2 && (d3.hasZ = u2), d3;
}
function it(e2, o) {
  const n = new e(), { hasM: r2, hasZ: s4, features: u2, objectIdFieldName: l2, spatialReference: c, geometryType: i, exceededTransferLimit: f2, transform: h, fields: d3 } = e2;
  return d3 && (n.fields = d3), n.geometryType = i ?? null, n.objectIdFieldName = l2 ?? o ?? null, n.spatialReference = c ?? null, n.objectIdFieldName ? (u2 && et(n.features, u2, i, s4, r2, n.objectIdFieldName), f2 && (n.exceededTransferLimit = f2), r2 && (n.hasM = r2), s4 && (n.hasZ = s4), h && (n.transform = h), n) : (m.error(new s2("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), n);
}
function ft(t3) {
  const { transform: e2, features: o, hasM: n, hasZ: r2 } = t3;
  if (!e2)
    return t3;
  for (const s4 of o)
    null != s4.geometry && It(s4.geometry, s4.geometry, n, r2, e2), null != s4.centroid && It(s4.centroid, s4.centroid, n, r2, e2);
  return t3.transform = null, t3;
}
function at(t3, e2) {
  const { geometryType: o, features: n, hasM: r2, hasZ: s4 } = e2;
  if (!t3)
    return e2;
  for (let u2 = 0; u2 < n.length; u2++) {
    const e3 = n[u2], l2 = e3.weakClone();
    l2.geometry = new t2(), ht(l2.geometry, e3.geometry, r2, s4, o, t3), e3.centroid && (l2.centroid = new t2(), ht(l2.centroid, e3.centroid, r2, s4, "esriGeometryPoint", t3)), n[u2] = l2;
  }
  return e2.transform = t3, e2;
}
function ht(t3, e2, o, n, r2, s4, u2 = o, l2 = n) {
  if (Ft(t3), null == e2 || !e2.coords.length)
    return null;
  const c = g[r2], { coords: i, lengths: f2 } = e2, a2 = d2(o, n), h = d2(o && u2, n && l2), m2 = w(o, n, u2, l2);
  if (!f2.length)
    return m2(t3.coords, i, 0, 0, M(s4, i[0]), N(s4, i[1])), Ft(t3, a2, 0), t3;
  let y2, p2, I2, b2, G = 0, T = 0, F2 = T;
  for (const d3 of f2) {
    if (d3 < c)
      continue;
    let e3 = 0;
    T = F2, I2 = y2 = M(s4, i[G]), b2 = p2 = N(s4, i[G + 1]), m2(t3.coords, i, T, G, I2, b2), e3++, G += a2, T += h;
    for (let o2 = 1; o2 < d3; o2++, G += a2)
      I2 = M(s4, i[G]), b2 = N(s4, i[G + 1]), I2 === y2 && b2 === p2 || (m2(t3.coords, i, T, G, I2 - y2, b2 - p2), T += h, e3++, y2 = I2, p2 = b2);
    e3 >= c && (t3.lengths.push(e3), F2 = T);
  }
  return Pt(t3.coords, F2), t3.coords.length ? t3 : null;
}
function dt(t3, e2, o, n, r2, s4, u2 = o, l2 = n) {
  if (Ft(t3), !e2 || !e2.coords.length)
    return null;
  const c = g[r2], { coords: i, lengths: f2 } = e2, a2 = d2(o, n), h = d2(o && u2, n && l2), m2 = w(o, n, u2, l2);
  if (!f2.length)
    return m2(t3.coords, i, 0, 0, i[0], i[1]), Ft(t3, a2, 0), t3;
  let y2 = 0;
  const p2 = s4 * s4;
  for (const d3 of f2) {
    if (d3 < c) {
      y2 += d3 * a2;
      continue;
    }
    const e3 = t3.coords.length / h, o2 = y2, n2 = y2 + (d3 - 1) * a2;
    m2(t3.coords, i, t3.coords.length, o2, i[o2], i[o2 + 1]), gt(t3.coords, i, a2, p2, m2, o2, n2), m2(t3.coords, i, t3.coords.length, n2, i[n2], i[n2 + 1]);
    const r3 = t3.coords.length / h - e3;
    r3 >= c ? t3.lengths.push(r3) : Pt(t3.coords, e3 * h), y2 += d3 * a2;
  }
  return t3.coords.length ? t3 : null;
}
function mt(t3, e2, o, n) {
  const r2 = t3[e2], s4 = t3[e2 + 1], u2 = t3[o], l2 = t3[o + 1], c = t3[n], i = t3[n + 1];
  let f2 = u2, a2 = l2, h = c - f2, d3 = i - a2;
  if (0 !== h || 0 !== d3) {
    const t4 = ((r2 - f2) * h + (s4 - a2) * d3) / (h * h + d3 * d3);
    t4 > 1 ? (f2 = c, a2 = i) : t4 > 0 && (f2 += h * t4, a2 += d3 * t4);
  }
  return h = r2 - f2, d3 = s4 - a2, h * h + d3 * d3;
}
function gt(t3, e2, o, n, r2, s4, u2) {
  let l2, c = n, i = 0;
  for (let f2 = s4 + o; f2 < u2; f2 += o)
    l2 = mt(e2, f2, s4, u2), l2 > c && (i = f2, c = l2);
  c > n && (i - s4 > o && gt(t3, e2, o, n, r2, s4, i), r2(t3, e2, t3.length, i, e2[i], e2[i + 1]), u2 - i > o && gt(t3, e2, o, n, r2, i, u2));
}
function yt(t3, e2, o, u2) {
  if (null == e2 || !e2.coords || !e2.coords.length)
    return null;
  const l2 = d2(o, u2);
  let c = Number.POSITIVE_INFINITY, i = Number.POSITIVE_INFINITY, f2 = Number.NEGATIVE_INFINITY, a2 = Number.NEGATIVE_INFINITY;
  if (e2 && e2.coords) {
    const t4 = e2.coords;
    for (let e3 = 0; e3 < t4.length; e3 += l2) {
      const o2 = t4[e3], n = t4[e3 + 1];
      c = Math.min(c, o2), f2 = Math.max(f2, o2), i = Math.min(i, n), a2 = Math.max(a2, n);
    }
  }
  return q(t3) ? d(t3, c, i, f2, a2) : a(c, i, f2, a2, t3), t3;
}
function It(t3, e2, n, r2, s4) {
  const { coords: u2, lengths: l2 } = e2, c = d2(n, r2);
  if (!u2.length)
    return t3 !== e2 && Ft(t3), t3;
  r(s4);
  const { originPosition: i, scale: f2, translate: a2 } = s4, h = xt;
  h.originPosition = i;
  const m2 = h.scale;
  m2[0] = f2[0] ?? 1, m2[1] = -(f2[1] ?? 1), m2[2] = f2[2] ?? 1, m2[3] = f2[3] ?? 1;
  const g2 = h.translate;
  if (g2[0] = a2[0] ?? 0, g2[1] = a2[1] ?? 0, g2[2] = a2[2] ?? 0, g2[3] = a2[3] ?? 0, !l2.length) {
    for (let e3 = 0; e3 < c; ++e3)
      t3.coords[e3] = F(h, u2[e3], e3);
    return t3 !== e2 && Ft(t3, c, 0), t3;
  }
  let y2 = 0;
  for (let o = 0; o < l2.length; o++) {
    const e3 = l2[o];
    t3.lengths[o] = e3;
    for (let o2 = 0; o2 < c; ++o2)
      t3.coords[y2 + o2] = F(h, u2[y2 + o2], o2);
    let n2 = t3.coords[y2], r3 = t3.coords[y2 + 1];
    y2 += c;
    for (let o2 = 1; o2 < e3; o2++, y2 += c) {
      n2 += u2[y2] * m2[0], r3 += u2[y2 + 1] * m2[1], t3.coords[y2] = n2, t3.coords[y2 + 1] = r3;
      for (let e4 = 2; e4 < c; ++e4)
        t3.coords[y2 + e4] = F(h, u2[y2 + e4], e4);
    }
  }
  return t3 !== e2 && Ft(t3, u2.length, l2.length), t3;
}
function bt(t3, e2, o, n, r2, s4) {
  if (Ft(t3), t3.lengths.push(...e2.lengths), o === r2 && n === s4)
    for (let u2 = 0; u2 < e2.coords.length; u2++)
      t3.coords.push(e2.coords[u2]);
  else {
    const u2 = d2(o, n), l2 = w(o, n, r2, s4), c = e2.coords;
    for (let e3 = 0; e3 < c.length; e3 += u2)
      l2(t3.coords, c, t3.coords.length, e3, c[e3], c[e3 + 1]);
  }
  return t3;
}
function Mt(t3, e2, o, n) {
  let r2 = 0, s4 = t3[n * e2], u2 = t3[n * (e2 + 1)];
  for (let l2 = 1; l2 < o; l2++) {
    const o2 = s4 + t3[n * (e2 + l2)], c = u2 + t3[n * (e2 + l2) + 1], i = (o2 - s4) * (c + u2);
    s4 = o2, u2 = c, r2 += i;
  }
  return 0.5 * r2;
}
function Nt(t3, e2) {
  const { coords: o, lengths: n } = t3;
  let r2 = 0, s4 = 0;
  for (let u2 = 0; u2 < n.length; u2++) {
    const t4 = n[u2];
    s4 += Mt(o, r2, t4, e2), r2 += t4;
  }
  return Math.abs(s4);
}
function Ft(t3, e2 = 0, o = 0) {
  Pt(t3.lengths, o), Pt(t3.coords, e2);
}
function Pt(t3, e2 = 0) {
  t3.length !== e2 && (t3.length = e2);
}
var xt = { originPosition: "lowerLeft", scale: [1, 1, 1, 1], translate: [0, 0, 0, 0] };

export {
  M,
  N,
  P,
  L,
  U,
  $,
  C,
  H,
  K,
  Q,
  tt,
  et,
  ot,
  nt,
  rt,
  st,
  ct,
  it,
  ft,
  at,
  ht,
  dt,
  yt,
  It,
  bt,
  Nt
};
//# sourceMappingURL=chunk-KKGVORR5.js.map
