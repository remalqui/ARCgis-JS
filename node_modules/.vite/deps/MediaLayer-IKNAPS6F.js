import {
  h,
  i as i3,
  j as j3
} from "./chunk-OEF4CKLZ.js";
import "./chunk-55E4WCHV.js";
import {
  t as t3
} from "./chunk-MW2UW5KK.js";
import {
  a as a2
} from "./chunk-5NBE4HDI.js";
import "./chunk-4NLQ63FV.js";
import "./chunk-Y7HVH6RU.js";
import {
  t
} from "./chunk-2HDAD5Q3.js";
import {
  c as c3
} from "./chunk-PPU6QR6F.js";
import {
  O
} from "./chunk-PCVJI7J2.js";
import "./chunk-HZHMZHPT.js";
import {
  e as e2,
  t as t2
} from "./chunk-EF6YPOUN.js";
import "./chunk-NYLF7BL2.js";
import "./chunk-32JSK7KN.js";
import {
  o as o3
} from "./chunk-APDPMAO5.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-S2P7FTAG.js";
import {
  n as n4,
  r as r4
} from "./chunk-VZAEQ6CY.js";
import {
  u as u2
} from "./chunk-SS33L3LC.js";
import {
  A,
  L,
  r as r3
} from "./chunk-X4Y5OF5X.js";
import "./chunk-42RWGG3D.js";
import {
  a as a3
} from "./chunk-LNMNRMVX.js";
import {
  R,
  c as c2,
  i as i2,
  v
} from "./chunk-OO4A3EBQ.js";
import "./chunk-GZTLZ6RD.js";
import {
  l as l2
} from "./chunk-KTEJJM3A.js";
import {
  Rn,
  nn,
  tn
} from "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import {
  c
} from "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  b
} from "./chunk-XU2Q4SCK.js";
import {
  i
} from "./chunk-KIEN3CY2.js";
import {
  n as n2
} from "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-Y2CLYMXQ.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import "./chunk-KSQTM6XI.js";
import {
  _
} from "./chunk-J4R3XNTP.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import {
  j as j2
} from "./chunk-TCASQSKO.js";
import {
  o as o2
} from "./chunk-5HAVROZG.js";
import {
  m as m3
} from "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import {
  r as r2
} from "./chunk-TJB4CGOM.js";
import {
  n as n3
} from "./chunk-5EXFDBQJ.js";
import {
  l
} from "./chunk-XN5VV437.js";
import {
  n
} from "./chunk-WBSPL6CJ.js";
import {
  m as m2
} from "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import {
  M,
  x as x2
} from "./chunk-3GSONYPC.js";
import {
  S2 as S,
  f,
  o2 as o,
  r,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import {
  s as s4
} from "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import {
  u2 as u
} from "./chunk-7A5C2EQ3.js";
import {
  m,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  V as V2,
  Y,
  Z,
  st,
  tt
} from "./chunk-O3CHVGVF.js";
import {
  s as s3
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c4 = class extends l2 {
  projectOrWarn(e3, r5) {
    if (null == e3)
      return e3;
    const { geometry: t4, pending: c6 } = tn(e3, r5);
    return c6 ? null : c6 || t4 ? t4 : (s.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e3, sourceSpatialReference: e3.spatialReference, targetSpatialReference: r5 }), null);
  }
};
c4 = e([a("esri.layers.support.GeoreferenceBase")], c4);
var a4 = c4;

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var C = e2();
var T = n4();
var _2 = class extends m {
  constructor() {
    super(...arguments), this.sourcePoint = null, this.mapPoint = null;
  }
};
e([y()], _2.prototype, "sourcePoint", void 0), e([y({ type: x })], _2.prototype, "mapPoint", void 0), _2 = e([a("esri.layers.support.ControlPoint")], _2);
var O2 = class extends u(a4) {
  constructor(o4) {
    super(o4), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(o4, t4) {
    const r5 = f.fromJSON(t4.spatialReference), n7 = t2(...t4.coefficients, 1);
    return o4.map((o5) => (r3(T, o5.x, o5.y), h(T, T, n7), { sourcePoint: o5, mapPoint: new x({ x: T[0], y: T[1], spatialReference: r5 }) }));
  }
  writeControlPoints(o4, t4, n7, i5) {
    if (null != this.transform)
      null != o4 && k(o4[0]) && (t4.controlPoints = o4.map((o5) => {
        const t5 = o5.sourcePoint;
        return { x: t5.x, y: t5.y };
      }), t4.spatialReference = o4[0].mapPoint.spatialReference.toJSON(), t4.coefficients = this.transform.slice(0, 8));
    else {
      const o5 = new s2("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration.", { layer: i5 == null ? void 0 : i5.layer, georeference: this });
      (i5 == null ? void 0 : i5.messages) ? i5.messages.push(o5) : s.getLogger(this).error(o5.name, o5.message);
    }
  }
  get coords() {
    if (null == this.controlPoints)
      return null;
    const o4 = this._updateTransform(C);
    if (null == o4 || !k(this.controlPoints[0]))
      return null;
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    return K(o4, this.width, this.height, t4);
  }
  set coords(o4) {
    if (null == this.controlPoints || !k(this.controlPoints[0]))
      return;
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (o4 = this.projectOrWarn(o4, t4)))
      return;
    const { width: r5, height: n7 } = this, { rings: [[e3, s5, c6, a6]] } = o4, p2 = { sourcePoint: c(0, n7), mapPoint: new x({ x: e3[0], y: e3[1], spatialReference: t4 }) }, u3 = { sourcePoint: c(0, 0), mapPoint: new x({ x: s5[0], y: s5[1], spatialReference: t4 }) }, m5 = { sourcePoint: c(r5, 0), mapPoint: new x({ x: c6[0], y: c6[1], spatialReference: t4 }) }, f3 = { sourcePoint: c(r5, n7), mapPoint: new x({ x: a6[0], y: a6[1], spatialReference: t4 }) };
    k(p2) && k(u3) && k(m5) && k(f3) && (E(C, p2, u3, m5, f3), this.controlPoints = this.controlPoints.map(({ sourcePoint: o5 }) => (r3(T, o5.x, o5.y), h(T, T, C), { sourcePoint: o5, mapPoint: new x({ x: T[0], y: T[1], spatialReference: t4 }) })));
  }
  get inverseTransform() {
    return null == this.transform ? null : u2(e2(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(o4) {
    if (null == o4 || null == this.transform || null == this.controlPoints || !k(this.controlPoints[0]))
      return null;
    r3(T, o4.x, o4.y);
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    return h(T, T, this.transform), new x({ x: T[0], y: T[1], spatialReference: t4 });
  }
  toSource(o4) {
    if (null == o4 || null == this.inverseTransform || null == this.controlPoints || !k(this.controlPoints[0]))
      return null;
    const t4 = this.controlPoints[0].mapPoint.spatialReference;
    return o4 = o4.normalize(), null == (o4 = tn(o4, t4).geometry) ? null : (r3(T, o4.x, o4.y), h(T, T, this.inverseTransform), c(T[0], T[1]));
  }
  _updateTransform(o4) {
    const { controlPoints: t4, width: r5, height: n7 } = this;
    if (!(null != t4 && r5 > 0 && n7 > 0))
      return null;
    const [e3, i5, s5, l4] = t4;
    if (!k(e3))
      return null;
    const c6 = e3.mapPoint.spatialReference, a6 = this._projectControlPoint(i5, c6), p2 = this._projectControlPoint(s5, c6), u3 = this._projectControlPoint(l4, c6);
    if (!a6.valid || !p2.valid || !u3.valid)
      return null;
    if (!k(a6.controlPoint))
      return null;
    null == o4 && (o4 = e2());
    let m5 = null;
    return m5 = k(p2.controlPoint) && k(u3.controlPoint) ? E(o4, e3, a6.controlPoint, p2.controlPoint, u3.controlPoint) : k(p2.controlPoint) ? B(o4, e3, a6.controlPoint, p2.controlPoint) : z(o4, e3, a6.controlPoint), m5.every((o5) => 0 === o5) ? null : m5;
  }
  _projectControlPoint(o4, t4) {
    if (!k(o4))
      return { valid: true, controlPoint: o4 };
    const { sourcePoint: r5, mapPoint: n7 } = o4, { geometry: i5, pending: s5 } = tn(n7, t4);
    return s5 ? { valid: false, controlPoint: null } : s5 || i5 ? { valid: true, controlPoint: { sourcePoint: r5, mapPoint: i5 } } : (s.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: o4, sourceSpatialReference: n7.spatialReference, targetSpatialReference: t4 }), { valid: false, controlPoint: null });
  }
};
function k(o4) {
  return null != o4 && null != o4.sourcePoint && null != o4.mapPoint;
}
e([y({ type: [_2], json: { write: { allowNull: false, isRequired: true } } })], O2.prototype, "controlPoints", void 0), e([o("controlPoints")], O2.prototype, "readControlPoints", null), e([r("controlPoints")], O2.prototype, "writeControlPoints", null), e([y()], O2.prototype, "coords", null), e([y({ json: { write: true } })], O2.prototype, "height", void 0), e([y({ readOnly: true })], O2.prototype, "inverseTransform", null), e([y({ readOnly: true })], O2.prototype, "transform", null), e([y({ json: { write: true } })], O2.prototype, "width", void 0), O2 = e([a("esri.layers.support.ControlPointsGeoreference")], O2);
var b2 = n4();
var I = n4();
var M2 = n4();
var N = n4();
var A2 = n4();
var J = n4();
var L2 = n4();
var U = n4();
var G = Math.PI / 2;
function q(o4, t4, r5) {
  r3(o4, r5.sourcePoint.x, r5.sourcePoint.y), r3(t4, r5.mapPoint.x, r5.mapPoint.y);
}
function z(o4, t4, r5) {
  return q(b2, A2, t4), q(I, J, r5), L(M2, I, b2, G), L(N, b2, I, G), L(L2, J, A2, -G), L(U, A2, J, -G), H(o4, b2, I, M2, N, A2, J, L2, U);
}
function B(o4, t4, r5, n7) {
  return q(b2, A2, t4), q(I, J, r5), q(M2, L2, n7), A(N, b2, I, 0.5), L(N, M2, N, Math.PI), A(U, A2, J, 0.5), L(U, L2, U, Math.PI), H(o4, b2, I, M2, N, A2, J, L2, U);
}
function E(o4, t4, r5, n7, e3) {
  return q(b2, A2, t4), q(I, J, r5), q(M2, L2, n7), q(N, U, e3), H(o4, b2, I, M2, N, A2, J, L2, U);
}
var W = new Array(8).fill(0);
var D = new Array(8).fill(0);
function F(o4, t4, r5, n7, e3) {
  return o4[0] = t4[0], o4[1] = t4[1], o4[2] = r5[0], o4[3] = r5[1], o4[4] = n7[0], o4[5] = n7[1], o4[6] = e3[0], o4[7] = e3[1], o4;
}
function H(o4, t4, r5, n7, e3, i5, l4, c6, a6) {
  return j3(o4, F(W, t4, r5, n7, e3), F(D, i5, l4, c6, a6));
}
function K(o4, t4, r5, n7) {
  const e3 = r4(0, r5), s5 = r4(0, 0), l4 = r4(t4, 0), c6 = r4(t4, r5);
  return h(e3, e3, o4), h(s5, s5, o4), h(l4, l4, o4), h(c6, c6, o4), new j2({ rings: [[e3, s5, l4, c6, e3]], spatialReference: n7 });
}
var Q = O2;

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var n5 = class extends a4 {
  constructor(t4) {
    super(t4), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t4, topRight: e3, bottomLeft: o4, bottomRight: r5 } = this;
    if (null == t4 || null == e3 || null == o4 || null == r5)
      return null;
    const p2 = t4.spatialReference;
    return e3 = this.projectOrWarn(e3, p2), o4 = this.projectOrWarn(o4, p2), r5 = this.projectOrWarn(r5, p2), null == e3 || null == o4 || null == r5 ? null : new j2({ rings: [[[o4.x, o4.y], [t4.x, t4.y], [e3.x, e3.y], [r5.x, r5.y], [o4.x, o4.y]]], spatialReference: p2 });
  }
  set coords(t4) {
    const { topLeft: e3 } = this;
    if (null == e3)
      return;
    const o4 = e3.spatialReference;
    if (null == (t4 = this.projectOrWarn(t4, o4)))
      return;
    const { rings: [[s5, p2, n7, i5]] } = t4;
    this.bottomLeft = new x({ x: s5[0], y: s5[1], spatialReference: o4 }), this.topLeft = new x({ x: p2[0], y: p2[1], spatialReference: o4 }), this.topRight = new x({ x: n7[0], y: n7[1], spatialReference: o4 }), this.bottomRight = new x({ x: i5[0], y: i5[1], spatialReference: o4 });
  }
};
e([y()], n5.prototype, "coords", null), e([y({ type: x })], n5.prototype, "bottomLeft", void 0), e([y({ type: x })], n5.prototype, "bottomRight", void 0), e([y({ type: x })], n5.prototype, "topLeft", void 0), e([y({ type: x })], n5.prototype, "topRight", void 0), n5 = e([a("esri.layers.support.CornersGeoreference")], n5);
var i4 = n5;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var c5 = class extends a4 {
  constructor(t4) {
    super(t4), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent)
      return null;
    const { xmin: t4, ymin: e3, xmax: r5, ymax: o4, spatialReference: s5 } = this.extent;
    let n7;
    if (this.rotation) {
      const { x: s6, y: i5 } = this.extent.center, a6 = p(s6, i5, this.rotation);
      n7 = [a6(t4, e3), a6(t4, o4), a6(r5, o4), a6(r5, e3)], n7.push(n7[0]);
    } else
      n7 = [[t4, e3], [t4, o4], [r5, o4], [r5, e3], [t4, e3]];
    return new j2({ rings: [n7], spatialReference: s5 });
  }
  set coords(t4) {
    if (null == t4 || null == this.extent)
      return;
    const r5 = this.extent.spatialReference;
    if (null == (t4 = this.projectOrWarn(t4, r5)) || null == t4.extent)
      return;
    const { rings: [[o4, s5, i5]], extent: { center: { x: a6, y: c6 } } } = t4, m5 = m3(Math.PI / 2 - Math.atan2(s5[1] - o4[1], s5[0] - o4[0])), l4 = p(a6, c6, -m5), [u3, x3] = l4(o4[0], o4[1]), [h2, f3] = l4(i5[0], i5[1]);
    this.extent = new M({ xmin: u3, ymin: x3, xmax: h2, ymax: f3, spatialReference: r5 }), this.rotation = m5;
  }
};
function p(t4, e3, r5) {
  const o4 = r2(r5), n7 = Math.cos(o4), i5 = Math.sin(o4);
  return (r6, o5) => [n7 * (r6 - t4) + i5 * (o5 - e3) + t4, n7 * (o5 - e3) - i5 * (r6 - t4) + e3];
}
e([y()], c5.prototype, "coords", null), e([y({ type: M })], c5.prototype, "extent", void 0), e([y({ type: Number })], c5.prototype, "rotation", void 0), c5 = e([a("esri.layers.support.ExtentAndRotationGeoreference")], c5);
var m4 = c5;

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var f2 = { key: "type", base: a4, typeMap: { "control-points": Q, corners: i4, "extent-and-rotation": m4 } };
var l3 = class extends i(u(_)) {
  constructor(e3) {
    super(e3), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e3) {
    return Q.fromJSON(e3);
  }
};
e([y({ types: f2, json: { write: true } })], l3.prototype, "georeference", void 0), e([o("georeference")], l3.prototype, "readGeoreference", null), e([y()], l3.prototype, "opacity", void 0), l3 = e([a("esri.layers.support.MediaElementBase")], l3);
var d = l3;

// node_modules/@arcgis/core/layers/support/ImageElement.js
var j4 = class extends d {
  constructor(e3) {
    super(e3), this.content = null, this.image = null, this.type = "image", this.image = null;
  }
  load() {
    const e3 = this.image;
    if ("string" == typeof e3) {
      const r5 = j(e3, { responseType: "image" }).then(({ data: e4 }) => {
        this._set("content", e4);
      });
      this.addResolvingPromise(r5);
    } else if (e3 instanceof HTMLImageElement) {
      const t4 = e3.decode().then(() => {
        this._set("content", e3);
      });
      this.addResolvingPromise(t4);
    } else
      e3 ? this._set("content", e3) : this.addResolvingPromise(Promise.reject(new s2("image-element:invalid-image-type", "Invalid image type", { image: e3 })));
    return Promise.resolve(this);
  }
  readImage(e3, t4, r5) {
    return i2(t4.url, r5);
  }
  writeImage(e3, t4, r5, n7) {
    if (null == e3)
      return;
    const a6 = n7 == null ? void 0 : n7.portalItem, m5 = n7 == null ? void 0 : n7.resources;
    if (!a6 || !m5)
      return void ("string" == typeof e3 && (t4[r5] = c2(e3, n7)));
    const p2 = "string" != typeof e3 || tt(e3) || Z(e3) ? null : e3;
    if (p2) {
      if (null == v(p2))
        return void (t4[r5] = p2);
      const e4 = c2(p2, { ...n7, verifyItemRelativeUrls: n7 && n7.verifyItemRelativeUrls ? { writtenUrls: n7.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, R.NO);
      if (a6 && e4 && !Y(e4))
        return m5.toKeep.push({ resource: a6.resourceFromPath(e4), compress: false }), void (t4[r5] = e4);
    }
    t4[r5] = "<pending>", m5.pendingOperations.push(w(e3).then((e4) => {
      const o4 = T2(e4, a6);
      t4[r5] = o4.itemRelativeUrl, m5.toAdd.push({ resource: o4, content: e4, compress: false, finish: (e5) => {
        this.image = e5.url;
      } });
    }));
  }
};
e([y({ readOnly: true })], j4.prototype, "content", void 0), e([y({ json: { name: "url", type: String } })], j4.prototype, "image", void 0), e([o("image", ["url"])], j4.prototype, "readImage", null), e([r("image")], j4.prototype, "writeImage", null), e([y({ readOnly: true, json: { name: "mediaType" } })], j4.prototype, "type", void 0), j4 = e([a("esri.layers.support.ImageElement")], j4);
var I2 = j4;
async function w(e3) {
  if ("string" == typeof e3) {
    if (Z(e3)) {
      const { data: r5 } = await j(e3, { responseType: "blob" });
      return r5;
    }
    if (tt(e3))
      return st(e3);
    return w((await j(e3, { responseType: "image" })).data);
  }
  return new Promise((t4) => E2(e3).toBlob(t4));
}
function E2(e3) {
  if (e3 instanceof HTMLCanvasElement)
    return e3;
  const t4 = e3 instanceof HTMLImageElement ? e3.naturalWidth : e3.width, r5 = e3 instanceof HTMLImageElement ? e3.naturalHeight : e3.height, o4 = document.createElement("canvas"), s5 = o4.getContext("2d");
  return o4.width = t4, o4.height = r5, e3 instanceof HTMLImageElement ? s5.drawImage(e3, 0, 0, e3.width, e3.height) : e3 instanceof ImageData && s5.putImageData(e3, 0, 0), o4;
}
function T2(e3, t4) {
  const r5 = n3(), o4 = `${V2("media", r5)}.${t3(e3)}`;
  return t4.resourceFromPath(o4);
}

// node_modules/@arcgis/core/layers/support/VideoElement.js
var n6 = class extends d {
  constructor(e3) {
    super(e3), this.content = null, this.type = "video";
  }
  load() {
    const e3 = this.video;
    if ("string" == typeof e3) {
      const o4 = document.createElement("video");
      o4.src = e3, o4.crossOrigin = "anonymous", o4.autoplay = true, o4.muted = true, o4.loop = true, this.addResolvingPromise(this._loadVideo(o4).then(() => {
        this._set("content", o4);
      }));
    } else
      e3 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e3).then(() => {
        this._set("content", e3);
      })) : this.addResolvingPromise(Promise.reject(new s2("video-element:invalid-video-type", "Invalid video type", { video: e3 })));
    return Promise.resolve(this);
  }
  set video(e3) {
    "not-loaded" === this.loadStatus ? this._set("video", e3) : s.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  _loadVideo(e3) {
    return new Promise((o4, t4) => {
      e3.oncanplay = () => {
        e3.oncanplay = null, e3.play().then(o4, t4);
      }, "anonymous" !== e3.crossOrigin && (e3.crossOrigin = "anonymous", e3.src = e3.src);
    });
  }
};
e([y({ readOnly: true })], n6.prototype, "content", void 0), e([y()], n6.prototype, "video", null), n6 = e([a("esri.layers.support.VideoElement")], n6);
var a5 = n6;

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var M3 = { key: "type", defaultKeyValue: "image", base: d, typeMap: { image: I2, video: a5 } };
var I3 = V.ofType(M3);
var S2 = class extends _.LoadableMixin(m2(a3(n.EventedAccessor))) {
  constructor(e3) {
    super(e3), this._index = new o3(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e4) => {
      for (const s5 of e4.removed) {
        const e5 = this._elementViewsMap.get(s5);
        this._elementViewsMap.delete(s5), this._index.delete(e5), this.handles.remove(e5), e5.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t4 } = this;
      for (const s5 of e4.added) {
        if (this._elementViewsMap.get(s5))
          continue;
        const e5 = new i3({ spatialReference: t4, element: s5 });
        this._elementViewsMap.set(s5, e5);
        const r5 = l(() => e5.coords, () => this._updateIndexForElement(e5, false));
        this._updateIndexForElement(e5, true), this.handles.add(r5, e5);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e5, t5) => this._elementsIndexes.set(e5, t5)), this.emit("refresh");
    }, this.elements = new I3();
  }
  async load(e3) {
    if (s3(e3), !this.spatialReference) {
      const e4 = this.elements.find((e5) => null != e5.georeference && null != e5.georeference.coords);
      this._set("spatialReference", e4 ? e4.georeference.coords.spatialReference : f.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.handles.add(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e3) {
    this._set("elements", n2(e3, this._get("elements"), I3));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus)
      return null;
    const e3 = this._index.fullBounds;
    return null == e3 ? null : new M({ xmin: e3[0], ymin: e3[1], xmax: e3[2], ymax: e3[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e3) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e3) : s.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e3, t4) {
    await this.load(), await Rn(e3.spatialReference, this.spatialReference, null, t4);
    const s5 = S(e3.spatialReference, this.spatialReference) ? e3 : nn(e3, this.spatialReference);
    if (!s5)
      return [];
    const r5 = s5.normalize(), o4 = [];
    for (const n7 of r5)
      this._index.forEachInBounds(o2(n7), ({ normalizedCoords: e4, element: t5 }) => {
        null != e4 && x2(n7, e4) && o4.push(t5);
      });
    return o4.sort((e4, t5) => this._elementsIndexes.get(e4) - this._elementsIndexes.get(t5)), o4;
  }
  _updateIndexForElement(e3, t4) {
    const s5 = e3.normalizedBounds, r5 = this._index.has(e3), o4 = null != s5;
    this._index.delete(e3), o4 && this._index.set(e3, s5), this.notifyChange("fullExtent"), t4 || (r5 !== o4 ? this.emit("refresh") : this.emit("change", { element: e3.element }));
  }
};
e([y()], S2.prototype, "elements", null), e([y({ readOnly: true })], S2.prototype, "fullExtent", null), e([y()], S2.prototype, "spatialReference", null), S2 = e([a("esri.layers.support.LocalMediaElementSource")], S2);
var V3 = S2;

// node_modules/@arcgis/core/layers/MediaLayer.js
function S3(e3) {
  return "object" == typeof e3 && null != e3 && "type" in e3;
}
var g = class extends a2(t(c3(O(b)))) {
  constructor(e3) {
    super(e3), this.effectiveSource = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this.source = new V3();
  }
  load(e3) {
    const t4 = this.source;
    if (!t4)
      return this.addResolvingPromise(Promise.reject(new s2("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer."))), Promise.resolve(this);
    const s5 = S3(t4) ? new V3({ elements: new V([t4]) }) : t4;
    this._set("effectiveSource", s5), this.spatialReference && (s5.spatialReference = this.spatialReference);
    const i5 = s5.load(e3).then(() => {
      this.spatialReference = s5.spatialReference;
    });
    return this.addResolvingPromise(i5), Promise.resolve(this);
  }
  destroy() {
    var _a, _b;
    (_a = this.effectiveSource) == null ? void 0 : _a.destroy(), (_b = this.source) == null ? void 0 : _b.destroy();
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  set source(e3) {
    "not-loaded" === this.loadStatus ? this._set("source", e3) : s.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e3) {
    return e3 ? Array.isArray(e3) ? new V3({ elements: new V(e3) }) : e3 instanceof V ? new V3({ elements: e3 }) : e3 : null;
  }
  readSource(e3, r5, o4) {
    const t4 = "image" === r5.mediaType ? new I2() : "video" === r5.mediaType ? new a5() : null;
    return t4 == null ? void 0 : t4.read(r5, o4), t4;
  }
  writeSource(e3, r5, t4, s5) {
    var _a;
    e3 && S3(e3) && "image" === e3.type ? e3.write(r5, s5) : (s5 == null ? void 0 : s5.messages) && ((_a = s5 == null ? void 0 : s5.messages) == null ? void 0 : _a.push(new s2("media-layer:unsupported-source", "source must be an 'ImageElement'")));
  }
};
e([y({ readOnly: true })], g.prototype, "effectiveSource", void 0), e([y({ type: String })], g.prototype, "copyright", void 0), e([y({ readOnly: true })], g.prototype, "fullExtent", null), e([y({ type: ["MediaLayer"] })], g.prototype, "operationalLayerType", void 0), e([y({ type: ["show", "hide"] })], g.prototype, "listMode", void 0), e([y({ nonNullable: true, json: { write: { enabled: true, allowNull: false } } })], g.prototype, "source", null), e([s4("source")], g.prototype, "castSource", null), e([o("source", ["url"])], g.prototype, "readSource", null), e([r("source")], g.prototype, "writeSource", null), e([y()], g.prototype, "spatialReference", void 0), e([y({ readOnly: true })], g.prototype, "type", void 0), g = e([a("esri.layers.MediaLayer")], g);
var j5 = g;
export {
  j5 as default
};
//# sourceMappingURL=MediaLayer-IKNAPS6F.js.map
