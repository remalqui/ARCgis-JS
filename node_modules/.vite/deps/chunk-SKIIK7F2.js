import {
  T as T3,
  f,
  t as t4
} from "./chunk-KMPUORBS.js";
import {
  n2 as n5,
  n3 as n6
} from "./chunk-TBMS67KR.js";
import {
  e as e3,
  n as n4
} from "./chunk-43WLCRAJ.js";
import {
  s as s2
} from "./chunk-IFHU7PKI.js";
import {
  t as t3
} from "./chunk-Z2RTGLQI.js";
import {
  M as M2,
  W
} from "./chunk-FE2XXDCR.js";
import {
  c,
  u,
  x
} from "./chunk-PEYWLFGJ.js";
import {
  T as T2,
  a,
  a2,
  e2
} from "./chunk-NE5U5H4D.js";
import {
  o
} from "./chunk-V66LHQVK.js";
import {
  r as r2
} from "./chunk-CN3PB7HS.js";
import {
  t as t2
} from "./chunk-FF5LS3YE.js";
import {
  A,
  C,
  D,
  E,
  F,
  G,
  I,
  L,
  M,
  N,
  O,
  P,
  R,
  S,
  T,
  U,
  V,
  X,
  Y,
  _,
  e,
  i,
  n as n2
} from "./chunk-BCDDCNQ2.js";
import {
  n as n3
} from "./chunk-OMDLZQUU.js";
import {
  r
} from "./chunk-KW3ZNPTA.js";
import {
  n3 as n
} from "./chunk-OYBXMT5R.js";
import {
  g
} from "./chunk-HNHXEGH2.js";
import {
  t
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s
} from "./chunk-W2N7YT6I.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MaterialPrograms.js
var e4 = (r6) => {
  let t7 = "";
  t7 += r6[0].toUpperCase();
  for (let e8 = 1; e8 < r6.length; e8++) {
    const s5 = r6[e8];
    s5 === s5.toUpperCase() ? (t7 += "_", t7 += s5) : t7 += s5.toUpperCase();
  }
  return t7;
};
var s3 = (r6) => {
  const s5 = {};
  for (const t7 in r6) {
    s5[e4(t7)] = r6[t7];
  }
  return n4(s5);
};
var o2 = (t7, e8, o5, n9) => {
  const a3 = t7 + t7.substring(t7.lastIndexOf("/")), p = e8 + e8.substring(e8.lastIndexOf("/")), f2 = s3(n9);
  return { attributes: o5, shaders: { vertexShader: f2 + n5(`${a3}.vert`), fragmentShader: f2 + n5(`${p}.frag`) } };
};

// node_modules/@arcgis/core/views/webgl/ContextState.js
var h = class {
  constructor() {
    this.blend = false, this.blendColor = { r: 0, g: 0, b: 0, a: 0 }, this.blendFunction = { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO }, this.blendEquation = { mode: T.ADD, modeAlpha: T.ADD }, this.colorMask = { r: true, g: true, b: true, a: true }, this.faceCulling = false, this.cullFace = N.BACK, this.frontFace = S.CCW, this.scissorTest = false, this.scissorRect = { x: 0, y: 0, width: 0, height: 0 }, this.depthTest = false, this.depthFunction = I.LESS, this.clearDepth = 1, this.depthWrite = true, this.depthRange = { zNear: 0, zFar: 1 }, this.viewport = null, this.stencilTest = false, this.polygonOffsetFill = false, this.polygonOffset = [0, 0], this.stencilFunction = { face: N.FRONT_AND_BACK, func: I.ALWAYS, ref: 0, mask: 1 }, this.clearStencil = 0, this.stencilWriteMask = 1, this.stencilOperation = { face: N.FRONT_AND_BACK, fail: O.KEEP, zFail: O.KEEP, zPass: O.KEEP }, this.clearColor = { r: 0, g: 0, b: 0, a: 0 }, this.program = null, this.vertexBuffer = null, this.indexBuffer = null, this.uniformBuffer = null, this.pixelPackBuffer = null, this.pixelUnpackBuffer = null, this.copyReadBuffer = null, this.copyWriteBuffer = null, this.uniformBufferBindingPoints = new Array(), this.readFramebuffer = null, this.drawFramebuffer = null, this.renderbuffer = null, this.activeTexture = 0, this.textureUnitMap = new Array(), this.vertexArrayObject = null;
  }
};

// node_modules/@arcgis/core/views/support/AllocationTracer.js
var t5 = class {
  constructor(t7) {
    this._allocations = /* @__PURE__ */ new Map(), t7 ? Error.stackTraceLimit = 1 / 0 : (this.add = () => {
    }, this.remove = () => {
    });
  }
  add(t7) {
    this._allocations.set(t7, new Error().stack);
  }
  remove(t7) {
    this._allocations.delete(t7);
  }
  get information() {
    let t7 = "";
    if (this._allocations.size > 0) {
      t7 += `${this._allocations.size} live object allocations:
`;
      const s5 = /* @__PURE__ */ new Map();
      this._allocations.forEach((t8) => {
        s5.set(t8, (s5.get(t8) ?? 0) + 1);
      }), s5.forEach((s6, o5) => {
        const i2 = o5.split("\n");
        i2.shift(), i2.shift(), t7 += `${s6}: ${i2.shift()}
`, i2.forEach((s7) => t7 += `   ${s7}
`);
      });
    }
    return t7;
  }
};

// node_modules/@arcgis/core/views/webgl/InstanceCounter.js
var e5 = { RECORD_ALLOCATIONS: false };
var s4 = class {
  constructor() {
    for (this._current = new Array(), this._max = new Array(), this._allocations = new t5(e5.RECORD_ALLOCATIONS); this._current.length < V.COUNT; )
      this._current.push(0), this._max.push(0);
  }
  resetMax() {
    for (this._max.length = 0; this._max.length < this._current.length; )
      this._max.push(0);
  }
  increment(t7, r6) {
    const e8 = ++this._current[t7];
    this._max[t7] = Math.max(e8, this._max[t7]), this._allocations.add(r6);
  }
  decrement(t7, r6) {
    --this._current[t7], this._allocations.remove(r6);
  }
  get max() {
    return this._max;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this.current.reduce((t7, r6) => t7 + r6, 0);
  }
  get resourceInformation() {
    let t7 = "";
    if (this.total > 0) {
      t7 += "Live objects:\n";
      for (let e8 = 0; e8 < V.COUNT; ++e8) {
        const s5 = this._current[e8];
        s5 > 0 && (t7 += `${V[e8]}: ${s5}
`);
      }
    }
    return t7 += this._allocations.information, t7;
  }
};

// node_modules/@arcgis/core/views/webgl/Parameters.js
var t6 = class {
  constructor(t7, r6, a3) {
    const i2 = r6.textureFilterAnisotropic, m = a3.maxAnisotropy ?? 1 / 0;
    this.versionString = t7.getParameter(t7.VERSION), this.maxVertexTextureImageUnits = t7.getParameter(t7.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.maxVertexAttributes = t7.getParameter(t7.MAX_VERTEX_ATTRIBS), this.maxMaxAnisotropy = i2 ? Math.min(t7.getParameter(i2.MAX_TEXTURE_MAX_ANISOTROPY), m) : 1, this.maxTextureImageUnits = t7.getParameter(t7.MAX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = t7.getParameter(t7.MAX_TEXTURE_SIZE), this.maxRenderbufferSize = t7.getParameter(t7.MAX_RENDERBUFFER_SIZE), this.maxViewportDims = t7.getParameter(t7.MAX_VIEWPORT_DIMS), n6(t7) ? (this.maxUniformBufferBindings = t7.getParameter(t7.MAX_UNIFORM_BUFFER_BINDINGS), this.maxVertexUniformBlocks = t7.getParameter(t7.MAX_VERTEX_UNIFORM_BLOCKS), this.maxFragmentUniformBlocks = t7.getParameter(t7.MAX_FRAGMENT_UNIFORM_BLOCKS), this.maxUniformBlockSize = t7.getParameter(t7.MAX_UNIFORM_BLOCK_SIZE), this.uniformBufferOffsetAlignment = t7.getParameter(t7.UNIFORM_BUFFER_OFFSET_ALIGNMENT), this.maxArrayTextureLayers = t7.getParameter(t7.MAX_ARRAY_TEXTURE_LAYERS), this.maxSamples = t7.getParameter(t7.MAX_SAMPLES)) : (this.maxUniformBufferBindings = 0, this.maxVertexUniformBlocks = 0, this.maxFragmentUniformBlocks = 0, this.maxUniformBlockSize = 0, this.uniformBufferOffsetAlignment = 1, this.maxArrayTextureLayers = 1, this.maxSamples = 1);
  }
};

// node_modules/@arcgis/core/views/webgl/AppleAmdDriverHelper.js
var n7 = class _n {
  constructor(e8) {
    this._rctx = e8, this._indexBuffer = this._createIndexbuffer(), this._program = this._createHelperProgram();
  }
  static getShaderSources() {
    return { vertex: "#version 300 es\n    precision highp float;\n\n    void main(void) {\n      gl_Position = vec4(0.0, 0.0, float(gl_VertexID)-2.0, 1.0);\n    }", fragment: "#version 300 es\n    precision highp float;\n\n    out vec4 fragColor;\n\n    void main(void) {\n      fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }" };
  }
  _createHelperProgram() {
    const e8 = _n.getShaderSources();
    return this._rctx.programCache.acquire(e8.vertex, e8.fragment, /* @__PURE__ */ new Map([]));
  }
  _createIndexbuffer() {
    return c.createIndex(this._rctx, F.STATIC_DRAW, new Uint32Array([0]));
  }
  resetIndicesType() {
    this._program.compiled && this._indexBuffer && (this._rctx.bindVAO(null), this._rctx.useProgram(this._program), this._rctx.bindBuffer(this._indexBuffer, A.ELEMENT_ARRAY_BUFFER), this._rctx.drawElements(E.POINTS, 1, C.UNSIGNED_INT, 0));
  }
  dispose() {
    this._program.dispose(), this._indexBuffer.dispose();
  }
};

// node_modules/@arcgis/core/views/webgl/testAppleAmdDrawArrays.js
var h2 = class extends t4 {
  constructor(r6) {
    super(), this._rctx = r6, this._helperProgram = null, this._rctx.type === n3.WEBGL2 && has("mac") && has("chrome") && (this._program = this._prepareProgram(), this._helperProgram = this._prepareHelperProgram());
  }
  dispose() {
    var _a;
    super.dispose(), (_a = this._helperProgram) == null ? void 0 : _a.dispose(), this._helperProgram = null;
  }
  _test(r6) {
    const e8 = this._rctx;
    e8.resetState();
    const o5 = new e2(1);
    o5.wrapMode = D.CLAMP_TO_EDGE, o5.samplingMode = L.NEAREST;
    const d3 = new x(e8, o5), h3 = c.createIndex(this._rctx, F.STATIC_DRAW, new Uint8Array([0]));
    e8.bindFramebuffer(d3), e8.setViewport(0, 0, 1, 1), e8.useProgram(this._helperProgram), e8.bindBuffer(h3, A.ELEMENT_ARRAY_BUFFER), e8.drawElements(E.POINTS, 1, C.UNSIGNED_BYTE, 0), e8.useProgram(r6), e8.bindVAO(null), e8.drawArrays(E.TRIANGLES, 0, 258);
    const _3 = new Uint8Array(4);
    return d3.readPixels(0, 0, 1, 1, G.RGBA, U.UNSIGNED_BYTE, _3), d3.dispose(), h3.dispose(), 255 === _3[0];
  }
  _prepareProgram() {
    const e8 = 85, t7 = `#version 300 es
    precision highp float;

    out float triangleId;

    const vec3 triangleVertices[3] = vec3[3](vec3(-0.5, -0.5, 0.0), vec3(0.5, -0.5, 0.0), vec3(0.0, 0.5, 0.0));

    void main(void) {
      triangleId = floor(float(gl_VertexID)/3.0);

      vec3 position = triangleVertices[gl_VertexID % 3];
      float offset = triangleId / ${o.float(e8)};
      position.z = 0.5 - offset;

      gl_Position = vec4(position, 1.0);
    }
    `, o5 = `#version 300 es
    precision highp float;

    in float triangleId;

    out vec4 fragColor;

    void main(void) {
      fragColor = triangleId == ${o.float(e8)} ? vec4(0.0, 1.0, 0.0, 1.0) : vec4(1.0, 0.0, 0.0, 1.0);
    }
    `;
    return this._rctx.programCache.acquire(t7, o5, /* @__PURE__ */ new Map([]));
  }
  _prepareHelperProgram() {
    const r6 = n7.getShaderSources();
    return this._rctx.programCache.acquire(r6.vertex, r6.fragment, /* @__PURE__ */ new Map([]));
  }
};

// node_modules/@arcgis/core/views/webgl/testDoublePrecisionArithmetic.js
var d = class extends t4 {
  constructor(e8) {
    super(), this._rctx = e8, this._program = A2(this._rctx, false), this._obfuscated = A2(this._rctx, true);
  }
  dispose() {
    super.dispose(), this._obfuscated = t(this._obfuscated);
  }
  _test(e8) {
    if (has("force-double-precision-obfuscation"))
      return true;
    if (null == this._obfuscated)
      return false;
    const n9 = this._runProgram(e8), o5 = this._runProgram(this._obfuscated);
    return 0 !== n9 && (0 === o5 || n9 / o5 > 5);
  }
  _runProgram(n9) {
    const _3 = this._rctx;
    _3.resetState();
    const d3 = new e2(1);
    d3.wrapMode = D.CLAMP_TO_EDGE, d3.samplingMode = L.NEAREST;
    const A4 = new x(_3, d3), b = c.createVertex(_3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), g4 = new u(_3, /* @__PURE__ */ new Map([["position", 0]]), { geometry: [new t2("position", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: b }), B = r(5633261287538229e-9, 2626832878767164e-9, 1.4349880495278358e6), F2 = r(563327146742708e-8, 2.6268736381334523e6, 1434963231608387e-9), w = new Float32Array(6);
    t3(B, w, 3);
    const E3 = new Float32Array(6);
    t3(F2, E3, 3), _3.useProgram(n9), n9.setUniform3f("u_highA", w[0], w[2], w[4]), n9.setUniform3f("u_lowA", w[1], w[3], w[5]), n9.setUniform3f("u_highB", E3[0], E3[2], E3[4]), n9.setUniform3f("u_lowB", E3[1], E3[3], E3[5]), _3.bindFramebuffer(A4), _3.setViewport(0, 0, 1, 1), _3.bindVAO(g4), _3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const O2 = new Uint8Array(4);
    A4.readPixels(0, 0, 1, 1, G.RGBA, U.UNSIGNED_BYTE, O2), g4.dispose(), A4.dispose();
    const I2 = (B[2] - F2[2]) / 25, U2 = r2(O2);
    return Math.abs(I2 - U2);
  }
};
function A2(e8, n9) {
  const o5 = `

  precision highp float;

  attribute vec2 position;

  uniform vec3 u_highA;
  uniform vec3 u_lowA;
  uniform vec3 u_highB;
  uniform vec3 u_lowB;

  varying vec4 v_color;

  ${n9 ? "#define DOUBLE_PRECISION_REQUIRES_OBFUSCATION" : ""}

  #ifdef DOUBLE_PRECISION_REQUIRES_OBFUSCATION

  vec3 dpPlusFrc(vec3 a, vec3 b) {
    return mix(a, a + b, vec3(notEqual(b, vec3(0))));
  }

  vec3 dpMinusFrc(vec3 a, vec3 b) {
    return mix(vec3(0), a - b, vec3(notEqual(a, b)));
  }

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = dpPlusFrc(hiA, hiB);
    vec3 e = dpMinusFrc(t1, hiA);
    vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
    return t1 + t2;
  }

  #else

  vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
    vec3 t1 = hiA + hiB;
    vec3 e = t1 - hiA;
    vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
    return t1 + t2;
  }

  #endif

  const float MAX_RGBA_FLOAT =
    255.0 / 256.0 +
    255.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 +
    255.0 / 256.0 / 256.0 / 256.0 / 256.0;

  const vec4 FIXED_POINT_FACTORS = vec4(1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0);

  vec4 float2rgba(const float value) {
    // Make sure value is in the domain we can represent
    float valueInValidDomain = clamp(value, 0.0, MAX_RGBA_FLOAT);

    // Decompose value in 32bit fixed point parts represented as
    // uint8 rgba components. Decomposition uses the fractional part after multiplying
    // by a power of 256 (this removes the bits that are represented in the previous
    // component) and then converts the fractional part to 8bits.
    vec4 fixedPointU8 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS) * 256.0);

    // Convert uint8 values (from 0 to 255) to floating point representation for
    // the shader
    const float toU8AsFloat = 1.0 / 255.0;

    return fixedPointU8 * toU8AsFloat;
  }

  void main() {
    vec3 val = dpAdd(u_highA, u_lowA, -u_highB, -u_lowB);

    v_color = float2rgba(val.z / 25.0);

    gl_Position = vec4(position * 2.0 - 1.0, 0.0, 1.0);
  }
  `, t7 = "\n  precision highp float;\n\n  varying vec4 v_color;\n\n  void main() {\n    gl_FragColor = v_color;\n  }\n  ";
  return e8.programCache.acquire(o5, t7, /* @__PURE__ */ new Map([["position", 0]]));
}

// node_modules/@arcgis/core/views/webgl/testFloatBufferBlend.js
var g2 = class extends t4 {
  constructor(e8) {
    var _a, _b, _c, _d, _e;
    if (super(), this._rctx = e8, !e8.gl)
      return;
    if (e8.type === n3.WEBGL1)
      return void (this._result = !(!((_a = e8.capabilities.textureFloat) == null ? void 0 : _a.textureFloat) || !((_b = e8.capabilities.colorBufferFloat) == null ? void 0 : _b.textureFloat)));
    if (!(((_c = e8.capabilities.textureFloat) == null ? void 0 : _c.textureFloat) && ((_d = e8.capabilities.colorBufferFloat) == null ? void 0 : _d.textureFloat) && ((_e = e8.capabilities.colorBufferFloat) == null ? void 0 : _e.floatBlend)))
      return;
    const t7 = "\n    precision highp float;\n    attribute vec2 a_pos;\n\n    void main() {\n      gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n    }\n    ", o5 = "\n     precision highp float;\n\n     void main() {\n      gl_FragColor = vec4(0.5, 0.5, 0.5, 0.5);\n     }\n    ";
    this._program = e8.programCache.acquire(t7, o5, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  _test(r6) {
    const d3 = this._rctx, g4 = new e2(1);
    g4.wrapMode = D.CLAMP_TO_EDGE, g4.dataType = U.FLOAT, g4.internalFormat = P.RGBA32F, g4.samplingMode = L.NEAREST;
    const _3 = new x(d3, g4), x2 = c.createVertex(d3, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), F2 = new u(d3, /* @__PURE__ */ new Map([["a_pos", 0]]), { geometry: [new t2("a_pos", 2, C.UNSIGNED_SHORT, 0, 4)] }, { geometry: x2 });
    d3.useProgram(r6);
    const w = d3.getBoundFramebufferObject(), { x: j, y: T4, width: A4, height: h3 } = d3.getViewport();
    d3.bindFramebuffer(_3), d3.setViewport(0, 0, 1, 1), d3.bindVAO(F2), d3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const y = W({ blending: s2 });
    d3.setPipelineState(y), d3.drawArrays(E.TRIANGLE_STRIP, 0, 4);
    const E3 = d3.gl.getError();
    return d3.setViewport(j, T4, A4, h3), d3.bindFramebuffer(w), F2.dispose(), _3.dispose(), 1282 !== E3 || (console.warn("Device claims support for WebGL extension EXT_float_blend but does not support it. Using fall back."), false);
  }
};

// node_modules/@arcgis/core/views/webgl/testSamplerPrecision.js
var g3 = class extends t4 {
  constructor(e8) {
    super(), this._rctx = e8;
    const r6 = "\n      precision highp float;\n      attribute vec2 a_pos;\n      uniform highp sampler2D u_texture;\n      varying vec4 v_color;\n\n      float getBit(in float bitset, in int bitIndex) {\n        float offset = pow(2.0, float(bitIndex));\n        return mod(floor(bitset / offset), 2.0);\n      }\n\n      void main() {\n        vec4 value = texture2D(u_texture, vec2(0.0));\n        float bit = getBit(value.x * 255.0, 1);\n\n        v_color = bit * vec4(1.0);\n        gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);\n      }\n      ", t7 = "\n      precision highp float;\n      varying vec4 v_color;\n\n      void main() {\n        gl_FragColor = v_color;\n      }\n      ";
    this._program = e8.programCache.acquire(r6, t7, /* @__PURE__ */ new Map([["a_pos", 0]]));
  }
  _test(d3) {
    const g4 = this._rctx, b = new e2(1);
    b.wrapMode = D.CLAMP_TO_EDGE, b.samplingMode = L.NEAREST;
    const w = new x(g4, b), v2 = new Uint8Array(4), _3 = c.createVertex(g4, F.STATIC_DRAW, new Uint16Array([0, 0, 1, 0, 0, 1, 1, 1])), h3 = new u(g4, /* @__PURE__ */ new Map([["a_position", 0]]), { geometry: [new t2("a_position", 2, C.SHORT, 0, 4)] }, { geometry: _3 });
    g4.useProgram(d3);
    const x2 = new T2(g4, b, new Uint8Array([2, 255, 0, 0]));
    d3.setUniform1i("u_texture", 0), g4.bindTexture(x2, 0);
    const y = g4.getBoundFramebufferObject();
    g4.bindFramebuffer(w), g4.useProgram(d3);
    const { x: A4, y: j, width: T4, height: D2 } = g4.getViewport();
    g4.setViewport(0, 0, 1, 1), g4.bindVAO(h3), g4.drawArrays(E.TRIANGLE_STRIP, 0, 4), g4.setViewport(A4, j, T4, D2), w.readPixels(0, 0, 1, 1, G.RGBA, U.UNSIGNED_BYTE, v2), h3.dispose(), w.dispose();
    const E3 = 255 !== v2[0] || 255 !== v2[1] || 255 !== v2[2] || 255 !== v2[3];
    return E3 && s.getLogger("esri.views.webgl.testSamplerPrecision").warn(`A problem was detected with your graphics driver. Your driver does not appear to honor sampler precision specifiers, which may result in rendering issues due to numerical instability. We recommend ensuring that your drivers have been updated to the latest version. Applying lowp sampler workaround. [${v2[0]}.${v2[1]}.${v2[2]}.${v2[3]}]`), g4.bindFramebuffer(y), E3;
  }
};

// node_modules/@arcgis/core/views/webgl/WebGLDriverTest.js
var o3 = class {
  constructor(o5) {
    this.rctx = o5, this.floatBufferBlend = new g2(o5), this.svgPremultipliesAlpha = new f(o5), this.doublePrecisionRequiresObfuscation = new d(o5), this.ignoresSamplerPrecision = new g3(o5), this.drawArraysRequiresIndicesTypeReset = new h2(o5);
  }
  dispose() {
    this.ignoresSamplerPrecision.dispose(), this.doublePrecisionRequiresObfuscation.dispose(), this.svgPremultipliesAlpha.dispose(), this.floatBufferBlend.dispose(), this.drawArraysRequiresIndicesTypeReset.dispose();
  }
};

// node_modules/@arcgis/core/views/webgl/capabilities/DrawBuffers.js
function A3(A4, _3) {
  if (_3.disjointTimerQuery)
    return null;
  if (n6(A4))
    return { drawBuffers: A4.drawBuffers.bind(A4), MAX_DRAW_BUFFERS: A4.MAX_DRAW_BUFFERS, MAX_COLOR_ATTACHMENTS: A4.MAX_COLOR_ATTACHMENTS };
  if (_3.drawBuffers)
    return null;
  const e8 = A4.getExtension("WEBGL_draw_buffers");
  return e8 ? { drawBuffers: e8.drawBuffersWEBGL.bind(e8), MAX_DRAW_BUFFERS: e8.MAX_DRAW_BUFFERS_WEBGL, MAX_COLOR_ATTACHMENTS: e8.MAX_COLOR_ATTACHMENTS_WEBGL } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Instancing.js
function r3(r6) {
  if (n6(r6))
    return r6;
  const t7 = r6.getExtension("ANGLE_instanced_arrays");
  return t7 ? { drawArraysInstanced: t7.drawArraysInstancedANGLE.bind(t7), drawElementsInstanced: t7.drawElementsInstancedANGLE.bind(t7), vertexAttribDivisor: t7.vertexAttribDivisorANGLE.bind(t7) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/load.js
function _2(t7, _3) {
  if (_3.compressedTextureETC)
    return null;
  const e8 = t7.getExtension("WEBGL_compressed_texture_etc");
  return e8 ? { COMPRESSED_R11_EAC: e8.COMPRESSED_R11_EAC, COMPRESSED_SIGNED_R11_EAC: e8.COMPRESSED_SIGNED_R11_EAC, COMPRESSED_RG11_EAC: e8.COMPRESSED_RG11_EAC, COMPRESSED_SIGNED_RG11_EAC: e8.COMPRESSED_SIGNED_RG11_EAC, COMPRESSED_RGB8_ETC2: e8.COMPRESSED_RGB8_ETC2, COMPRESSED_SRGB8_ETC2: e8.COMPRESSED_SRGB8_ETC2, COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: e8.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: e8.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, COMPRESSED_RGBA8_ETC2_EAC: e8.COMPRESSED_RGBA8_ETC2_EAC, COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: e8.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC } : null;
}
function e6(t7, _3) {
  if (_3.compressedTextureS3TC)
    return null;
  const e8 = t7.getExtension("WEBGL_compressed_texture_s3tc");
  return e8 ? { COMPRESSED_RGB_S3TC_DXT1: e8.COMPRESSED_RGB_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT1: e8.COMPRESSED_RGBA_S3TC_DXT1_EXT, COMPRESSED_RGBA_S3TC_DXT3: e8.COMPRESSED_RGBA_S3TC_DXT3_EXT, COMPRESSED_RGBA_S3TC_DXT5: e8.COMPRESSED_RGBA_S3TC_DXT5_EXT } : null;
}
function E2(_3, e8) {
  if (n6(_3))
    return { MIN: _3.MIN, MAX: _3.MAX };
  if (e8.blendMinMax)
    return null;
  {
    const t7 = _3.getExtension("EXT_blend_minmax");
    return t7 ? { MIN: t7.MIN_EXT, MAX: t7.MAX_EXT } : null;
  }
}
function n8(t7, _3) {
  if (_3.textureFilterAnisotropic)
    return null;
  const e8 = t7.getExtension("EXT_texture_filter_anisotropic") || t7.getExtension("MOZ_EXT_texture_filter_anisotropic") || t7.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
  return e8 ? { MAX_TEXTURE_MAX_ANISOTROPY: e8.MAX_TEXTURE_MAX_ANISOTROPY_EXT, TEXTURE_MAX_ANISOTROPY: e8.TEXTURE_MAX_ANISOTROPY_EXT } : null;
}
function R2(_3, e8) {
  if (n6(_3))
    return { textureFloat: true, textureFloatLinear: !e8.textureFloatLinear && !!_3.getExtension("OES_texture_float_linear"), textureHalfFloat: true, textureHalfFloatLinear: true, HALF_FLOAT: _3.HALF_FLOAT, R16F: _3.R16F, RG16F: _3.RG16F, RGBA16F: _3.RGBA16F, R32F: _3.R32F, RG32F: _3.RG32F, RGBA32F: _3.RGBA32F, R11F_G11F_B10F: _3.R11F_G11F_B10F, RGB16F: _3.RGB16F };
  if (_3 instanceof WebGLRenderingContext) {
    const t7 = !e8.textureHalfFloat && _3.getExtension("OES_texture_half_float");
    return { textureFloat: !e8.textureFloat && !!_3.getExtension("OES_texture_float"), textureFloatLinear: !e8.textureFloatLinear && !!_3.getExtension("OES_texture_float_linear"), textureHalfFloat: !!t7, textureHalfFloatLinear: !e8.textureHalfFloatLinear && !!_3.getExtension("OES_texture_half_float_linear"), HALF_FLOAT: t7 ? t7.HALF_FLOAT_OES : void 0 };
  }
  return null;
}
function r4(_3, e8) {
  if (n6(_3)) {
    const t7 = !e8.colorBufferHalfFloat && _3.getExtension("EXT_color_buffer_half_float") || !e8.colorBufferFloat && _3.getExtension("EXT_color_buffer_float"), E3 = !e8.colorBufferFloat && _3.getExtension("EXT_color_buffer_float"), n9 = !e8.floatBlend && !e8.colorBufferFloat && _3.getExtension("EXT_float_blend");
    return t7 || E3 || n9 ? { textureFloat: !!E3, textureHalfFloat: !!t7, floatBlend: !!n9, R16F: _3.R16F, RG16F: _3.RG16F, RGBA16F: _3.RGBA16F, R32F: _3.R32F, RG32F: _3.RG32F, RGBA32F: _3.RGBA32F, R11F_G11F_B10F: _3.R11F_G11F_B10F, RGB16F: _3.RGB16F } : null;
  }
  if (_3 instanceof WebGLRenderingContext) {
    const t7 = !e8.colorBufferHalfFloat && _3.getExtension("EXT_color_buffer_half_float"), E3 = !e8.colorBufferFloat && _3.getExtension("WEBGL_color_buffer_float"), n9 = !e8.floatBlend && !e8.colorBufferFloat && _3.getExtension("EXT_float_blend");
    return t7 || E3 || n9 ? { textureFloat: !!E3, textureHalfFloat: !!t7, floatBlend: !!n9, RGBA16F: t7 ? t7.RGBA16F_EXT : void 0, RGB16F: t7 ? t7.RGB16F_EXT : void 0, RGBA32F: E3 ? E3.RGBA32F_EXT : void 0 } : null;
  }
  return null;
}
function o4(_3, e8, E3, n9, R3) {
  if (n9 && n6(_3))
    return true;
  if (e8[E3])
    return false;
  for (const t7 of R3)
    if (_3.getExtension(t7))
      return true;
  return false;
}
function l(_3, e8) {
  if (!n6(_3))
    return null;
  if (e8.textureNorm16)
    return null;
  const E3 = _3.getExtension("EXT_texture_norm16");
  return E3 ? { R16: E3.R16_EXT, RG16: E3.RG16_EXT, RGB16: E3.RGB16_EXT, RGBA16: E3.RGBA16_EXT, R16_SNORM: E3.R16_SNORM_EXT, RG16_SNORM: E3.RG16_SNORM_EXT, RGB16_SNORM: E3.RGB16_SNORM_EXT, RGBA16_SNORM: E3.RGBA16_SNORM_EXT } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/LoseContext.js
function e7(e8, t7) {
  const n9 = t7.loseContext && e8.getExtension("WEBGL_lose_context");
  return n9 ? { loseRenderingContext: () => n9.loseContext() } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/VertexArrayObjects.js
function r5(r6, t7) {
  if (n6(r6))
    return { createVertexArray: r6.createVertexArray.bind(r6), deleteVertexArray: r6.deleteVertexArray.bind(r6), bindVertexArray: r6.bindVertexArray.bind(r6) };
  if (t7.vao)
    return null;
  const n9 = r6.getExtension("OES_vertex_array_object") || r6.getExtension("MOZ_OES_vertex_array_object") || r6.getExtension("WEBKIT_OES_vertex_array_object");
  return n9 ? { createVertexArray: n9.createVertexArrayOES.bind(n9), deleteVertexArray: n9.deleteVertexArrayOES.bind(n9), bindVertexArray: n9.bindVertexArrayOES.bind(n9) } : null;
}

// node_modules/@arcgis/core/views/webgl/capabilities/Capabilities.js
var d2 = class {
  constructor(t7, e8) {
    this._gl = t7, this._instancing = null, this._vertexArrayObject = null, this._compressedTextureETC = null, this._compressedTextureS3TC = null, this._textureFilterAnisotropic = null, this._textureFloat = null, this._colorBufferFloat = null, this._minMaxBlending = null, this._loseContext = null, this._drawBuffers = null, this._textureNorm16 = null, this._depthTexture = null, this._textureFloatLinear = null, this._disabledExtensions = e8.disabledExtensions || {}, this._debugWebGLExtensions = e8.debugWebGLExtensions || {};
  }
  get drawBuffers() {
    return this._drawBuffers || (this._drawBuffers = A3(this._gl, this._disabledExtensions)), this._drawBuffers;
  }
  get instancing() {
    return this._instancing || (this._instancing = r3(this._gl)), this._instancing;
  }
  get vao() {
    return this._vertexArrayObject || (this._vertexArrayObject = r5(this._gl, this._disabledExtensions)), this._vertexArrayObject;
  }
  get compressedTextureETC() {
    return this._compressedTextureETC || (this._compressedTextureETC = _2(this._gl, this._disabledExtensions)), this._compressedTextureETC;
  }
  get compressedTextureS3TC() {
    return this._compressedTextureS3TC || (this._compressedTextureS3TC = e6(this._gl, this._disabledExtensions)), this._compressedTextureS3TC;
  }
  get textureFilterAnisotropic() {
    return this._textureFilterAnisotropic || (this._textureFilterAnisotropic = n8(this._gl, this._disabledExtensions)), this._textureFilterAnisotropic;
  }
  get disjointTimerQuery() {
    return this._disjointTimerQuery || (this._disjointTimerQuery = T3(this._gl, this._disabledExtensions)), this._disjointTimerQuery;
  }
  get textureFloat() {
    return this._textureFloat || (this._textureFloat = R2(this._gl, this._disabledExtensions)), this._textureFloat;
  }
  get colorBufferFloat() {
    return this._colorBufferFloat || (this._colorBufferFloat = r4(this._gl, this._disabledExtensions)), this._colorBufferFloat;
  }
  get blendMinMax() {
    return this._minMaxBlending || (this._minMaxBlending = E2(this._gl, this._disabledExtensions)), this._minMaxBlending;
  }
  get depthTexture() {
    return null === this._depthTexture && (this._depthTexture = o4(this._gl, this._disabledExtensions, "depthTexture", true, ["WEBGL_depth_texture", "MOZ_WEBGL_depth_texture", "WEBKIT_WEBGL_depth_texture"])), this._depthTexture;
  }
  get loseContext() {
    return this._loseContext || (this._loseContext = e7(this._gl, this._debugWebGLExtensions)), this._loseContext;
  }
  get textureNorm16() {
    return this._textureNorm16 || (this._textureNorm16 = l(this._gl, this._disabledExtensions)), this._textureNorm16;
  }
  get textureFloatLinear() {
    return null === this._textureFloatLinear && (this._textureFloatLinear = o4(this._gl, this._disabledExtensions, "textureFloatLinear", false, ["OES_texture_float_linear"])), this._textureFloatLinear;
  }
  enable(t7) {
    return this[t7];
  }
};

// node_modules/@arcgis/core/views/webgl/RenderingContext.js
var P2 = class {
  constructor(t7, e8) {
    this.gl = t7, this.instanceCounter = new s4(), this.programCache = new e3(this), this._state = new h(), this._numOfDrawCalls = 0, this._numOfTriangles = 0, this.type = n6(t7) ? n3.WEBGL2 : n3.WEBGL1, this._loadExtensions(), this.configure(e8);
  }
  get gl2() {
    return this.type === n3.WEBGL1 ? null : this.gl;
  }
  configure(e8) {
    this._capabilities = new d2(this.gl, e8), this._parameters = new t6(this.gl, this._capabilities, e8), T2.TEXTURE_UNIT_FOR_UPDATES = this._parameters.maxTextureImageUnits - 1;
    const s5 = this.gl.getParameter(this.gl.VIEWPORT);
    this._state = new h(), this._state.viewport = { x: s5[0], y: s5[1], width: s5[2], height: s5[3] }, this._stateTracker = new M2({ setBlending: (t7) => {
      if (t7) {
        this.setBlendingEnabled(true), this.setBlendEquationSeparate(t7.opRgb, t7.opAlpha), this.setBlendFunctionSeparate(t7.srcRgb, t7.dstRgb, t7.srcAlpha, t7.dstAlpha);
        const e9 = t7.color;
        this.setBlendColor(e9.r, e9.g, e9.b, e9.a);
      } else
        this.setBlendingEnabled(false);
    }, setCulling: (t7) => {
      t7 ? (this.setFaceCullingEnabled(true), this.setCullFace(t7.face), this.setFrontFace(t7.mode)) : this.setFaceCullingEnabled(false);
    }, setPolygonOffset: (t7) => {
      t7 ? (this.setPolygonOffsetFillEnabled(true), this.setPolygonOffset(t7.factor, t7.units)) : this.setPolygonOffsetFillEnabled(false);
    }, setDepthTest: (t7) => {
      t7 ? (this.setDepthTestEnabled(true), this.setDepthFunction(t7.func)) : this.setDepthTestEnabled(false);
    }, setStencilTest: (t7) => {
      if (t7) {
        this.setStencilTestEnabled(true);
        const e9 = t7.function;
        this.setStencilFunction(e9.func, e9.ref, e9.mask);
        const s6 = t7.operation;
        this.setStencilOp(s6.fail, s6.zFail, s6.zPass);
      } else
        this.setStencilTestEnabled(false);
    }, setDepthWrite: (t7) => {
      t7 ? (this.setDepthWriteEnabled(true), this.setDepthRange(t7.zNear, t7.zFar)) : this.setDepthWriteEnabled(false);
    }, setColorWrite: (t7) => {
      t7 ? this.setColorMask(t7.r, t7.g, t7.b, t7.a) : this.setColorMask(false, false, false, false);
    }, setStencilWrite: (t7) => {
      t7 ? this.setStencilWriteMask(t7.mask) : this.setStencilWriteMask(0);
    } }), this.enforceState(), t(this._driverTest), this._driverTest = new o3(this);
  }
  dispose() {
    t(this._driverTest), this.programCache.dispose(), this.bindVAO(null), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), this.type === n3.WEBGL2 && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER)), this._state.textureUnitMap.length = 0, a() && console.log(this.instanceCounter.resourceInformation);
  }
  get driverTest() {
    return this._driverTest;
  }
  get contextAttributes() {
    return this.gl.getContextAttributes();
  }
  get parameters() {
    return this._parameters;
  }
  setPipelineState(t7) {
    this._stateTracker.setPipeline(t7);
  }
  setBlendingEnabled(t7) {
    this._state.blend !== t7 && (true === t7 ? this.gl.enable(this.gl.BLEND) : this.gl.disable(this.gl.BLEND), this._state.blend = t7, this._stateTracker.invalidateBlending());
  }
  externalProgramUpdate() {
    var _a;
    (_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = null;
  }
  externalTextureUnitUpdate(t7, e8) {
    for (let s5 = 0; s5 < t7.length; ++s5)
      this._state.textureUnitMap[t7[s5]] = null;
    e8 >= 0 && (this._state.activeTexture = e8);
  }
  externalVertexArrayObjectUpdate() {
    const t7 = this.capabilities.vao;
    t7 && (t7.bindVertexArray(null), this._state.vertexArrayObject = null), this._state.vertexBuffer = null, this._state.indexBuffer = null;
  }
  externalVertexBufferUpdate() {
    this._state.vertexBuffer = null;
  }
  externalIndexBufferUpdate() {
    this._state.indexBuffer = null;
  }
  setBlendColor(t7, e8, s5, i2) {
    t7 === this._state.blendColor.r && e8 === this._state.blendColor.g && s5 === this._state.blendColor.b && i2 === this._state.blendColor.a || (this.gl.blendColor(t7, e8, s5, i2), this._state.blendColor.r = t7, this._state.blendColor.g = e8, this._state.blendColor.b = s5, this._state.blendColor.a = i2, this._stateTracker.invalidateBlending());
  }
  setBlendFunction(t7, e8) {
    t7 === this._state.blendFunction.srcRGB && e8 === this._state.blendFunction.dstRGB || (this.gl.blendFunc(t7, e8), this._state.blendFunction.srcRGB = t7, this._state.blendFunction.srcAlpha = t7, this._state.blendFunction.dstRGB = e8, this._state.blendFunction.dstAlpha = e8, this._stateTracker.invalidateBlending());
  }
  setBlendFunctionSeparate(t7, e8, s5, i2) {
    this._state.blendFunction.srcRGB === t7 && this._state.blendFunction.srcAlpha === s5 && this._state.blendFunction.dstRGB === e8 && this._state.blendFunction.dstAlpha === i2 || (this.gl.blendFuncSeparate(t7, e8, s5, i2), this._state.blendFunction.srcRGB = t7, this._state.blendFunction.srcAlpha = s5, this._state.blendFunction.dstRGB = e8, this._state.blendFunction.dstAlpha = i2, this._stateTracker.invalidateBlending());
  }
  setBlendEquation(t7) {
    this._state.blendEquation.mode !== t7 && (this.gl.blendEquation(t7), this._state.blendEquation.mode = t7, this._state.blendEquation.modeAlpha = t7, this._stateTracker.invalidateBlending());
  }
  setBlendEquationSeparate(t7, e8) {
    this._state.blendEquation.mode === t7 && this._state.blendEquation.modeAlpha === e8 || (this.gl.blendEquationSeparate(t7, e8), this._state.blendEquation.mode = t7, this._state.blendEquation.modeAlpha = e8, this._stateTracker.invalidateBlending());
  }
  setColorMask(t7, e8, s5, i2) {
    this._state.colorMask.r === t7 && this._state.colorMask.g === e8 && this._state.colorMask.b === s5 && this._state.colorMask.a === i2 || (this.gl.colorMask(t7, e8, s5, i2), this._state.colorMask.r = t7, this._state.colorMask.g = e8, this._state.colorMask.b = s5, this._state.colorMask.a = i2, this._stateTracker.invalidateColorWrite());
  }
  setClearColor(t7, e8, s5, i2) {
    this._state.clearColor.r === t7 && this._state.clearColor.g === e8 && this._state.clearColor.b === s5 && this._state.clearColor.a === i2 || (this.gl.clearColor(t7, e8, s5, i2), this._state.clearColor.r = t7, this._state.clearColor.g = e8, this._state.clearColor.b = s5, this._state.clearColor.a = i2);
  }
  setFaceCullingEnabled(t7) {
    this._state.faceCulling !== t7 && (true === t7 ? this.gl.enable(this.gl.CULL_FACE) : this.gl.disable(this.gl.CULL_FACE), this._state.faceCulling = t7, this._stateTracker.invalidateCulling());
  }
  setPolygonOffsetFillEnabled(t7) {
    this._state.polygonOffsetFill !== t7 && (true === t7 ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL) : this.gl.disable(this.gl.POLYGON_OFFSET_FILL), this._state.polygonOffsetFill = t7, this._stateTracker.invalidatePolygonOffset());
  }
  setPolygonOffset(t7, e8) {
    this._state.polygonOffset[0] === t7 && this._state.polygonOffset[1] === e8 || (this._state.polygonOffset[0] = t7, this._state.polygonOffset[1] = e8, this.gl.polygonOffset(t7, e8), this._stateTracker.invalidatePolygonOffset());
  }
  setCullFace(t7) {
    this._state.cullFace !== t7 && (this.gl.cullFace(t7), this._state.cullFace = t7, this._stateTracker.invalidateCulling());
  }
  setFrontFace(t7) {
    this._state.frontFace !== t7 && (this.gl.frontFace(t7), this._state.frontFace = t7, this._stateTracker.invalidateCulling());
  }
  setScissorTestEnabled(t7) {
    this._state.scissorTest !== t7 && (true === t7 ? this.gl.enable(this.gl.SCISSOR_TEST) : this.gl.disable(this.gl.SCISSOR_TEST), this._state.scissorTest = t7);
  }
  setScissorRect(t7, e8, s5, i2) {
    this._state.scissorRect.x === t7 && this._state.scissorRect.y === e8 && this._state.scissorRect.width === s5 && this._state.scissorRect.height === i2 || (this.gl.scissor(t7, e8, s5, i2), this._state.scissorRect.x = t7, this._state.scissorRect.y = e8, this._state.scissorRect.width = s5, this._state.scissorRect.height = i2);
  }
  setDepthTestEnabled(t7) {
    this._state.depthTest !== t7 && (true === t7 ? this.gl.enable(this.gl.DEPTH_TEST) : this.gl.disable(this.gl.DEPTH_TEST), this._state.depthTest = t7, this._stateTracker.invalidateDepthTest());
  }
  setClearDepth(t7) {
    this._state.clearDepth !== t7 && (this.gl.clearDepth(t7), this._state.clearDepth = t7);
  }
  setDepthFunction(t7) {
    this._state.depthFunction !== t7 && (this.gl.depthFunc(t7), this._state.depthFunction = t7, this._stateTracker.invalidateDepthTest());
  }
  setDepthWriteEnabled(t7) {
    this._state.depthWrite !== t7 && (this.gl.depthMask(t7), this._state.depthWrite = t7, this._stateTracker.invalidateDepthWrite());
  }
  setDepthRange(t7, e8) {
    this._state.depthRange.zNear === t7 && this._state.depthRange.zFar === e8 || (this.gl.depthRange(t7, e8), this._state.depthRange.zNear = t7, this._state.depthRange.zFar = e8, this._stateTracker.invalidateDepthWrite());
  }
  setStencilTestEnabled(t7) {
    this._state.stencilTest !== t7 && (true === t7 ? this.gl.enable(this.gl.STENCIL_TEST) : this.gl.disable(this.gl.STENCIL_TEST), this._state.stencilTest = t7, this._stateTracker.invalidateStencilTest());
  }
  setClearStencil(t7) {
    t7 !== this._state.clearStencil && (this.gl.clearStencil(t7), this._state.clearStencil = t7);
  }
  setStencilFunction(t7, e8, s5) {
    this._state.stencilFunction.func === t7 && this._state.stencilFunction.ref === e8 && this._state.stencilFunction.mask === s5 || (this.gl.stencilFunc(t7, e8, s5), this._state.stencilFunction.face = N.FRONT_AND_BACK, this._state.stencilFunction.func = t7, this._state.stencilFunction.ref = e8, this._state.stencilFunction.mask = s5, this._stateTracker.invalidateStencilTest());
  }
  setStencilFunctionSeparate(t7, e8, s5, i2) {
    this._state.stencilFunction.face === t7 && this._state.stencilFunction.func === e8 && this._state.stencilFunction.ref === s5 && this._state.stencilFunction.mask === i2 || (this.gl.stencilFuncSeparate(t7, e8, s5, i2), this._state.stencilFunction.face = t7, this._state.stencilFunction.func = e8, this._state.stencilFunction.ref = s5, this._state.stencilFunction.mask = i2, this._stateTracker.invalidateStencilTest());
  }
  setStencilWriteMask(t7) {
    this._state.stencilWriteMask !== t7 && (this.gl.stencilMask(t7), this._state.stencilWriteMask = t7, this._stateTracker.invalidateStencilWrite());
  }
  setStencilOp(t7, e8, s5) {
    this._state.stencilOperation.face === N.FRONT_AND_BACK && this._state.stencilOperation.fail === t7 && this._state.stencilOperation.zFail === e8 && this._state.stencilOperation.zPass === s5 || (this.gl.stencilOp(t7, e8, s5), this._state.stencilOperation.face = N.FRONT_AND_BACK, this._state.stencilOperation.fail = t7, this._state.stencilOperation.zFail = e8, this._state.stencilOperation.zPass = s5, this._stateTracker.invalidateStencilTest());
  }
  setStencilOpSeparate(t7, e8, s5, i2) {
    this._state.stencilOperation.face === t7 && this._state.stencilOperation.fail === e8 && this._state.stencilOperation.zFail === s5 && this._state.stencilOperation.zPass === i2 || (this.gl.stencilOpSeparate(t7, e8, s5, i2), this._state.stencilOperation.face = t7, this._state.stencilOperation.fail = e8, this._state.stencilOperation.zFail = s5, this._state.stencilOperation.zPass = i2, this._stateTracker.invalidateStencilTest());
  }
  setActiveTexture(t7, e8 = false) {
    const s5 = this._state.activeTexture;
    return t7 >= 0 && (e8 || t7 !== this._state.activeTexture) && (this.gl.activeTexture(Y + t7), this._state.activeTexture = t7), s5;
  }
  clear(t7) {
    t7 && this.gl.clear(t7);
  }
  clearSafe(t7, e8 = 255) {
    t7 && (t7 & _.COLOR_BUFFER_BIT && this.setColorMask(true, true, true, true), t7 & _.DEPTH_BUFFER_BIT && this.setDepthWriteEnabled(true), t7 & _.STENCIL_BUFFER_BIT && this.setStencilWriteMask(e8), this.gl.clear(t7));
  }
  drawArrays(t7, e8, s5) {
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += N2(t7, s5)), this.gl.drawArrays(t7, e8, s5), a()) {
      const t8 = a2(this);
      t8 && console.error("drawArrays:", t8);
    }
  }
  drawElements(t7, e8, s5, a3) {
    if (a() && (this._numOfDrawCalls++, this._numOfTriangles += N2(t7, e8)), this.gl.drawElements(t7, e8, s5, a3), a()) {
      const i2 = a2(this);
      if (i2) {
        const r6 = this.getBoundVAO(), n9 = r6 == null ? void 0 : r6.indexBuffer, l2 = r6 == null ? void 0 : r6.vertexBuffers, h3 = { indexBuffer: n9, vertexBuffers: l2 }, f2 = { mode: t7, count: e8, type: s5, offset: a3 }, o5 = (n9 == null ? void 0 : n9.size) ?? 0, u2 = a3 + e8, c2 = o5 < u2 ? `. Buffer is too small. Attempted to draw index ${u2} of ${o5}` : "";
        console.error(`drawElements: ${i2}${c2}`, { args: f2, vao: h3 });
      }
    }
  }
  logInfo() {
    a() && console.log(`DrawCalls: ${this._numOfDrawCalls}, Triangles: ${this._numOfTriangles}`);
  }
  resetInfo() {
    a() && (this._numOfDrawCalls = 0, this._numOfTriangles = 0);
  }
  get capabilities() {
    return this._capabilities;
  }
  setViewport(t7, e8, s5, i2) {
    s5 = Math.max(Math.round(s5), 1), i2 = Math.max(Math.round(i2), 1);
    const a3 = this._state.viewport;
    a3.x === t7 && a3.y === e8 && a3.width === s5 && a3.height === i2 || (a3.x = t7, a3.y = e8, a3.width = s5, a3.height = i2, this.gl.viewport(t7, e8, s5, i2));
  }
  getViewport() {
    const t7 = this._state.viewport;
    return { x: t7.x, y: t7.y, width: t7.width, height: t7.height };
  }
  useProgram(t7) {
    var _a;
    this._state.program !== t7 && ((_a = this._state.program) == null ? void 0 : _a.stop(), this._state.program = t7, this.gl.useProgram((t7 == null ? void 0 : t7.glName) ?? null));
  }
  bindTexture(t7, e8, s5 = false) {
    (e8 >= this.parameters.maxTextureImageUnits || e8 < 0) && console.error("Input texture unit is out of range of available units!");
    const i2 = this._state.textureUnitMap[e8];
    return null == t7 || null == t7.glName ? (null != i2 && (this.setActiveTexture(e8, s5), this.gl.bindTexture(i2.descriptor.target, null)), this._state.textureUnitMap[e8] = null, i2) : s5 || i2 !== t7 ? (this.setActiveTexture(e8, s5), this.gl.bindTexture(t7.descriptor.target, t7.glName), t7.applyChanges(), this._state.textureUnitMap[e8] = t7, i2) : (t7.isDirty && (this.setActiveTexture(e8, s5), t7.applyChanges()), i2);
  }
  unbindTexture(t7) {
    if (null != t7)
      for (let e8 = 0; e8 < this.parameters.maxTextureImageUnits; e8++)
        this._state.textureUnitMap[e8] === t7 && (this.bindTexture(null, e8), this._state.textureUnitMap[e8] = null);
  }
  bindFramebuffer(t7, e8 = false) {
    if (e8 || this._state.readFramebuffer !== t7 || this._state.drawFramebuffer !== t7) {
      if (null == t7)
        return this.gl.bindFramebuffer(n2.FRAMEBUFFER, null), this._state.readFramebuffer = null, void (this._state.drawFramebuffer = null);
      t7.initializeAndBind(n2.FRAMEBUFFER), this._state.readFramebuffer = t7, this._state.drawFramebuffer = t7;
    }
  }
  bindFramebufferSeparate(t7, e8, s5 = false) {
    const i2 = e8 === n2.READ_FRAMEBUFFER, a3 = i2 ? this._state.readFramebuffer : this._state.drawFramebuffer;
    (s5 || a3 !== t7) && (null == t7 ? this.gl.bindFramebuffer(e8, null) : t7.initializeAndBind(e8), i2 ? this._state.readFramebuffer = t7 ?? null : this._state.drawFramebuffer = t7 ?? null);
  }
  blitFramebuffer(t7, e8, s5 = 0, i2 = 0, a3 = t7.width, r6 = t7.height, n9 = 0, l2 = 0, h3 = e8.width, c2 = e8.height, _3 = _.COLOR_BUFFER_BIT, d3 = L.NEAREST) {
    this.bindFramebufferSeparate(t7, n2.READ_FRAMEBUFFER), this.bindFramebufferSeparate(e8, n2.DRAW_FRAMEBUFFER);
    this.gl.blitFramebuffer(s5, i2, a3, r6, n9, l2, h3, c2, _3, d3);
  }
  bindBuffer(t7, e8) {
    if (t7)
      switch (e8 ?? (e8 = t7.bufferType), e8) {
        case A.ARRAY_BUFFER:
          this._state.vertexBuffer = v(this.gl, t7, e8, this._state.vertexBuffer);
          break;
        case A.ELEMENT_ARRAY_BUFFER:
          this._state.indexBuffer = v(this.gl, t7, e8, this._state.indexBuffer);
          break;
        case A.UNIFORM_BUFFER:
          this._state.uniformBuffer = v(this.gl, t7, e8, this._state.uniformBuffer);
          break;
        case A.PIXEL_PACK_BUFFER:
          this._state.pixelPackBuffer = v(this.gl, t7, e8, this._state.pixelPackBuffer);
          break;
        case A.PIXEL_UNPACK_BUFFER:
          this._state.pixelUnpackBuffer = v(this.gl, t7, e8, this._state.pixelUnpackBuffer);
          break;
        case A.COPY_READ_BUFFER:
          this._state.copyReadBuffer = v(this.gl, t7, e8, this._state.copyReadBuffer);
          break;
        case A.COPY_WRITE_BUFFER:
          this._state.copyWriteBuffer = v(this.gl, t7, e8, this._state.copyWriteBuffer);
      }
  }
  bindRenderbuffer(t7) {
    const e8 = this.gl;
    t7 || (e8.bindRenderbuffer(e8.RENDERBUFFER, null), this._state.renderbuffer = null), this._state.renderbuffer !== t7 && (e8.bindRenderbuffer(e8.RENDERBUFFER, t7.glName), this._state.renderbuffer = t7);
  }
  _getBufferBinding(t7, e8) {
    if (e8 >= this.parameters.maxUniformBufferBindings || e8 < 0)
      return console.error("Uniform buffer binding point is out of range!"), null;
    const s5 = this._state.uniformBufferBindingPoints;
    let i2 = s5[e8];
    return null == i2 && (i2 = { buffer: null, offset: 0, size: 0 }, s5[e8] = i2), i2;
  }
  bindBufferBase(t7, e8, s5) {
    const i2 = this._getBufferBinding(t7, e8);
    if (null == i2)
      return;
    if (i2.buffer === s5 && 0 === i2.offset && 0 === i2.size)
      return;
    this.gl.bindBufferBase(t7, e8, s5 ? s5.glName : null), i2.buffer = s5, i2.offset = 0, i2.size = 0;
  }
  bindBufferRange(t7, e8, s5, i2, a3) {
    const r6 = this._getBufferBinding(t7, e8);
    if (null == r6)
      return;
    if (r6.buffer === s5 && r6.offset === i2 && r6.size === a3)
      return;
    if (i2 % this._parameters.uniformBufferOffsetAlignment != 0)
      return void console.error("Uniform buffer binding offset is not a multiple of the context offset alignment");
    this.gl.bindBufferRange(t7, e8, s5.glName, i2, a3), r6.buffer = s5, r6.offset = i2, r6.size = a3;
  }
  bindUBO(t7, e8, s5, a3) {
    null != e8 ? (a() && (a3 ?? e8.byteLength) > this._parameters.maxUniformBlockSize && console.error("Attempting to bind more data than the maximum uniform block size"), e8.initialize(), void 0 !== s5 && void 0 !== a3 ? this.bindBufferRange(A.UNIFORM_BUFFER, t7, e8.buffer, s5, a3) : this.bindBufferBase(A.UNIFORM_BUFFER, t7, e8.buffer)) : this.bindBufferBase(A.UNIFORM_BUFFER, t7, null);
  }
  unbindUBO(t7) {
    for (let e8 = 0, s5 = this._state.uniformBufferBindingPoints.length; e8 < s5; e8++) {
      const s6 = this._state.uniformBufferBindingPoints[e8];
      null != s6 && s6.buffer === t7.buffer && this.bindBufferBase(A.UNIFORM_BUFFER, e8, null);
    }
  }
  unbindBuffer(t7) {
    switch (t7) {
      case A.ARRAY_BUFFER:
        this._state.vertexBuffer = v(this.gl, null, t7, this._state.vertexBuffer);
        break;
      case A.ELEMENT_ARRAY_BUFFER:
        this._state.indexBuffer = v(this.gl, null, t7, this._state.indexBuffer);
        break;
      case A.UNIFORM_BUFFER:
        this._state.uniformBuffer = v(this.gl, null, t7, this._state.uniformBuffer);
        break;
      case A.PIXEL_PACK_BUFFER:
        this._state.pixelPackBuffer = v(this.gl, null, t7, this._state.pixelPackBuffer);
        break;
      case A.PIXEL_UNPACK_BUFFER:
        this._state.pixelUnpackBuffer = v(this.gl, null, t7, this._state.pixelUnpackBuffer);
        break;
      case A.COPY_READ_BUFFER:
        this._state.copyReadBuffer = v(this.gl, null, t7, this._state.copyReadBuffer);
        break;
      case A.COPY_WRITE_BUFFER:
        this._state.copyWriteBuffer = v(this.gl, null, t7, this._state.copyWriteBuffer);
    }
  }
  bindVAO(t7 = null) {
    null != t7 ? this._state.vertexArrayObject !== t7 && (t7.bind(), this._state.vertexArrayObject = t7) : this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null);
  }
  async clientWaitAsync(t7 = n(10)) {
    const i2 = this.gl, a3 = i2.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!a3)
      throw new Error("Client wait failed, could not create sync object");
    let r6;
    this.instanceCounter.increment(V.Sync, a3), i2.flush();
    do {
      await g(t7), r6 = i2.clientWaitSync(a3, 0, 0);
    } while (r6 === e.TIMEOUT_EXPIRED);
    if (this.instanceCounter.decrement(V.Sync, a3), i2.deleteSync(a3), r6 === e.WAIT_FAILED)
      throw new Error("Client wait failed");
  }
  getBoundFramebufferObject(t7 = n2.FRAMEBUFFER) {
    return t7 === n2.READ_FRAMEBUFFER ? this._state.readFramebuffer : this._state.drawFramebuffer;
  }
  getBoundVAO() {
    return this._state.vertexArrayObject;
  }
  resetState() {
    this.useProgram(null), this.bindVAO(null), this.bindFramebuffer(null, true), this.unbindBuffer(A.ARRAY_BUFFER), this.unbindBuffer(A.ELEMENT_ARRAY_BUFFER), this.type === n3.WEBGL2 && (this.unbindBuffer(A.UNIFORM_BUFFER), this._state.uniformBufferBindingPoints.length = 0, this.unbindBuffer(A.PIXEL_PACK_BUFFER), this.unbindBuffer(A.PIXEL_UNPACK_BUFFER), this.unbindBuffer(A.COPY_READ_BUFFER), this.unbindBuffer(A.COPY_WRITE_BUFFER));
    for (let t7 = 0; t7 < this.parameters.maxTextureImageUnits; ++t7)
      this.bindTexture(null, t7);
    this.setBlendingEnabled(false), this.setBlendFunction(R.ONE, R.ZERO), this.setBlendEquation(T.ADD), this.setBlendColor(0, 0, 0, 0), this.setFaceCullingEnabled(false), this.setCullFace(N.BACK), this.setFrontFace(S.CCW), this.setPolygonOffsetFillEnabled(false), this.setPolygonOffset(0, 0), this.setScissorTestEnabled(false), this.setScissorRect(0, 0, this.gl.canvas.width, this.gl.canvas.height), this.setDepthTestEnabled(false), this.setDepthFunction(I.LESS), this.setDepthRange(0, 1), this.setStencilTestEnabled(false), this.setStencilFunction(I.ALWAYS, 0, 0), this.setStencilOp(O.KEEP, O.KEEP, O.KEEP), this.setClearColor(0, 0, 0, 0), this.setClearDepth(1), this.setClearStencil(0), this.setColorMask(true, true, true, true), this.setStencilWriteMask(4294967295), this.setDepthWriteEnabled(true), this.setViewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
  }
  enforceState() {
    var _a, _b, _c;
    const t7 = this.capabilities.vao;
    t7 && t7.bindVertexArray(null);
    const { gl: e8, gl2: s5 } = this;
    for (let a3 = 0; a3 < this.parameters.maxVertexAttributes; a3++)
      e8.disableVertexAttribArray(a3);
    if (this._state.vertexBuffer ? e8.bindBuffer(this._state.vertexBuffer.bufferType, this._state.vertexBuffer.glName) : e8.bindBuffer(A.ARRAY_BUFFER, null), this._state.indexBuffer ? e8.bindBuffer(this._state.indexBuffer.bufferType, this._state.indexBuffer.glName) : e8.bindBuffer(A.ELEMENT_ARRAY_BUFFER, null), null != s5) {
      this._state.uniformBuffer ? s5.bindBuffer(this._state.uniformBuffer.bufferType, this._state.uniformBuffer.glName) : s5.bindBuffer(A.UNIFORM_BUFFER, null);
      for (let t8 = 0; t8 < this._parameters.maxUniformBufferBindings; t8++) {
        const e9 = this._state.uniformBufferBindingPoints[t8];
        if (null != e9) {
          const { buffer: i3, offset: a3, size: r6 } = e9;
          null !== i3 ? 0 === a3 && 0 === r6 ? s5.bindBufferBase(A.UNIFORM_BUFFER, t8, i3.glName) : s5.bindBufferRange(A.UNIFORM_BUFFER, t8, i3.glName, a3, r6) : s5.bindBufferBase(A.UNIFORM_BUFFER, t8, null);
        }
      }
      this._state.pixelPackBuffer ? s5.bindBuffer(this._state.pixelPackBuffer.bufferType, this._state.pixelPackBuffer.glName) : s5.bindBuffer(A.PIXEL_PACK_BUFFER, null), this._state.pixelUnpackBuffer ? s5.bindBuffer(this._state.pixelUnpackBuffer.bufferType, this._state.pixelUnpackBuffer.glName) : s5.bindBuffer(A.PIXEL_UNPACK_BUFFER, null), this._state.copyReadBuffer ? s5.bindBuffer(this._state.copyReadBuffer.bufferType, this._state.copyReadBuffer.glName) : s5.bindBuffer(A.COPY_READ_BUFFER, null), this._state.copyWriteBuffer ? s5.bindBuffer(this._state.copyWriteBuffer.bufferType, this._state.copyWriteBuffer.glName) : s5.bindBuffer(A.COPY_WRITE_BUFFER, null), s5.bindFramebuffer(n2.READ_FRAMEBUFFER, null), s5.readBuffer(s5.BACK), this._state.readFramebuffer && (s5.bindFramebuffer(n2.READ_FRAMEBUFFER, this._state.readFramebuffer.glName), s5.readBuffer(X.COLOR_ATTACHMENT0)), s5.bindFramebuffer(n2.DRAW_FRAMEBUFFER, ((_a = this._state.drawFramebuffer) == null ? void 0 : _a.glName) ?? null);
    } else
      this._state.readFramebuffer = this._state.drawFramebuffer, e8.bindFramebuffer(n2.FRAMEBUFFER, ((_b = this._state.drawFramebuffer) == null ? void 0 : _b.glName) ?? null);
    if (t7 && this._state.vertexArrayObject) {
      const t8 = this._state.vertexArrayObject;
      this._state.vertexArrayObject && (this._state.vertexArrayObject.unbind(), this._state.vertexArrayObject = null), this.bindVAO(t8);
    }
    e8.useProgram(((_c = this._state.program) == null ? void 0 : _c.glName) ?? null), e8.blendColor(this._state.blendColor.r, this._state.blendColor.g, this._state.blendColor.b, this._state.blendColor.a), e8.bindRenderbuffer(e8.RENDERBUFFER, this._state.renderbuffer ? this._state.renderbuffer.glName : null), true === this._state.blend ? e8.enable(this.gl.BLEND) : e8.disable(this.gl.BLEND), e8.blendEquationSeparate(this._state.blendEquation.mode, this._state.blendEquation.modeAlpha), e8.blendFuncSeparate(this._state.blendFunction.srcRGB, this._state.blendFunction.dstRGB, this._state.blendFunction.srcAlpha, this._state.blendFunction.dstAlpha), e8.clearColor(this._state.clearColor.r, this._state.clearColor.g, this._state.clearColor.b, this._state.clearColor.a), e8.clearDepth(this._state.clearDepth), e8.clearStencil(this._state.clearStencil), e8.colorMask(this._state.colorMask.r, this._state.colorMask.g, this._state.colorMask.b, this._state.colorMask.a), e8.cullFace(this._state.cullFace), e8.depthFunc(this._state.depthFunction), e8.depthRange(this._state.depthRange.zNear, this._state.depthRange.zFar), true === this._state.depthTest ? e8.enable(e8.DEPTH_TEST) : e8.disable(e8.DEPTH_TEST), e8.depthMask(this._state.depthWrite), e8.frontFace(this._state.frontFace), e8.lineWidth(1), true === this._state.faceCulling ? e8.enable(e8.CULL_FACE) : e8.disable(e8.CULL_FACE), e8.polygonOffset(this._state.polygonOffset[0], this._state.polygonOffset[1]), true === this._state.polygonOffsetFill ? e8.enable(e8.POLYGON_OFFSET_FILL) : e8.disable(e8.POLYGON_OFFSET_FILL), e8.scissor(this._state.scissorRect.x, this._state.scissorRect.y, this._state.scissorRect.width, this._state.scissorRect.height), true === this._state.scissorTest ? e8.enable(e8.SCISSOR_TEST) : e8.disable(e8.SCISSOR_TEST), e8.stencilFunc(this._state.stencilFunction.func, this._state.stencilFunction.ref, this._state.stencilFunction.mask), e8.stencilOpSeparate(this._state.stencilOperation.face, this._state.stencilOperation.fail, this._state.stencilOperation.zFail, this._state.stencilOperation.zPass), true === this._state.stencilTest ? e8.enable(e8.STENCIL_TEST) : e8.disable(e8.STENCIL_TEST), e8.stencilMask(this._state.stencilWriteMask);
    for (let a3 = 0; a3 < this.parameters.maxTextureImageUnits; a3++) {
      e8.activeTexture(Y + a3), e8.bindTexture(M.TEXTURE_2D, null), e8.bindTexture(M.TEXTURE_CUBE_MAP, null), this.type === n3.WEBGL2 && (e8.bindTexture(M.TEXTURE_3D, null), e8.bindTexture(M.TEXTURE_2D_ARRAY, null));
      const t8 = this._state.textureUnitMap[a3];
      null != t8 && e8.bindTexture(t8.descriptor.target, t8.glName);
    }
    e8.activeTexture(Y + this._state.activeTexture);
    const i2 = this._state.viewport;
    e8.viewport(i2.x, i2.y, i2.width, i2.height), this.resetInfo();
  }
  _loadExtensions() {
    this.type === n3.WEBGL1 && this.gl.getExtension("OES_element_index_uint"), this.gl.getExtension("KHR_parallel_shader_compile");
  }
};
function v(t7, e8, s5, i2) {
  return e8 ? i2 !== e8 && t7.bindBuffer(s5, e8.glName) : t7.bindBuffer(s5, null), e8;
}
function N2(t7, e8) {
  switch (t7) {
    case E.POINTS:
      return 2 * e8;
    case E.TRIANGLES:
      return e8 / 3;
    case E.TRIANGLE_STRIP:
    case E.TRIANGLE_FAN:
      return e8 - 2;
    default:
      return 0;
  }
}

export {
  o2 as o,
  P2 as P
};
//# sourceMappingURL=chunk-SKIIK7F2.js.map
