import {
  n as n2,
  o as o3
} from "./chunk-PODY5IF6.js";
import {
  s as s2
} from "./chunk-CKK5HS7D.js";
import {
  y
} from "./chunk-RR2V4HRU.js";
import {
  Rn,
  nn
} from "./chunk-SO6DBMQG.js";
import {
  o as o2
} from "./chunk-FJQ7HIY7.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  S2 as S,
  f,
  p
} from "./chunk-SFV6XLDZ.js";
import {
  n,
  o
} from "./chunk-OYBXMT5R.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import {
  F,
  ht,
  yt
} from "./chunk-O3CHVGVF.js";
import {
  j
} from "./chunk-HNHXEGH2.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/layers/ogc/dateUtils.js
function e(e2) {
  return t(e2) ?? n3(e2);
}
function n3(e2) {
  const n4 = new Date(e2).getTime();
  return Number.isNaN(n4) ? null : n4;
}
function t(e2) {
  const n4 = s3.exec(e2);
  if (!(n4 == null ? void 0 : n4.groups))
    return null;
  const t2 = n4.groups, u = +t2.year, o4 = +t2.month - 1, r = +t2.day, f2 = +(t2.hours ?? "0"), i = +(t2.minutes ?? "0"), d = +(t2.seconds ?? "0");
  if (f2 > 23)
    return null;
  if (i > 59)
    return null;
  if (d > 59)
    return null;
  const l = t2.ms ?? "0", c = l ? +l.padEnd(3, "0").substring(0, 3) : 0;
  let a;
  if (t2.isUTC)
    a = Date.UTC(u, o4, r, f2, i, d, c);
  else if (t2.offsetSign) {
    const e3 = +t2.offsetHours, n5 = +t2.offsetMinutes;
    a = 6e4 * ("+" === t2.offsetSign ? -1 : 1) * (60 * e3 + n5) + Date.UTC(u, o4, r, f2, i, d, c);
  } else
    a = new Date(u, o4, r, f2, i, d, c).getTime();
  return Number.isNaN(a) ? null : a;
}
var s3 = /^(?:(?<year>-?\d{4,})-(?<month>\d{2})-(?<day>\d{2}))(?:T(?<hours>\d{2}):(?<minutes>\d{2}):(?<seconds>\d{2})(?:\.(?<ms>\d+))?)?(?:(?<isUTC>Z)|(?:(?<offsetSign>\+|-)(?<offsetHours>\d{2}):(?<offsetMinutes>\d{2})))?$/;

// node_modules/@arcgis/core/layers/ogc/wfsUtils.js
var T = "xlink:href";
var F2 = "2.0.0";
var S2 = "__esri_wfs_id__";
var x = "wfs-layer:getWFSLayerTypeInfo-error";
var C = "wfs-layer:empty-service";
var E = "wfs-layer:feature-type-not-found";
var N = "wfs-layer:geojson-not-supported";
var P = "wfs-layer:kvp-encoding-not-supported";
var R = "wfs-layer:malformed-json";
var j3 = "wfs-layer:unknown-geometry-type";
var A = "wfs-layer:unknown-field-type";
var G = "wfs-layer:unsupported-spatial-reference";
var k = "wfs-layer:unsupported-wfs-version";
async function v(t2, r) {
  const n4 = U((await j2(t2, { responseType: "text", query: { SERVICE: "WFS", REQUEST: "GetCapabilities", VERSION: F2, ...r == null ? void 0 : r.customParameters }, signal: r == null ? void 0 : r.signal })).data);
  return O(t2, n4), n4;
}
function U(e2) {
  const t2 = Z(e2);
  te(t2), re(t2);
  const n4 = t2.firstElementChild, a = n(L(n4));
  return { operations: I(n4), get featureTypes() {
    return Array.from(a());
  }, readFeatureTypes: a };
}
var D = /* @__PURE__ */ new Set(["json", "application/json", "geojson", "application/json; subtype=geojson"]);
function I(e2) {
  let r = false;
  const n4 = { GetCapabilities: { url: "" }, DescribeFeatureType: { url: "" }, GetFeature: { url: "", outputFormat: null, supportsPagination: false } };
  if (o3(e2, { OperationsMetadata: { Operation: (e3) => {
    switch (e3.getAttribute("name")) {
      case "GetCapabilities":
        return { DCP: { HTTP: { Get: (e4) => {
          n4.GetCapabilities.url = e4.getAttribute(T);
        } } } };
      case "DescribeFeatureType":
        return { DCP: { HTTP: { Get: (e4) => {
          n4.DescribeFeatureType.url = e4.getAttribute(T);
        } } } };
      case "GetFeature":
        return { DCP: { HTTP: { Get: (e4) => {
          n4.GetFeature.url = e4.getAttribute(T);
        } } }, Parameter: (e4) => {
          if ("outputFormat" === e4.getAttribute("name"))
            return { AllowedValues: { Value: (e5) => {
              const t2 = e5.textContent;
              t2 && D.has(t2.toLowerCase()) && (n4.GetFeature.outputFormat = t2);
            } } };
        } };
    }
  }, Constraint: (e3) => {
    switch (e3.getAttribute("name")) {
      case "KVPEncoding":
        return { DefaultValue: (e4) => {
          r = "true" === e4.textContent.toLowerCase();
        } };
      case "ImplementsResultPaging":
        return { DefaultValue: (e4) => {
          n4.GetFeature.supportsPagination = "true" === e4.textContent.toLowerCase();
        } };
    }
  } } }), !r)
    throw new s(P, "WFS service doesn't support key/value pair (KVP) encoding");
  if (null == n4.GetFeature.outputFormat)
    throw new s(N, "WFS service doesn't support GeoJSON output format");
  return n4;
}
function O(e2, t2) {
  ht(e2) && (F(e2, t2.operations.DescribeFeatureType.url, true) && (t2.operations.DescribeFeatureType.url = yt(t2.operations.DescribeFeatureType.url)), F(e2, t2.operations.GetFeature.url, true) && (t2.operations.GetFeature.url = yt(t2.operations.GetFeature.url)));
}
function L(e2) {
  return n2(e2, { FeatureTypeList: { FeatureType: (e3) => {
    const t2 = { typeName: "undefined:undefined", name: "", title: "", description: "", extent: null, namespacePrefix: "", namespaceUri: "", supportedSpatialReferences: [] }, r = /* @__PURE__ */ new Set([4326]), n4 = (e4) => {
      var _a, _b, _c;
      const t3 = parseInt(((_c = (_b = (_a = e4.textContent) == null ? void 0 : _a.match(/(?<wkid>\d+$)/i)) == null ? void 0 : _b.groups) == null ? void 0 : _c.wkid) ?? "", 10);
      Number.isNaN(t3) || r.add(t3);
    };
    return o3(e3, { Name: (e4) => {
      const { name: r2, prefix: n5 } = ee(e4.textContent);
      t2.typeName = `${n5}:${r2}`, t2.name = r2, t2.namespacePrefix = n5, t2.namespaceUri = e4.lookupNamespaceURI(n5);
    }, Abstract: (e4) => {
      t2.description = e4.textContent;
    }, Title: (e4) => {
      t2.title = e4.textContent;
    }, WGS84BoundingBox: (e4) => {
      t2.extent = $(e4);
    }, DefaultSRS: n4, DefaultCRS: n4, OtherSRS: n4, OtherCRS: n4 }), t2.title || (t2.title = t2.name), t2.supportedSpatialReferences.push(...r), t2;
  } } });
}
function $(e2) {
  let t2, r, n4, a;
  for (const o4 of e2.children)
    switch (o4.localName) {
      case "LowerCorner":
        [t2, r] = o4.textContent.split(" ").map((e3) => Number.parseFloat(e3));
        break;
      case "UpperCorner":
        [n4, a] = o4.textContent.split(" ").map((e3) => Number.parseFloat(e3));
    }
  return { xmin: t2, ymin: r, xmax: n4, ymax: a, spatialReference: p };
}
function M2(e2, t2, r) {
  return o(e2, (e3) => r ? e3.name === t2 && e3.namespaceUri === r : e3.typeName === t2 || e3.name === t2);
}
async function V(e2, t2, r, n4 = {}) {
  const { featureType: a, extent: o4 } = await W(e2, t2, r, n4), { fields: s4, geometryType: i, swapXY: p2, objectIdField: u, geometryField: l } = await X(e2, a.typeName, n4);
  return { url: e2.operations.GetCapabilities.url, name: a.name, namespaceUri: a.namespaceUri, fields: s4, geometryField: l, geometryType: i, objectIdField: u, spatialReference: n4.spatialReference ?? f.WGS84, extent: o4, swapXY: p2, wfsCapabilities: e2, customParameters: n4.customParameters };
}
async function W(e2, r, n4, a = {}) {
  const { spatialReference: o4 = f.WGS84 } = a, s4 = e2.readFeatureTypes(), i = r ? M2(s4, r, n4) : s4.next().value;
  if (null == i)
    throw r ? new s(E, `The type '${r}' could not be found in the service`) : new s(C, "The service is empty");
  let m = new M({ ...i.extent, spatialReference: o4 });
  if (!S(o4, p))
    try {
      await Rn(p, o4, void 0, a), m = nn(m, p);
    } catch {
      throw new s(G, "Projection not supported");
    }
  return { extent: m, spatialReference: o4, featureType: i };
}
async function X(e2, r, n4 = {}) {
  var _a, _b, _c;
  const [o4, s4] = await j([z(e2.operations.DescribeFeatureType.url, r, n4), q(e2, r, n4)]);
  if (o4.error || s4.error)
    throw new s(x, `An error occurred while getting info about the feature type '${r}'`, { error: o4.error || s4.error });
  const { fields: i, errors: p2 } = o4.value ?? {}, u = ((_a = o4.value) == null ? void 0 : _a.geometryType) || ((_b = s4.value) == null ? void 0 : _b.geometryType), l = ((_c = s4.value) == null ? void 0 : _c.swapXY) ?? false;
  if (null == u)
    throw new s(j3, `The geometry type could not be determined for type '${r}`, { typeName: r, geometryType: u, fields: i, errors: p2 });
  return { ...Y(i ?? []), geometryType: u, swapXY: l };
}
function Y(e2) {
  const t2 = e2.find((e3) => "geometry" === e3.type);
  let r = e2.find((e3) => "oid" === e3.type);
  return e2 = e2.filter((e3) => "geometry" !== e3.type), r || (r = new y({ name: S2, type: "oid", alias: S2 }), e2.unshift(r)), { geometryField: (t2 == null ? void 0 : t2.name) ?? null, objectIdField: r.name, fields: e2 };
}
async function q(t2, r, n4 = {}) {
  var _a;
  let a, o4 = false;
  const [s4, i] = await Promise.all([H(t2.operations.GetFeature.url, r, t2.operations.GetFeature.outputFormat, { ...n4, count: 1 }), j2(t2.operations.GetFeature.url, { responseType: "text", query: B(r, void 0, { ...n4, count: 1 }), signal: n4 == null ? void 0 : n4.signal })]), p2 = "FeatureCollection" === s4.type && ((_a = s4.features[0]) == null ? void 0 : _a.geometry);
  if (p2) {
    let e2;
    switch (a = o2.fromJSON(s2(p2.type)), p2.type) {
      case "Point":
        e2 = p2.coordinates;
        break;
      case "LineString":
      case "MultiPoint":
        e2 = p2.coordinates[0];
        break;
      case "MultiLineString":
      case "Polygon":
        e2 = p2.coordinates[0][0];
        break;
      case "MultiPolygon":
        e2 = p2.coordinates[0][0][0];
    }
    const t3 = /<[^>]*pos[^>]*> *(-?\d+(?:\.\d+)?) (-?\d+(?:\.\d+)?)/.exec(i.data);
    if (t3) {
      const r2 = e2[0].toFixed(3), n5 = e2[1].toFixed(3), a2 = parseFloat(t3[1]).toFixed(3);
      r2 === parseFloat(t3[2]).toFixed(3) && n5 === a2 && (o4 = true);
    }
  }
  return { geometryType: a, swapXY: o4 };
}
async function z(t2, r, n4) {
  return _(r, (await j2(t2, { responseType: "text", query: { SERVICE: "WFS", REQUEST: "DescribeFeatureType", VERSION: F2, TYPENAME: r, ...n4 == null ? void 0 : n4.customParameters }, signal: n4 == null ? void 0 : n4.signal })).data);
}
function _(e2, r) {
  const { name: a } = ee(e2), o4 = Z(r);
  re(o4);
  const s4 = o(n2(o4.firstElementChild, { element: (e3) => ({ name: e3.getAttribute("name"), typeName: ee(e3.getAttribute("type")).name }) }), ({ name: e3 }) => e3 === a);
  if (null != s4) {
    const e3 = o(n2(o4.firstElementChild, { complexType: (e4) => e4 }), (e4) => e4.getAttribute("name") === s4.typeName);
    if (null != e3)
      return Q(e3);
  }
  throw new s(E, `Type '${e2}' not found in document`, { document: new XMLSerializer().serializeToString(o4) });
}
var J = /* @__PURE__ */ new Set(["objectid", "fid"]);
function Q(e2) {
  const r = [], n4 = [];
  let a;
  const o4 = n2(e2, { complexContent: { extension: { sequence: { element: (e3) => e3 } } } });
  for (const s4 of o4) {
    const o5 = s4.getAttribute("name");
    if (!o5)
      continue;
    let i, p2;
    if (s4.hasAttribute("type") ? i = ee(s4.getAttribute("type")).name : o3(s4, { simpleType: { restriction: (e3) => (i = ee(e3.getAttribute("base")).name, { maxLength: (e4) => {
      p2 = +e4.getAttribute("value");
    } }) } }), !i)
      continue;
    const u = "true" === s4.getAttribute("nillable");
    let l = false;
    switch (i.toLowerCase()) {
      case "integer":
      case "nonpositiveinteger":
      case "negativeinteger":
      case "long":
      case "int":
      case "short":
      case "byte":
      case "nonnegativeinteger":
      case "unsignedlong":
      case "unsignedint":
      case "unsignedshort":
      case "unsignedbyte":
      case "positiveinteger":
        n4.push(new y({ name: o5, alias: o5, type: "integer", nullable: u }));
        break;
      case "float":
      case "double":
      case "decimal":
        n4.push(new y({ name: o5, alias: o5, type: "double", nullable: u }));
        break;
      case "boolean":
      case "string":
      case "gyearmonth":
      case "gyear":
      case "gmonthday":
      case "gday":
      case "gmonth":
      case "anyuri":
      case "qname":
      case "notation":
      case "normalizedstring":
      case "token":
      case "language":
      case "idrefs":
      case "entities":
      case "nmtoken":
      case "nmtokens":
      case "name":
      case "ncname":
      case "id":
      case "idref":
      case "entity":
      case "duration":
      case "time":
        n4.push(new y({ name: o5, alias: o5, type: "string", nullable: u, length: p2 ?? 255 }));
        break;
      case "datetime":
      case "date":
        n4.push(new y({ name: o5, alias: o5, type: "date", nullable: u, length: p2 ?? 36 }));
        break;
      case "pointpropertytype":
        a = "point", l = true;
        break;
      case "multipointpropertytype":
        a = "multipoint", l = true;
        break;
      case "curvepropertytype":
      case "multicurvepropertytype":
      case "multilinestringpropertytype":
        a = "polyline", l = true;
        break;
      case "surfacepropertytype":
      case "multisurfacepropertytype":
      case "multipolygonpropertytype":
        a = "polygon", l = true;
        break;
      case "geometrypropertytype":
      case "multigeometrypropertytype":
        l = true, r.push(new s(j3, `geometry type '${i}' is not supported`, { type: new XMLSerializer().serializeToString(e2) }));
        break;
      default:
        r.push(new s(A, `Unknown field type '${i}'`, { type: new XMLSerializer().serializeToString(e2) }));
    }
    l && n4.push(new y({ name: o5, alias: o5, type: "geometry", nullable: u }));
  }
  for (const t2 of n4)
    if ("integer" === t2.type && !t2.nullable && J.has(t2.name.toLowerCase())) {
      t2.type = "oid";
      break;
    }
  return { geometryType: a, fields: n4, errors: r };
}
async function H(r, n4, a, o4) {
  var _a;
  let { data: s4 } = await j2(r, { responseType: "text", query: B(n4, a, o4), signal: o4 == null ? void 0 : o4.signal });
  s4 = s4.replaceAll(/": +(-?\d+),(\d+)(,)?/g, '": $1.$2$3');
  try {
    if ((_a = o4 == null ? void 0 : o4.dateFields) == null ? void 0 : _a.length) {
      const e2 = new Set(o4.dateFields);
      return JSON.parse(s4, (t2, r2) => e2.has(t2) ? e(r2) : r2);
    }
    return JSON.parse(s4);
  } catch (i) {
    throw new s(R, "Error while parsing the response", { response: s4, error: i });
  }
}
function B(e2, t2, r) {
  return { SERVICE: "WFS", REQUEST: "GetFeature", VERSION: F2, TYPENAMES: e2, OUTPUTFORMAT: t2, SRSNAME: "EPSG:4326", STARTINDEX: r == null ? void 0 : r.startIndex, COUNT: r == null ? void 0 : r.count, ...r == null ? void 0 : r.customParameters };
}
function Z(e2) {
  return new DOMParser().parseFromString(e2.trim(), "text/xml");
}
function ee(e2) {
  const [t2, r] = e2.split(":");
  return { prefix: r ? t2 : "", name: r ?? t2 };
}
function te(e2) {
  var _a;
  const r = (_a = e2.firstElementChild) == null ? void 0 : _a.getAttribute("version");
  if (r && r !== F2)
    throw new s(k, `Unsupported WFS version ${r}. Supported version: ${F2}`);
}
function re(e2) {
  let r = "", n4 = "";
  if (o3(e2.firstElementChild, { Exception: (e3) => (r = e3.getAttribute("exceptionCode"), { ExceptionText: (e4) => {
    n4 = e4.textContent;
  } }) }), r)
    throw new s(`wfs-layer:${r}`, n4);
}

export {
  S2 as S,
  v,
  M2 as M,
  V,
  Y,
  H
};
//# sourceMappingURL=chunk-SCYZEDVN.js.map
