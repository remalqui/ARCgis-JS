import {
  o as o2,
  r as r2
} from "./chunk-6VJWKAPY.js";
import {
  i,
  o,
  r,
  s as s4
} from "./chunk-UQOM5GR4.js";
import {
  f
} from "./chunk-YBMFRTPB.js";
import {
  p,
  v
} from "./chunk-T4XWQYGC.js";
import {
  j as j2,
  m2 as m
} from "./chunk-TCASQSKO.js";
import {
  R3 as R,
  d,
  d2
} from "./chunk-SFV6XLDZ.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  L
} from "./chunk-O3CHVGVF.js";
import {
  s,
  s2,
  s3
} from "./chunk-W2N7YT6I.js";

// node_modules/@arcgis/core/rest/geometryService/cut.js
async function o3(o5, i2, n, m3) {
  const a = f(o5), p2 = i2[0].spatialReference, u = { ...m3, query: { ...a.query, f: "json", sr: JSON.stringify(p2), target: JSON.stringify({ geometryType: v(i2[0]), geometries: i2 }), cutter: JSON.stringify(n) } }, c = await j(a.path + "/cut", u), { cutIndexes: f2, geometries: g2 = [] } = c.data;
  return { cutIndexes: f2, geometries: g2.map((e) => {
    const t = p(e);
    return t.spatialReference = p2, t;
  }) };
}

// node_modules/@arcgis/core/rest/geometryService/simplify.js
async function o4(o5, m3, f2) {
  const n = "string" == typeof o5 ? L(o5) : o5, p2 = m3[0].spatialReference, a = v(m3[0]), u = { ...f2, query: { ...n.query, f: "json", sr: p2.wkid ?? JSON.stringify(p2), geometries: JSON.stringify(r2(m3)) } }, { data: y2 } = await j(n.path + "/simplify", u);
  return o2(y2.geometries, a, p2);
}

// node_modules/@arcgis/core/geometry/support/normalizeUtils.js
var m2 = s2.getLogger("esri.geometry.support.normalizeUtils");
function g(e) {
  return "polygon" === e.type;
}
function y(e) {
  return "polygon" === e[0].type;
}
function x(e) {
  return "polyline" === e[0].type;
}
function w(e, n) {
  if (!(e instanceof m || e instanceof j2)) {
    const e2 = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw m2.error(e2), new s3(e2);
  }
  const i2 = o(e), l = [];
  for (const t of i2) {
    const e2 = [];
    l.push(e2), e2.push([t[0][0], t[0][1]]);
    for (let o5 = 0; o5 < t.length - 1; o5++) {
      const s5 = t[o5][0], r3 = t[o5][1], i3 = t[o5 + 1][0], l2 = t[o5 + 1][1], f2 = Math.sqrt((i3 - s5) * (i3 - s5) + (l2 - r3) * (l2 - r3)), c = (l2 - r3) / f2, p2 = (i3 - s5) / f2, u = f2 / n;
      if (u > 1) {
        for (let l3 = 1; l3 <= u - 1; l3++) {
          const t3 = l3 * n, o7 = p2 * t3 + s5, i5 = c * t3 + r3;
          e2.push([o7, i5]);
        }
        const t2 = (f2 + Math.floor(u - 1) * n) / 2, o6 = p2 * t2 + s5, i4 = c * t2 + r3;
        e2.push([o6, i4]);
      }
      e2.push([i3, l2]);
    }
  }
  return g(e) ? new j2({ rings: l, spatialReference: e.spatialReference }) : new m({ paths: l, spatialReference: e.spatialReference });
}
function j3(e, t, n) {
  if (t) {
    const t2 = w(e, 1e6);
    e = R(t2, true);
  }
  return n && (e = s4(e, n)), e;
}
function M(e, t, n) {
  if (Array.isArray(e)) {
    const o5 = e[0];
    if (o5 > t) {
      const n2 = i(o5, t);
      e[0] = o5 + n2 * (-2 * t);
    } else if (o5 < n) {
      const t2 = i(o5, n);
      e[0] = o5 + t2 * (-2 * n);
    }
  } else {
    const o5 = e.x;
    if (o5 > t) {
      const n2 = i(o5, t);
      e = e.clone().offset(n2 * (-2 * t), 0);
    } else if (o5 < n) {
      const t2 = i(o5, n);
      e = e.clone().offset(t2 * (-2 * n), 0);
    }
  }
  return e;
}
function R2(e, t) {
  let n = -1;
  for (let o5 = 0; o5 < t.cutIndexes.length; o5++) {
    const s5 = t.cutIndexes[o5], i2 = t.geometries[o5], f2 = o(i2);
    for (let e2 = 0; e2 < f2.length; e2++) {
      const t2 = f2[e2];
      t2.some((n2) => {
        if (n2[0] < 180)
          return true;
        {
          let n3 = 0;
          for (let e3 = 0; e3 < t2.length; e3++) {
            const o7 = t2[e3][0];
            n3 = o7 > n3 ? o7 : n3;
          }
          n3 = Number(n3.toFixed(9));
          const o6 = -360 * i(n3, 180);
          for (let s6 = 0; s6 < t2.length; s6++) {
            const t3 = i2.getPoint(e2, s6);
            i2.setPoint(e2, s6, t3.clone().offset(o6, 0));
          }
          return true;
        }
      });
    }
    if (s5 === n) {
      if (y(e))
        for (const t2 of o(i2))
          e[s5] = e[s5].addRing(t2);
      else if (x(e))
        for (const t2 of o(i2))
          e[s5] = e[s5].addPath(t2);
    } else
      n = s5, e[s5] = i2;
  }
  return e;
}
async function b(t, n, r3) {
  if (!Array.isArray(t))
    return b([t], n);
  n && "string" != typeof n && m2.warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
  const u = "string" == typeof n ? n : (n == null ? void 0 : n.url) ?? s.geometryServiceUrl;
  let g2, y2, x2, d3, w2, P, v3, L2, U = 0;
  const z = [], A = [];
  for (const e of t)
    if (null != e)
      if (g2 || (g2 = e.spatialReference, y2 = d(g2), x2 = g2.isWebMercator, P = x2 ? 102100 : 4326, d3 = r[P].maxX, w2 = r[P].minX, v3 = r[P].plus180Line, L2 = r[P].minus180Line), y2)
        if ("mesh" === e.type)
          A.push(e);
        else if ("point" === e.type)
          A.push(M(e.clone(), d3, w2));
        else if ("multipoint" === e.type) {
          const t2 = e.clone();
          t2.points = t2.points.map((e2) => M(e2, d3, w2)), A.push(t2);
        } else if ("extent" === e.type) {
          const t2 = e.clone()._normalize(false, false, y2);
          A.push(t2.rings ? new j2(t2) : t2);
        } else if (e.extent) {
          const t2 = e.extent, n2 = i(t2.xmin, w2) * (2 * d3);
          let o5 = 0 === n2 ? e.clone() : s4(e.clone(), n2);
          t2.offset(n2, 0), t2.intersects(v3) && t2.xmax !== d3 ? (U = t2.xmax > U ? t2.xmax : U, o5 = j3(o5, x2), z.push(o5), A.push("cut")) : t2.intersects(L2) && t2.xmin !== w2 ? (U = t2.xmax * (2 * d3) > U ? t2.xmax * (2 * d3) : U, o5 = j3(o5, x2, 360), z.push(o5), A.push("cut")) : A.push(o5);
        } else
          A.push(e.clone());
      else
        A.push(e);
    else
      A.push(e);
  let S = i(U, d3), k = -90;
  const C = S, I = new m();
  for (; S > 0; ) {
    const e = 360 * S - 180;
    I.addPath([[e, k], [e, -1 * k]]), k *= -1, S--;
  }
  if (z.length > 0 && C > 0) {
    const e = R2(z, await o3(u, z, I, r3)), n2 = [], o5 = [];
    for (let r4 = 0; r4 < A.length; r4++) {
      const s6 = A[r4];
      if ("cut" !== s6)
        o5.push(s6);
      else {
        const s7 = e.shift(), i3 = t[r4];
        null != i3 && "polygon" === i3.type && i3.rings && i3.rings.length > 1 && s7.rings.length >= i3.rings.length ? (n2.push(s7), o5.push("simplify")) : o5.push(x2 ? d2(s7) : s7);
      }
    }
    if (!n2.length)
      return o5;
    const s5 = await o4(u, n2, r3), i2 = [];
    for (let t2 = 0; t2 < o5.length; t2++) {
      const e2 = o5[t2];
      "simplify" !== e2 ? i2.push(e2) : i2.push(x2 ? d2(s5.shift()) : s5.shift());
    }
    return i2;
  }
  const X = [];
  for (let e = 0; e < A.length; e++) {
    const t2 = A[e];
    if ("cut" !== t2)
      X.push(t2);
    else {
      const e2 = z.shift();
      X.push(true === x2 ? d2(e2) : e2);
    }
  }
  return X;
}
function v2(e, t) {
  const n = d(t);
  if (n) {
    const [t2, o5] = n.valid, s5 = o5 - t2;
    if (e < t2)
      for (; e < t2; )
        e += s5;
    if (e > o5)
      for (; e > o5; )
        e -= s5;
  }
  return e;
}

export {
  b,
  v2 as v
};
//# sourceMappingURL=chunk-PM3CFO6N.js.map
