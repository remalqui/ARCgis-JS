import {
  o as o5
} from "./chunk-CN3PB7HS.js";
import {
  t as t8,
  u as u4
} from "./chunk-NLX3GR5V.js";
import {
  A as A2,
  F,
  G as G2,
  I,
  L,
  P as P2,
  S,
  b as b2,
  c as c3,
  d,
  e as e7,
  g as g2,
  h as h3,
  i as i5,
  k as k3,
  l as l3,
  m as m4,
  p,
  s as s7,
  t as t9,
  u as u5,
  w as w4,
  x
} from "./chunk-ZL3HOHNK.js";
import {
  C
} from "./chunk-PX3Q44FM.js";
import {
  t as t7
} from "./chunk-XYJMHUDA.js";
import {
  e as e6,
  n as n5,
  t as t5
} from "./chunk-CSLWFQJE.js";
import {
  w as w3
} from "./chunk-A4HFWKMU.js";
import {
  A,
  B,
  C as C2,
  K,
  O,
  P,
  R,
  U as U2,
  X,
  Y,
  Z,
  a as a4,
  e as e3,
  i as i3,
  ie,
  k as k2,
  l as l2,
  m as m2,
  n as n2,
  ne,
  o as o3,
  oe,
  u as u3,
  w as w2,
  y
} from "./chunk-TDXHXKUI.js";
import {
  e as e5,
  t as t4
} from "./chunk-IVABPLLZ.js";
import {
  ae,
  b,
  se,
  w
} from "./chunk-JSMUQBPG.js";
import {
  t as t3
} from "./chunk-M5UHI5WR.js";
import {
  U,
  k,
  q,
  v
} from "./chunk-TQGXXOXA.js";
import {
  a as a5,
  n as n3
} from "./chunk-QNFDBY7V.js";
import {
  e as e4,
  h,
  i as i4,
  o as o4
} from "./chunk-EL72ISXP.js";
import {
  n as n4,
  t as t6
} from "./chunk-5KLICR5E.js";
import {
  m2 as m3,
  s as s6
} from "./chunk-VFQINJTY.js";
import {
  r,
  z
} from "./chunk-X4Y5OF5X.js";
import {
  e as e2,
  u as u2
} from "./chunk-EIE3W25Z.js";
import {
  n as n6,
  u as u6
} from "./chunk-7KM4XBUC.js";
import {
  h as h2
} from "./chunk-KKGH4SRQ.js";
import {
  f as f4,
  l,
  m,
  s as s5,
  u
} from "./chunk-T4XWQYGC.js";
import {
  M,
  N,
  a as a3,
  c as c2,
  f as f3,
  g,
  i,
  n,
  o,
  o2,
  s as s3,
  s2 as s4,
  t as t2
} from "./chunk-TCASQSKO.js";
import {
  a as a2,
  f as f2,
  i as i2
} from "./chunk-5HAVROZG.js";
import {
  G
} from "./chunk-3GSONYPC.js";
import {
  f
} from "./chunk-SFV6XLDZ.js";
import {
  e
} from "./chunk-2YSHZRCT.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a,
  c
} from "./chunk-I5JT24BO.js";
import {
  has,
  t
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/core/BidiText.js
var n7 = new C();
function i6(r16) {
  if (null == r16)
    return ["", false];
  if (!n7.hasBidiChar(r16))
    return [r16, false];
  let i18;
  return i18 = "rtl" === n7.checkContextual(r16) ? "IDNNN" : "ICNNN", [n7.bidiTransform(r16, i18, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t10 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rzCos && 0 !== this.rzSin) && (this.rz = Math.atan2(this.rzSin, this.rzCos)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rzCos = 1, this.rzSin = 0;
  }
  setTranslate(t19, s17) {
    this.tx = t19, this.ty = s17;
  }
  setTranslateZ(t19) {
    this.tz = t19;
  }
  setRotateCS(t19, s17) {
    this.rz = void 0, this.rzCos = t19, this.rzSin = s17;
  }
  setRotate(t19) {
    this.rz = t19, this.rzCos = void 0, this.rzSin = void 0;
  }
  setRotateY(t19) {
    this.ry = t19;
  }
  setScale(t19) {
    this.s = t19;
  }
  setMeasure(t19) {
    this.m = t19;
  }
};

// node_modules/@arcgis/core/geometry/GeometryCursor.js
var a6 = class {
  static fromOptimized(t19, e20, s17 = false, i18 = false) {
    return new p2().initialize(t19, e20, s17, i18, 1);
  }
  static fromJSON(t19, e20 = false, s17 = false) {
    const [i18, h11] = u7(t19);
    return new m5().initialize(i18, h11, e20, s17, 1);
  }
  static fromOptimizedCIM(t19, e20, s17 = false, i18 = false) {
    return new y2().initialize(t19, e20, s17, i18, 1);
  }
  static fromJSONCIM(t19, e20 = false, s17 = false) {
    const [i18, h11] = u7(t19);
    return new l4().initialize(i18, h11, e20, s17, 1);
  }
  static fromFeatureSetReader(t19) {
    const e20 = t19.readGeometryForDisplay(), s17 = t19.geometryType;
    return e20 && s17 ? this.fromOptimized(e20, s17) : null;
  }
  static fromFeatureSetReaderCIM(t19) {
    const e20 = t19.readGeometryForDisplay(), s17 = t19.geometryType;
    return e20 && s17 ? this.fromOptimizedCIM(e20, s17) : null;
  }
  static createEmptyOptimized(t19, e20 = false, s17 = false) {
    return new p2().initialize(new t3(), t19, e20, s17, 1);
  }
  static createEmptyJSON(t19, e20 = false, s17 = false) {
    return new m5().initialize([], t19, e20, s17, 1);
  }
  static createEmptyOptimizedCIM(t19, e20 = false, s17 = false) {
    return new y2().initialize(new t3(), t19, e20, s17, 1);
  }
  static createEmptyJSONCIM(t19, e20 = false, s17 = false) {
    return new l4().initialize([], t19, e20, s17, 1);
  }
  asJSON() {
    const t19 = t2(this);
    return "esriGeometryEnvelope" === this.geometryType ? { xmin: t19[0][0][0], ymin: t19[0][0][1], xmax: t19[0][2][0], ymax: t19[0][2][1] } : "esriGeometryMultipoint" === this.geometryType ? { points: t19.flat() } : "esriGeometryPoint" === this.geometryType ? { x: t19[0][0][0], y: t19[0][0][1] } : "esriGeometryPolygon" === this.geometryType ? { rings: t19 } : { paths: t19 };
  }
  invertY() {
    this.yFactor *= -1;
  }
};
var p2 = class _p extends a6 {
  constructor() {
    super(...arguments), this._end = -1;
  }
  initialize(t19, e20, s17, i18, h11) {
    return this.hasZ = s17, this.hasM = i18, this.geometryType = e20, this._stride = 2 + Number(s17) + Number(i18), this._geometry = t19, this._pathIndex = -1, this._pathOffset = 0, this._pointOffset = -this._stride, this._end = -1, this.yFactor = h11, this;
  }
  reset() {
    this.initialize(this._geometry, this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  seekPathStart() {
    this._pointOffset = this._pathOffset - this._stride;
  }
  seekPathEnd() {
    this._pointOffset = this._end;
  }
  seekInPath(t19) {
    const e20 = this._pathOffset + t19 * this._stride;
    return e20 >= 0 && e20 < this._end && (this._pointOffset = e20, true);
  }
  nextPoint() {
    return (this._pointOffset += this._stride) < this._end;
  }
  prevPoint() {
    return (this._pointOffset -= this._stride) >= this._pathOffset;
  }
  nextPath() {
    if (this._pathIndex >= 0) {
      const t20 = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex];
      this._pathOffset += this._stride * t20;
    }
    this._pointOffset = this._pathOffset - this._stride;
    const t19 = this._geometry.isPoint ? 1 : this._geometry.lengths[this._pathIndex + 1];
    return this._end = this._pointOffset + this._stride + this._stride * t19, ++this._pathIndex < this.numPaths;
  }
  pathLength() {
    const t19 = this._end, e20 = this._stride, s17 = this._geometry.coords;
    let i18 = 0;
    for (let h11 = this._pathOffset + e20; h11 < t19; h11 += e20) {
      const t20 = s17[h11 - e20], n23 = s17[h11 - e20 + 1], r16 = s17[h11] - t20, o10 = s17[h11 + 1] - n23;
      i18 += Math.sqrt(r16 * r16 + o10 * o10);
    }
    return i18;
  }
  startPath() {
    this._geometry.lengths.push(0);
  }
  pushPath(t19) {
    this.startPath(), this.pushPoints(t19);
  }
  pushPoint(t19) {
    for (let e20 = 0; e20 < this._stride; ++e20)
      this._geometry.coords.push(t19[e20]);
    this._geometry.lengths[this.numPaths - 1]++;
  }
  pushXY(t19, e20) {
    this._geometry.coords.push(t19, e20), this._geometry.lengths[this.numPaths - 1]++;
  }
  pushPoints(t19) {
    for (const e20 of t19)
      for (let t20 = 0; t20 < this._stride; ++t20)
        this._geometry.coords.push(e20[t20]);
    this._geometry.lengths[this.numPaths - 1] += t19.length;
  }
  asOptimized() {
    const t19 = this._geometry.clone();
    if (1 !== this.yFactor)
      for (let e20 = 1; e20 < t19.coords.length; e20 += this._stride)
        t19.coords[e20] *= this.yFactor;
    return "esriGeometryPoint" === this.geometryType && (t19.lengths.length = 0), t19;
  }
  isClosed() {
    const t19 = this._geometry.coords, e20 = this._pathOffset, s17 = this._end - this._stride;
    for (let i18 = 0; i18 < this._stride; i18++)
      if (t19[e20 + i18] !== t19[s17 + i18])
        return false;
    return true;
  }
  clone() {
    return new _p().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get numPoints() {
    const { lengths: t19 } = this._geometry;
    return this._pathIndex < 0 || this._pathIndex > t19.length - 1 ? 0 : t19[this._pathIndex];
  }
  get numPaths() {
    return this._geometry.lengths.length;
  }
  get x() {
    return this._geometry.coords[this._pointOffset];
  }
  set x(t19) {
    this._geometry.coords[this._pointOffset] = t19;
  }
  get y() {
    return this.yFactor * this._geometry.coords[this._pointOffset + 1];
  }
  set y(t19) {
    this._geometry.coords[this._pointOffset + 1] = this.yFactor * t19;
  }
  get z() {
    return this._geometry.coords[this._pointOffset + 2];
  }
  set z(t19) {
    this._geometry.coords[this._pointOffset + 2] = t19;
  }
  get m() {
    const t19 = this.hasZ ? 3 : 2;
    return this._geometry.coords[this._pointOffset + t19];
  }
  set m(t19) {
    this._geometry.coords[this._pointOffset + 3] = t19;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get pointIndex() {
    return this._pointOffset / this._stride;
  }
};
function _(t19) {
  const e20 = [t19.x, t19.y];
  return t19.z && e20.push(t19.z), t19.m && e20.push(t19.m), e20;
}
function u7(t19) {
  return f4(t19) ? [t19.rings, "esriGeometryPolygon"] : s5(t19) ? [t19.paths, "esriGeometryPolyline"] : u(t19) ? [[t19.points], "esriGeometryMultipoint"] : m(t19) ? [[[[t19.xmin, t19.ymin], [t19.xmin, t19.ymax], [t19.xmax, t19.ymax], [t19.xmax, t19.ymin], [t19.xmin, t19.ymin]]], "esriGeometryEnvelope"] : l(t19) ? [[[_(t19)]], "esriGeometryPoint"] : [[], "esriGeometryPolyline"];
}
var m5 = class _m extends a6 {
  initialize(t19, e20, s17, i18, h11) {
    return this._paths = t19, this.geometryType = e20, this.hasZ = s17, this.hasM = i18, this._pathIndex = this._pointIndex = -1, this.yFactor = h11, this._mIdx = this.hasZ ? 3 : 2, this;
  }
  reset() {
    this._pathIndex = this._pointIndex = -1;
  }
  seekPathStart() {
    this._pointIndex = -1;
  }
  seekPathEnd() {
    this._pointIndex = this._currentPath.length;
  }
  seekInPath(t19) {
    return t19 >= 0 && t19 < this._currentPath.length && (this._pointIndex = t19, this._currentPoint = this._currentPath[this._pointIndex], true);
  }
  nextPoint() {
    return this._currentPoint = this._currentPath[++this._pointIndex], this._pointIndex < this._currentPath.length;
  }
  prevPoint() {
    return this._currentPoint = this._currentPath[--this._pointIndex], this._pointIndex >= 0;
  }
  nextPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[++this._pathIndex], this._pathIndex < this.numPaths;
  }
  pathLength() {
    const t19 = this._currentPath.length, e20 = this._currentPath;
    let s17 = 0;
    for (let i18 = 1; i18 < t19; i18++) {
      const t20 = e20[i18 - 1], h11 = e20[i18], n23 = t20[0], r16 = t20[1], o10 = h11[0] - n23, a13 = h11[1] - r16;
      s17 += Math.sqrt(o10 * o10 + a13 * a13);
    }
    return s17;
  }
  startPath() {
    this._paths.push([]);
  }
  pushPath(t19) {
    this._paths.push(t19);
  }
  pushPoint(t19) {
    this._paths[this.pathIndex].push(t19);
  }
  pushXY(t19, e20) {
    this._paths[this.pathIndex].push([t19, e20]);
  }
  pushPoints(t19) {
    this._paths[this.pathIndex].push(...t19);
  }
  asOptimized() {
    const t19 = new t3();
    if ("esriGeometryPoint" === this.geometryType)
      t19.coords.push(...this._paths[0][0]), t19.lengths.length = 0;
    else
      for (const e20 of this._paths) {
        for (const s17 of e20)
          t19.coords.push(s17[0]), t19.coords.push(s17[1] * this.yFactor), this.hasZ && t19.coords.push(s17[2]), this.hasM && t19.coords.push(s17[this._mIdx]);
        t19.lengths.push(e20.length);
      }
    return t19;
  }
  isClosed() {
    const t19 = this._currentPath[0], e20 = this._currentPath[this._currentPath.length - 1];
    for (let s17 = 0; s17 < t19.length; s17++)
      if (t19[s17] !== e20[s17])
        return false;
    return true;
  }
  clone() {
    return new _m().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get numPoints() {
    return this._pathIndex < 0 || this._pathIndex > this.numPaths - 1 ? -1 : this._paths[this._pathIndex].length;
  }
  get numPaths() {
    return this._paths.length;
  }
  get x() {
    return this._currentPoint[0];
  }
  set x(t19) {
    this._currentPoint[0] = t19;
  }
  get y() {
    return this.yFactor * this._currentPoint[1];
  }
  set y(t19) {
    this._currentPoint[1] = this.yFactor * t19;
  }
  get z() {
    return this._currentPoint[2];
  }
  set z(t19) {
    this._currentPoint[2] = t19;
  }
  get m() {
    return this._currentPoint[this._mIdx];
  }
  set m(t19) {
    this._currentPoint[this._mIdx] = t19;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get pointIndex() {
    return this._pointIndex;
  }
};
var c4 = 4;
var d2 = 1;
var y2 = class _y extends p2 {
  initialize(t19, e20, s17, i18, h11) {
    return super.initialize(t19, e20, s17, i18, h11), this._controlPoints || (this._controlPoints = this._controlPoints = new Array(this.numPaths).fill(void 0).map((t20) => /* @__PURE__ */ new Set())), this;
  }
  startPath() {
    super.startPath(), this._controlPoints.push(/* @__PURE__ */ new Set());
  }
  clone() {
    const t19 = new _y().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
    return t19._controlPoints = this._controlPoints, t19;
  }
  setControlPoint() {
    this._controlPoints[this.pathIndex].add(this.pointIndex);
  }
  getControlPoint() {
    return this._controlPoints[this.pathIndex].has(this.pointIndex);
  }
  setControlPointAt(t19) {
    this._controlPoints[this.pathIndex].add(t19);
  }
  getControlPointAt(t19) {
    return this._controlPoints[this.pathIndex].has(t19);
  }
};
var l4 = class _l extends m5 {
  initialize(t19, e20, s17, i18, h11) {
    return super.initialize(t19, e20, s17, i18, h11);
  }
  clone() {
    return new _l().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, 1);
  }
  setControlPoint() {
    this._paths[this.pathIndex][this.pointIndex][c4] = d2;
  }
  getControlPoint() {
    return this._paths[this.pathIndex][this.pointIndex][c4] === d2;
  }
  setControlPointAt(t19) {
    this._paths[this.pathIndex][t19][c4] = d2;
  }
  getControlPointAt(t19) {
    return this._paths[this.pathIndex][t19][c4] === d2;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var r2 = 512;
var n8;
var s8 = class {
  constructor(t19) {
    this._geometry = t19;
  }
  next() {
    const t19 = this._geometry;
    return this._geometry = null, t19;
  }
};
function i7(s17, i18) {
  n8 || (n8 = new e6(0, 0, 0, 1));
  const m10 = "esriGeometryPolygon" === s17.geometryType, y5 = m10 ? t5.Polygon : t5.LineString, l12 = m10 ? 3 : 2;
  let c8, p5;
  for (n8.reset(y5), n8.setPixelMargin(i18 + 1), n8.setExtent(r2); s17.nextPath(); )
    if (!(s17.numPoints < l12)) {
      for (s17.nextPoint(), c8 = s17.x, p5 = -s17.y, n8.moveTo(c8, p5); s17.nextPoint(); )
        c8 = s17.x, p5 = -s17.y, n8.lineTo(c8, p5);
      m10 && n8.close();
    }
  const u12 = n8.result(false);
  if (u12) {
    const e20 = a6.createEmptyOptimizedCIM(s17.geometryType);
    for (const t19 of u12) {
      e20.startPath();
      for (const o10 of t19)
        e20.pushXY(o10.x, -o10.y);
    }
    return e20.reset(), e20;
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/CIMImageColorSubstitutionHelper.js
var t11 = class {
  applyColorSubstituition(t19, a13) {
    if (!a13)
      return t19;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e20, height: n23 } = t19, o10 = this._rasterizationCanvas, r16 = o10.getContext("2d");
    t19 !== o10 && (o10.width = e20, o10.height = n23, r16.drawImage(t19, 0, 0, e20, n23));
    const i18 = r16.getImageData(0, 0, e20, n23).data;
    if (a13) {
      for (const h11 of a13)
        if (h11 && h11.oldColor && 4 === h11.oldColor.length && h11.newColor && 4 === h11.newColor.length) {
          const [t20, a14, e21, n24] = h11.oldColor, [o11, r17, s18, l12] = h11.newColor;
          if (t20 === o11 && a14 === r17 && e21 === s18 && n24 === l12)
            continue;
          for (let h12 = 0; h12 < i18.length; h12 += 4)
            t20 === i18[h12] && a14 === i18[h12 + 1] && e21 === i18[h12 + 2] && n24 === i18[h12 + 3] && (i18[h12] = o11, i18[h12 + 1] = r17, i18[h12 + 2] = s18, i18[h12 + 3] = l12);
        }
    }
    const s17 = new ImageData(i18, e20, n23);
    return r16.putImageData(s17, 0, 0), o10;
  }
  tintImageData(t19, a13) {
    if (!a13 || a13.length < 4)
      return t19;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e20, height: n23 } = t19, o10 = this._rasterizationCanvas, r16 = o10.getContext("2d");
    t19 !== o10 && (o10.width = e20, o10.height = n23, r16.drawImage(t19, 0, 0, e20, n23));
    const i18 = r16.getImageData(0, 0, e20, n23), s17 = new Uint8Array(i18.data), h11 = [a13[0] / 255, a13[1] / 255, a13[2] / 255, a13[3] / 255];
    for (let g6 = 0; g6 < s17.length; g6 += 4)
      s17[g6] *= h11[0], s17[g6 + 1] *= h11[1], s17[g6 + 2] *= h11[2], s17[g6 + 3] *= h11[3];
    const l12 = new ImageData(new Uint8ClampedArray(s17.buffer), e20, n23);
    return r16.putImageData(l12, 0, 0), o10;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var e8 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e20, s17, n23, i18, o10) {
    return new t12(e20, s17, n23);
  }
};
e8.instance = null;
var t12 = class {
  constructor(e20, t19, s17) {
    this._inputGeometries = e20, this._angleTolerance = void 0 !== t19.angleTolerance ? t19.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let e20 = this._inputGeometries.next();
    for (; e20; ) {
      if ("esriGeometryPolygon" === e20.geometryType)
        this._isClosed = true;
      else if ("esriGeometryPolyline" === e20.geometryType)
        this._isClosed = false;
      else {
        if ("esriGeometryEnvelope" !== e20.geometryType) {
          e20 = this._inputGeometries.next();
          continue;
        }
        if (this._maxCosAngle)
          return e20;
        this._isClosed = true;
      }
      for (; e20.nextPath(); )
        this._processPath(e20);
      return e20.reset(), e20;
    }
    return null;
  }
  _processPath(e20) {
    if (e20.nextPoint()) {
      const t19 = e20.x, s17 = e20.y;
      let n23 = t19, i18 = s17, o10 = e20.numPoints, l12 = 0, r16 = 0, a13 = 0, h11 = 0, c8 = 0, _4 = 0;
      this._isClosed && ++o10;
      for (let u12 = 1; e20.nextPoint() || u12 < o10; ++u12) {
        let m10, x4;
        this._isClosed && u12 === o10 - 1 ? (m10 = t19, x4 = s17) : (m10 = e20.x, x4 = e20.y);
        const y5 = m10 - n23, g6 = x4 - i18, C4 = Math.sqrt(y5 * y5 + g6 * g6);
        if (u12 > 1 && C4 > 0 && a13 > 0) {
          (l12 * y5 + r16 * g6) / C4 / a13 <= this._maxCosAngle && e20.setControlPointAt(u12 - 1);
        }
        1 === u12 && (h11 = y5, c8 = g6, _4 = C4), C4 > 0 && (n23 = m10, i18 = x4, l12 = y5, r16 = g6, a13 = C4);
      }
      if (this._isClosed && a13 > 0 && _4 > 0) {
        (l12 * h11 + r16 * c8) / _4 / a13 <= this._maxCosAngle && e20.setControlPointAt(0);
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function r3(t19, e20) {
  t19[4] = e20;
}
var s9 = class {
  constructor(e20, r16 = true, s17 = true, i18 = 0) {
    this.isClosed = false, this.geometryCursor = null, this.geometryCursor = !r16 && "esriGeometryPolygon" === e20.geometryType || !s17 && "esriGeometryPolyline" === e20.geometryType ? null : e20, this.geomUnitsPerPoint = i18, this.iteratePath = false, this.internalPlacement = new t10();
  }
  next() {
    if (!this.geometryCursor)
      return null;
    for (; this.iteratePath || this.geometryCursor.nextPath(); ) {
      this.geometryCursor.seekPathStart();
      const t19 = this.processPath(this.geometryCursor);
      if (t19)
        return t19;
    }
    return this.geometryCursor = null, null;
  }
};
var i8 = class {
  constructor(t19, e20, r16, s17 = 0) {
    this.isClosed = false, this.inputGeometries = t19, this.acceptPolygon = e20, this.acceptPolyline = r16, this.geomUnitsPerPoint = s17, this.iteratePath = false, this.multiPathCursor = null;
  }
  next() {
    for (; ; ) {
      if (!this.multiPathCursor) {
        let t19 = this.inputGeometries.next();
        for (; t19 && (this.isClosed = this.acceptPolygon && "esriGeometryPolygon" === t19.geometryType || "esriGeometryEnvelope" === t19.geometryType, this.multiPathCursor = t19, !this.multiPathCursor); )
          t19 = this.inputGeometries.next();
        if (!this.multiPathCursor)
          return null;
      }
      for (; this.iteratePath || this.multiPathCursor.nextPath(); ) {
        this.multiPathCursor.seekPathStart();
        const t19 = this.processPath(this.multiPathCursor);
        if (t19)
          return t19;
      }
      this.multiPathCursor = null;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var n9 = 0.03;
var s10 = class {
  constructor(t19 = 0, e20 = false) {
  }
  isEmpty(t19) {
    if (!t19.nextPoint())
      return true;
    let e20, n23, s17, r16;
    for (e20 = t19.x, n23 = t19.y; t19.nextPoint(); e20 = n23, n23 = r16)
      if (s17 = t19.x, r16 = t19.y, s17 !== e20 || r16 !== n23)
        return t19.seekPathStart(), false;
    return t19.seekPathStart(), true;
  }
  normalize(t19) {
    const e20 = Math.sqrt(t19[0] * t19[0] + t19[1] * t19[1]);
    0 !== e20 && (t19[0] /= e20, t19[1] /= e20);
  }
  getLength(t19, e20, n23, s17) {
    const r16 = n23 - t19, o10 = s17 - e20;
    return Math.sqrt(r16 * r16 + o10 * o10);
  }
  getSegLength(t19) {
    const [[e20, n23], [s17, r16]] = t19;
    return this.getLength(e20, n23, s17, r16);
  }
  getCoord2D(t19, e20, n23, s17, r16) {
    return [t19 + (n23 - t19) * r16, e20 + (s17 - e20) * r16];
  }
  getSegCoord2D(t19, e20) {
    const [[n23, s17], [r16, o10]] = t19;
    return this.getCoord2D(n23, s17, r16, o10, e20);
  }
  getAngle(t19, e20, n23, s17, r16) {
    const o10 = n23 - t19, i18 = s17 - e20;
    return Math.atan2(i18, o10);
  }
  getAngleCS(t19, e20, n23, s17, r16) {
    const o10 = n23 - t19, i18 = s17 - e20, u12 = Math.sqrt(o10 * o10 + i18 * i18);
    return u12 > 0 ? [o10 / u12, i18 / u12] : [1, 0];
  }
  getSegAngleCS(t19, e20) {
    const [[n23, s17], [r16, o10]] = t19;
    return this.getAngleCS(n23, s17, r16, o10, e20);
  }
  cut(t19, e20, n23, s17, r16, o10) {
    return [r16 <= 0 ? [t19, e20] : this.getCoord2D(t19, e20, n23, s17, r16), o10 >= 1 ? [n23, s17] : this.getCoord2D(t19, e20, n23, s17, o10)];
  }
  getSubCurve(e20, n23, s17) {
    const r16 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    return this.appendSubCurve(r16, e20, n23, s17) ? r16 : null;
  }
  appendSubCurve(t19, e20, n23, s17) {
    t19.startPath(), e20.seekPathStart();
    let r16 = 0, o10 = true;
    if (!e20.nextPoint())
      return false;
    let i18 = e20.x, u12 = e20.y;
    for (; e20.nextPoint(); ) {
      const h11 = this.getLength(i18, u12, e20.x, e20.y);
      if (0 !== h11) {
        if (o10) {
          if (r16 + h11 > n23) {
            const l12 = (n23 - r16) / h11;
            let a13 = 1, c8 = false;
            r16 + h11 >= s17 && (a13 = (s17 - r16) / h11, c8 = true);
            const f6 = this.cut(i18, u12, e20.x, e20.y, l12, a13);
            if (f6 && t19.pushPoints(f6), c8)
              break;
            o10 = false;
          }
        } else {
          if (r16 + h11 > s17) {
            const n24 = this.cut(i18, u12, e20.x, e20.y, 0, (s17 - r16) / h11);
            n24 && t19.pushPoint(n24[1]);
            break;
          }
          t19.pushXY(e20.x, e20.y);
        }
        r16 += h11, i18 = e20.x, u12 = e20.y;
      } else
        i18 = e20.x, u12 = e20.y;
    }
    return true;
  }
  getCIMPointAlong(t19, e20) {
    if (!t19.nextPoint())
      return null;
    let n23, s17, r16, o10, i18 = 0;
    for (n23 = t19.x, s17 = t19.y; t19.nextPoint(); n23 = r16, s17 = o10) {
      r16 = t19.x, o10 = t19.y;
      const u12 = this.getLength(n23, s17, r16, o10);
      if (0 !== u12) {
        if (i18 + u12 > e20) {
          const t20 = (e20 - i18) / u12;
          return this.getCoord2D(n23, s17, r16, o10, t20);
        }
        i18 += u12;
      }
    }
    return null;
  }
  offset(t19, n23, s17, r16, o10) {
    if (!t19 || t19.length < 2)
      return null;
    let i18 = 0, u12 = t19[i18++], h11 = i18;
    for (; i18 < t19.length; ) {
      const e20 = t19[i18];
      e20[0] === u12[0] && e20[1] === u12[1] || (i18 !== h11 && (t19[h11] = t19[i18]), u12 = t19[h11++]), i18++;
    }
    const l12 = t19[0][0] === t19[h11 - 1][0] && t19[0][1] === t19[h11 - 1][1];
    if (l12 && --h11, h11 < (l12 ? 3 : 2))
      return null;
    const a13 = [];
    u12 = l12 ? t19[h11 - 1] : null;
    let c8 = t19[0];
    for (let f6 = 0; f6 < h11; f6++) {
      const o11 = f6 === h11 - 1 ? l12 ? t19[0] : null : t19[f6 + 1];
      if (u12)
        if (o11) {
          const t20 = [o11[0] - c8[0], o11[1] - c8[1]];
          this.normalize(t20);
          const i19 = [c8[0] - u12[0], c8[1] - u12[1]];
          this.normalize(i19);
          const h12 = i19[0] * t20[1] - i19[1] * t20[0], l13 = i19[0] * t20[0] + i19[1] * t20[1];
          if (0 === h12 && 1 === l13) {
            c8 = o11;
            continue;
          }
          if (h12 >= 0 == n23 <= 0) {
            if (l13 < 1) {
              const e20 = [t20[0] - i19[0], t20[1] - i19[1]];
              this.normalize(e20);
              const s18 = Math.sqrt((1 + l13) / 2);
              if (s18 > 1 / r16) {
                const t21 = -Math.abs(n23) / s18;
                a13.push([c8[0] - e20[0] * t21, c8[1] - e20[1] * t21]);
              }
            }
          } else
            switch (s17) {
              case O.Mitered: {
                const e20 = Math.sqrt((1 + l13) / 2);
                if (e20 > 0 && 1 / e20 < r16) {
                  const s18 = [t20[0] - i19[0], t20[1] - i19[1]];
                  this.normalize(s18);
                  const r17 = Math.abs(n23) / e20;
                  a13.push([c8[0] - s18[0] * r17, c8[1] - s18[1] * r17]);
                  break;
                }
              }
              case O.Bevelled:
                a13.push([c8[0] + i19[1] * n23, c8[1] - i19[0] * n23]), a13.push([c8[0] + t20[1] * n23, c8[1] - t20[0] * n23]);
                break;
              case O.Rounded:
                if (l13 < 1) {
                  a13.push([c8[0] + i19[1] * n23, c8[1] - i19[0] * n23]);
                  const e20 = Math.floor(2.5 * (1 - l13));
                  if (e20 > 0) {
                    const s18 = 1 / e20;
                    let r17 = s18;
                    for (let o12 = 1; o12 < e20; o12++, r17 += s18) {
                      const e21 = [i19[1] * (1 - r17) + t20[1] * r17, -i19[0] * (1 - r17) - t20[0] * r17];
                      this.normalize(e21), a13.push([c8[0] + e21[0] * n23, c8[1] + e21[1] * n23]);
                    }
                  }
                  a13.push([c8[0] + t20[1] * n23, c8[1] - t20[0] * n23]);
                }
                break;
              case O.Square:
              default:
                if (h12 < 0)
                  a13.push([c8[0] + (i19[1] + i19[0]) * n23, c8[1] + (i19[1] - i19[0]) * n23]), a13.push([c8[0] + (t20[1] - t20[0]) * n23, c8[1] - (t20[0] + t20[1]) * n23]);
                else {
                  const e20 = Math.sqrt((1 + Math.abs(l13)) / 2), s18 = [t20[0] - i19[0], t20[1] - i19[1]];
                  this.normalize(s18);
                  const r17 = n23 / e20;
                  a13.push([c8[0] - s18[0] * r17, c8[1] - s18[1] * r17]);
                }
            }
        } else {
          const t20 = [c8[0] - u12[0], c8[1] - u12[1]];
          this.normalize(t20), a13.push([c8[0] + t20[1] * n23, c8[1] - t20[0] * n23]);
        }
      else {
        const t20 = [o11[0] - c8[0], o11[1] - c8[1]];
        this.normalize(t20), a13.push([c8[0] + t20[1] * n23, c8[1] - t20[0] * n23]);
      }
      u12 = c8, c8 = o11;
    }
    return a13.length < (l12 ? 3 : 2) ? null : (l12 && a13.push([a13[0][0], a13[0][1]]), a13);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var c5 = 1.7320508075688772;
var u8 = 5;
var h4 = P.OpenEnded;
var P3 = class _P {
  static local() {
    return null === _P.instance && (_P.instance = new _P()), _P.instance;
  }
  execute(t19, e20, r16, n23, o10) {
    return new l5(t19, e20, r16);
  }
};
P3.instance = null;
var l5 = class extends i8 {
  constructor(t19, e20, r16) {
    super(t19, false, true), this._curveHelper = new s10(), this._width = (void 0 !== e20.width ? e20.width : u8) * r16, this._arrowType = void 0 !== e20.geometricEffectArrowType ? e20.geometricEffectArrowType : void 0 !== e20.arrowType ? e20.arrowType : h4, this._offsetFlattenError = n9 * r16;
  }
  processPath(e20) {
    const r16 = a6.createEmptyOptimizedCIM(e20.geometryType);
    switch (this._arrowType) {
      case P.OpenEnded:
      default:
        this._constructSimpleArrow(r16, e20, true);
        break;
      case P.Block:
        this._constructSimpleArrow(r16, e20, false);
        break;
      case P.Crossed:
        this._constructCrossedArrow(r16, e20);
    }
    return r16;
  }
  _constructSimpleArrow(t19, r16, n23) {
    const o10 = r16.pathLength();
    let s17 = this._width;
    o10 < 2 * s17 && (s17 = o10 / 2);
    const i18 = this._curveHelper.getSubCurve(r16, 0, o10 - s17);
    if (!i18 || !i18.nextPath())
      return;
    i18.seekPathStart();
    const c8 = s17 / 2;
    if (this._curveHelper.isEmpty(i18))
      return;
    const u12 = n(i18), h11 = this._constructOffset(u12, -c8);
    if (!h11)
      return;
    const P5 = this._constructOffset(u12, c8);
    if (!P5)
      return;
    const l12 = this._constructArrowBasePoint(h11, -c8 / 2);
    if (!l12)
      return;
    const p5 = this._constructArrowBasePoint(P5, c8 / 2);
    if (!p5)
      return;
    r16.seekInPath(r16.numPoints - 1);
    const f6 = [r16.x, r16.y];
    t19.pushPath(P5), t19.nextPath(), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(p5), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(f6), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(l12), t19.nextPoint(), t19.setControlPoint(), t19.pushPoints(h11.reverse()), t19.setControlPoint(), n23 || (t19.setControlPointAt(0), t19.setControlPointAt(t19.numPoints - 1), t19.pushPoint(P5[0])), t19.reset();
  }
  _constructCrossedArrow(t19, r16) {
    const n23 = r16.pathLength();
    let o10 = this._width;
    n23 < o10 * (1 + c5 + 1) && (o10 = n23 / (1 + c5 + 1)), r16.seekPathStart();
    const s17 = this._curveHelper.getSubCurve(r16, 0, n23 - o10 * (1 + c5));
    if (!s17)
      return;
    s17.nextPath();
    const i18 = o10 / 2;
    if (this._curveHelper.isEmpty(s17))
      return;
    const u12 = n(s17), h11 = this._constructOffset(u12, i18);
    if (!h11)
      return;
    const P5 = this._constructOffset(u12, -i18);
    if (!P5)
      return;
    const l12 = this._curveHelper.getSubCurve(r16, 0, n23 - o10);
    if (!l12)
      return;
    if (l12.nextPath(), this._curveHelper.isEmpty(l12))
      return;
    const p5 = n(l12), f6 = this._constructOffset(p5, i18);
    if (!f6)
      return;
    const a13 = this._constructOffset(p5, -i18);
    if (!a13)
      return;
    const _4 = f6[f6.length - 1], m10 = this._constructArrowBasePoint(f6, i18 / 2);
    if (!m10)
      return;
    const C4 = a13[a13.length - 1], w7 = this._constructArrowBasePoint(a13, -i18 / 2);
    if (!w7)
      return;
    r16.seekInPath(r16.numPoints - 1);
    const x4 = [r16.x, r16.y];
    t19.pushPath(h11), t19.nextPath(), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(C4), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(w7), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(x4), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(m10), t19.nextPoint(), t19.setControlPoint(), t19.pushPoint(_4), t19.nextPoint(), t19.setControlPoint(), t19.pushPoints(P5.reverse()), t19.nextPoint(), t19.setControlPoint(), t19.reset();
  }
  _constructOffset(t19, e20) {
    return this._curveHelper.offset(t19, e20, O.Rounded, 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t19, e20) {
    if (!t19 || t19.length < 2)
      return null;
    const r16 = t19[t19.length - 2], n23 = t19[t19.length - 1], o10 = [n23[0] - r16[0], n23[1] - r16[1]];
    return this._curveHelper.normalize(o10), [n23[0] + o10[1] * e20, n23[1] - o10[0] * e20];
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var m6 = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(e20, t19, i18, s17, r16, n23) {
    return new l6(e20, t19, i18, s17, r16, n23);
  }
};
m6.instance = null;
var l6 = class {
  constructor(e20, t19, i18, n23, o10, m10) {
    this._inputGeometries = e20, this._tileKey = n23, this._geometryEngine = o10, this._curveHelper = new s10(), this._size = (void 0 !== t19.size ? t19.size : 1) * i18, this._maxInflateSize = m10 * i18, this._offsetFlattenError = n9 * i18;
  }
  next() {
    let s17;
    for (; s17 = this._inputGeometries.next(); ) {
      if (0 === this._size)
        return s17;
      if ("esriGeometryEnvelope" === s17.geometryType) {
        if (this._size > 0) {
          const i18 = a6.createEmptyOptimizedCIM(s17.geometryType), r17 = t2(s17)[0], o10 = this._curveHelper.offset(r17, this._size, O.Rounded, 4, this._offsetFlattenError);
          if (o10)
            return i18.pushPath(o10), i18;
        } else if (this._size < 0) {
          const t19 = s17.asJSON();
          if (Math.min(t19.xmax - t19.xmin, t19.ymax - t19.ymin) + 2 * this._size > 0)
            return a6.fromJSONCIM({ xmin: t19.xmin - this._size, xmax: t19.xmax + this._size, ymin: t19.ymin - this._size, ymax: t19.ymax + this._size });
        }
      }
      const r16 = this._geometryEngine;
      if (null == r16)
        return null;
      const m10 = this._tileKey ? i7(s17, this._maxInflateSize) : s17;
      if (!m10)
        continue;
      const l12 = r16.buffer(f.WebMercator, m10.asJSON(), this._size, 1);
      return l12 ? a6.fromJSONCIM(l12) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var e9 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(s17, t19, i18, h11, e20) {
    return new r4(s17, t19, i18);
  }
};
e9.instance = null;
var r4 = class {
  constructor(s17, t19, i18) {
    this._defaultPointSize = 20, this._inputGeometries = s17, this._geomUnitsPerPoint = i18, this._rule = t19.rule ?? R.FullGeometry, this._defaultSize = this._defaultPointSize * i18;
  }
  next() {
    let i18;
    for (; i18 = this._inputGeometries.next(); ) {
      const h11 = this._processGeom(t2(i18));
      if (h11 && h11.length)
        return a6.fromJSONCIM({ paths: h11 });
    }
    return null;
  }
  _clone(s17) {
    return [s17[0], s17[1]];
  }
  _mid(s17, t19) {
    return [(s17[0] + t19[0]) / 2, (s17[1] + t19[1]) / 2];
  }
  _mix(s17, t19, i18, h11) {
    return [s17[0] * t19 + i18[0] * h11, s17[1] * t19 + i18[1] * h11];
  }
  _add(s17, t19) {
    return [s17[0] + t19[0], s17[1] + t19[1]];
  }
  _add2(s17, t19, i18) {
    return [s17[0] + t19, s17[1] + i18];
  }
  _sub(s17, t19) {
    return [s17[0] - t19[0], s17[1] - t19[1]];
  }
  _dist(s17, t19) {
    return Math.sqrt((s17[0] - t19[0]) * (s17[0] - t19[0]) + (s17[1] - t19[1]) * (s17[1] - t19[1]));
  }
  _norm(s17) {
    return Math.sqrt(s17[0] * s17[0] + s17[1] * s17[1]);
  }
  _normalize(s17, t19 = 1) {
    const i18 = t19 / this._norm(s17);
    s17[0] *= i18, s17[1] *= i18;
  }
  _leftPerpendicular(s17) {
    const t19 = -s17[1], i18 = s17[0];
    s17[0] = t19, s17[1] = i18;
  }
  _leftPerp(s17) {
    return [-s17[1], s17[0]];
  }
  _rightPerpendicular(s17) {
    const t19 = s17[1], i18 = -s17[0];
    s17[0] = t19, s17[1] = i18;
  }
  _rightPerp(s17) {
    return [s17[1], -s17[0]];
  }
  _dotProduct(s17, t19) {
    return s17[0] * t19[0] + s17[1] * t19[1];
  }
  _crossProduct(s17, t19) {
    return s17[0] * t19[1] - s17[1] * t19[0];
  }
  _rotateDirect(s17, t19, i18) {
    const h11 = s17[0] * t19 - s17[1] * i18, e20 = s17[0] * i18 + s17[1] * t19;
    s17[0] = h11, s17[1] = e20;
  }
  _makeCtrlPt(s17) {
    const t19 = [s17[0], s17[1]];
    return r3(t19, 1), t19;
  }
  _addAngledTicks(s17, t19, i18, h11) {
    const e20 = this._sub(i18, t19);
    this._normalize(e20);
    const r16 = this._crossProduct(e20, this._sub(h11, t19));
    let _4;
    _4 = r16 > 0 ? this._rightPerp(e20) : this._leftPerp(e20);
    const c8 = Math.abs(r16) / 2, u12 = [];
    u12.push([t19[0] + (_4[0] - e20[0]) * c8, t19[1] + (_4[1] - e20[1]) * c8]), u12.push(t19), u12.push(i18), u12.push([i18[0] + (_4[0] + e20[0]) * c8, i18[1] + (_4[1] + e20[1]) * c8]), s17.push(u12);
  }
  _addBezier2(s17, t19, i18, h11, e20) {
    if (0 == e20--)
      return void s17.push(h11);
    const r16 = this._mid(t19, i18), _4 = this._mid(i18, h11), c8 = this._mid(r16, _4);
    this._addBezier2(s17, t19, r16, c8, e20), this._addBezier2(s17, c8, _4, h11, e20);
  }
  _addBezier3(s17, t19, i18, h11, e20, r16) {
    if (0 == r16--)
      return void s17.push(e20);
    const _4 = this._mid(t19, i18), c8 = this._mid(i18, h11), u12 = this._mid(h11, e20), o10 = this._mid(_4, c8), n23 = this._mid(c8, u12), a13 = this._mid(o10, n23);
    this._addBezier3(s17, t19, _4, o10, a13, r16), this._addBezier3(s17, a13, n23, u12, e20, r16);
  }
  _add90DegArc(s17, t19, i18, h11, e20) {
    const r16 = e20 ?? this._crossProduct(this._sub(i18, t19), this._sub(h11, t19)) > 0, _4 = this._mid(t19, i18), c8 = this._sub(_4, t19);
    r16 ? this._leftPerpendicular(c8) : this._rightPerpendicular(c8), _4[0] += c8[0], _4[1] += c8[1], this._addBezier3(s17, t19, this._mix(t19, 0.33333, _4, 0.66667), this._mix(i18, 0.33333, _4, 0.66667), i18, 4);
  }
  _addArrow(s17, t19, i18) {
    const h11 = t19[0], e20 = t19[1], r16 = t19[t19.length - 1], _4 = this._sub(h11, e20);
    this._normalize(_4);
    const c8 = this._crossProduct(_4, this._sub(r16, e20)), u12 = 0.5 * c8, o10 = this._leftPerp(_4), n23 = [r16[0] - o10[0] * c8, r16[1] - o10[1] * c8], a13 = t19.length - 1, p5 = [];
    p5.push(i18 ? [-o10[0], -o10[1]] : o10);
    let l12 = [-_4[0], -_4[1]];
    for (let d4 = 1; d4 < a13 - 1; d4++) {
      const s18 = this._sub(t19[d4 + 1], t19[d4]);
      this._normalize(s18);
      const i19 = this._dotProduct(s18, l12), h12 = this._crossProduct(s18, l12), e21 = Math.sqrt((1 + i19) / 2), r17 = this._sub(s18, l12);
      this._normalize(r17), r17[0] /= e21, r17[1] /= e21, p5.push(h12 < 0 ? [-r17[0], -r17[1]] : r17), l12 = s18;
    }
    p5.push(this._rightPerp(l12));
    for (let d4 = p5.length - 1; d4 > 0; d4--)
      s17.push([t19[d4][0] + p5[d4][0] * u12, t19[d4][1] + p5[d4][1] * u12]);
    s17.push([n23[0] + p5[0][0] * u12, n23[1] + p5[0][1] * u12]), s17.push([n23[0] + p5[0][0] * c8, n23[1] + p5[0][1] * c8]), s17.push(h11), s17.push([n23[0] - p5[0][0] * c8, n23[1] - p5[0][1] * c8]), s17.push([n23[0] - p5[0][0] * u12, n23[1] - p5[0][1] * u12]);
    for (let d4 = 1; d4 < p5.length; d4++)
      s17.push([t19[d4][0] - p5[d4][0] * u12, t19[d4][1] - p5[d4][1] * u12]);
  }
  _cp2(s17, t19, i18) {
    return s17.length >= 2 ? s17[1] : this._add2(s17[0], t19 * this._defaultSize, i18 * this._defaultSize);
  }
  _cp3(s17, t19, i18, h11) {
    if (s17.length >= 3)
      return s17[2];
    const e20 = this._mix(s17[0], 1 - i18, t19, i18), r16 = this._sub(t19, s17[0]);
    return this._normalize(r16), this._rightPerpendicular(r16), [e20[0] + r16[0] * h11 * this._defaultSize, e20[1] + r16[1] * h11 * this._defaultSize];
  }
  _arrowPath(s17) {
    if (s17.length > 2)
      return s17;
    const t19 = s17[0], i18 = this._cp2(s17, -4, 0), h11 = this._sub(t19, i18);
    this._normalize(h11);
    const e20 = this._rightPerp(h11);
    return [t19, i18, [t19[0] + (e20[0] - h11[0]) * this._defaultSize, t19[1] + (e20[1] - h11[1]) * this._defaultSize]];
  }
  _arrowLastSeg(s17) {
    const t19 = s17[0], i18 = this._cp2(s17, -4, 0);
    let h11;
    if (s17.length >= 3)
      h11 = s17[s17.length - 1];
    else {
      const s18 = this._sub(t19, i18);
      this._normalize(s18);
      const e20 = this._rightPerp(s18);
      h11 = [t19[0] + (e20[0] - s18[0]) * this._defaultSize, t19[1] + (e20[1] - s18[1]) * this._defaultSize];
    }
    return [i18, h11];
  }
  _processGeom(s17) {
    if (!s17)
      return null;
    const t19 = [];
    for (const e20 of s17) {
      if (!e20 || 0 === e20.length)
        continue;
      const s18 = e20.length;
      let r16 = e20[0];
      switch (this._rule) {
        case R.PerpendicularFromFirstSegment: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 4), h11 = [];
          h11.push(i18), h11.push(this._mid(r16, s19)), t19.push(h11);
          break;
        }
        case R.ReversedFirstSegment: {
          const s19 = this._cp2(e20, 0, -1);
          t19.push([s19, r16]);
          break;
        }
        case R.PerpendicularToSecondSegment: {
          const s19 = this._cp2(e20, -4, 1), i18 = this._cp3(e20, s19, 0.882353, -1.94), h11 = [];
          h11.push(this._mid(s19, i18)), h11.push(r16), t19.push(h11);
          break;
        }
        case R.SecondSegmentWithTicks: {
          const s19 = this._cp2(e20, -4, 1), i18 = this._cp3(e20, s19, 0.882353, -1.94), h11 = this._sub(i18, s19);
          let _4;
          _4 = this._crossProduct(h11, this._sub(r16, s19)) > 0 ? this._rightPerp(_4) : this._leftPerp(h11);
          const c8 = [];
          c8.push([s19[0] + (_4[0] - h11[0]) / 3, s19[1] + (_4[1] - h11[1]) / 3]), c8.push(s19), c8.push(i18), c8.push([i18[0] + (_4[0] + h11[0]) / 3, i18[1] + (_4[1] + h11[1]) / 3]), t19.push(c8);
          break;
        }
        case R.DoublePerpendicular: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 3), h11 = this._mid(r16, s19), _4 = this._sub(h11, i18);
          this._normalize(_4);
          const c8 = this._crossProduct(_4, this._sub(r16, i18));
          this._leftPerpendicular(_4);
          const u12 = [];
          u12.push(r16), u12.push([i18[0] + _4[0] * c8, i18[1] + _4[1] * c8]), t19.push(u12);
          const o10 = [];
          o10.push([i18[0] - _4[0] * c8, i18[1] - _4[1] * c8]), o10.push(s19), t19.push(o10);
          break;
        }
        case R.OppositeToFirstSegment: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 3), h11 = this._mid(r16, s19), _4 = this._sub(h11, i18);
          this._normalize(_4);
          const c8 = this._crossProduct(_4, this._sub(r16, i18));
          this._leftPerpendicular(_4);
          const u12 = [];
          u12.push([i18[0] + _4[0] * c8, i18[1] + _4[1] * c8]), u12.push([i18[0] - _4[0] * c8, i18[1] - _4[1] * c8]), t19.push(u12);
          break;
        }
        case R.TriplePerpendicular: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 4), h11 = this._mid(r16, s19), _4 = this._sub(h11, i18);
          this._normalize(_4);
          const c8 = this._crossProduct(_4, this._sub(r16, i18));
          this._leftPerpendicular(_4);
          const u12 = [];
          u12.push([i18[0] + _4[0] * c8 * 0.8, i18[1] + _4[1] * c8 * 0.8]), u12.push([h11[0] + 0.8 * (r16[0] - h11[0]), h11[1] + 0.8 * (r16[1] - h11[1])]), t19.push(u12), t19.push([i18, h11]);
          const o10 = [];
          o10.push([i18[0] - _4[0] * c8 * 0.8, i18[1] - _4[1] * c8 * 0.8]), o10.push([h11[0] + 0.8 * (s19[0] - h11[0]), h11[1] + 0.8 * (s19[1] - h11[1])]), t19.push(o10);
          break;
        }
        case R.HalfCircleFirstSegment: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 4), h11 = this._mid(r16, s19);
          let _4 = this._sub(s19, r16);
          const c8 = Math.cos(Math.PI / 18), u12 = Math.sin(Math.PI / 18), o10 = Math.sqrt((1 + c8) / 2), n23 = Math.sqrt((1 - c8) / 2), a13 = [];
          let p5;
          this._crossProduct(_4, this._sub(i18, r16)) > 0 ? (a13.push(r16), _4 = this._sub(r16, h11), p5 = s19) : (a13.push(s19), _4 = this._sub(s19, h11), p5 = r16), this._rotateDirect(_4, o10, n23), _4[0] /= o10, _4[1] /= o10;
          for (let t20 = 1; t20 <= 18; t20++)
            a13.push(this._add(h11, _4)), this._rotateDirect(_4, c8, u12);
          a13.push(p5), t19.push(a13);
          break;
        }
        case R.HalfCircleSecondSegment: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 1, -1);
          let h11 = this._sub(r16, s19);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, s19)) / 2;
          this._leftPerpendicular(h11);
          const c8 = [s19[0] + h11[0] * _4, s19[1] + h11[1] * _4];
          h11 = this._sub(s19, c8);
          const u12 = Math.cos(Math.PI / 18);
          let o10 = Math.sin(Math.PI / 18);
          _4 > 0 && (o10 = -o10);
          const n23 = [s19];
          for (let t20 = 1; t20 <= 18; t20++)
            this._rotateDirect(h11, u12, o10), n23.push(this._add(c8, h11));
          t19.push(n23);
          break;
        }
        case R.HalfCircleExtended: {
          const i18 = this._cp2(e20, 0, -2), h11 = this._cp3(e20, i18, 1, -1);
          let _4;
          if (s18 >= 4)
            _4 = e20[3];
          else {
            const s19 = this._sub(r16, i18);
            _4 = this._add(h11, s19);
          }
          const c8 = this._dist(i18, h11) / 2 / 0.75, u12 = this._sub(i18, r16);
          this._normalize(u12, c8);
          const o10 = this._sub(h11, _4);
          this._normalize(o10, c8);
          const n23 = [_4, h11];
          t19.push(n23);
          const a13 = [this._clone(h11)];
          this._addBezier3(a13, h11, this._add(h11, o10), this._add(i18, u12), i18, 4), a13.push(r16), t19.push(a13);
          break;
        }
        case R.OpenCircle: {
          const s19 = this._cp2(e20, -2, 0), i18 = this._sub(s19, r16), h11 = Math.cos(Math.PI / 18), _4 = -Math.sin(Math.PI / 18), c8 = [s19];
          for (let t20 = 1; t20 <= 33; t20++)
            this._rotateDirect(i18, h11, _4), c8.push(this._add(r16, i18));
          t19.push(c8);
          break;
        }
        case R.CoverageEdgesWithTicks: {
          const i18 = this._cp2(e20, 0, -1);
          let h11, _4;
          if (s18 >= 3)
            h11 = e20[2];
          else {
            const s19 = this._sub(i18, r16), t20 = this._leftPerp(s19);
            h11 = [r16[0] + t20[0] - 0.25 * s19[0], r16[1] + t20[1] - 0.25 * s19[1]];
          }
          if (s18 >= 4)
            _4 = e20[3];
          else {
            const s19 = this._mid(r16, i18), t20 = this._sub(r16, i18);
            this._normalize(t20), this._leftPerpendicular(t20);
            const e21 = this._crossProduct(t20, this._sub(h11, s19));
            this._rightPerpendicular(t20), _4 = [h11[0] + t20[0] * e21 * 2, h11[1] + t20[1] * e21 * 2];
          }
          const c8 = this._sub(i18, r16);
          let u12, o10;
          u12 = this._crossProduct(c8, this._sub(h11, r16)) > 0 ? this._rightPerp(c8) : this._leftPerp(c8), o10 = [], o10.push(h11), o10.push(r16), o10.push([r16[0] + (u12[0] - c8[0]) / 3, r16[1] + (u12[1] - c8[1]) / 3]), t19.push(o10), u12 = this._crossProduct(c8, this._sub(_4, i18)) > 0 ? this._rightPerp(u12) : this._leftPerp(c8), o10 = [], o10.push([i18[0] + (u12[0] + c8[0]) / 3, i18[1] + (u12[1] + c8[1]) / 3]), o10.push(i18), o10.push(_4), t19.push(o10);
          break;
        }
        case R.GapExtentWithDoubleTicks: {
          const i18 = this._cp2(e20, 0, 2), h11 = this._cp3(e20, i18, 0, 1);
          let _4;
          if (s18 >= 4)
            _4 = e20[3];
          else {
            const s19 = this._sub(i18, r16);
            _4 = this._add(h11, s19);
          }
          this._addAngledTicks(t19, r16, i18, this._mid(h11, _4)), this._addAngledTicks(t19, h11, _4, this._mid(r16, i18));
          break;
        }
        case R.GapExtentMidline: {
          const i18 = this._cp2(e20, 2, 0), h11 = this._cp3(e20, i18, 0, 1);
          let _4;
          if (s18 >= 4)
            _4 = e20[3];
          else {
            const s19 = this._sub(i18, r16);
            _4 = this._add(h11, s19);
          }
          const c8 = [];
          c8.push(this._mid(r16, h11)), c8.push(this._mid(i18, _4)), t19.push(c8);
          break;
        }
        case R.Chevron: {
          const i18 = this._cp2(e20, -1, -1);
          let h11;
          if (s18 >= 3)
            h11 = e20[2];
          else {
            const s19 = this._sub(i18, r16);
            this._leftPerpendicular(s19), h11 = this._add(r16, s19);
          }
          t19.push([i18, this._makeCtrlPt(r16), h11]);
          break;
        }
        case R.PerpendicularWithArc: {
          const s19 = this._cp2(e20, 0, -2), i18 = this._cp3(e20, s19, 0.5, -1);
          let h11 = this._sub(s19, r16);
          const _4 = this._norm(h11);
          h11[0] /= _4, h11[1] /= _4;
          const c8 = this._crossProduct(h11, this._sub(i18, r16));
          let u12 = this._dotProduct(h11, this._sub(i18, r16));
          u12 < 0.05 * _4 ? u12 = 0.05 * _4 : u12 > 0.95 * _4 && (u12 = 0.95 * _4);
          const o10 = [r16[0] + h11[0] * u12, r16[1] + h11[1] * u12];
          this._leftPerpendicular(h11);
          let n23 = [];
          n23.push([o10[0] - h11[0] * c8, o10[1] - h11[1] * c8]), n23.push([o10[0] + h11[0] * c8, o10[1] + h11[1] * c8]), t19.push(n23);
          const a13 = [s19[0] + h11[0] * c8, s19[1] + h11[1] * c8];
          h11 = this._sub(s19, a13);
          const p5 = Math.cos(Math.PI / 18);
          let l12 = Math.sin(Math.PI / 18);
          c8 < 0 && (l12 = -l12), n23 = [r16, s19];
          for (let t20 = 1; t20 <= 9; t20++)
            this._rotateDirect(h11, p5, l12), n23.push(this._add(a13, h11));
          t19.push(n23);
          break;
        }
        case R.ClosedHalfCircle: {
          const s19 = this._cp2(e20, 2, 0), i18 = this._mid(r16, s19), h11 = this._sub(s19, i18), _4 = Math.cos(Math.PI / 18), c8 = Math.sin(Math.PI / 18), u12 = [r16, s19];
          for (let t20 = 1; t20 <= 18; t20++)
            this._rotateDirect(h11, _4, c8), u12.push(this._add(i18, h11));
          t19.push(u12);
          break;
        }
        case R.TripleParallelExtended: {
          const s19 = this._cp2(e20, 0, -2), h11 = this._cp3(e20, s19, 1, -2), _4 = this._mid(r16, s19), c8 = this._sub(h11, s19);
          this._normalize(c8);
          const u12 = Math.abs(this._crossProduct(c8, this._sub(_4, s19))) / 2, o10 = this._dist(s19, h11), n23 = [s19, r16];
          n23.push([r16[0] + c8[0] * o10 * 0.5, r16[1] + c8[1] * o10 * 0.5]), t19.push(n23);
          const a13 = [];
          a13.push([_4[0] - c8[0] * u12, _4[1] - c8[1] * u12]), a13.push([_4[0] + c8[0] * o10 * 0.375, _4[1] + c8[1] * o10 * 0.375]), r3(a13[a13.length - 1], 1), a13.push([_4[0] + c8[0] * o10 * 0.75, _4[1] + c8[1] * o10 * 0.75]), t19.push(a13);
          const p5 = [s19, h11];
          t19.push(p5);
          break;
        }
        case R.ParallelWithTicks: {
          const s19 = this._cp2(e20, 3, 0), i18 = this._cp3(e20, s19, 0.5, -1), h11 = this._sub(i18, s19);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, r16));
          this._leftPerpendicular(h11), this._addAngledTicks(t19, r16, s19, i18), this._addAngledTicks(t19, this._mix(r16, 1, h11, _4), this._mix(s19, 1, h11, _4), this._mid(r16, s19));
          break;
        }
        case R.Parallel: {
          const s19 = this._cp2(e20, 3, 0), i18 = this._cp3(e20, s19, 0.5, -1), h11 = this._sub(s19, r16);
          this._normalize(h11);
          const _4 = this._leftPerp(h11), c8 = this._crossProduct(h11, this._sub(i18, r16));
          let u12 = [r16, s19];
          t19.push(u12), u12 = [], u12.push([r16[0] + _4[0] * c8, r16[1] + _4[1] * c8]), u12.push([s19[0] + _4[0] * c8, s19[1] + _4[1] * c8]), t19.push(u12);
          break;
        }
        case R.PerpendicularToFirstSegment: {
          const s19 = this._cp2(e20, 3, 0), i18 = this._cp3(e20, s19, 0.5, -1), h11 = this._mid(r16, s19), _4 = this._sub(s19, r16);
          this._normalize(_4);
          const c8 = this._crossProduct(_4, this._sub(i18, r16));
          this._leftPerpendicular(_4);
          const u12 = [];
          u12.push([h11[0] - _4[0] * c8 * 0.25, h11[1] - _4[1] * c8 * 0.25]), u12.push([h11[0] + _4[0] * c8 * 1.25, h11[1] + _4[1] * c8 * 1.25]), t19.push(u12);
          break;
        }
        case R.ParallelOffset: {
          const s19 = this._cp2(e20, 3, 0), i18 = this._cp3(e20, s19, 0.5, -1), h11 = this._sub(s19, r16);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, r16));
          this._leftPerpendicular(h11);
          const c8 = [];
          c8.push([r16[0] - h11[0] * _4, r16[1] - h11[1] * _4]), c8.push([s19[0] - h11[0] * _4, s19[1] - h11[1] * _4]), t19.push(c8);
          const u12 = [];
          u12.push([r16[0] + h11[0] * _4, r16[1] + h11[1] * _4]), u12.push([s19[0] + h11[0] * _4, s19[1] + h11[1] * _4]), t19.push(u12);
          break;
        }
        case R.OffsetOpposite: {
          const s19 = this._cp2(e20, 3, 0), i18 = this._cp3(e20, s19, 0.5, -1), h11 = this._sub(s19, r16);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, r16));
          this._leftPerpendicular(h11);
          const c8 = [];
          c8.push([r16[0] - h11[0] * _4, r16[1] - h11[1] * _4]), c8.push([s19[0] - h11[0] * _4, s19[1] - h11[1] * _4]), t19.push(c8);
          break;
        }
        case R.OffsetSame: {
          const s19 = this._cp2(e20, 3, 0), i18 = this._cp3(e20, s19, 0.5, -1), h11 = this._sub(s19, r16);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, r16));
          this._leftPerpendicular(h11);
          const c8 = [];
          c8.push([r16[0] + h11[0] * _4, r16[1] + h11[1] * _4]), c8.push([s19[0] + h11[0] * _4, s19[1] + h11[1] * _4]), t19.push(c8);
          break;
        }
        case R.CircleWithArc: {
          let h11 = this._cp2(e20, 3, 0);
          const _4 = this._cp3(e20, h11, 0.5, -1);
          let c8, u12;
          if (s18 >= 4)
            c8 = e20[3], u12 = this._crossProduct(this._sub(c8, h11), this._sub(_4, h11)) > 0;
          else {
            c8 = h11, u12 = this._crossProduct(this._sub(c8, r16), this._sub(_4, r16)) > 0;
            const s19 = 24 * this._geomUnitsPerPoint, t20 = this._sub(c8, r16);
            this._normalize(t20, s19);
            const i18 = Math.sqrt(2) / 2;
            this._rotateDirect(t20, i18, u12 ? i18 : -i18), h11 = this._add(r16, t20);
          }
          const o10 = this._sub(h11, r16), n23 = Math.cos(Math.PI / 18), a13 = Math.sin(Math.PI / 18), p5 = [h11];
          for (let s19 = 1; s19 <= 36; s19++)
            this._rotateDirect(o10, n23, a13), p5.push(this._add(r16, o10));
          this._add90DegArc(p5, h11, c8, _4, u12), r3(p5[p5.length - 8], 1), t19.push(p5);
          break;
        }
        case R.DoubleJog: {
          let i18, h11, _4 = this._cp2(e20, -3, 1);
          if (i18 = s18 >= 3 ? e20[2] : this._add(r16, this._sub(r16, _4)), s18 >= 4)
            h11 = e20[3];
          else {
            const s19 = r16;
            r16 = _4, h11 = i18;
            const t20 = this._dist(r16, s19), e21 = this._dist(h11, s19);
            let c9 = 30 * this._geomUnitsPerPoint;
            0.5 * t20 < c9 && (c9 = 0.5 * t20), 0.5 * e21 < c9 && (c9 = 0.5 * e21), _4 = this._mix(r16, c9 / t20, s19, (t20 - c9) / t20), i18 = this._mix(h11, c9 / e21, s19, (e21 - c9) / e21);
          }
          const c8 = this._mid(r16, _4), u12 = this._mid(h11, i18), o10 = this._dist(r16, _4), n23 = this._dist(i18, h11);
          let a13 = Math.min(o10, n23) / 8;
          a13 = Math.min(a13, 24 * this._geomUnitsPerPoint);
          const p5 = Math.cos(Math.PI / 4);
          let l12 = this._sub(r16, _4);
          this._normalize(l12, a13), this._crossProduct(l12, this._sub(h11, _4)) > 0 ? this._rotateDirect(l12, p5, -p5) : this._rotateDirect(l12, p5, p5);
          let d4 = [];
          d4.push(_4), d4.push(this._add(c8, l12)), d4.push(this._sub(c8, l12)), d4.push(r16), t19.push(d4), l12 = this._sub(h11, i18), this._normalize(l12, a13), this._crossProduct(l12, this._sub(r16, i18)) < 0 ? this._rotateDirect(l12, p5, p5) : this._rotateDirect(l12, p5, -p5), d4 = [], d4.push(i18), d4.push(this._add(u12, l12)), d4.push(this._sub(u12, l12)), d4.push(h11), t19.push(d4);
          break;
        }
        case R.PerpendicularOffset: {
          const s19 = this._cp2(e20, -4, 1), i18 = this._cp3(e20, s19, 0.882353, -1.94), h11 = this._sub(i18, s19);
          this._crossProduct(h11, this._sub(r16, s19)) > 0 ? this._rightPerpendicular(h11) : this._leftPerpendicular(h11);
          const _4 = [h11[0] / 8, h11[1] / 8], c8 = this._sub(this._mid(s19, i18), _4);
          t19.push([c8, r16]);
          break;
        }
        case R.LineExcludingLastSegment: {
          const s19 = this._arrowPath(e20), i18 = [];
          let h11 = s19.length - 2;
          for (; h11--; )
            i18.push(s19[h11]);
          t19.push(i18);
          break;
        }
        case R.MultivertexArrow: {
          const s19 = this._arrowPath(e20), i18 = [];
          this._addArrow(i18, s19, false), t19.push(i18);
          break;
        }
        case R.CrossedArrow: {
          const s19 = this._arrowPath(e20), i18 = [];
          this._addArrow(i18, s19, true), t19.push(i18);
          break;
        }
        case R.ChevronArrow: {
          const [s19, i18] = this._arrowLastSeg(e20), h11 = 10 * this._geomUnitsPerPoint, _4 = this._sub(r16, s19);
          this._normalize(_4);
          const c8 = this._crossProduct(_4, this._sub(i18, s19)), u12 = this._leftPerp(_4), o10 = [i18[0] - u12[0] * c8 * 2, i18[1] - u12[1] * c8 * 2], n23 = [];
          n23.push([i18[0] + _4[0] * h11, i18[1] + _4[1] * h11]), n23.push(r16), n23.push([o10[0] + _4[0] * h11, o10[1] + _4[1] * h11]), t19.push(n23);
          break;
        }
        case R.ChevronArrowOffset: {
          const [s19, i18] = this._arrowLastSeg(e20), h11 = this._sub(r16, s19);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, s19));
          this._leftPerpendicular(h11);
          const c8 = [i18[0] - h11[0] * _4, i18[1] - h11[1] * _4], u12 = [];
          u12.push([c8[0] + h11[0] * _4 * 0.5, c8[1] + h11[1] * _4 * 0.5]), u12.push(this._mid(c8, r16)), u12.push([c8[0] - h11[0] * _4 * 0.5, c8[1] - h11[1] * _4 * 0.5]), t19.push(u12);
          break;
        }
        case R.PartialFirstSegment: {
          const [s19, i18] = this._arrowLastSeg(e20), h11 = this._sub(r16, s19);
          this._normalize(h11);
          const _4 = this._crossProduct(h11, this._sub(i18, s19));
          this._leftPerpendicular(h11);
          const c8 = [i18[0] - h11[0] * _4, i18[1] - h11[1] * _4];
          t19.push([s19, c8]);
          break;
        }
        case R.Arch: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 1), h11 = this._sub(r16, s19), _4 = this._mix(i18, 1, h11, 0.55), c8 = this._mix(i18, 1, h11, -0.55), u12 = [r16];
          this._addBezier2(u12, r16, _4, i18, 4), this._addBezier2(u12, i18, c8, s19, 4), t19.push(u12);
          break;
        }
        case R.CurvedParallelTicks: {
          const s19 = this._cp2(e20, -4, 1), i18 = this._cp3(e20, s19, 0.882353, -1.94), h11 = this._sub(i18, s19);
          this._crossProduct(h11, this._sub(r16, s19)) > 0 ? this._rightPerpendicular(h11) : this._leftPerpendicular(h11);
          const _4 = [h11[0] / 8, h11[1] / 8], c8 = this._sub(this._mid(s19, i18), _4), u12 = this._sub(this._mix(s19, 0.75, i18, 0.25), _4), o10 = this._sub(this._mix(s19, 0.25, i18, 0.75), _4), n23 = [s19];
          this._addBezier2(n23, s19, u12, c8, 3), this._addBezier2(n23, c8, o10, i18, 3), t19.push(n23);
          for (let e21 = 0; e21 < 8; e21++) {
            const s20 = n23[2 * e21 + 1], i19 = [this._clone(s20)];
            i19.push(this._add(s20, [h11[0] / 4, h11[1] / 4])), t19.push(i19);
          }
          break;
        }
        case R.Arc90Degrees: {
          const s19 = this._cp2(e20, 0, -1), i18 = this._cp3(e20, s19, 0.5, 1), h11 = [s19];
          this._add90DegArc(h11, s19, r16, i18), t19.push(h11);
          break;
        }
        case R.FullGeometry:
        default:
          t19.push(e20);
      }
    }
    return t19;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var r5 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(e20, t19, i18, r16, n23) {
    return new u9(e20, t19, i18);
  }
};
r5.instance = null;
var u9 = class extends i8 {
  constructor(e20, t19, r16) {
    super(e20, true, true), this._curveHelper = new s10(), this._beginCut = (void 0 !== t19.beginCut ? t19.beginCut : 1) * r16, this._endCut = (void 0 !== t19.endCut ? t19.endCut : 1) * r16, this._middleCut = (void 0 !== t19.middleCut ? t19.middleCut : 0) * r16, this._invert = void 0 !== t19.invert && t19.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(t19) {
    const { _beginCut: i18, _endCut: r16, _middleCut: u12 } = this, n23 = t19.pathLength(), s17 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._invert) {
      if (0 !== i18 || 0 !== r16 || 0 !== u12)
        if (i18 + r16 + u12 >= n23)
          for (s17.startPath(); t19.nextPoint(); )
            s17.pushXY(t19.x, t19.y);
        else
          this._curveHelper.appendSubCurve(s17, t19, 0, i18), this._curveHelper.appendSubCurve(s17, t19, 0.5 * (n23 - u12), 0.5 * (n23 + u12)), this._curveHelper.appendSubCurve(s17, t19, n23 - r16, r16);
    } else if (0 === i18 && 0 === r16 && 0 === u12)
      for (s17.startPath(); t19.nextPoint(); )
        s17.pushXY(t19.x, t19.y);
    else
      i18 + r16 + u12 < n23 && (0 === u12 ? this._curveHelper.appendSubCurve(s17, t19, i18, n23 - r16) : (this._curveHelper.appendSubCurve(s17, t19, i18, 0.5 * (n23 - u12)), this._curveHelper.appendSubCurve(s17, t19, 0.5 * (n23 + u12), n23 - r16)));
    return 0 === s17.numPaths ? null : s17;
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var n10 = 1e-7;
var i9 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t19, s17, e20 = true) {
    if (this._setEmpty(), !t19 || 0 === t19.length)
      return false;
    for (let i18 = 0; i18 < t19.length; i18++) {
      let s18 = Math.abs(t19[i18]);
      e20 && s18 < n10 && (s18 = n10), this._values.push(s18), this._length += s18;
    }
    return s17 && 1 & t19.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t19) {
    const s17 = this._values ? this._values.length : 0;
    for (let e20 = 0; e20 < s17; ++e20)
      this._values[e20] *= t19;
    this._length *= t19, this.extPtGap *= t19, this.ctrlPtGap *= t19;
  }
  addValue(t19) {
    this._length += t19, this._values.push(t19);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h5 = class {
  constructor() {
    this.pt = null, this.ca = 0, this.sa = 0;
  }
};
var r6;
!function(t19) {
  t19[t19.FAIL = 0] = "FAIL", t19[t19.END = 1] = "END", t19[t19.CONTINUE = 2] = "CONTINUE";
}(r6 || (r6 = {}));
var a7 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = null, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return null !== this.segment;
  }
  copyTo(t19) {
    t19.segment = this.segment, t19.segmentLength = this.segmentLength, t19.abscissa = this.abscissa, t19.isPathEnd = this.isPathEnd, t19.isPartEnd = this.isPartEnd;
  }
};
var o6 = class extends s10 {
  constructor(t19 = 0, s17 = false) {
    super(t19, s17), this._tolerance = n9, this._currentPosition = new a7();
  }
  updateTolerance(t19) {
    this._tolerance = n9 * t19;
  }
  init(t19, s17, e20 = true) {
    return e20 ? (this._patternLength = s17.length(), this._partExtPtGap = s17.extPtGap, this._partCtrlPtGap = s17.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._pathCursor = t19, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t19, s17 = r6.FAIL) {
    const e20 = new a7();
    return !!this._nextPosition(t19, e20, null, s17) && (e20.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t19) {
    t19.pt = this._getPoint(this._currentPosition);
    const [s17, e20] = this._getAngleCS(this._currentPosition);
    t19.ca = s17, t19.sa = e20;
  }
  nextPointAndAngle(t19, s17, e20 = r6.FAIL) {
    const n23 = new a7();
    if (!this._nextPosition(t19, n23, null, e20))
      return false;
    n23.copyTo(this._currentPosition), s17.pt = this._getPoint(n23);
    const [i18, h11] = this._getAngleCS(n23);
    return s17.ca = i18, s17.sa = h11, true;
  }
  nextCurve(s17) {
    if (0 === s17)
      return null;
    const e20 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    e20.startPath(), e20.nextPath();
    const n23 = new a7();
    return this._nextPosition(s17, n23, e20, r6.END) ? (n23.copyTo(this._currentPosition), e20) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    return this._currentPosition.segment[1];
  }
  getPt(t19) {
    return this._pathCursor.seekInPath(t19), [this._pathCursor.x, this._pathCursor.y];
  }
  getSeg(t19) {
    return [this.getPt(t19), this.getPt(t19 + 1)];
  }
  _nextPosition(t19, s17, e20, n23) {
    if (this._currentPosition.isPathEnd)
      return false;
    let i18 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (i18 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(s17); s17.abscissa + t19 * this._partLengthRatio > s17.segmentLength + this._tolerance; ) {
      if (e20) {
        if (0 === e20.numPoints)
          if (0 === i18) {
            const t21 = s17.segment[0];
            e20.pushXY(t21[0], t21[1]);
          } else
            e20.pushPoint(this.getSegCoord2D(s17.segment, i18));
        const t20 = s17.segment[1];
        e20.pushXY(t20[0], t20[1]);
      }
      if (i18 = 0, t19 -= (s17.segmentLength - s17.abscissa) / this._partLengthRatio, this._partSegCount)
        s17.segment = this._nextSegment(), s17.segmentLength = this.getSegLength(s17.segment), s17.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart())
          return n23 !== r6.FAIL && (s17.segmentLength = this.getSegLength(s17.segment), s17.isPartEnd = true, n23 === r6.END ? (s17.abscissa = s17.segmentLength, s17.isPathEnd = true) : s17.abscissa = s17.segmentLength + t19, true);
        this._currentPosition.copyTo(s17);
      }
    }
    if (s17.abscissa += t19 * this._partLengthRatio, e20) {
      0 === e20.numPoints && (0 === i18 ? e20.pushPoint(s17.segment[0]) : e20.pushPoint(this.getSegCoord2D(s17.segment, i18)));
      const t20 = s17.abscissa / s17.segmentLength;
      1 === t20 ? e20.pushPoint(s17.segment[1]) : e20.pushPoint(this.getSegCoord2D(s17.segment, t20));
    }
    return this._partSegCount || Math.abs(s17.abscissa - s17.segmentLength) < this._tolerance && (s17.isPathEnd = this._partIsLast, s17.isPartEnd = true), true;
  }
  _getPoint(t19) {
    const s17 = t19.segmentLength <= 0 ? 0 : t19.abscissa / t19.segmentLength;
    return this.getSegCoord2D(this._currentPosition.segment, s17);
  }
  _getAngleCS(t19) {
    const s17 = t19.segmentLength <= 0 ? 0 : t19.abscissa / t19.segmentLength;
    return this.getSegAngleCS(this._currentPosition.segment, s17);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; )
      this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment())
      return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); )
      if (this._partLength += this.getSegLength(this._nextSegment()), this._partSegCount++, this._pathCursor.getControlPointAt(this._getEndPointIndex())) {
        this._partIsLast = !this._hasNextSegment();
        break;
      }
    let t19 = this._partSegCount;
    for (; t19; )
      this._previousSegment(), --t19;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.getSegLength(this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const s17 = this._getStartPointIndex();
    this._ctrlPtBegin = this._pathCursor.getControlPointAt(s17);
    let e20 = s17 + this._partSegCount + 1;
    if (e20 >= this._pathCursor.numPoints && (e20 = 0), this._ctrlPtEnd = this._pathCursor.getControlPointAt(e20), this._patternLength > 0) {
      const t20 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, s18 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let e21 = Math.round((this._partLength - (t20 + s18)) / this._patternLength);
      e21 <= 0 && (e21 = t20 + s18 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t20 + s18 + e21 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else
      this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._pathCursor.numPoints - 2;
  }
  _previousSegment() {
    return this.getSeg(--this._seg);
  }
  _nextSegment() {
    return this.getSeg(++this._seg);
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var n11 = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t19, e20, s17, i18, r16) {
    return new h6(t19, e20, s17);
  }
};
n11.instance = null;
var h6 = class extends i8 {
  constructor(t19, e20, s17) {
    super(t19, true, true), this._firstCurve = null, this._walker = new o6(), this._walker.updateTolerance(s17), this._endings = e20.lineDashEnding, this._customDashPos = -(e20.offsetAlongLine ?? 0) * s17, this._offsetAtEnd = (e20.customEndingOffset ?? 0) * s17, this._pattern = new i9(), this._pattern.init(e20.dashTemplate, true), this._pattern.scale(s17);
  }
  processPath(s17) {
    if (0 === this._pattern.length()) {
      this.iteratePath = false;
      const i18 = n(s17);
      return a6.fromJSONCIM({ paths: [i18] });
    }
    if (!this.iteratePath) {
      let r17 = true;
      switch (this._endings) {
        case k2.HalfPattern:
        case k2.HalfGap:
        default:
          this._pattern.extPtGap = 0;
          break;
        case k2.FullPattern:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case k2.FullGap:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case k2.NoConstraint:
          this.isClosed || (r17 = false);
          break;
        case k2.Custom:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const a14 = s17.pathLength();
      if (this._pattern.isEmpty() || a14 < 0.1 * this._pattern.length()) {
        const i18 = n(s17);
        return a6.fromJSONCIM({ paths: [i18] });
      }
      if (!this._walker.init(s17, this._pattern, r17)) {
        const i18 = n(s17);
        return a6.fromJSONCIM({ paths: [i18] });
      }
    }
    let r16;
    if (this.iteratePath)
      r16 = this._pattern.nextValue();
    else {
      let t19;
      switch (this._endings) {
        case k2.HalfPattern:
        default:
          t19 = 0.5 * this._pattern.firstValue();
          break;
        case k2.HalfGap:
          t19 = 0.5 * -this._pattern.lastValue();
          break;
        case k2.FullGap:
          t19 = -this._pattern.lastValue();
          break;
        case k2.FullPattern:
          t19 = 0;
          break;
        case k2.NoConstraint:
        case k2.Custom:
          t19 = -this._customDashPos;
      }
      let e20 = t19 / this._pattern.length();
      e20 -= Math.floor(e20), t19 = e20 * this._pattern.length(), this._pattern.reset(), r16 = this._pattern.nextValue();
      let s18 = false;
      for (; t19 >= r16; )
        t19 -= r16, r16 = this._pattern.nextValue(), s18 = !s18;
      r16 -= t19, s18 ? (this._walker.nextPosition(r16), r16 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(r16), r16 = this._pattern.nextValue(), this._walker.nextPosition(r16), r16 = this._pattern.nextValue());
    }
    let a13 = this._walker.nextCurve(r16);
    if (a13)
      if (this._walker.isPathEnd()) {
        if (this.iteratePath = false, this._firstCurve) {
          for (this._firstCurve.nextPath(); this._firstCurve.nextPoint(); )
            a13.pushXY(this._firstCurve.x, this._firstCurve.y);
          this._firstCurve = null;
        }
      } else
        r16 = this._pattern.nextValue(), !this._walker.nextPosition(r16) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (a13 = this._firstCurve, this._firstCurve = null)) : this.iteratePath = true;
    else
      this.iteratePath = false, a13 = this._firstCurve, this._firstCurve = null;
    return a13 == null ? void 0 : a13.reset(), a13;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var s11 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(t19, e20, i18, n23, s17, m10) {
    return new r7(t19, e20, i18, n23, s17, m10);
  }
};
s11.instance = null;
var r7 = class {
  constructor(t19, e20, n23, s17, r16, m10) {
    switch (this._inputGeometries = t19, this._tileKey = s17, this._geometryEngine = r16, this._maxInflateSize = m10 * n23, this._width = (void 0 !== e20.width ? e20.width : 2) * n23, e20.method) {
      case B.Mitered:
      case B.Bevelled:
      case B.Rounded:
      case B.TrueBuffer:
      case B.Square:
    }
    this._option = e20.option;
  }
  next() {
    let i18;
    for (; i18 = this._inputGeometries.next(); ) {
      if ("esriGeometryEnvelope" === i18.geometryType && this._width > 0) {
        const e20 = i18.asJSON();
        return Math.min(e20.xmax - e20.xmin, e20.ymax - e20.ymin) - 2 * this._width < 0 ? i18 : a6.fromJSONCIM({ paths: [[[e20.xmin + this._width, e20.ymin + this._width], [e20.xmax - this._width, e20.ymin + this._width], [e20.xmax - this._width, e20.ymax - this._width], [e20.xmin + this._width, e20.ymax - this._width], [e20.xmin + this._width, e20.ymin + this._width]], [[e20.xmin, e20.ymin], [e20.xmin, e20.ymax], [e20.xmax, e20.ymax], [e20.xmax, e20.ymin], [e20.xmin, e20.ymin]]] });
      }
      if ("esriGeometryPolygon" === i18.geometryType) {
        if (0 === this._width)
          return i18.clone();
        const t19 = this._geometryEngine;
        if (null == t19)
          return null;
        const s17 = this._tileKey ? i7(i18, this._maxInflateSize) : i18.clone();
        if (!s17)
          continue;
        const r16 = t19.buffer(f.WebMercator, s17.asJSON(), -this._width, 1);
        if (r16)
          for (const e20 of r16.rings)
            e20 && s17.pushPath(e20.reverse());
        return s17;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var e10 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t19, i18, s17, e20, o10) {
    return new n12(t19, i18, s17);
  }
};
e10.instance = null;
var n12 = class extends i8 {
  constructor(t19, i18, e20) {
    super(t19, false, true), this._curveHelper = new s10(), this._length = (void 0 !== i18.length ? i18.length : 20) * e20, this._angle = void 0 !== i18.angle ? i18.angle : 225, this._position = void 0 !== i18.position ? i18.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(i18) {
    const s17 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._curveHelper.isEmpty(i18))
      return null;
    i18.seekInPath(0);
    const e20 = i18.x, n23 = i18.y;
    i18.seekInPath(i18.numPoints - 1);
    const o10 = i18.x, r16 = i18.y, h11 = [o10 - e20, r16 - n23];
    this._curveHelper.normalize(h11);
    const l12 = e20 + (o10 - e20) * this._position / 100, _4 = n23 + (r16 - n23) * this._position / 100, a13 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let p5 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (p5 = -p5), this._mirror = !this._mirror;
    const c8 = [l12 - this._length / 2 * a13, _4 - this._length / 2 * p5], m10 = [l12 + this._length / 2 * a13, _4 + this._length / 2 * p5];
    return s17.pushPath([[e20, n23], c8, m10, [o10, r16]]), s17;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var t13 = class _t {
  static local() {
    return null === _t.instance && (_t.instance = new _t()), _t.instance;
  }
  execute(t19, s17, n23, o10, i18) {
    return new e11(t19, s17, n23);
  }
};
t13.instance = null;
var e11 = class {
  constructor(t19, e20, s17) {
    this._inputGeometries = t19, this._offsetX = void 0 !== e20.offsetX ? e20.offsetX * s17 : 0, this._offsetY = void 0 !== e20.offsetY ? e20.offsetY * s17 : 0;
  }
  next() {
    let t19 = this._inputGeometries.next();
    for (; t19; ) {
      if (t19.numPaths > 0)
        return this._move(t19.clone(), this._offsetX, this._offsetY);
      t19 = this._inputGeometries.next();
    }
    return null;
  }
  _move(t19, e20, s17) {
    for (; t19.nextPath(); )
      for (; t19.nextPoint(); )
        t19.x = t19.x + e20, t19.y = t19.y + s17;
    return t19.reset(), t19;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var m7 = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(t19, e20, o10, s17, r16, i18) {
    return new h7(t19, e20, o10, s17, r16, i18);
  }
};
m7.instance = null;
var h7 = class {
  constructor(t19, e20, o10, s17, n23, f6) {
    this._inputGeometries = t19, this._tileKey = s17, this._geometryEngine = n23, this._curveHelper = new s10(), this._offset = (e20.offset ?? 1) * o10, this._method = e20.method, this._maxInflateSize = f6 * o10, this._option = e20.option, this._offsetFlattenError = n9 * o10;
  }
  next() {
    let r16;
    for (; r16 = this._inputGeometries.next(); ) {
      if (0 === this._offset)
        return r16.clone();
      if ("esriGeometryEnvelope" === r16.geometryType) {
        if (this._method === O.Rounded && this._offset > 0) {
          const o10 = n(r16), s18 = this._curveHelper.offset(o10, -this._offset, this._method, 4, this._offsetFlattenError);
          if (s18) {
            const e20 = a6.createEmptyOptimizedCIM(r16.geometryType);
            return e20.pushPath(s18), e20;
          }
          return null;
        }
        const s17 = r16.asJSON();
        if (m(s17) && Math.min(s17.xmax - s17.xmin, s17.ymax - s17.ymin) + 2 * this._offset > 0)
          return a6.fromJSONCIM({ xmin: s17.xmin - this._offset, xmax: s17.xmax + this._offset, ymin: s17.ymin - this._offset, ymax: s17.ymax + this._offset });
      }
      const i18 = this._geometryEngine;
      if (null == i18)
        continue;
      const m10 = this._tileKey ? i7(r16, this._maxInflateSize) : r16.clone();
      if (!m10)
        continue;
      const h11 = i18.offset(f.WebMercator, m10.asJSON(), -this._offset, 1, this._method, 4, this._offsetFlattenError);
      return h11 ? a6.fromJSONCIM(h11) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var e12 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e20, n23, r16, s17, i18) {
    return new t14(e20, n23, r16);
  }
};
e12.instance = null;
var t14 = class {
  constructor(e20, t19, n23) {
    this._inputGeometries = e20, this._reverse = void 0 === t19.reverse || t19.reverse;
  }
  next() {
    let e20 = this._inputGeometries.next();
    for (; e20; ) {
      if (!this._reverse)
        return e20;
      if ("esriGeometryPolyline" === e20.geometryType)
        return n13(e20.clone());
      e20 = this._inputGeometries.next();
    }
    return null;
  }
};
function n13(e20) {
  for (; e20.nextPath(); )
    for (let t19 = 0; t19 < e20.numPoints / 2; t19++) {
      e20.seekInPath(t19);
      const n23 = e20.x, r16 = e20.y;
      e20.seekInPath(e20.numPoints - t19 - 1);
      const s17 = e20.x, i18 = e20.y;
      e20.x = n23, e20.y = r16, e20.seekInPath(t19), e20.x = s17, e20.y = i18;
    }
  return e20.reset(), e20;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var e13 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t19, e20, r16, s17, o10) {
    return new n14(t19, e20, r16);
  }
};
e13.instance = null;
var n14 = class {
  constructor(t19, e20, n23) {
    this._inputGeometries = t19, this._rotateAngle = void 0 !== e20.angle ? e20.angle * Math.PI / 180 : 0;
  }
  next() {
    let e20 = this._inputGeometries.next();
    for (; e20; ) {
      if (0 === this._rotateAngle || "esriGeometryPoint" === e20.geometryType)
        return e20;
      if (e20.numPaths > 0) {
        const n23 = c2(e20), r16 = (n23[2] + n23[0]) / 2, s17 = (n23[3] + n23[1]) / 2;
        return e20.reset(), this._rotate(e20.clone(), r16, s17);
      }
      e20 = this._inputGeometries.next();
    }
    return null;
  }
  _rotate(t19, e20, n23) {
    const r16 = Math.cos(this._rotateAngle), s17 = Math.sin(this._rotateAngle);
    for (; t19.nextPath(); )
      for (; t19.nextPoint(); ) {
        const o10 = t19.x - e20, i18 = t19.y - n23;
        t19.x = e20 + o10 * r16 - i18 * s17, t19.y = n23 + o10 * s17 + i18 * r16;
      }
    return t19.reset(), t19;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var e14 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t19, e20, s17, n23, o10) {
    return new r8(t19, e20, s17);
  }
};
e14.instance = null;
var r8 = class {
  constructor(t19, e20, r16) {
    this._inputGeometries = t19, this._xFactor = void 0 !== e20.XScaleFactor ? e20.XScaleFactor : 1.15, this._yFactor = void 0 !== e20.YScaleFactor ? e20.YScaleFactor : 1.15;
  }
  next() {
    const e20 = this._inputGeometries.next();
    if (e20) {
      if (1 === this._xFactor && 1 === this._yFactor)
        return e20;
      if ("esriGeometryPoint" === e20.geometryType)
        return e20;
      if (e20.numPaths > 0) {
        const r16 = c2(e20), s17 = (r16[2] + r16[0]) / 2, n23 = (r16[3] + r16[1]) / 2;
        return e20.reset(), this._scaleCursor(e20.clone(), s17, n23);
      }
    }
    return null;
  }
  _scaleCursor(t19, e20, r16) {
    for (; t19.nextPath(); )
      for (; t19.nextPoint(); )
        t19.x = e20 + (t19.x - e20) * this._xFactor, t19.y = r16 + (t19.y - r16) * this._yFactor;
    return t19.reset(), t19;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var n15 = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t19, e20, i18, s17, h11) {
    return new r9(t19, e20, i18);
  }
};
n15.instance = null;
var r9 = class {
  constructor(t19, e20, h11) {
    this._inputGeometries = t19, this._height = (void 0 !== e20.amplitude ? e20.amplitude : 2) * h11, this._period = (void 0 !== e20.period ? e20.period : 3) * h11, this._style = e20.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new i9(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new o6(), this._walker.updateTolerance(h11);
  }
  next() {
    let t19 = this._inputGeometries.next();
    for (; t19; ) {
      if (0 === this._height || 0 === this._period)
        return t19;
      const e20 = this._processGeom(t19);
      if (e20)
        return e20;
      t19 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(i18) {
    const s17 = a6.createEmptyOptimizedCIM(i18.geometryType);
    for (; i18.nextPath(); ) {
      s17.startPath();
      const t19 = i18.pathLength();
      if (this._walker.init(i18, this._pattern))
        switch (this._style) {
          case A.Sinus:
          default:
            this._constructCurve(s17, t19, false);
            break;
          case A.Square:
            this._constructSquare(s17, t19);
            break;
          case A.Triangle:
            this._constructTriangle(s17, t19);
            break;
          case A.Random:
            this._constructCurve(s17, t19, true);
        }
      else
        for (; i18.nextPoint(); )
          s17.pushXY(i18.x, i18.y);
    }
    return s17;
  }
  _constructCurve(t19, e20, i18) {
    let s17 = Math.round(e20 / this._period);
    0 === s17 && (s17 = 1);
    const n23 = s17 * 16 + 1, r16 = e20 / s17, a13 = this._period / 16, o10 = 1 / n23, p5 = 2 * Math.PI * e20 / r16, _4 = 2 * Math.PI * Math.random(), u12 = 2 * Math.PI * Math.random(), l12 = 2 * Math.PI * Math.random(), c8 = 0.75 - Math.random() / 2, d4 = 0.75 - Math.random() / 2, g6 = new h5();
    this._walker.curPointAndAngle(g6), t19.pushPoint(g6.pt);
    let w7 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(a13, g6)) {
        t19.pushPoint(this._walker.getPathEnd());
        break;
      }
      {
        const e21 = w7;
        let s18;
        if (w7 += o10, i18) {
          const t20 = this._height / 2 * (1 + 0.3 * Math.sin(c8 * p5 * e21 + _4));
          s18 = t20 * Math.sin(p5 * e21 + u12), s18 += t20 * Math.sin(d4 * p5 * e21 + l12), s18 /= 2;
        } else
          s18 = 0.5 * this._height * Math.sin(0.5 * p5 * e21);
        t19.pushXY(g6.pt[0] - s18 * g6.sa, g6.pt[1] + s18 * g6.ca);
      }
    }
  }
  _constructSquare(t19, e20) {
    Math.round(e20 / this._period);
    let i18 = true;
    for (; ; ) {
      let e21 = false;
      if (this._walker.curPositionIsValid()) {
        const s17 = new h5();
        this._walker.curPointAndAngle(s17);
        const n23 = new h5();
        if (this._walker.nextPointAndAngle(this._period, n23)) {
          const r16 = new h5();
          this._walker.nextPointAndAngle(this._period, r16) && (i18 ? (t19.pushPoint(s17.pt), i18 = false) : t19.pushPoint(s17.pt), t19.pushXY(s17.pt[0] - this._height / 2 * s17.sa, s17.pt[1] + this._height / 2 * s17.ca), t19.pushXY(n23.pt[0] - this._height / 2 * n23.sa, n23.pt[1] + this._height / 2 * n23.ca), t19.pushXY(n23.pt[0] + this._height / 2 * n23.sa, n23.pt[1] - this._height / 2 * n23.ca), t19.pushXY(r16.pt[0] + this._height / 2 * r16.sa, r16.pt[1] - this._height / 2 * r16.ca), e21 = true);
        }
      }
      if (!e21) {
        t19.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
  _constructTriangle(t19, e20) {
    Math.round(e20 / this._period);
    let i18 = true;
    for (; ; ) {
      let e21 = false;
      if (this._walker.curPositionIsValid()) {
        const s17 = new h5();
        this._walker.curPointAndAngle(s17);
        const n23 = new h5();
        if (this._walker.nextPointAndAngle(this._period / 2, n23)) {
          const r16 = new h5();
          this._walker.nextPointAndAngle(this._period, r16) && (this._walker.nextPosition(this._period / 2) && (i18 ? (t19.pushPoint(s17.pt), i18 = false) : t19.pushPoint(s17.pt), t19.pushXY(n23.pt[0] - this._height / 2 * n23.sa, n23.pt[1] + this._height / 2 * n23.ca), t19.pushXY(r16.pt[0] + this._height / 2 * r16.sa, r16.pt[1] - this._height / 2 * r16.ca)), e21 = true);
        }
      }
      if (!e21) {
        t19.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var a8 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t19, e20, s17, i18, n23) {
    return new r10(t19, e20, s17);
  }
};
a8.instance = null;
var r10 = class extends s9 {
  constructor(t19, e20, n23) {
    super(t19), this._geometryWalker = new o6(), this._geometryWalker.updateTolerance(n23), this._angleToLine = e20.angleToLine ?? true, this._offset = (e20.offset ? e20.offset : 0) * n23, this._originalEndings = e20.endings, this._offsetAtEnd = (e20.customEndingOffset ? e20.customEndingOffset : 0) * n23, this._position = -(e20.offsetAlongLine ? e20.offsetAlongLine : 0) * n23, this._pattern = new i9(), this._pattern.init(e20.placementTemplate, false), this._pattern.scale(n23), this._endings = this._originalEndings;
  }
  processPath(t19) {
    if (this._pattern.isEmpty())
      return null;
    let s17;
    if (this.iteratePath)
      s17 = this._pattern.nextValue();
    else {
      this._originalEndings === X.WithFullGap && this.isClosed ? this._endings = X.WithMarkers : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let i19, n23 = true;
      switch (this._endings) {
        case X.NoConstraint:
          i19 = -this._position, i19 = this._adjustPosition(i19), n23 = false;
          break;
        case X.WithHalfGap:
        default:
          i19 = -this._pattern.lastValue() / 2;
          break;
        case X.WithFullGap:
          i19 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case X.WithMarkers:
          i19 = 0;
          break;
        case X.Custom:
          i19 = -this._position, i19 = this._adjustPosition(i19), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t19, this._pattern, n23))
        return null;
      this._pattern.reset();
      let a13 = 0;
      for (; i19 > a13; )
        i19 -= a13, a13 = this._pattern.nextValue();
      a13 -= i19, s17 = a13, this.iteratePath = true;
    }
    const i18 = new h5();
    return this._geometryWalker.nextPointAndAngle(s17, i18) ? this._endings === X.WithFullGap && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : this._endings === X.WithMarkers && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(i18.pt[0] - this._offset * i18.sa, i18.pt[1] + this._offset * i18.ca), this._angleToLine && this.internalPlacement.setRotateCS(i18.ca, i18.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t19) {
    let e20 = t19 / this._pattern.length();
    return e20 -= Math.floor(e20), e20 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var i10 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(e20, t19, s17, i18, r16) {
    return new n16(e20, t19, s17);
  }
};
i10.instance = null;
var n16 = class extends s9 {
  constructor(e20, s17, i18) {
    super(e20, false, true), this._curveHelper = new s10(), this._angleToLine = void 0 === s17.angleToLine || s17.angleToLine, this._offset = void 0 !== s17.offset ? s17.offset * i18 : 0, this._type = s17.extremityPlacement, this._position = void 0 !== s17.offsetAlongLine ? s17.offsetAlongLine * i18 : 0, this._beginProcessed = false;
  }
  processPath(e20) {
    let t19;
    switch (this._type) {
      case o3.Both:
      default:
        this._beginProcessed ? (t19 = this._atExtremities(e20, this._position, false), this._beginProcessed = false, this.iteratePath = false) : (t19 = this._atExtremities(e20, this._position, true), this._beginProcessed = true, this.iteratePath = true);
        break;
      case o3.JustBegin:
        t19 = this._atExtremities(e20, this._position, true);
        break;
      case o3.JustEnd:
        t19 = this._atExtremities(e20, this._position, false);
      case o3.None:
    }
    return t19;
  }
  _atExtremities(e20, t19, s17) {
    if (s17 || e20.seekPathEnd(), s17 ? e20.nextPoint() : e20.prevPoint()) {
      let i18 = 0, [n23, r16] = [0, 0], [o10, a13] = [e20.x, e20.y];
      for (; s17 ? e20.nextPoint() : e20.prevPoint(); ) {
        n23 = o10, r16 = a13, o10 = e20.x, a13 = e20.y;
        const s18 = this._curveHelper.getLength(n23, r16, o10, a13);
        if (i18 + s18 > t19) {
          const e21 = (t19 - i18) / s18, [h11, l12] = this._curveHelper.getAngleCS(n23, r16, o10, a13, e21), c8 = this._curveHelper.getCoord2D(n23, r16, o10, a13, e21);
          return this.internalPlacement.setTranslate(c8[0] - this._offset * l12, c8[1] + this._offset * h11), this._angleToLine && this.internalPlacement.setRotateCS(-h11, -l12), this.internalPlacement;
        }
        i18 += s18;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var a9 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t19, i18, s17, e20, n23) {
    return new r11(t19, i18, s17);
  }
};
a9.instance = null;
var r11 = class extends s9 {
  constructor(t19, e20, n23) {
    super(t19), this._walker = new o6(), this._walker.updateTolerance(n23), this._angleToLine = void 0 === e20.angleToLine || e20.angleToLine, this._offset = void 0 !== e20.offset ? e20.offset * n23 : 0, this._beginGap = void 0 !== e20.beginPosition ? e20.beginPosition * n23 : 0, this._endGap = void 0 !== e20.endPosition ? e20.endPosition * n23 : 0, this._flipFirst = void 0 === e20.flipFirst || e20.flipFirst, this._pattern = new i9(), this._pattern.init(e20.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t19) {
    if (this._pattern.isEmpty())
      return null;
    let i18;
    if (this.iteratePath) {
      const t20 = this._pattern.nextValue() * this._subPathLen, s18 = this._beginGap + t20;
      i18 = s18 - this._prevPos, this._prevPos = s18;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = t19.pathLength() - this._beginGap - this._endGap, this._subPathLen < 0)
        return this.iteratePath = false, null;
      if (!this._walker.init(t19, this._pattern, false))
        return null;
      this._pattern.reset();
      const s18 = this._pattern.nextValue() * this._subPathLen, e20 = this._beginGap + s18;
      i18 = e20 - this._prevPos, this._prevPos = e20, this.iteratePath = true;
    }
    const s17 = new h5();
    if (!this._walker.nextPointAndAngle(i18, s17, r6.END))
      return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s17.pt[0] - this._offset * s17.sa, s17.pt[1] + this._offset * s17.ca);
    const a13 = this._isFirst && this._flipFirst;
    let r16, h11;
    return this._angleToLine ? (r16 = s17.ca, h11 = s17.sa) : (r16 = 1, h11 = 0), a13 && (r16 = -r16, h11 = -h11), this.internalPlacement.setRotateCS(r16, h11), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
var e15 = 512;
var h8 = 10;
var n17 = 24;
var _2 = 1e-6;
var r12 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(t19, s17, i18, e20, h11) {
    return new o7(t19, s17, i18, e20, h11);
  }
};
r12.instance = null;
var o7 = class _o {
  constructor(h11, n23, _4, r16, o10) {
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._accelerationMap = null, this._testInsidePolygon = false, this._verticalSubdivision = true, this._stepX = Math.abs(n23.stepX ?? 16) * _4, this._stepY = Math.abs(n23.stepY ?? 16) * _4, this._stepX = Math.round(128 * this._stepX) / 128, this._stepY = Math.round(128 * this._stepY) / 128, 0 !== this._stepX && 0 !== this._stepY) {
      if (this._gridType = n23.gridType ?? Y.Fixed, this._gridType === Y.Random) {
        const s17 = n23.seed ?? 13, i18 = 1;
        this._randomLCG = new t(s17 * i18), this._randomness = (n23.randomness ?? 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0, this._buildRandomValues();
      } else {
        if (this._randomness = 0, this._gridAngle = n23.gridAngle ?? 0, this._shiftOddRows = n23.shiftOddRows ?? false, this._offsetX = (n23.offsetX ?? 0) * _4, this._offsetY = (n23.offsetY ?? 0) * _4, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX)
          if (this._offsetX < 0)
            for (; this._offsetX < -0.5 * this._stepX; )
              this._offsetX += this._stepX;
          else
            for (; this._offsetX >= 0.5 * this._stepX; )
              this._offsetX -= this._stepX;
        if (this._stepY)
          if (this._offsetY < 0)
            for (; this._offsetY < -0.5 * this._stepY; )
              this._offsetY += this._stepY;
          else
            for (; this._offsetY >= 0.5 * this._stepY; )
              this._offsetY -= this._stepY;
      }
      if (this._graphicOriginX = 0, this._graphicOriginY = 0, null != r16) {
        const [t19, s17, i18, h12] = r16.split("/"), n24 = parseFloat(t19), _5 = parseFloat(s17), o11 = parseFloat(i18), a13 = parseFloat(h12);
        this._graphicOriginX = -(a13 * 2 ** n24 + o11) * e15, this._graphicOriginY = _5 * e15, this._testInsidePolygon = true;
      }
      this._internalPlacement = new t10(), this._calculateMinMax(h11), this._geometryCursor = h11;
    }
  }
  next() {
    return this._geometryCursor ? this._nextInside() : null;
  }
  _buildRandomValues() {
    if (!_o._randValues) {
      _o._randValues = [];
      for (let t19 = 0; t19 < n17; t19++)
        for (let s17 = 0; s17 < n17; s17++)
          _o._randValues.push(this._randomLCG.getFloat()), _o._randValues.push(this._randomLCG.getFloat());
    }
  }
  _calculateMinMax(t19) {
    let s17, i18, h11, n23, _4, r16, o10, a13, l12, f6, c8, u12, p5, M4;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, o10 = a13 = p5 = c8 = Number.MAX_VALUE, l12 = f6 = M4 = u12 = -Number.MAX_VALUE;
    const g6 = 1 !== this._cosAngle;
    for (t19.reset(); t19.nextPath(); )
      for (; t19.nextPoint(); )
        r16 = t19.x, _4 = t19.y, s17 = r16 - this._graphicOriginX - this._offsetX, i18 = _4 - this._graphicOriginY - this._offsetY, g6 ? (h11 = this._cosAngle * s17 - this._sinAngle * i18, n23 = this._sinAngle * s17 + this._cosAngle * i18) : (h11 = s17, n23 = i18), o10 = Math.min(o10, h11), l12 = Math.max(l12, h11), a13 = Math.min(a13, n23), f6 = Math.max(f6, n23), c8 = Math.min(c8, _4), u12 = Math.max(u12, _4), p5 = Math.min(p5, r16), M4 = Math.max(M4, r16);
    c8 = c8 !== Number.MAX_VALUE ? c8 : -e15 - this._stepY, u12 = u12 !== -Number.MAX_VALUE ? u12 : this._stepY, p5 = p5 !== Number.MAX_VALUE ? p5 : -this._stepX, M4 = M4 !== -Number.MAX_VALUE ? M4 : e15 + this._stepX;
    const d4 = u12 - c8, m10 = M4 - p5;
    if (this._verticalSubdivision = d4 >= m10, this._polygonMin = this._verticalSubdivision ? c8 : p5, this._testInsidePolygon) {
      let t20 = 0 - this._graphicOriginX - this._offsetX - this._stepX, s18 = e15 - this._graphicOriginX - this._offsetX + this._stepX, i19 = -e15 - this._graphicOriginY - this._offsetY - this._stepY, h12 = 0 - this._graphicOriginY - this._offsetY + this._stepY;
      if (g6) {
        const e20 = [[t20, i19], [t20, h12], [s18, i19], [s18, h12]];
        t20 = i19 = Number.MAX_VALUE, s18 = h12 = -Number.MAX_VALUE;
        for (const n24 of e20) {
          const e21 = this._cosAngle * n24[0] - this._sinAngle * n24[1], _5 = this._sinAngle * n24[0] + this._cosAngle * n24[1];
          t20 = Math.min(t20, e21), s18 = Math.max(s18, e21), i19 = Math.min(i19, _5), h12 = Math.max(h12, _5);
        }
      }
      o10 = o10 !== Number.MAX_VALUE ? Math.max(o10, t20) : t20, a13 = a13 !== Number.MAX_VALUE ? Math.max(a13, i19) : i19, l12 = l12 !== -Number.MAX_VALUE ? Math.min(l12, s18) : s18, f6 = f6 !== -Number.MAX_VALUE ? Math.min(f6, h12) : h12;
    }
    this._xMin = Math.round(o10 / this._stepX), this._xMax = Math.round(l12 / this._stepX), this._yMin = Math.round(a13 / this._stepY), this._yMax = Math.round(f6 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1, this._buildAccelerationMap(t19, p5, M4, c8, u12);
  }
  _buildAccelerationMap(t19, s17, i18, n23, _4) {
    t19.reset();
    const r16 = /* @__PURE__ */ new Map(), o10 = this._verticalSubdivision, a13 = o10 ? _4 - n23 : i18 - s17;
    let f6 = Math.ceil(a13 / h8);
    if (f6 <= 1)
      return;
    const c8 = Math.floor(a13 / f6);
    let u12, p5, M4, g6, d4, m10, X2, x4, A5, Y3, y5;
    for (f6++, this._delta = c8, o10 ? (A5 = -e15 - this._stepY, Y3 = this._stepY, y5 = n23) : (A5 = -this._stepX, Y3 = e15 + this._stepX, y5 = s17); t19.nextPath(); )
      if (!(t19.numPoints < 2) && t19.nextPoint())
        for (u12 = t19.x, p5 = t19.y; t19.nextPoint(); u12 = M4, p5 = g6) {
          if (M4 = t19.x, g6 = t19.y, o10) {
            if (p5 === g6 || p5 < A5 && g6 < A5 || p5 > Y3 && g6 > Y3)
              continue;
            d4 = Math.min(p5, g6), m10 = Math.max(p5, g6);
          } else {
            if (u12 === M4 || u12 < A5 && M4 < A5 || u12 > Y3 && M4 > Y3)
              continue;
            d4 = Math.min(u12, M4), m10 = Math.max(u12, M4);
          }
          for (; d4 < m10; )
            X2 = Math.floor((d4 - y5) / c8), l7(X2, u12, p5, M4, g6, r16), d4 += c8;
          x4 = Math.floor((m10 - y5) / c8), x4 > X2 && l7(x4, u12, p5, M4, g6, r16);
        }
    this._accelerationMap = r16;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax)
          return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t19 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t19 += 0.5 * this._stepX);
      const s17 = this._currentY * this._stepY + this._offsetY;
      let e20, h11;
      if (this._currentX++, this._gridType === Y.Random) {
        const i18 = (this._currentX % n17 + n17) % n17, _4 = (this._currentY % n17 + n17) % n17;
        e20 = this._graphicOriginX + t19 + this._stepX * this._randomness * (0.5 - _o._randValues[_4 * n17 + i18]) * 2 / 3, h11 = this._graphicOriginY + s17 + this._stepY * this._randomness * (0.5 - _o._randValues[_4 * n17 + i18 + 1]) * 2 / 3;
      } else
        e20 = this._graphicOriginX + this._cosAngle * t19 + this._sinAngle * s17, h11 = this._graphicOriginY - this._sinAngle * t19 + this._cosAngle * s17;
      if (!this._testInsidePolygon || this._isInsidePolygon(e20, h11, this._geometryCursor))
        return this._internalPlacement.setTranslate(e20, h11), this._internalPlacement;
    }
  }
  _isInsidePolygon(t19, s17, i18) {
    if (null == this._accelerationMap)
      return a10(t19, s17, i18);
    t19 += _2, s17 += _2;
    const e20 = this._verticalSubdivision, h11 = e20 ? s17 : t19, n23 = Math.floor((h11 - this._polygonMin) / this._delta), r16 = this._accelerationMap.get(n23);
    if (!r16)
      return false;
    let o10, l12, f6, c8 = 0;
    for (const _4 of r16) {
      if (o10 = _4[0], l12 = _4[1], e20) {
        if (o10[1] > s17 == l12[1] > s17)
          continue;
        f6 = (l12[0] - o10[0]) * (s17 - o10[1]) - (l12[1] - o10[1]) * (t19 - o10[0]);
      } else {
        if (o10[0] > t19 == l12[0] > t19)
          continue;
        f6 = (l12[1] - o10[1]) * (t19 - o10[0]) - (l12[0] - o10[0]) * (s17 - o10[1]);
      }
      f6 > 0 ? c8++ : c8--;
    }
    return 0 !== c8;
  }
};
function a10(t19, s17, i18) {
  let e20, h11, n23, r16, o10 = 0;
  for (t19 += _2, s17 += _2, i18.reset(); i18.nextPath(); )
    if (i18.nextPoint())
      for (e20 = i18.x, h11 = i18.y; i18.nextPoint(); e20 = n23, h11 = r16) {
        if (n23 = i18.x, r16 = i18.y, h11 > s17 == r16 > s17)
          continue;
        (n23 - e20) * (s17 - h11) - (r16 - h11) * (t19 - e20) > 0 ? o10++ : o10--;
      }
  return 0 !== o10;
}
function l7(t19, s17, i18, e20, h11, n23) {
  let _4 = n23.get(t19);
  _4 || (_4 = [], n23.set(t19, _4)), _4.push([[s17, i18], [e20, h11]]);
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var i11 = 1e-3;
var s12 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(e20, t19, n23, i18, s17) {
    return new r13(e20, t19, n23);
  }
};
s12.instance = null;
var r13 = class extends s9 {
  constructor(e20, n23, s17) {
    super(e20), this._curveHelper = new s10(), this._angleToLine = void 0 === n23.angleToLine || n23.angleToLine, this._offset = void 0 !== n23.offset ? n23.offset * s17 : 0, this._relativeTo = n23.relativeTo, this._position = void 0 !== n23.startPointOffset ? n23.startPointOffset * s17 : 0, this._epsilon = i11 * s17;
  }
  processPath(e20) {
    const t19 = this._position;
    if (this._relativeTo === Z.SegmentMidpoint) {
      if (this.iteratePath || (this.iteratePath = true), e20.nextPoint()) {
        let [t20, n23] = [e20.x, e20.y], [i19, s17] = [0, 0];
        for (; e20.nextPoint(); ) {
          i19 = e20.x, s17 = e20.y;
          const r16 = this._curveHelper.getLength(t20, n23, i19, s17);
          if (r16 < this._epsilon) {
            t20 = i19, n23 = s17;
            continue;
          }
          const o10 = 0.5 + this._position / r16, [a13, l12] = this._curveHelper.getAngleCS(t20, n23, i19, s17, o10), h11 = this._curveHelper.getCoord2D(t20, n23, i19, s17, o10);
          return this.internalPlacement.setTranslate(h11[0] - this._offset * l12, h11[1] + this._offset * a13), this._angleToLine && this.internalPlacement.setRotateCS(a13, l12), this.internalPlacement;
        }
      }
      return this.iteratePath = false, null;
    }
    const i18 = this._relativeTo === Z.LineEnd;
    return this.onLine(e20, t19, i18);
  }
  onLine(e20, t19, i18) {
    let s17, r16 = false;
    switch (this._relativeTo) {
      case Z.LineMiddle:
      default:
        e20.seekPathStart(), s17 = e20.pathLength() / 2 + t19;
        break;
      case Z.LineBeginning:
        s17 = t19;
        break;
      case Z.LineEnd:
        s17 = t19, r16 = true;
    }
    i18 ? e20.seekPathEnd() : e20.seekPathStart();
    let o10 = 0;
    if (i18 ? e20.prevPoint() : e20.nextPoint()) {
      let [t20, n23] = [e20.x, e20.y], [a13, l12] = [0, 0];
      for (; i18 ? e20.prevPoint() : e20.nextPoint(); ) {
        a13 = e20.x, l12 = e20.y;
        const i19 = this._curveHelper.getLength(t20, n23, a13, l12);
        if (o10 + i19 > s17) {
          const e21 = (s17 - o10) / i19, [h11, c8] = this._curveHelper.getAngleCS(t20, n23, a13, l12, e21), f6 = this._curveHelper.getCoord2D(t20, n23, a13, l12, e21), u12 = r16 ? -this._offset : this._offset;
          return this.internalPlacement.setTranslate(f6[0] - u12 * c8, f6[1] + u12 * h11), this._angleToLine && (r16 ? this.internalPlacement.setRotateCS(-h11, -c8) : this.internalPlacement.setRotateCS(h11, c8)), this.internalPlacement;
        }
        t20 = a13, n23 = l12, o10 += i19;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var s13 = 1e-15;
var i12 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(t19, e20, s17, i18, o10) {
    return new n18(t19, e20, s17);
  }
};
i12.instance = null;
var n18 = class extends s9 {
  constructor(t19, s17, i18) {
    super(t19), this._curveHelper = new s10(), this._angleToLine = void 0 === s17.angleToLine || s17.angleToLine, this._offset = void 0 !== s17.offset ? s17.offset * i18 : 0, this._endPoints = void 0 === s17.placeOnEndPoints || s17.placeOnEndPoints, this._controlPoints = void 0 === s17.placeOnControlPoints || s17.placeOnControlPoints, this._regularVertices = void 0 === s17.placeOnRegularVertices || s17.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t19) {
    if (this.iteratePath || (this._preparePath(t19), this.iteratePath = true), this._tagIterator >= this._tags.length)
      return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const e20 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(e20[2]);
    let s17 = e20[0], i18 = e20[1];
    if (0 !== this._offset) {
      const t20 = Math.cos(e20[2]), n23 = Math.sin(e20[2]);
      s17 -= this._offset * n23, i18 += this._offset * t20;
    }
    return this.internalPlacement.setTranslate(s17, i18), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t19) {
    this._tags.length = 0, this._tagIterator = 0, t19.seekPathStart();
    const e20 = t19.isClosed();
    let s17 = 0, i18 = false, n23 = 0, r16 = 0;
    if (t19.seekPathStart(), t19.nextPoint()) {
      let a13 = t19.x, h11 = t19.y, l12 = t19.getControlPoint(), _4 = true, c8 = t19.nextPoint();
      for (; c8; ) {
        const g6 = t19.x, P5 = t19.y, u12 = t19.getControlPoint();
        (this._angleToLine || 0 !== this._offset) && (n23 = this._curveHelper.getAngle(a13, h11, g6, P5, 0)), _4 ? (_4 = false, e20 ? (s17 = n23, i18 = l12) : (this._endPoints || this._controlPoints && l12) && this._tags.push([a13, h11, n23])) : l12 ? this._controlPoints && this._tags.push([a13, h11, o8(r16, n23)]) : this._regularVertices && this._tags.push([a13, h11, o8(r16, n23)]), (this._angleToLine || 0 !== this._offset) && (r16 = this._curveHelper.getAngle(a13, h11, g6, P5, 1)), c8 = t19.nextPoint(), c8 || (e20 ? u12 || i18 ? this._controlPoints && this._tags.push([g6, P5, o8(r16, s17)]) : this._regularVertices && this._tags.push([g6, P5, o8(r16, s17)]) : (this._endPoints || this._controlPoints && u12) && this._tags.push([g6, P5, r16])), a13 = g6, h11 = P5, l12 = u12;
      }
    }
    this._tagIterator = 0;
  }
};
function o8(t19, e20) {
  const i18 = Math.PI;
  for (; Math.abs(e20 - t19) > i18 + 2 * s13; )
    e20 - t19 > i18 ? e20 -= 2 * i18 : e20 += 2 * i18;
  return (t19 + e20) / 2;
}

// node_modules/@arcgis/core/core/PriorityQueue.js
var t15 = class {
  constructor(t19 = e16) {
    this._data = [], this._compare = t19;
  }
  get size() {
    return this._data.length;
  }
  enqueue(t19) {
    if (null == t19)
      return;
    const { _data: e20, _compare: n23 } = this;
    e20.push(t19);
    let l12 = e20.length - 1 >>> 0;
    const r16 = e20[l12];
    for (; l12 > 0; ) {
      const t20 = l12 - 1 >> 1, s17 = e20[t20];
      if (!(n23(s17, r16) <= 0))
        break;
      e20[t20] = r16, e20[l12] = s17, l12 = t20;
    }
  }
  dequeue() {
    const { _data: t19, _compare: e20 } = this, n23 = t19[0], l12 = t19.pop();
    if (0 === t19.length)
      return n23;
    t19[0] = l12;
    let r16 = 0;
    const s17 = t19.length, u12 = t19[0];
    let a13, o10, c8 = null;
    for (; ; ) {
      const n24 = 2 * r16 + 1, l13 = 2 * r16 + 2;
      if (c8 = null, n24 < s17 && (a13 = t19[n24], e20(a13, u12) > 0 && (c8 = n24)), l13 < s17 && (o10 = t19[l13], (null === c8 && e20(o10, u12) <= 0 || null !== c8 && e20(o10, a13) <= 0) && (c8 = l13)), null === c8)
        break;
      t19[r16] = t19[c8], t19[c8] = u12, r16 = c8;
    }
    return n23;
  }
};
var e16 = (t19, e20) => t19 < e20 ? -1 : t19 > e20 ? 1 : 0;

// node_modules/@arcgis/core/geometry/support/labelPoint.js
var N2 = 100 * 222045e-21;
function h9(t19) {
  return m8({ rings: t2(t19) });
}
function m8(t19) {
  const { rings: n23 } = t19;
  if (!n23 || 0 === n23.length)
    return null;
  const o10 = a3(i2(), t19);
  if (!o10)
    return null;
  const a13 = 4 * (Math.abs(o10[0]) + Math.abs(o10[2]) + Math.abs(o10[1]) + Math.abs(o10[3]) + 1) * N2;
  let l12 = 0, f6 = 0;
  for (let e20 = 0; e20 < n23.length; e20++) {
    const t20 = M(n23[e20]);
    t20 > f6 && (f6 = t20, l12 = e20);
  }
  if (Math.abs(f6) <= 2 * a13 * a13) {
    const t20 = g(i2(), n23[l12]);
    return [(t20[0] + t20[2]) / 2, (t20[1] + t20[3]) / 2];
  }
  const u12 = s4(n23[l12], false, i2());
  if (null === u12)
    return null;
  if (1 === n23.length && n23[0].length < 4)
    return u12;
  const h11 = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]], m10 = [NaN, NaN, NaN, NaN], M4 = [NaN, NaN, NaN, NaN];
  let b5 = false, w7 = g3(u12, t19, true);
  0 === w7.distance && (b5 = true, h11[0][0] = u12[0], h11[0][1] = u12[1], w7 = g3(u12, t19, false)), m10[0] = w7.distance, M4[0] = 0;
  const y5 = [NaN, NaN];
  let C4 = false, p5 = 0.25, j4 = -1;
  const T4 = g(i2(), n23[l12]);
  let z3 = NaN;
  do {
    if (z3 = NaN, h11[1] = x2(t19, q2(T4[0], T4[2], p5), a13, o10), isNaN(h11[1][0]) || isNaN(h11[1][1]) || (w7 = g3(h11[1], t19, false), z3 = w7.distance), !isNaN(z3) && z3 > a13 && d3(h11[1], t19))
      C4 = true, m10[1] = z3, M4[1] = P4(h11[1], u12);
    else if (!isNaN(z3) && z3 > j4 && (j4 = z3, y5[0] = h11[1][0], y5[1] = h11[1][1]), p5 -= 0.01, p5 < 0.1) {
      if (!(j4 >= 0))
        break;
      C4 = true, m10[1] = j4, h11[1][0] = y5[0], h11[1][1] = y5[1], M4[1] = P4(h11[1], u12);
    }
  } while (!C4);
  C4 = false, p5 = 0.5, j4 = -1;
  let D3 = 0.01, S4 = 1;
  do {
    if (z3 = NaN, h11[2] = x2(t19, q2(T4[0], T4[2], p5), a13, o10), isNaN(h11[2][0]) || isNaN(h11[2][1]) || (w7 = g3(h11[2], t19, false), z3 = w7.distance), !isNaN(z3) && z3 > a13 && d3(h11[2], t19))
      C4 = true, m10[2] = z3, M4[2] = P4(h11[2], u12);
    else if (!isNaN(z3) && z3 > j4)
      j4 = z3, y5[0] = h11[2][0], y5[1] = h11[2][1];
    else if (z3 > j4 && (j4 = z3, y5[0] = h11[2][0], y5[1] = h11[2][1]), p5 = 0.5 + D3 * S4, D3 += 0.01, S4 *= -1, p5 < 0.3 || p5 > 0.7) {
      if (!(j4 >= 0))
        break;
      C4 = true, m10[2] = j4, h11[2][0] = y5[0], h11[2][1] = y5[1], M4[2] = P4(h11[2], u12);
    }
  } while (!C4);
  C4 = false, p5 = 0.75, j4 = -1;
  do {
    if (z3 = NaN, h11[3] = x2(t19, q2(T4[0], T4[2], p5), a13, o10), isNaN(h11[3][0]) || isNaN(h11[3][1]) || (w7 = g3(h11[3], t19, false), z3 = w7.distance), !isNaN(z3) && z3 > a13 && d3(h11[3], t19))
      C4 = true, m10[3] = z3, M4[3] = P4(h11[3], u12);
    else if (z3 > j4 && (j4 = z3, y5[0] = h11[3][0], y5[1] = h11[3][1]), p5 += 0.01, p5 > 0.9) {
      if (!(j4 >= 0))
        break;
      C4 = true, m10[3] = j4, h11[3][0] = y5[0], h11[3][1] = y5[1], M4[3] = P4(h11[3], u12);
    }
  } while (!C4);
  const U4 = [0, 1, 2, 3], B4 = b5 ? 0 : 1;
  let Q3;
  for (let e20 = B4; e20 < 4; e20++)
    for (let t20 = B4; t20 < 3; t20++) {
      const n24 = M4[t20], e21 = M4[t20 + 1];
      k4(n24, e21) > 0 && (Q3 = U4[t20], U4[t20] = U4[t20 + 1], U4[t20 + 1] = Q3, M4[t20] = e21, M4[t20 + 1] = n24);
    }
  let R3 = B4, v3 = 0, A5 = 0;
  for (let e20 = B4; e20 < 4; e20++) {
    switch (e20) {
      case 0:
        A5 = 2 * m10[U4[e20]];
        break;
      case 1:
        A5 = 1.66666666 * m10[U4[e20]];
        break;
      case 2:
        A5 = 1.33333333 * m10[U4[e20]];
        break;
      case 3:
        A5 = m10[U4[e20]];
    }
    A5 > v3 && (v3 = A5, R3 = U4[e20]);
  }
  return h11[R3];
}
function d3(t19, n23) {
  const { rings: e20 } = n23;
  let i18 = 0;
  for (const r16 of e20) {
    const n24 = r16.length;
    for (let e21 = 1; e21 < n24; ++e21) {
      const n25 = r16[e21 - 1], o10 = r16[e21];
      if (n25[1] > t19[1] == o10[1] > t19[1])
        continue;
      (o10[0] - n25[0]) * (t19[1] - n25[1]) - (o10[1] - n25[1]) * (t19[0] - n25[0]) > 0 ? i18++ : i18--;
    }
  }
  return 0 !== i18;
}
function g3(t19, n23, e20) {
  if (e20 && d3(t19, n23))
    return { coord: t19, distance: 0 };
  let i18 = 1 / 0, r16 = 0, o10 = 0;
  const s17 = [0, 0], { rings: a13 } = n23;
  for (const c8 of a13)
    if (!(c8.length < 2))
      for (let n24 = 0; n24 < c8.length - 1; n24++) {
        o(s17, t19, c8, n24);
        const e21 = P4(t19, s17);
        e21 < i18 && (i18 = e21, r16 = s17[0], o10 = s17[1]);
      }
  return { coord: [r16, o10], distance: Math.sqrt(i18) };
}
function x2(t19, n23, i18, r16) {
  const o10 = [n23, 0];
  let s17 = 1 / 0, a13 = 1 / 0, c8 = false, l12 = false;
  const f6 = [[n23, r16[1] - 1], [n23, r16[3] + 1]], N4 = [0, 0], h11 = [0, 0], m10 = [0, 0], d4 = [[0, 0], [0, 0]], g6 = i2(), { rings: x4 } = t19;
  for (const e20 of x4)
    if (!(e20.length < 2))
      for (let t20 = 1; t20 < e20.length; t20++) {
        if (d4[0][0] = e20[t20 - 1][0], d4[0][1] = e20[t20 - 1][1], d4[1][0] = e20[t20][0], d4[1][1] = e20[t20][1], null === M2(g6, d4))
          continue;
        if (h11[0] = f6[0][0], h11[1] = f6[0][1], m10[0] = f6[1][0], m10[1] = f6[1][1], 0 === p3(g6, h11, m10))
          continue;
        if (!G(f6[0], f6[1], d4[0], d4[1], N4))
          continue;
        const n24 = N4[1];
        s17 > a13 ? n24 < s17 && (s17 = n24, c8 = true) : n24 < a13 && (a13 = n24, l12 = true);
      }
  return c8 && l12 ? o10[1] = (s17 + a13) / 2 : o10[0] = o10[1] = NaN, o10;
}
function M2(t19, n23) {
  if (n23.length < 2)
    return null;
  t19 || (t19 = i2());
  const [i18, r16] = n23[0], [o10, s17] = n23[1];
  return t19[0] = Math.min(i18, o10), t19[1] = Math.min(r16, s17), t19[2] = Math.max(i18, o10), t19[3] = Math.max(r16, s17), t19;
}
var b3 = 1;
var w5 = 4;
var y3 = 3;
var C3 = 12;
function p3(t19, n23, e20) {
  let i18 = j(n23, t19), r16 = j(e20, t19);
  const o10 = t19[0], s17 = t19[1], a13 = t19[2], c8 = t19[3];
  if (i18 & r16)
    return 0;
  if (!(i18 | r16))
    return 4;
  const l12 = (i18 ? 1 : 0) | (r16 ? 2 : 0);
  do {
    const l13 = e20[0] - n23[0], f6 = e20[1] - n23[1];
    if (l13 > f6)
      i18 & y3 ? (i18 & b3 ? (n23[1] += f6 * (o10 - n23[0]) / l13, n23[0] = o10) : (n23[1] += f6 * (a13 - n23[0]) / l13, n23[0] = a13), i18 = j(n23, t19)) : r16 & y3 ? (r16 & b3 ? (e20[1] += f6 * (o10 - e20[0]) / l13, e20[0] = o10) : (e20[1] += f6 * (a13 - e20[0]) / l13, e20[0] = a13), r16 = j(e20, t19)) : i18 ? (i18 & w5 ? (n23[0] += l13 * (s17 - n23[1]) / f6, n23[1] = s17) : (n23[0] += l13 * (c8 - n23[1]) / f6, n23[1] = c8), i18 = j(n23, t19)) : (r16 & w5 ? (e20[0] += l13 * (s17 - e20[1]) / f6, e20[1] = s17) : (e20[0] += l13 * (c8 - e20[1]) / f6, e20[1] = c8), r16 = j(e20, t19));
    else if (i18 & C3 ? (i18 & w5 ? (n23[0] += l13 * (s17 - n23[1]) / f6, n23[1] = s17) : (n23[0] += l13 * (c8 - n23[1]) / f6, n23[1] = c8), i18 = j(n23, t19)) : r16 & C3 ? (r16 & w5 ? (e20[0] += l13 * (s17 - e20[1]) / f6, e20[1] = s17) : (e20[0] += l13 * (c8 - e20[1]) / f6, e20[1] = c8), r16 = j(e20, t19)) : i18 ? (i18 & b3 ? (n23[1] += f6 * (o10 - n23[0]) / l13, n23[0] = o10) : (n23[1] += f6 * (a13 - n23[0]) / l13, n23[0] = a13), i18 = j(n23, t19)) : (r16 & b3 ? (e20[1] += f6 * (o10 - e20[0]) / l13, e20[0] = o10) : (e20[1] += f6 * (a13 - e20[0]) / l13, e20[0] = a13), r16 = j(e20, t19)), i18 & r16)
      return 0;
  } while (i18 | r16);
  return l12;
}
function j(t19, n23) {
  return (t19[0] < n23[0] ? 1 : 0) | (t19[0] > n23[2] ? 1 : 0) << 1 | (t19[1] < n23[1] ? 1 : 0) << 2 | (t19[1] > n23[3] ? 1 : 0) << 3;
}
function q2(t19, n23, e20) {
  return t19 + (n23 - t19) * e20;
}
function P4(t19, n23) {
  return (t19[0] - n23[0]) * (t19[0] - n23[0]) + (t19[1] - n23[1]) * (t19[1] - n23[1]);
}
function k4(t19, n23) {
  if (t19 < n23)
    return -1;
  if (t19 > n23)
    return 1;
  if (t19 === n23)
    return 0;
  const e20 = isNaN(t19), i18 = isNaN(n23);
  return e20 < i18 ? -1 : e20 > i18 ? 1 : 0;
}
var T = class {
  constructor(t19, n23, e20, i18) {
    this.x = t19, this.y = n23, this.cellSize = e20, this.distancefromCellCenter = s3(t19, n23, i18), this.maxDistanceToPolygon = this.distancefromCellCenter + this.cellSize * Math.SQRT2;
  }
};
var z2 = 1;
var D = 100;
function S2(n23) {
  if (!n23.nextPath() || !n23.numPoints)
    return null;
  const e20 = f3(n23), i18 = e20[2] - e20[0], r16 = e20[3] - e20[1];
  if (0 === i18 || 0 === r16)
    return [e20[0] + i18 / 2, e20[1] + r16 / 2];
  const s17 = Math.max(Math.min(i18, r16) / D, z2), c8 = new t15((t19, n24) => n24.maxDistanceToPolygon - t19.maxDistanceToPolygon), l12 = Math.min(i18, r16);
  let f6 = l12 / 2, u12 = 0, N4 = 0;
  for (u12 = e20[0]; u12 < e20[2]; u12 += l12)
    for (N4 = e20[1]; N4 < e20[3]; N4 += l12)
      c8.enqueue(new T(u12 + f6, N4 + f6, f6, n23));
  const h11 = i(n23);
  if (null === h11)
    return null;
  let m10, d4 = new T(h11[0], h11[1], 0, n23);
  for (; c8.size > 0; )
    m10 = c8.dequeue(), m10.distancefromCellCenter > d4.distancefromCellCenter && (d4 = m10), m10.maxDistanceToPolygon - d4.distancefromCellCenter <= s17 || (f6 = m10.cellSize / 2, c8.enqueue(new T(m10.x - f6, m10.y - f6, f6, n23)), c8.enqueue(new T(m10.x + f6, m10.y - f6, f6, n23)), c8.enqueue(new T(m10.x - f6, m10.y + f6, f6, n23)), c8.enqueue(new T(m10.x + f6, m10.y + f6, f6, n23)));
  return [d4.x, d4.y];
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
var l8 = class _l {
  static local() {
    return null === _l.instance && (_l.instance = new _l()), _l.instance;
  }
  execute(t19, e20, s17, o10, n23) {
    return new i13(t19, e20, s17);
  }
};
l8.instance = null;
var i13 = class {
  constructor(t19, e20, s17) {
    this._geometryCursor = t19, this._offsetX = void 0 !== e20.offsetX ? e20.offsetX * s17 : 0, this._offsetY = void 0 !== e20.offsetY ? e20.offsetY * s17 : 0, this._method = void 0 !== e20.method ? e20.method : K.OnPolygon, this._internalPlacement = new t10();
  }
  next() {
    const t19 = this._geometryCursor;
    return this._geometryCursor = null, t19 ? this._polygonCenter(t19) : null;
  }
  _polygonCenter(n23) {
    let l12 = false;
    switch (this._method) {
      case K.CenterOfMass:
        {
          const t19 = N(n23);
          t19 && (this._internalPlacement.setTranslate(t19[0] + this._offsetX, t19[1] + this._offsetY), l12 = true);
        }
        break;
      case K.BoundingBoxCenter:
        {
          const e20 = c2(n23);
          e20 && (this._internalPlacement.setTranslate((e20[2] + e20[0]) / 2 + this._offsetX, (e20[3] + e20[1]) / 2 + this._offsetY), l12 = true);
        }
        break;
      case K.OnPolygon:
      default: {
        let t19;
        t19 = has("polylabel-placement-enabled") ? S2(n23) : h9(n23), null !== t19 && (this._internalPlacement.setTranslate(t19[0] + this._offsetX, t19[1] + this._offsetY), l12 = true);
      }
    }
    return l12 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function A3(p5) {
  if (!p5)
    return null;
  switch (p5.type) {
    case "CIMGeometricEffectAddControlPoints":
      return e8.local();
    case "CIMGeometricEffectArrow":
      return P3.local();
    case "CIMGeometricEffectBuffer":
      return m6.local();
    case "CIMGeometricEffectControlMeasureLine":
      return e9.local();
    case "CIMGeometricEffectCut":
      return r5.local();
    case "CIMGeometricEffectDashes":
      return n11.local();
    case "CIMGeometricEffectDonut":
      return s11.local();
    case "CIMGeometricEffectJog":
      return e10.local();
    case "CIMGeometricEffectMove":
      return t13.local();
    case "CIMGeometricEffectOffset":
      return m7.local();
    case "CIMGeometricEffectReverse":
      return e12.local();
    case "CIMGeometricEffectRotate":
      return e13.local();
    case "CIMGeometricEffectScale":
      return e14.local();
    case "CIMGeometricEffectWave":
      return n15.local();
  }
  return null;
}
function g4(e20) {
  if (!e20)
    return null;
  switch (e20.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return a8.local();
    case "CIMMarkerPlacementAtExtremities":
      return i10.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return a9.local();
    case "CIMMarkerPlacementInsidePolygon":
      return r12.local();
    case "CIMMarkerPlacementOnLine":
      return s12.local();
    case "CIMMarkerPlacementOnVertices":
      return i12.local();
    case "CIMMarkerPlacementPolygonCenter":
      return l8.local();
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/imageUtils.js
function t16(t19) {
  const e20 = t19.getFrame(0);
  if (e20 instanceof HTMLImageElement || e20 instanceof HTMLCanvasElement)
    return e20;
  const n23 = document.createElement("canvas");
  n23.width = t19.width, n23.height = t19.height;
  const a13 = n23.getContext("2d");
  return e20 instanceof ImageData ? a13.putImageData(e20, 0, 0) : a13.drawImage(e20, 0, 0), n23;
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t17 = class {
  constructor(t19 = 0, h11 = 0, i18 = 0, s17 = 0) {
    this.x = t19, this.y = h11, this.width = i18, this.height = s17;
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t19) {
    this.x = Math.min(this.x, t19.x), this.y = Math.min(this.y, t19.y), this.width = Math.max(this.width, t19.width), this.height = Math.max(this.height, t19.height);
  }
};

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function i14(t19) {
  return `rgb(${t19.slice(0, 3).toString()})`;
}
function s14(t19) {
  return `rgba(${t19.slice(0, 3).toString()},${t19[3]})`;
}
var r14 = class {
  constructor(t19) {
    t19 && (this._textRasterizationCanvas = t19);
  }
  rasterizeText(r16, o10) {
    var _a, _b;
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const h11 = this._textRasterizationCanvas, a13 = h11.getContext("2d");
    this._setFontProperties(a13, o10), this._parameters = o10, this._textLines = r16.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const { decoration: l12, weight: d4 } = o10.font;
    this._lineThroughWidthOffset = l12 && "line-through" === l12 ? 0.1 * this._lineHeight : 0;
    const c8 = null != o10.backgroundColor || null != o10.borderLine, _4 = c8 ? s6 : 0, g6 = this._computeTextWidth(a13, o10) + 2 * _4, f6 = this._lineHeight * this._textLines.length + 2 * _4;
    if (h11.width = g6 + 2 * this._lineThroughWidthOffset, h11.height = f6, 0 === h11.width || 0 === h11.height)
      return h11.width = h11.height = 1, { size: [0, 0], image: new Uint32Array(0), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, canvas: h11 };
    this._renderedLineHeight = Math.round(this._lineHeight * o10.pixelRatio), this._renderedHaloSize = u2(o10.halo.size) * o10.pixelRatio, this._renderedWidth = g6 * o10.pixelRatio, this._renderedHeight = f6 * o10.pixelRatio, this._lineThroughWidthOffset *= o10.pixelRatio;
    const u12 = o10.color ?? [0, 0, 0, 0], p5 = o10.halo && o10.halo.color ? o10.halo.color : [0, 0, 0, 0];
    this._fillStyle = s14(u12), this._haloStyle = i14(p5);
    const x4 = this._renderedLineHeight, m10 = this._renderedHaloSize;
    a13.save(), a13.clearRect(0, 0, h11.width, h11.height), this._setFontProperties(a13, o10);
    const b5 = _4 * o10.pixelRatio, w7 = n19(a13.textAlign, this._renderedWidth - 2 * b5) + m10 + b5, z3 = m10 + b5, v3 = m10 > 0;
    let y5 = this._lineThroughWidthOffset, R3 = 0;
    if (c8) {
      a13.save();
      const e20 = o10.backgroundColor ?? [0, 0, 0, 0], i18 = ((_a = o10.borderLine) == null ? void 0 : _a.color) ?? [0, 0, 0, 0], r17 = 2 * u2(((_b = o10.borderLine) == null ? void 0 : _b.size) ?? 0);
      a13.fillStyle = s14(e20), a13.strokeStyle = s14(i18), a13.lineWidth = r17, a13.fillRect(0, 0, h11.width, h11.height), a13.strokeRect(0, 0, h11.width, h11.height), a13.restore();
    }
    v3 && this._renderHalo(a13, w7, z3, y5, R3, o10), R3 += z3, y5 += w7;
    for (const t19 of this._textLines)
      v3 ? (a13.globalCompositeOperation = "destination-out", a13.fillStyle = "rgb(0, 0, 0)", a13.fillText(t19, y5, R3), a13.globalCompositeOperation = "source-over", a13.fillStyle = this._fillStyle, a13.fillText(t19, y5, R3)) : (a13.fillStyle = this._fillStyle, a13.fillText(t19, y5, R3)), l12 && "none" !== l12 && this._renderDecoration(a13, y5, R3, l12, d4), R3 += x4;
    a13.restore();
    const H = this._renderedWidth + 2 * this._lineThroughWidthOffset, S4 = this._renderedHeight, C4 = a13.getImageData(0, 0, H, S4), T4 = new Uint8Array(C4.data);
    if (o10.premultiplyColors) {
      let t19;
      for (let e20 = 0; e20 < T4.length; e20 += 4)
        t19 = T4[e20 + 3] / 255, T4[e20] = T4[e20] * t19, T4[e20 + 1] = T4[e20 + 1] * t19, T4[e20 + 2] = T4[e20 + 2] * t19;
    }
    let W4, k6;
    switch (o10.horizontalAlignment) {
      case "left":
        W4 = -0.5;
        break;
      case "right":
        W4 = 0.5;
        break;
      default:
        W4 = 0;
    }
    switch (o10.verticalAlignment) {
      case "bottom":
        k6 = -0.5;
        break;
      case "top":
        k6 = 0.5;
        break;
      default:
        k6 = 0;
    }
    return { size: [H, S4], image: new Uint32Array(T4.buffer), sdf: false, simplePattern: false, anchorX: W4, anchorY: k6, canvas: h11 };
  }
  _renderHalo(t19, e20, i18, s17, r16, n23) {
    const o10 = this._renderedWidth, h11 = this._renderedHeight;
    this._haloRasterizationCanvas || (this._haloRasterizationCanvas = document.createElement("canvas")), this._haloRasterizationCanvas.width = o10, this._haloRasterizationCanvas.height = h11;
    const a13 = this._haloRasterizationCanvas, l12 = a13.getContext("2d");
    l12.clearRect(0, 0, o10, h11), this._setFontProperties(l12, n23);
    const { decoration: d4, weight: c8 } = n23.font;
    l12.fillStyle = this._haloStyle, l12.strokeStyle = this._haloStyle, l12.lineJoin = "round", this._renderHaloNative(l12, e20, i18, d4, c8), t19.globalAlpha = this._parameters.halo.color[3], t19.drawImage(a13, 0, 0, o10, h11, s17, r16, o10, h11), t19.globalAlpha = 1;
  }
  _renderHaloNative(t19, e20, i18, s17, r16) {
    const n23 = this._renderedLineHeight, o10 = this._renderedHaloSize;
    for (const h11 of this._textLines) {
      const a13 = 2 * o10, l12 = 5, d4 = 0.1;
      for (let n24 = 0; n24 < l12; n24++) {
        const o11 = (1 - (l12 - 1) * d4 + n24 * d4) * a13;
        t19.lineWidth = o11, t19.strokeText(h11, e20, i18), s17 && "none" !== s17 && this._renderDecoration(t19, e20, i18, s17, r16, o11);
      }
      i18 += n23;
    }
  }
  _setFontProperties(e20, i18) {
    const s17 = Math.max(i18.size, 0.5), r16 = i18.font, n23 = `${r16.style} ${r16.weight} ${u2(s17 * i18.pixelRatio).toFixed(1)}px ${r16.family}, sans-serif`;
    let o10;
    switch (e20.font = n23, e20.textBaseline = "top", i18.horizontalAlignment) {
      case "left":
      default:
        o10 = "left";
        break;
      case "right":
        o10 = "right";
        break;
      case "center":
        o10 = "center";
    }
    e20.textAlign = o10;
  }
  computeTextSize(t19, e20) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i18 = this._textRasterizationCanvas, s17 = i18.getContext("2d");
    this._setFontProperties(s17, e20), this._parameters = e20, this._textLines = t19.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const r16 = this._computeTextWidth(s17, e20), n23 = this._lineHeight * this._textLines.length;
    return i18.width = r16, i18.height = n23, [r16 * e20.pixelRatio, n23 * e20.pixelRatio];
  }
  _computeTextWidth(e20, i18) {
    let s17 = 0;
    for (const t19 of this._textLines)
      s17 = Math.max(s17, e20.measureText(t19).width);
    const r16 = i18.font;
    return ("italic" === r16.style || "oblique" === r16.style || "string" == typeof r16.weight && ("bold" === r16.weight || "bolder" === r16.weight) || "number" == typeof r16.weight && r16.weight > 600) && (s17 += 0.3 * e20.measureText("w").width), s17 += 2 * u2(this._parameters.halo.size), Math.round(s17);
  }
  _computeLineHeight() {
    let e20 = 1.275 * this._parameters.size;
    const i18 = this._parameters.font.decoration;
    return i18 && "underline" === i18 && (e20 *= 1.3), Math.round(e20 + 2 * u2(this._parameters.halo.size));
  }
  _renderDecoration(t19, e20, i18, s17, r16, n23) {
    const o10 = 0.9 * this._lineHeight, h11 = "bold" === r16 ? 0.06 : "bolder" === r16 ? 0.09 : 0.04;
    switch (t19.textAlign) {
      case "center":
        e20 -= this._renderedWidth / 2;
        break;
      case "right":
        e20 -= this._renderedWidth;
    }
    const a13 = t19.textBaseline;
    if ("underline" === s17)
      switch (a13) {
        case "top":
          i18 += o10;
          break;
        case "middle":
          i18 += o10 / 2;
      }
    else if ("line-through" === s17)
      switch (a13) {
        case "top":
          i18 += o10 / 1.5;
          break;
        case "middle":
          i18 += o10 / 3;
      }
    const l12 = n23 ? 1.5 * n23 : Math.ceil(o10 * h11);
    t19.save(), t19.beginPath(), t19.strokeStyle = t19.fillStyle, t19.lineWidth = l12, t19.moveTo(e20 - this._lineThroughWidthOffset, i18), t19.lineTo(e20 + this._renderedWidth + 2 * this._lineThroughWidthOffset, i18), t19.stroke(), t19.restore();
  }
};
function n19(t19, e20) {
  return "center" === t19 ? 0.5 * e20 : "right" === t19 ? e20 : 0;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/BoundingBox.js
var i15 = class _i {
  constructor(i18, e20, s17, r16) {
    this.center = t6(i18, e20), this.centerT = n4(), this.halfWidth = s17 / 2, this.halfHeight = r16 / 2, this.width = s17, this.height = r16;
  }
  get x() {
    return this.center[0];
  }
  get y() {
    return this.center[1];
  }
  get blX() {
    return this.center[0] + this.halfWidth;
  }
  get blY() {
    return this.center[1] + this.halfHeight;
  }
  get trX() {
    return this.center[0] - this.halfWidth;
  }
  get trY() {
    return this.center[1] - this.halfHeight;
  }
  get xmin() {
    return this.x - this.halfWidth;
  }
  get xmax() {
    return this.x + this.halfWidth;
  }
  get ymin() {
    return this.y - this.halfHeight;
  }
  get ymax() {
    return this.y + this.halfHeight;
  }
  set x(t19) {
    this.center[0] = t19;
  }
  set y(t19) {
    this.center[1] = t19;
  }
  clone() {
    return new _i(this.x, this.y, this.width, this.height);
  }
  serialize(t19) {
    return t19.writeF32(this.center[0]), t19.writeF32(this.center[1]), t19.push(this.width), t19.push(this.height), t19;
  }
  findCollisionDelta(t19, h11 = 4) {
    const i18 = Math.abs(t19.centerT[0] - this.centerT[0]), e20 = Math.abs(t19.centerT[1] - this.centerT[1]), s17 = (t19.halfWidth + this.halfWidth + h11) / i18, r16 = (t19.halfHeight + this.halfHeight + h11) / e20, n23 = Math.min(s17, r16);
    return Math.log2(n23);
  }
  extend(t19) {
    const h11 = Math.min(this.xmin, t19.xmin), i18 = Math.min(this.ymin, t19.ymin), e20 = Math.max(this.xmax, t19.xmax) - h11, s17 = Math.max(this.ymax, t19.ymax) - i18, r16 = h11 + e20 / 2, n23 = i18 + s17 / 2;
    this.width = e20, this.height = s17, this.halfWidth = e20 / 2, this.halfHeight = s17 / 2, this.x = r16, this.y = n23;
  }
  static deserialize(t19) {
    const h11 = t19.readF32(), e20 = t19.readF32(), s17 = t19.readInt32(), r16 = t19.readInt32();
    return new _i(h11, e20, s17, r16);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var l9 = 26;
var g5 = 4;
var _3 = l9 + g5;
var p4 = l9 - 6;
var x3 = 3;
var w6 = 8;
var y4 = Math.PI / 180;
var M3 = 8;
var b4 = 1.5;
var B2 = class {
  constructor(t19, s17, e20, i18) {
    this._rotationT = n3(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const n23 = e20.rect, h11 = new Float32Array(8);
    t19 *= i18, s17 *= i18;
    const r16 = e20.code ? n23.width * i18 : e20.metrics.width, a13 = e20.code ? n23.height * i18 : e20.metrics.height;
    this.width = r16, this.height = a13, h11[0] = t19, h11[1] = s17, h11[2] = t19 + r16, h11[3] = s17, h11[4] = t19, h11[5] = s17 + a13, h11[6] = t19 + r16, h11[7] = s17 + a13, this._data = h11, this._setTextureCoords(n23), this._scale = i18, this._mosaic = e20, this.x = t19, this.y = s17, this.maxOffset = Math.max(t19 + r16, s17 + a13);
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(t19) {
    this._angle = t19, h(this._rotationT, -t19), this._setOffsets(this._data);
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(this._data), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t19, width: s17 } = this._mosaic.metrics, i18 = s17 * this._scale, n23 = Math.abs(t19) * this._scale, r16 = new Float32Array(8);
      r16[0] = this.x, r16[1] = this.y, r16[2] = this.x + i18, r16[3] = this.y, r16[4] = this.x, r16[5] = this.y + n23, r16[6] = this.x + i18, r16[7] = this.y + n23;
      const a13 = o4(n3(), this._rotationT, this._transform);
      a5(r16, r16, a13);
      let c8 = 1 / 0, d4 = 1 / 0, f6 = 0, m10 = 0;
      for (let e20 = 0; e20 < 4; e20++) {
        const t20 = r16[2 * e20], s18 = r16[2 * e20 + 1];
        c8 = Math.min(c8, t20), d4 = Math.min(d4, s18), f6 = Math.max(f6, t20), m10 = Math.max(m10, s18);
      }
      const l12 = f6 - c8, g6 = m10 - d4, _4 = c8 + l12 / 2, p5 = d4 + g6 / 2;
      this._bounds = new i15(_4, p5, l12, g6);
    }
    return this._bounds;
  }
  setTransform(t19) {
    this._transform = t19, this._offsets = null;
  }
  _setOffsets(t19) {
    this._offsets || (this._offsets = { upperLeft: 0, upperRight: 0, lowerLeft: 0, lowerRight: 0 });
    const s17 = this._offsets, i18 = new Float32Array(8), n23 = o4(n3(), this._rotationT, this._transform);
    a5(i18, t19, n23), s17.upperLeft = w3(i18[0] * w6, i18[1] * w6), s17.upperRight = w3(i18[2] * w6, i18[3] * w6), s17.lowerLeft = w3(i18[4] * w6, i18[5] * w6), s17.lowerRight = w3(i18[6] * w6, i18[7] * w6);
  }
  _setTextureCoords({ x: t19, y: s17, width: e20, height: i18 }) {
    this._texcoords = { upperLeft: w3(t19, s17), upperRight: w3(t19 + e20, s17), lowerLeft: w3(t19, s17 + i18), lowerRight: w3(t19 + e20, s17 + i18) };
  }
};
var L2 = (t19, s17) => ({ code: 0, page: 0, sdf: true, rect: new t7(0, 0, 11, 8), textureBinding: s17, metrics: { advance: 0, height: 4, width: t19, left: 0, top: 0 } });
function R2(t19, s17) {
  return t19.forEach((t20) => z(t20, t20, s17)), { upperLeft: w3(w6 * t19[0][0], w6 * t19[0][1]), upperRight: w3(w6 * t19[1][0], w6 * t19[1][1]), lowerLeft: w3(w6 * t19[2][0], w6 * t19[2][1]), lowerRight: w3(w6 * t19[3][0], w6 * t19[3][1]) };
}
var T2 = class {
  constructor(t19, s17, e20) {
    this._rotation = 0, this._decorate(t19, s17, e20), this.glyphs = t19, this.bounds = this._createBounds(t19), this.isMultiline = s17.length > 1, this._hasRotation = 0 !== e20.angle, this._transform = this._createGlyphTransform(this.bounds, e20), this._borderLineSize = e20.borderLineSize, (e20.borderLineSize || e20.hasBackground) && ([this.bounds, this.background] = this.shapeBackground(this._transform));
    for (const i18 of t19)
      i18.setTransform(this._transform);
  }
  setRotation(t19) {
    if (0 === t19 && 0 === this._rotation)
      return;
    this._rotation = t19;
    const i18 = this._transform, n23 = h(n3(), t19);
    o4(i18, n23, i18);
    for (const s17 of this.glyphs)
      s17.setTransform(this._transform);
  }
  _decorate(t19, s17, e20) {
    if (!e20.decoration || "none" === e20.decoration || !t19.length)
      return;
    const i18 = e20.scale, n23 = "underline" === e20.decoration ? _3 : p4, o10 = t19[0].textureBinding;
    for (const h11 of s17) {
      const s18 = h11.startX * i18, e21 = h11.startY * i18, r16 = (h11.width + h11.glyphWidthEnd) * i18;
      t19.push(new B2(s18, e21 + n23 * i18, L2(r16, o10), 1));
    }
  }
  shapeBackground(s17) {
    const e20 = u2(this._borderLineSize || 0), i18 = (b4 + e20) / 2, n23 = this._borderLineSize ? i18 : 0, { xmin: o10, ymin: h11, xmax: r16, ymax: a13, x: c8, y: d4, width: f6, height: m10 } = this.bounds, l12 = [o10 - M3, h11 - M3], g6 = [r16 + M3, h11 - M3], _4 = [o10 - M3, a13 + M3], p5 = [r16 + M3, a13 + M3], x4 = R2([[l12[0] - i18, l12[1] - i18], [g6[0] + i18, g6[1] - i18], [l12[0] + n23, l12[1] + n23], [g6[0] - n23, g6[1] + n23]], s17), w7 = R2([[_4[0] + n23, _4[1] - n23], [p5[0] - n23, p5[1] - n23], [_4[0] - i18, _4[1] + i18], [p5[0] + i18, p5[1] + i18]], s17), y5 = R2([[l12[0] - i18, l12[1] - i18], [l12[0] + n23, l12[1] + n23], [_4[0] - i18, _4[1] + i18], [_4[0] + n23, _4[1] - n23]], s17), B4 = R2([[g6[0] - n23, g6[1] + n23], [g6[0] + i18, g6[1] - i18], [p5[0] - n23, p5[1] - n23], [p5[0] + i18, p5[1] + i18]], s17), L3 = { main: R2([l12, g6, _4, p5], s17), top: x4, bot: w7, left: y5, right: B4 };
    return [new i15(c8, d4, f6 + 2 * i18, m10 + 2 * i18), L3];
  }
  get boundsT() {
    const t19 = this.bounds, s17 = r(n4(), t19.x, t19.y);
    if (z(s17, s17, this._transform), this._hasRotation) {
      const e20 = Math.max(t19.width, t19.height);
      return new i15(s17[0], s17[1], e20, e20);
    }
    return new i15(s17[0], s17[1], t19.width, t19.height);
  }
  _createBounds(t19) {
    let s17 = 1 / 0, e20 = 1 / 0, i18 = 0, n23 = 0;
    for (const r16 of t19)
      s17 = Math.min(s17, r16.xTopLeft), e20 = Math.min(e20, r16.yTopLeft), i18 = Math.max(i18, r16.xBottomRight), n23 = Math.max(n23, r16.yBottomRight);
    const o10 = i18 - s17, h11 = n23 - e20;
    return new i15(s17 + o10 / 2, e20 + h11 / 2, o10, h11);
  }
  _createGlyphTransform(t19, s17) {
    const e20 = y4 * s17.angle, h11 = n3(), a13 = n4();
    return i4(h11, h11, r(a13, s17.xOffset, -s17.yOffset)), s17.isCIM ? e4(h11, h11, e20) : (i4(h11, h11, r(a13, t19.x, t19.y)), e4(h11, h11, e20), i4(h11, h11, r(a13, -t19.x, -t19.y))), h11;
  }
};
var v2 = class {
  constructor(t19, s17, e20, i18, n23, o10) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s17, e20)), this.end = Math.max(0, Math.max(s17, e20)), this.end < t19.length && (this.glyphWidthEnd = t19[this.end].metrics.width), this.width = i18, this.yMin = n23, this.yMax = o10;
  }
};
var j2 = (t19) => 10 === t19;
var k5 = (t19) => 32 === t19;
function A4(t19, s17, e20) {
  const i18 = new Array(), n23 = 1 / e20.scale, o10 = e20.maxLineWidth * n23, h11 = s17 ? t19.length - 1 : 0, r16 = s17 ? -1 : t19.length, a13 = s17 ? -1 : 1;
  let c8 = h11, d4 = 0, f6 = 0, m10 = c8, u12 = m10, l12 = 0, g6 = 1 / 0, _4 = 0;
  for (; c8 !== r16; ) {
    const { code: s18, metrics: e21 } = t19[c8], n24 = Math.abs(e21.top);
    if (j2(s18) || k5(s18) || (g6 = Math.min(g6, n24), _4 = Math.max(_4, n24 + e21.height)), j2(s18))
      c8 !== h11 && (i18.push(new v2(t19, m10, c8 - a13, d4, g6, _4)), g6 = 1 / 0, _4 = 0), d4 = 0, m10 = c8 + a13, u12 = c8 + a13, f6 = 0;
    else if (k5(s18))
      u12 = c8 + a13, f6 = 0, l12 = e21.advance, d4 += e21.advance;
    else if (d4 > o10) {
      if (u12 !== m10) {
        const s19 = u12 - 2 * a13;
        d4 -= l12, i18.push(new v2(t19, m10, s19, d4 - f6, g6, _4)), g6 = 1 / 0, _4 = 0, m10 = u12, d4 = f6;
      } else
        i18.push(new v2(t19, m10, c8 - a13, d4, g6, _4)), g6 = 1 / 0, _4 = 0, m10 = c8, u12 = c8, d4 = 0;
      d4 += e21.advance, f6 += e21.advance;
    } else
      d4 += e21.advance, f6 += e21.advance;
    c8 += a13;
  }
  const p5 = new v2(t19, m10, c8 - a13, d4, g6, _4);
  return p5.start >= 0 && p5.end < t19.length && i18.push(p5), i18;
}
function O2(t19, s17) {
  let e20 = 0;
  for (let o10 = 0; o10 < t19.length; o10++) {
    const { width: s18 } = t19[o10];
    e20 = Math.max(s18, e20);
  }
  const i18 = "underline" === s17.decoration ? g5 : 0, n23 = t19[0].yMin;
  return { x: 0, y: n23, height: t19[t19.length - 1].yMax + s17.lineHeight * (t19.length - 1) + i18 - n23, width: e20 };
}
function S3(t19, s17, e20) {
  const i18 = e20.scale, n23 = new Array(), o10 = A4(t19, s17, e20), h11 = O2(o10, e20), { vAlign: r16, hAlign: a13 } = e20, c8 = r16 === t4.Baseline ? 1 : 0, f6 = c8 ? 0 : r16 - 1, m10 = (1 - c8) * -h11.y + f6 * (h11.height / 2) + (c8 ? 1 : 0) * -l9;
  for (let d4 = 0; d4 < o10.length; d4++) {
    const { start: s18, end: h12, width: r17 } = o10[d4];
    let c9 = -1 * (a13 + 1) * (r17 / 2) - x3;
    const f7 = d4 * e20.lineHeight + m10 - x3;
    o10[d4].startX = c9, o10[d4].startY = f7;
    for (let e21 = s18; e21 <= h12; e21++) {
      const s19 = t19[e21];
      if (j2(s19.code))
        continue;
      const o11 = new B2(c9 + s19.metrics.left, f7 - s19.metrics.top, s19, i18);
      c9 += s19.metrics.advance, n23.push(o11);
    }
  }
  return new T2(n23, o10, e20);
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var J = Math.PI / 180;
var N3 = s.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var O3 = 4;
var q3 = 10;
var V = 10;
var Y2 = 4;
var W = 10;
var Q = class _Q {
  constructor(t19) {
    this._t = t19;
  }
  static createIdentity() {
    return new _Q([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t19 = this._t;
    return new _Q(t19.slice());
  }
  transform(t19) {
    const e20 = this._t;
    return [e20[0] * t19[0] + e20[1] * t19[1] + e20[2], e20[3] * t19[0] + e20[4] * t19[1] + e20[5]];
  }
  static createScale(t19, e20) {
    return new _Q([t19, 0, 0, 0, e20, 0]);
  }
  scale(t19, e20) {
    const r16 = this._t;
    return r16[0] *= t19, r16[1] *= t19, r16[2] *= t19, r16[3] *= e20, r16[4] *= e20, r16[5] *= e20, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t19, e20) {
    return new _Q([0, 0, t19, 0, 0, e20]);
  }
  translate(t19, e20) {
    const r16 = this._t;
    return r16[2] += t19, r16[5] += e20, this;
  }
  static createRotate(t19) {
    const e20 = Math.cos(t19), r16 = Math.sin(t19);
    return new _Q([e20, -r16, 0, r16, e20, 0]);
  }
  rotate(t19) {
    return _Q.multiply(this, _Q.createRotate(t19), this);
  }
  angle() {
    const t19 = this._t[0], e20 = this._t[3], r16 = Math.sqrt(t19 * t19 + e20 * e20);
    return [t19 / r16, e20 / r16];
  }
  static multiply(t19, e20, r16) {
    const i18 = t19._t, s17 = e20._t, o10 = i18[0] * s17[0] + i18[3] * s17[1], n23 = i18[1] * s17[0] + i18[4] * s17[1], a13 = i18[2] * s17[0] + i18[5] * s17[1] + s17[2], l12 = i18[0] * s17[3] + i18[3] * s17[4], h11 = i18[1] * s17[3] + i18[4] * s17[4], c8 = i18[2] * s17[3] + i18[5] * s17[4] + s17[5], m10 = r16._t;
    return m10[0] = o10, m10[1] = n23, m10[2] = a13, m10[3] = l12, m10[4] = h11, m10[5] = c8, r16;
  }
  invert() {
    const t19 = this._t;
    let e20 = t19[0] * t19[4] - t19[1] * t19[3];
    if (0 === e20)
      return new _Q([0, 0, 0, 0, 0, 0]);
    e20 = 1 / e20;
    const r16 = (t19[1] * t19[5] - t19[2] * t19[4]) * e20, i18 = (t19[2] * t19[3] - t19[0] * t19[5]) * e20, s17 = t19[4] * e20, o10 = -t19[1] * e20, n23 = -t19[3] * e20, a13 = t19[0] * e20;
    return new _Q([s17, o10, r16, n23, a13, i18]);
  }
};
var Z2 = class {
  constructor(t19, e20) {
    this._resourceManager = t19, this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e(t10, void 0, void 0, 100), this._earlyReturn = false, this._mapRotation = 0, this._transfos.push(e20 || Q.createIdentity()), this._sizeTransfos.push(e20 ? e20.scaleRatio() : 1);
  }
  setTransform(t19, e20) {
    this._transfos = [t19 || Q.createIdentity()], this._sizeTransfos = [e20 || (t19 ? t19.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t19) {
    this._geomUnitsPerPoint = t19;
  }
  transformPt(t19) {
    return this._transfos[this._transfos.length - 1].transform(t19);
  }
  transformSize(t19) {
    return t19 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t19) {
    return this._transfos[this._transfos.length - 1].invert().transform(t19);
  }
  reverseTransformSize(t19) {
    return t19 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  getTransformAngle() {
    return this._transfos[this._transfos.length - 1].angle();
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t19, e20) {
    const r16 = e20 ? t19.scaleRatio() : 1;
    Q.multiply(t19, this.back(), t19), this._transfos.push(t19), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * r16);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t19, e20, r16) {
    if (t19)
      switch (t19.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          this.drawMultiLayerSymbol(t19, e20);
          break;
        case "CIMTextSymbol":
          this.drawTextSymbol(t19, e20, r16);
      }
  }
  drawMultiLayerSymbol(t19, e20) {
    if (!t19 || !e20)
      return;
    const r16 = t19.symbolLayers;
    if (!r16)
      return;
    const i18 = t19.effects;
    if (i18 && i18.length > 0) {
      const t20 = this.executeEffects(i18, e20);
      if (t20) {
        let e21 = t20.next();
        for (; e21; )
          this.drawSymbolLayers(r16, e21.asJSON()), e21 = t20.next();
      }
    } else
      this.drawSymbolLayers(r16, e20);
  }
  executeEffects(t19, e20) {
    const r16 = this._resourceManager.geometryEngine;
    let i18 = new s8(a6.fromJSONCIM(e20));
    for (const s17 of t19) {
      const t20 = A3(s17);
      t20 && (i18 = t20.execute(i18, s17, this.geomUnitsPerPoint(), null, r16));
    }
    return i18;
  }
  drawSymbolLayers(t19, e20) {
    let r16 = t19.length;
    for (; r16--; ) {
      const i18 = t19[r16];
      if (!i18 || false === i18.enable)
        continue;
      const s17 = i18.effects;
      if (s17 && s17.length > 0) {
        const t20 = this.executeEffects(s17, e20);
        if (t20) {
          let e21 = null;
          for (; (e21 = t20.next()) && (this.drawSymbolLayer(i18, e21.asJSON()), !this._earlyReturn); )
            ;
        }
      } else
        this.drawSymbolLayer(i18, e20);
      if (this._earlyReturn)
        return;
    }
  }
  drawSymbolLayer(t19, e20) {
    switch (t19.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e20, t19.color);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e20, t19);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e20, t19);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e20, t19);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e20, t19.color, t19.width, t19.capStyle, t19.joinStyle, t19.miterLimit);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e20, t19);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e20, t19);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t19, e20);
    }
  }
  drawHatchFill(t19, e20) {
    const r16 = this._buildHatchPolyline(e20, t19, this.geomUnitsPerPoint());
    r16 && (this.pushClipPath(t19), this.drawMultiLayerSymbol(e20.lineSymbol, r16), this.popClipPath());
  }
  drawPictureFill(t19, e20) {
  }
  drawGradientFill(t19, e20) {
  }
  drawPictureStroke(t19, e20) {
  }
  drawGradientStroke(t19, e20) {
  }
  drawMarkerLayer(t19, e20) {
    const r16 = t19.markerPlacement;
    if (r16) {
      const i18 = g4(r16);
      if (i18) {
        const s17 = "CIMMarkerPlacementInsidePolygon" === r16.type || "CIMMarkerPlacementPolygonCenter" === r16.type && r16.clipAtBoundary;
        s17 && this.pushClipPath(e20);
        const o10 = i18.execute(a6.fromJSONCIM(e20), r16, this.geomUnitsPerPoint(), null, this._resourceManager.geometryEngine);
        if (o10) {
          let e21 = null;
          for (; (e21 = o10.next()) && (this.drawMarker(t19, e21), !this._earlyReturn); )
            ;
        }
        s17 && this.popClipPath();
      }
    } else {
      const r17 = this._placementPool.acquire();
      if (l(e20))
        r17.tx = e20.x, r17.ty = e20.y, this.drawMarker(t19, r17);
      else if (f4(e20)) {
        const i18 = o2(e20);
        i18 && ([r17.tx, r17.ty] = i18, this.drawMarker(t19, r17));
      } else
        for (const i18 of e20.points)
          if (r17.tx = i18[0], r17.ty = i18[1], this.drawMarker(t19, r17), this._earlyReturn)
            break;
      this._placementPool.release(r17);
    }
  }
  drawMarker(t19, e20) {
    switch (t19.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t19, e20);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t19, e20);
    }
  }
  drawPictureMarker(t19, e20) {
    if (!t19)
      return;
    const r16 = this._resourceManager.getResource(t19.url), i18 = b2(t19.size, q3);
    if (null == r16 || i18 <= 0)
      return;
    const s17 = r16.width, o10 = r16.height;
    if (!s17 || !o10)
      return;
    const n23 = s17 / o10, a13 = b2(t19.scaleX, 1), l12 = Q.createIdentity(), h11 = t19.anchorPoint;
    if (h11) {
      let e21 = h11.x, r17 = h11.y;
      "Absolute" !== t19.anchorPointUnits && (e21 *= i18 * n23 * a13, r17 *= i18), l12.translate(-e21, -r17);
    }
    let c8 = b2(t19.rotation);
    t19.rotateClockwise && (c8 = -c8), this._mapRotation && (c8 += this._mapRotation), c8 && l12.rotate(c8 * J);
    let m10 = b2(t19.offsetX), f6 = b2(t19.offsetY);
    if (m10 || f6) {
      if (this._mapRotation) {
        const t20 = J * this._mapRotation, e21 = Math.cos(t20), r17 = Math.sin(t20), i19 = m10 * r17 + f6 * e21;
        m10 = m10 * e21 - f6 * r17, f6 = i19;
      }
      l12.translate(m10, f6);
    }
    const u12 = this.geomUnitsPerPoint();
    1 !== u12 && l12.scale(u12, u12);
    const d4 = e20.getAngle();
    d4 && l12.rotate(d4), l12.translate(e20.tx, e20.ty), this.push(l12, false), this.drawImage(t19, i18), this.pop();
  }
  drawVectorMarker(t19, e20) {
    if (!t19)
      return;
    const r16 = t19.markerGraphics;
    if (!r16)
      return;
    const i18 = b2(t19.size, q3), s17 = t19.frame, o10 = s17 ? s17.ymax - s17.ymin : 0, n23 = i18 && o10 ? i18 / o10 : 1, a13 = Q.createIdentity();
    s17 && a13.translate(0.5 * -(s17.xmax + s17.xmin), 0.5 * -(s17.ymax + s17.ymin));
    const l12 = t19.anchorPoint;
    if (l12) {
      let e21 = l12.x, r17 = l12.y;
      "Absolute" !== t19.anchorPointUnits ? s17 && (e21 *= s17.xmax - s17.xmin, r17 *= s17.ymax - s17.ymin) : (e21 /= n23, r17 /= n23), a13.translate(-e21, -r17);
    }
    1 !== n23 && a13.scale(n23, n23);
    let h11 = b2(t19.rotation);
    t19.rotateClockwise && (h11 = -h11), this._mapRotation && (h11 += this._mapRotation), h11 && a13.rotate(h11 * J);
    let c8 = b2(t19.offsetX), m10 = b2(t19.offsetY);
    if (c8 || m10) {
      if (this._mapRotation) {
        const t20 = J * this._mapRotation, e21 = Math.cos(t20), r17 = Math.sin(t20), i19 = c8 * r17 + m10 * e21;
        c8 = c8 * e21 - m10 * r17, m10 = i19;
      }
      a13.translate(c8, m10);
    }
    const f6 = this.geomUnitsPerPoint();
    1 !== f6 && a13.scale(f6, f6);
    const u12 = e20.getAngle();
    u12 && a13.rotate(u12), a13.translate(e20.tx, e20.ty), this.push(a13, t19.scaleSymbolsProportionally);
    for (const d4 of r16)
      if (d4 && d4.symbol && d4.geometry || N3.error("Invalid marker graphic", d4), this.drawSymbol(d4.symbol, d4.geometry, d4.textString), this._earlyReturn)
        break;
    this.pop();
  }
  drawTextSymbol(t19, e20, r16) {
    if (!t19)
      return;
    if (!l(e20))
      return;
    if (b2(t19.height, W) <= 0)
      return;
    const i18 = Q.createIdentity();
    let s17 = b2(t19.angle);
    s17 = -s17, s17 && i18.rotate(s17 * J);
    const o10 = b2(t19.offsetX), n23 = b2(t19.offsetY);
    (o10 || n23) && i18.translate(o10, n23);
    const a13 = this.geomUnitsPerPoint();
    1 !== a13 && i18.scale(a13, a13), i18.translate(e20.x, e20.y), this.push(i18, false), this.drawText(t19, r16), this.pop();
  }
  _buildHatchPolyline(t19, e20, r16) {
    let i18 = b2(t19.separation, Y2) * r16, s17 = b2(t19.rotation);
    if (0 === i18)
      return null;
    i18 < 0 && (i18 = -i18);
    let o10 = 0;
    const n23 = 0.5 * i18;
    for (; o10 > n23; )
      o10 -= i18;
    for (; o10 < -n23; )
      o10 += i18;
    const a13 = i2();
    a3(a13, e20), a13[0] -= n23, a13[1] -= n23, a13[2] += n23, a13[3] += n23;
    const h11 = [[a13[0], a13[1]], [a13[0], a13[3]], [a13[2], a13[3]], [a13[2], a13[1]]];
    for (; s17 > 180; )
      s17 -= 180;
    for (; s17 < 0; )
      s17 += 180;
    const m10 = Math.cos(s17 * J), f6 = Math.sin(s17 * J), u12 = -i18 * f6, d4 = i18 * m10;
    let p5, _4, g6, y5;
    o10 = b2(t19.offsetX) * r16 * f6 - b2(t19.offsetY) * r16 * m10, p5 = g6 = Number.MAX_VALUE, _4 = y5 = -Number.MAX_VALUE;
    for (const l12 of h11) {
      const t20 = l12[0], e21 = l12[1], r17 = m10 * t20 + f6 * e21, i19 = -f6 * t20 + m10 * e21;
      p5 = Math.min(p5, r17), g6 = Math.min(g6, i19), _4 = Math.max(_4, r17), y5 = Math.max(y5, i19);
    }
    g6 = Math.floor(g6 / i18) * i18;
    let P5 = m10 * p5 - f6 * g6 - u12 * o10 / i18, w7 = f6 * p5 + m10 * g6 - d4 * o10 / i18, x4 = m10 * _4 - f6 * g6 - u12 * o10 / i18, S4 = f6 * _4 + m10 * g6 - d4 * o10 / i18;
    const M4 = 1 + Math.round((y5 - g6) / i18), b5 = [];
    for (let l12 = 0; l12 < M4; l12++)
      P5 += u12, w7 += d4, x4 += u12, S4 += d4, b5.push([[P5, w7], [x4, S4]]);
    return { paths: b5 };
  }
};
var $ = class extends Z2 {
  constructor(t19, e20) {
    super(t19, e20), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t17(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return a2(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t19) {
    if (t19 && !(this._clipCount > 0))
      if (f4(t19))
        this._processPath(t19.rings, 0);
      else if (s5(t19))
        this._processPath(t19.paths, 0);
      else if (m(t19)) {
        const e20 = it(t19);
        e20 && this._processPath(e20.rings, 0);
      } else
        console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t19, e20, r16) {
    if (!t19 || this._clipCount > 0)
      return;
    const i18 = 0.5 * this.transformSize(b2(r16, O3));
    if (f4(t19))
      this._processPath(t19.rings, i18);
    else if (s5(t19))
      this._processPath(t19.paths, i18);
    else if (m(t19)) {
      const e21 = it(t19);
      e21 && this._processPath(e21.rings, i18);
    } else
      console.error("drawSolidStroke unexpected geometry type!");
  }
  drawMarkerLayer(t19, e20) {
    f4(e20) && t19.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t19.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t19.markerPlacement.type && t19.markerPlacement.clipAtBoundary) ? this._processPath(e20.rings, 0) : super.drawMarkerLayer(t19, e20);
  }
  drawHatchFill(t19, e20) {
    this.drawSolidFill(t19);
  }
  drawPictureFill(t19, e20) {
    this.drawSolidFill(t19);
  }
  drawGradientFill(t19, e20) {
    this.drawSolidFill(t19);
  }
  drawPictureStroke(t19, e20) {
    this.drawSolidStroke(t19, null, e20.width);
  }
  drawGradientStroke(t19, e20) {
    this.drawSolidStroke(t19, null, e20.width);
  }
  pushClipPath(t19) {
    this.drawSolidFill(t19), this._clipCount++;
  }
  popClipPath() {
    this._clipCount--;
  }
  drawImage(t19, e20) {
    const { url: r16 } = t19, i18 = b2(t19.scaleX, 1);
    let s17 = i18 * e20, o10 = e20;
    const n23 = this._resourceManager.getResource(r16);
    e20 || null == n23 || (s17 = i18 * n23.width, o10 = n23.height), this._merge(this.transformPt([-s17 / 2, -o10 / 2]), 0), this._merge(this.transformPt([-s17 / 2, o10 / 2]), 0), this._merge(this.transformPt([s17 / 2, -o10 / 2]), 0), this._merge(this.transformPt([s17 / 2, o10 / 2]), 0);
  }
  drawText(t19, e20) {
    if (!e20 || 0 === e20.length)
      return;
    this._textRasterizer || (this._textRasterizer = new r14());
    const r16 = at(t19), [i18, s17] = this._textRasterizer.computeTextSize(e20, r16);
    let o10 = 0;
    switch (t19.horizontalAlignment) {
      case "Left":
        o10 = i18 / 2;
        break;
      case "Right":
        o10 = -i18 / 2;
    }
    let n23 = 0;
    switch (t19.verticalAlignment) {
      case "Bottom":
        n23 = s17 / 2;
        break;
      case "Top":
        n23 = -s17 / 2;
        break;
      case "Baseline":
        n23 = s17 / 6;
    }
    this._merge(this.transformPt([-i18 / 2 + o10, -s17 / 2 + n23]), 0), this._merge(this.transformPt([-i18 / 2 + o10, s17 / 2 + n23]), 0), this._merge(this.transformPt([i18 / 2 + o10, -s17 / 2 + n23]), 0), this._merge(this.transformPt([i18 / 2 + o10, s17 / 2 + n23]), 0);
  }
  _processPath(t19, e20) {
    if (t19)
      for (const r16 of t19) {
        const t20 = r16 ? r16.length : 0;
        if (t20 > 1) {
          this._merge(this.transformPt(r16[0]), e20);
          for (let i18 = 1; i18 < t20; i18++)
            this._merge(this.transformPt(r16[i18]), e20);
        }
      }
  }
  _merge(t19, e20) {
    t19[0] - e20 < this._xmin && (this._xmin = t19[0] - e20), t19[0] + e20 > this._xmax && (this._xmax = t19[0] + e20), t19[1] - e20 < this._ymin && (this._ymin = t19[1] - e20), t19[1] + e20 > this._ymax && (this._ymax = t19[1] + e20);
  }
};
var tt = class extends Z2 {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0, this._textInfo = null;
  }
  hitTest(t19, e20, r16, i18, s17, o10) {
    const a13 = o10 * u2(1);
    this.setTransform(), this.setGeomUnitsPerPoint(a13), this._searchPoint = [(t19[0] + t19[2]) / 2, (t19[1] + t19[3]) / 2], this._searchDistPoint = (t19[2] - t19[0]) / 2 / a13, this._textInfo = i18;
    const l12 = e20 && ("CIMPointSymbol" === e20.type && "Map" !== e20.angleAlignment || "CIMTextSymbol" === e20.type);
    return this._mapRotation = l12 ? s17 : 0, this._earlyReturn = false, this.drawSymbol(e20, r16), this._earlyReturn;
  }
  drawSolidFill(t19, e20) {
    this._hitTestFill(t19);
  }
  drawHatchFill(t19, e20) {
    this._hitTestFill(t19);
  }
  drawPictureFill(t19, e20) {
    this._hitTestFill(t19);
  }
  drawGradientFill(t19, e20) {
    this._hitTestFill(t19);
  }
  drawSolidStroke(t19, e20, r16, i18, s17, o10) {
    this._hitTestStroke(t19, r16);
  }
  drawPictureStroke(t19, e20) {
    this._hitTestStroke(t19, e20.width);
  }
  drawGradientStroke(t19, e20) {
    this._hitTestStroke(t19, e20.width);
  }
  drawMarkerLayer(t19, e20) {
    t19.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t19.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t19.markerPlacement.type && t19.markerPlacement.clipAtBoundary) ? this._hitTestFill(e20) : super.drawMarkerLayer(t19, e20);
  }
  pushClipPath(t19) {
  }
  popClipPath() {
  }
  drawImage(t19, e20) {
    const { url: r16 } = t19, i18 = b2(t19.scaleX, 1), s17 = this._resourceManager.getResource(r16);
    if (null == s17 || 0 === s17.height || 0 === e20)
      return;
    const o10 = e20 * this.geomUnitsPerPoint(), n23 = o10 * i18 * (s17.width / s17.height), a13 = this.reverseTransformPt(this._searchPoint), l12 = this._searchDistPoint;
    Math.abs(a13[0]) < n23 / 2 + l12 && Math.abs(a13[1]) < o10 / 2 + l12 && (this._earlyReturn = true);
  }
  drawText(e20, r16) {
    var _a, _b;
    const i18 = this._textInfo;
    if (!i18)
      return;
    const s17 = i18.get(e20);
    if (!s17)
      return;
    const { text: o10, mosaicItem: n23 } = s17;
    if (!((_a = n23 == null ? void 0 : n23.glyphMosaicItems) == null ? void 0 : _a.length))
      return;
    const a13 = b2(e20.height, W), { lineGapType: l12, lineGap: h11 } = e20, c8 = l12 ? nt(l12, b2(h11), a13) : 0, m10 = i6(o10)[1], f6 = n23.glyphMosaicItems, u12 = "CIMBackgroundCallout" === ((_b = e20.callout) == null ? void 0 : _b.type), d4 = S3(f6, m10, { scale: a13 / b, angle: 0, xOffset: 0, yOffset: 0, hAlign: st(e20.horizontalAlignment), vAlign: ot(e20.verticalAlignment), maxLineWidth: 512, lineHeight: w * Math.max(0.25, Math.min(c8 || 1, 4)), decoration: e20.font.decoration || "none", isCIM: true, hasBackground: u12 }), p5 = this.reverseTransformPt(this._searchPoint), _4 = p5[0], g6 = p5[1];
    for (const t19 of d4.glyphs)
      if (_4 > t19.xTopLeft && _4 < t19.xBottomRight && g6 > -t19.yBottomRight && g6 < -t19.yTopLeft) {
        this._earlyReturn = true;
        break;
      }
  }
  _hitTestFill(t19) {
    let e20 = null;
    if (m(t19)) {
      const r17 = t19;
      e20 = [[[r17.xmin, r17.ymin], [r17.xmin, r17.ymax], [r17.xmax, r17.ymax], [r17.xmax, r17.ymin], [r17.xmin, r17.ymin]]];
    } else if (f4(t19))
      e20 = t19.rings;
    else {
      if (!s5(t19))
        return;
      e20 = t19.paths;
    }
    const r16 = this.reverseTransformPt(this._searchPoint);
    if (this._pointInPolygon(r16, e20) && (this._earlyReturn = true), !this._earlyReturn) {
      const t20 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
      this._nearLine(r16, e20, t20) && (this._earlyReturn = true);
    }
  }
  _hitTestStroke(t19, e20) {
    let r16 = null;
    if (m(t19)) {
      const e21 = t19;
      r16 = [[[e21.xmin, e21.ymin], [e21.xmin, e21.ymax], [e21.xmax, e21.ymax], [e21.xmax, e21.ymin], [e21.xmin, e21.ymin]]];
    } else if (f4(t19))
      r16 = t19.rings;
    else {
      if (!s5(t19))
        return;
      r16 = t19.paths;
    }
    const i18 = this.reverseTransformPt(this._searchPoint), s17 = b2(e20, O3) * this.geomUnitsPerPoint(), o10 = this.reverseTransformSize(this._searchDistPoint) * this.geomUnitsPerPoint();
    this._nearLine(i18, r16, s17 / 2 + o10) && (this._earlyReturn = true);
  }
  _pointInPolygon(t19, e20) {
    let r16 = 0;
    for (const i18 of e20) {
      const e21 = i18.length;
      for (let s17 = 1; s17 < e21; s17++) {
        const e22 = i18[s17 - 1], o10 = i18[s17];
        if (e22[1] > t19[1] == o10[1] > t19[1])
          continue;
        (o10[0] - e22[0]) * (t19[1] - e22[1]) - (o10[1] - e22[1]) * (t19[0] - e22[0]) > 0 ? r16++ : r16--;
      }
    }
    return 0 !== r16;
  }
  _nearLine(t19, e20, r16) {
    for (const i18 of e20) {
      const e21 = i18.length;
      for (let s17 = 1; s17 < e21; s17++) {
        const e22 = i18[s17 - 1], o10 = i18[s17];
        let n23 = (o10[0] - e22[0]) * (o10[0] - e22[0]) + (o10[1] - e22[1]) * (o10[1] - e22[1]);
        if (0 === n23)
          continue;
        n23 = Math.sqrt(n23);
        const a13 = ((o10[0] - e22[0]) * (t19[1] - e22[1]) - (o10[1] - e22[1]) * (t19[0] - e22[0])) / n23;
        if (Math.abs(a13) < r16) {
          const i19 = ((o10[0] - e22[0]) * (t19[0] - e22[0]) + (o10[1] - e22[1]) * (t19[1] - e22[1])) / n23;
          if (i19 > -r16 && i19 < n23 + r16)
            return true;
        }
      }
    }
    return false;
  }
};
var et = class extends Z2 {
  constructor(t19, e20, r16, i18) {
    super(e20, r16), this._applyAdditionalRenderProps = i18, this._colorSubstitutionHelper = new t11(), this._ctx = t19;
  }
  drawSolidFill(t19, e20) {
    if (!t19)
      return;
    if (f4(t19))
      this._buildPath(t19.rings, true);
    else if (s5(t19))
      this._buildPath(t19.paths, true);
    else if (m(t19))
      this._buildPath(it(t19).rings, true);
    else {
      if (!u(t19))
        return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const r16 = this._ctx;
    r16.fillStyle = "string" == typeof e20 ? e20 : "rgba(" + Math.round(e20[0]) + "," + Math.round(e20[1]) + "," + Math.round(e20[2]) + "," + (e20[3] ?? 255) / 255 + ")", r16.fill("evenodd");
  }
  drawSolidStroke(t19, e20, r16, i18, s17, o10) {
    if (!t19 || !e20 || 0 === r16)
      return;
    if (f4(t19))
      this._buildPath(t19.rings, true);
    else if (s5(t19))
      this._buildPath(t19.paths, false);
    else {
      if (!m(t19))
        return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(it(t19).rings, true);
    }
    const n23 = this._ctx;
    n23.strokeStyle = "string" == typeof e20 ? e20 : "rgba(" + Math.round(e20[0]) + "," + Math.round(e20[1]) + "," + Math.round(e20[2]) + "," + (e20[3] ?? 255) / 255 + ")", n23.lineWidth = Math.max(this.transformSize(r16), 0.5), this._setCapStyle(i18), this._setJoinStyle(s17), n23.miterLimit = o10, n23.stroke();
  }
  pushClipPath(t19) {
    if (this._ctx.save(), f4(t19))
      this._buildPath(t19.rings, true);
    else if (s5(t19))
      this._buildPath(t19.paths, true);
    else {
      if (!m(t19))
        return;
      this._buildPath(it(t19).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t19, e20) {
    const { colorSubstitutions: r16, url: i18, tintColor: s17 } = t19, o10 = b2(t19.scaleX, 1), n23 = this._resourceManager.getResource(i18);
    if (null == n23)
      return;
    let a13 = e20 * (n23.width / n23.height), l12 = e20;
    e20 || (a13 = n23.width, l12 = n23.height);
    const h11 = F(i18) || "src" in n23 && F(n23.src);
    let c8 = "getFrame" in n23 ? t16(n23) : n23;
    r16 && (c8 = this._colorSubstitutionHelper.applyColorSubstituition(c8, r16)), this._applyAdditionalRenderProps && !h11 && s17 && (c8 = this._colorSubstitutionHelper.tintImageData(c8, s17));
    const m10 = this.transformPt([0, 0]), [f6, u12] = this.getTransformAngle(), d4 = this.transformSize(1), p5 = this._ctx;
    p5.save(), p5.setTransform({ m11: o10 * d4 * f6, m12: o10 * d4 * u12, m21: -d4 * u12, m22: d4 * f6, m41: m10[0], m42: m10[1] }), p5.drawImage(c8, -a13 / 2, -l12 / 2, a13, l12), p5.restore();
  }
  drawText(t19, e20) {
    if (!e20 || 0 === e20.length)
      return;
    this._textRasterizer || (this._textRasterizer = new r14());
    const r16 = at(t19);
    r16.size *= this.transformSize(e2(1));
    const i18 = this._textRasterizer.rasterizeText(e20, r16);
    if (!i18)
      return;
    const { size: s17, anchorX: n23, anchorY: a13, canvas: l12 } = i18, h11 = s17[0] * (n23 + 0.5), c8 = s17[1] * (a13 - 0.5), m10 = this._ctx, f6 = this.transformPt([0, 0]), [u12, d4] = this.getTransformAngle(), p5 = 1;
    m10.save(), m10.setTransform({ m11: p5 * u12, m12: p5 * d4, m21: -p5 * d4, m22: p5 * u12, m41: f6[0] - p5 * h11, m42: f6[1] + p5 * c8 }), m10.drawImage(l12, 0, 0), m10.restore();
  }
  drawPictureFill(t19, e20) {
    if (!t19)
      return;
    let { colorSubstitutions: r16, height: i18, offsetX: s17, offsetY: o10, rotation: n23, scaleX: a13, tintColor: l12, url: h11 } = e20;
    const c8 = this._resourceManager.getResource(h11);
    if (null == c8)
      return;
    if (f4(t19))
      this._buildPath(t19.rings, true);
    else if (s5(t19))
      this._buildPath(t19.paths, true);
    else if (m(t19))
      this._buildPath(it(t19).rings, true);
    else {
      if (!u(t19))
        return;
      console.log("CanvasDrawHelper.drawPictureFill - No implementation!");
    }
    const m10 = this._ctx, f6 = F(h11) || "src" in c8 && F(c8.src);
    let g6, y5 = "getFrame" in c8 ? t16(c8) : c8;
    if (r16 && (y5 = this._colorSubstitutionHelper.applyColorSubstituition(y5, r16)), this._applyAdditionalRenderProps) {
      f6 || l12 && (y5 = this._colorSubstitutionHelper.tintImageData(y5, l12)), g6 = m10.createPattern(y5, "repeat");
      const t20 = this.transformSize(1);
      n23 || (n23 = 0), s17 ? s17 *= t20 : s17 = 0, o10 ? o10 *= t20 : o10 = 0, i18 && (i18 *= t20);
      const e21 = i18 ? i18 / c8.height : 1, r17 = a13 && i18 ? a13 * i18 / c8.width : 1;
      if (0 !== n23 || 1 !== e21 || 1 !== r17 || 0 !== s17 || 0 !== o10) {
        const t21 = new DOMMatrix();
        t21.rotateSelf(0, 0, -n23).translateSelf(s17, o10).scaleSelf(r17, e21, 1), g6.setTransform(t21);
      }
    } else
      g6 = m10.createPattern(y5, "repeat");
    m10.save(), m10.fillStyle = g6, m10.fill("evenodd"), m10.restore();
  }
  drawPictureStroke(t19, e20) {
    if (!t19)
      return;
    let { colorSubstitutions: i18, capStyle: s17, joinStyle: o10, miterLimit: a13, tintColor: l12, url: h11, width: c8 } = e20;
    const m10 = this._resourceManager.getResource(h11);
    if (null == m10)
      return;
    let f6;
    if (f4(t19))
      f6 = t19.rings;
    else if (s5(t19))
      f6 = t19.paths;
    else {
      if (!m(t19))
        return u(t19) ? void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!") : void 0;
      f6 = it(t19).rings;
    }
    c8 || (c8 = m10.width);
    const g6 = F(h11) || "src" in m10 && F(m10.src);
    let y5 = "getFrame" in m10 ? t16(m10) : m10;
    i18 && (y5 = this._colorSubstitutionHelper.applyColorSubstituition(y5, i18)), this._applyAdditionalRenderProps && (g6 || l12 && (y5 = this._colorSubstitutionHelper.tintImageData(y5, l12)));
    const P5 = Math.max(this.transformSize(u2(c8)), 0.5), w7 = P5 / y5.width, x4 = this._ctx, S4 = x4.createPattern(y5, "repeat-y");
    let M4, k6;
    x4.save(), this._setCapStyle(s17), this._setJoinStyle(o10), void 0 !== a13 && (x4.miterLimit = a13), x4.lineWidth = P5;
    for (let n23 of f6)
      if (n23 = a(n23), ht(n23), n23 && !(n23.length <= 1)) {
        M4 = this.transformPt(n23[0]);
        for (let t20 = 1; t20 < n23.length; t20++) {
          k6 = this.transformPt(n23[t20]);
          const e21 = rt(M4, k6), r16 = new DOMMatrix();
          r16.translateSelf(0, M4[1] - P5 / 2).scaleSelf(w7, w7, 1).rotateSelf(0, 0, 90 - e21), S4.setTransform(r16), x4.strokeStyle = S4, x4.beginPath(), x4.moveTo(M4[0], M4[1]), x4.lineTo(k6[0], k6[1]), x4.stroke(), M4 = k6;
        }
      }
    x4.restore();
  }
  _buildPath(t19, e20) {
    const r16 = this._ctx;
    if (r16.beginPath(), t19)
      for (const i18 of t19) {
        const t20 = i18 ? i18.length : 0;
        if (t20 > 1) {
          let s17 = this.transformPt(i18[0]);
          r16.moveTo(s17[0], s17[1]);
          for (let e21 = 1; e21 < t20; e21++)
            s17 = this.transformPt(i18[e21]), r16.lineTo(s17[0], s17[1]);
          e20 && r16.closePath();
        }
      }
  }
  _setCapStyle(t19) {
    switch (t19) {
      case U2.Butt:
        this._ctx.lineCap = "butt";
        break;
      case U2.Round:
        this._ctx.lineCap = "round";
        break;
      case U2.Square:
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t19) {
    switch (t19) {
      case w2.Bevel:
        this._ctx.lineJoin = "bevel";
        break;
      case w2.Round:
        this._ctx.lineJoin = "round";
        break;
      case w2.Miter:
        this._ctx.lineJoin = "miter";
    }
  }
};
function rt(t19, e20) {
  const r16 = e20[0] - t19[0], i18 = e20[1] - t19[1];
  return 180 / Math.PI * Math.atan2(i18, r16);
}
var it = (t19) => t19 ? { spatialReference: t19.spatialReference, rings: [[[t19.xmin, t19.ymin], [t19.xmin, t19.ymax], [t19.xmax, t19.ymax], [t19.xmax, t19.ymin], [t19.xmin, t19.ymin]]] } : null;
var st = (t19) => {
  switch (t19) {
    case "Left":
      return e5.Left;
    case "Right":
      return e5.Right;
    case "Center":
      return e5.Center;
    case "Justify":
      return N3.warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), e5.Center;
  }
};
var ot = (t19) => {
  switch (t19) {
    case "Top":
      return t4.Top;
    case "Center":
      return t4.Center;
    case "Bottom":
      return t4.Bottom;
    case "Baseline":
      return t4.Baseline;
  }
};
var nt = (t19, e20, r16) => {
  switch (t19) {
    case "ExtraLeading":
      return 1 + e20 / r16;
    case "Multiple":
      return e20;
    case "Exact":
      return e20 / r16;
  }
};
function at(t19, r16 = 1) {
  var _a;
  const i18 = k3(t19), s17 = S(t19.fontStyleName), o10 = t19.fontFamilyName ?? t8, { weight: n23, style: a13 } = s17, l12 = r16 * (t19.height || 5), h11 = x(t19.horizontalAlignment), c8 = G2(t19.verticalAlignment), m10 = P2(t19), f6 = P2(t19.haloSymbol), u12 = f6 ? r16 * (0 | t19.haloSize) : 0, d4 = "CIMBackgroundCallout" === ((_a = t19.callout) == null ? void 0 : _a.type) ? t19.callout.backgroundSymbol : null, p5 = P2(d4), _4 = L(d4), g6 = w4(d4);
  return { color: m10, size: l12, horizontalAlignment: h11, verticalAlignment: c8, font: { family: o10, style: h3(a13), weight: g2(n23), decoration: i18 }, halo: { size: u12 || 0, color: f6, style: a13 }, backgroundColor: p5, borderLine: null != _4 && null != g6 ? { size: _4, color: g6 } : null, pixelRatio: 1, premultiplyColors: true };
}
var lt = 1e-4;
function ht(t19) {
  let e20, r16, i18, s17, o10, n23 = t19[0], a13 = 1;
  for (; a13 < t19.length; )
    e20 = t19[a13][0] - n23[0], r16 = t19[a13][1] - n23[1], s17 = 0 !== e20 ? r16 / e20 : Math.PI / 2, void 0 !== i18 && s17 - i18 <= lt ? (t19.splice(a13 - 1, 1), n23 = o10) : (o10 = n23, n23 = t19[a13], a13++), i18 = s17;
}

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithFeature.js
function s15(e20, t19, o10, n23, a13) {
  if (null == e20)
    return null;
  const s17 = e20.referencesGeometry() && a13 ? i16(t19, n23, a13) : t19, u12 = e20.repurposeFeature(s17);
  try {
    return e20.evaluate({ ...o10, $feature: u12 }, e20.services);
  } catch (c8) {
    return s.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", c8), null;
  }
}
var u10 = /* @__PURE__ */ new Map();
function i16(e20, r16, t19) {
  const { transform: o10, hasZ: n23, hasM: a13 } = t19;
  u10.has(r16) || u10.set(r16, c6(r16));
  const s17 = u10.get(r16)(e20.geometry, o10, n23, a13);
  return { ...e20, geometry: s17 };
}
function c6(s17) {
  const u12 = {};
  switch (s17) {
    case "esriGeometryPoint":
      return (e20, r16, t19, o10) => k(r16, u12, e20, t19, o10);
    case "esriGeometryPolygon":
      return (e20, r16, t19, o10) => q(r16, u12, e20, t19, o10);
    case "esriGeometryPolyline":
      return (e20, r16, t19, n23) => v(r16, u12, e20, t19, n23);
    case "esriGeometryMultipoint":
      return (e20, r16, o10, n23) => U(r16, u12, e20, o10, n23);
    default:
      return s.getLogger("esri.views.2d.support.arcadeOnDemand").error(new s2("mapview-arcade", `Unable to handle geometryType: ${s17}`)), (e20) => e20;
  }
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var q4 = Math.PI;
var W2 = q4 / 2;
var J2 = Math.PI / 180;
var K2 = 96 / 72;
var Q2 = 4;
var Z3 = s.getLogger("esri.symbols.cim.CIMSymbolHelper");
function ee(e20) {
  if (!e20 || !e20.type)
    return null;
  let t19;
  switch (e20.type) {
    case "cim":
      return e20.data;
    case "web-style":
      return e20;
    case "simple-marker": {
      const r16 = ie2.fromSimpleMarker(e20);
      if (!r16)
        return null;
      t19 = r16;
      break;
    }
    case "picture-marker":
      t19 = ie2.fromPictureMarker(e20);
      break;
    case "simple-line":
      t19 = ie2.fromSimpleLineSymbol(e20);
      break;
    case "simple-fill":
      t19 = ie2.fromSimpleFillSymbol(e20);
      break;
    case "picture-fill":
      t19 = ie2.fromPictureFillSymbol(e20);
      break;
    case "text":
      t19 = ie2.fromTextSymbol(e20);
  }
  return { type: "CIMSymbolReference", symbol: t19 };
}
function te(e20, t19, r16) {
  switch (t19.type) {
    case "CIMSymbolReference":
      return te(e20, t19.symbol, r16);
    case "CIMPointSymbol":
      null == r16 && (r16 = { x: 0, y: 0 }), e20.drawSymbol(t19, r16);
      break;
    case "CIMLineSymbol":
      null == r16 && (r16 = { paths: [[[0, 0], [10, 0]]] }), e20.drawSymbol(t19, r16);
      break;
    case "CIMPolygonSymbol":
      null == r16 && (r16 = { rings: [[[0, 0], [0, 10], [10, 10], [10, 0], [0, 0]]] }), e20.drawSymbol(t19, r16);
      break;
    case "CIMTextSymbol": {
      const r17 = { x: 0, y: 0 };
      e20.drawSymbol(t19, r17);
      break;
    }
    case "CIMVectorMarker": {
      const r17 = new t10();
      e20.drawMarker(t19, r17);
      break;
    }
  }
  return e20.envelope();
}
function re(e20) {
  if (!e20)
    return 0;
  switch (e20.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e20.offset);
    default:
      return 0;
  }
}
function oe2(e20) {
  if (!e20)
    return 0;
  switch (e20.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e20.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e20.size);
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e20.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e20.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(b2(e20.offsetX)), Math.abs(b2(e20.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e20.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e20.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e20.fromWidth), Math.abs(e20.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e20.amplitude);
    case "CIMGeometricEffectDonut":
      return Math.abs(e20.width);
  }
}
function ae2(e20) {
  if (!e20)
    return 0;
  let t19 = 0;
  for (const r16 of e20)
    t19 += oe2(r16);
  return t19;
}
var se2 = class {
  getSymbolInflateSize(e20, t19, r16, o10, a13) {
    return e20 || (e20 = [0, 0, 0, 0]), t19 ? this._getInflateSize(e20, t19, r16, o10, a13) : e20;
  }
  static safeSize(e20) {
    const t19 = Math.max(Math.abs(e20[0]), Math.abs(e20[2])), r16 = Math.max(Math.abs(e20[1]), Math.abs(e20[3]));
    return Math.sqrt(t19 * t19 + r16 * r16);
  }
  _vectorMarkerBounds(e20, t19, r16, o10) {
    let a13 = true;
    const s17 = i2();
    if (t19 && t19.markerGraphics)
      for (const i18 of t19.markerGraphics) {
        const t20 = [0, 0, 0, 0];
        i18.geometry && (a3(s17, i18.geometry), t20[0] = 0, t20[1] = 0, t20[2] = 0, t20[3] = 0, this.getSymbolInflateSize(t20, i18.symbol, r16, 0, o10), s17[0] += t20[0], s17[1] += t20[1], s17[2] += t20[2], s17[3] += t20[3], a13 ? (e20[0] = s17[0], e20[1] = s17[1], e20[2] = s17[2], e20[3] = s17[3], a13 = false) : (e20[0] = Math.min(e20[0], s17[0]), e20[1] = Math.min(e20[1], s17[1]), e20[2] = Math.max(e20[2], s17[2]), e20[3] = Math.max(e20[3], s17[3])));
      }
    return e20;
  }
  _getInflateSize(e20, t19, r16, o10, a13) {
    if (de(t19)) {
      const s17 = this._getLayersInflateSize(e20, t19.symbolLayers, r16, o10, a13), i18 = ae2(t19.effects);
      return i18 > 0 && (s17[0] -= i18, s17[1] -= i18, s17[2] += i18, s17[3] += i18), s17;
    }
    return this._getTextInflatedSize(e20, t19, a13);
  }
  _getLayersInflateSize(e20, t19, r16, o10, a13) {
    let s17 = true;
    if (!t19)
      return e20;
    for (const i18 of t19) {
      if (!i18)
        continue;
      let t20 = [0, 0, 0, 0];
      switch (i18.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e21 = i18;
          let r17 = e21.width;
          null != r17 && (e21.capStyle === U2.Square || e21.joinStyle === w2.Miter ? r17 /= 1.4142135623730951 : r17 /= 2, t20[0] = -r17, t20[1] = -r17, t20[2] = r17, t20[3] = r17);
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e21 = i18;
          if ("CIMVectorMarker" === i18.type) {
            const e22 = i18;
            if (t20 = this._vectorMarkerBounds(t20, e22, r16, a13), e22.frame) {
              const r17 = (e22.frame.xmin + e22.frame.xmax) / 2, o11 = (e22.frame.ymin + e22.frame.ymax) / 2;
              if (t20[0] -= r17, t20[1] -= o11, t20[2] -= r17, t20[3] -= o11, null != e22.size) {
                const r18 = e22.size / (e22.frame.ymax - e22.frame.ymin);
                t20[0] *= r18, t20[1] *= r18, t20[2] *= r18, t20[3] *= r18;
              }
            }
          } else if ("CIMPictureMarker" === i18.type) {
            const o11 = i18, a14 = r16.getResource(o11.url);
            let s19 = 1;
            if (null != a14 && a14.height && (s19 = a14.width / a14.height), null != e21.size) {
              const r17 = e21.size / 2, a15 = e21.size * s19 * o11.scaleX / 2;
              t20 = [-a15, -r17, a15, r17];
            }
          } else if (null != e21.size) {
            const r17 = e21.size / 2;
            t20 = [-r17, -r17, r17, r17];
          }
          if (e21.anchorPoint) {
            let r17, o11;
            "Absolute" === e21.anchorPointUnits ? (r17 = e21.anchorPoint.x, o11 = e21.anchorPoint.y) : (r17 = e21.anchorPoint.x * (t20[2] - t20[0]), o11 = e21.anchorPoint.y * (t20[3] - t20[1])), t20[0] -= r17, t20[1] -= o11, t20[2] -= r17, t20[3] -= o11;
          }
          let s18 = b2(e21.rotation);
          if (e21.rotateClockwise && (s18 = -s18), o10 && (s18 -= o10), s18) {
            const e22 = J2 * s18, r17 = Math.cos(e22), o11 = Math.sin(e22), a14 = i2([n5, n5, -n5, -n5]);
            f2(a14, [t20[0] * r17 - t20[1] * o11, t20[0] * o11 + t20[1] * r17]), f2(a14, [t20[0] * r17 - t20[3] * o11, t20[0] * o11 + t20[3] * r17]), f2(a14, [t20[2] * r17 - t20[1] * o11, t20[2] * o11 + t20[1] * r17]), f2(a14, [t20[2] * r17 - t20[3] * o11, t20[2] * o11 + t20[3] * r17]), t20 = a14;
          }
          let c9 = b2(e21.offsetX), f6 = b2(e21.offsetY);
          if (o10) {
            const e22 = J2 * o10, t21 = Math.cos(e22), r17 = Math.sin(e22), a14 = c9 * r17 + f6 * t21;
            c9 = c9 * t21 - f6 * r17, f6 = a14;
          }
          t20[0] += c9, t20[1] += f6, t20[2] += c9, t20[3] += f6;
          const m10 = re(e21.markerPlacement);
          m10 > 0 && (t20[0] -= m10, t20[1] -= m10, t20[2] += m10, t20[3] += m10);
          break;
        }
      }
      const c8 = ae2(i18.effects);
      c8 > 0 && (t20[0] -= c8, t20[1] -= c8, t20[2] += c8, t20[3] += c8), s17 ? (e20[0] = t20[0], e20[1] = t20[1], e20[2] = t20[2], e20[3] = t20[3], s17 = false) : (e20[0] = Math.min(e20[0], t20[0]), e20[1] = Math.min(e20[1], t20[1]), e20[2] = Math.max(e20[2], t20[2]), e20[3] = Math.max(e20[3], t20[3]));
    }
    return e20;
  }
  _getTextInflatedSize(e20, r16, o10) {
    var _a, _b;
    const a13 = r16.height ?? W;
    if (e20[0] = -a13 / 2, e20[1] = -a13 / 2, e20[2] = a13 / 2, e20[3] = a13 / 2, !o10)
      return e20;
    const s17 = o10.get(r16);
    if (!s17)
      return e20;
    const { text: i18, mosaicItem: n23 } = s17;
    if (!((_a = n23 == null ? void 0 : n23.glyphMosaicItems) == null ? void 0 : _a.length))
      return e20;
    const { lineGapType: l12, lineGap: c8 } = r16, f6 = l12 ? nt(l12, c8 ?? 0, a13) : 0, m10 = i6(i18)[1], p5 = n23.glyphMosaicItems, M4 = "CIMBackgroundCallout" === ((_b = r16.callout) == null ? void 0 : _b.type), d4 = S3(p5, m10, { scale: a13 / b, angle: b2(r16.angle), xOffset: b2(r16.offsetX), yOffset: b2(r16.offsetY), hAlign: st(r16.horizontalAlignment), vAlign: ot(r16.verticalAlignment), maxLineWidth: 512, lineHeight: w * Math.max(0.25, Math.min(f6 || 1, 4)), decoration: r16.font.decoration || "none", isCIM: true, hasBackground: M4 }).boundsT;
    return e20[0] = d4.x - d4.halfWidth, e20[1] = -d4.y - d4.halfHeight, e20[2] = d4.x + d4.halfWidth, e20[3] = -d4.y + d4.halfHeight, e20;
  }
};
var ie2 = class _ie {
  static getEnvelope(e20, t19, r16) {
    if (!e20)
      return null;
    const o10 = new $(r16);
    if (Array.isArray(e20)) {
      let r17;
      for (const a13 of e20)
        r17 ? r17.union(te(o10, a13, t19)) : r17 = te(o10, a13, t19);
      return r17;
    }
    return te(o10, e20, t19);
  }
  static getTextureAnchor(e20, t19) {
    const r16 = this.getEnvelope(e20, null, t19);
    if (!r16)
      return [0, 0, 0];
    const o10 = (r16.x + 0.5 * r16.width) * K2, a13 = (r16.y + 0.5 * r16.height) * K2, s17 = r16.width * K2 + 2, i18 = r16.height * K2 + 2;
    return [-o10 / s17, -a13 / i18, i18];
  }
  static rasterize(e20, t19, r16, o10, a13 = true) {
    const s17 = r16 || this.getEnvelope(t19, null, o10);
    if (!s17)
      return [null, 0, 0, 0, 0];
    const i18 = (s17.x + 0.5 * s17.width) * K2, n23 = (s17.y + 0.5 * s17.height) * K2;
    e20.width = s17.width * K2, e20.height = s17.height * K2, r16 || (e20.width += 2, e20.height += 2);
    const l12 = e20.getContext("2d"), c8 = Q.createScale(K2, -K2);
    c8.translate(0.5 * e20.width - i18, 0.5 * e20.height + n23);
    const f6 = new et(l12, o10, c8);
    switch (t19.type) {
      case "CIMPointSymbol": {
        const e21 = { type: "point", x: 0, y: 0 };
        f6.drawSymbol(t19, e21);
        break;
      }
      case "CIMVectorMarker": {
        const e21 = new t10();
        f6.drawMarker(t19, e21);
        break;
      }
    }
    const y5 = l12.getImageData(0, 0, e20.width, e20.height), u12 = new Uint8Array(y5.data);
    if (a13) {
      let e21;
      for (let t20 = 0; t20 < u12.length; t20 += 4)
        e21 = u12[t20 + 3] / 255, u12[t20] = u12[t20] * e21, u12[t20 + 1] = u12[t20 + 1] * e21, u12[t20 + 2] = u12[t20 + 2] * e21;
    }
    return [u12, e20.width, e20.height, -i18 / e20.width, -n23 / e20.height];
  }
  static fromTextSymbol(e20) {
    const { angle: r16, color: o10, font: a13, haloColor: s17, haloSize: i18, horizontalAlignment: n23, kerning: l12, text: c8, verticalAlignment: f6, xoffset: m10, yoffset: y5, backgroundColor: u12, borderLineColor: h11, borderLineSize: p5 } = e20;
    let M4, d4, S4, b5, C4, g6;
    a13 && (M4 = a13.family, d4 = a13.style, S4 = a13.weight, b5 = a13.size, C4 = a13.decoration);
    let D3 = false;
    if (c8) {
      D3 = i6(c8)[1];
    }
    return (u12 || p5) && (g6 = { type: "CIMBackgroundCallout", margin: null, backgroundSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", color: ye(u12) }, { type: "CIMSolidStroke", color: ye(h11), width: p5 }] }, accentBarSymbol: null, gap: null, leaderLineSymbol: null, lineStyle: null }), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: { type: "CIMTextSymbol", angle: r16, blockProgression: C2.BTT, depth3D: 1, extrapolateBaselines: true, fontEffects: l2.Normal, fontEncoding: a4.Unicode, fontFamilyName: M4 || "Arial", fontStyleName: ue(d4, S4), fontType: u3.Unspecified, haloSize: i18, height: b5, hinting: y.Default, horizontalAlignment: fe(n23 ?? "center"), kerning: l12, letterWidth: 100, ligatures: true, lineGapType: "Multiple", offsetX: b2(m10), offsetY: b2(y5), strikethrough: "line-through" === C4, underline: "underline" === C4, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: ye(o10) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: ye(s17) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: D3 ? ne.RTL : ne.LTR, verticalAlignment: me(f6 ?? "baseline"), verticalGlyphOrientation: oe.Right, wordSpacing: 100, billboardMode3D: m2.FaceNearPlane, callout: g6 }, textString: c8 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e20) {
    const { height: t19, outline: r16, width: o10, xoffset: a13, xscale: s17, yoffset: i18, yscale: n23 } = e20, l12 = [], c8 = { type: "CIMPolygonSymbol", symbolLayers: l12 };
    if (r16) {
      const e21 = Ie(r16);
      e21 && l12.push(e21);
    }
    let f6 = e20.url;
    "esriPFS" === e20.type && e20.imageData && (f6 = e20.imageData);
    const m10 = "angle" in e20 ? e20.angle ?? 0 : 0, y5 = (o10 ?? 0) * (s17 || 1), u12 = (t19 ?? 0) * (n23 || 1);
    return l12.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: f6, height: u12, width: y5, offsetX: b2(a13), offsetY: b2(i18), rotation: b2(-m10), colorSubstitutions: null }), c8;
  }
  static fromSimpleFillSymbol(e20) {
    const { color: t19, style: o10, outline: a13 } = e20, s17 = [], n23 = { type: "CIMPolygonSymbol", symbolLayers: s17 };
    if (a13) {
      const e21 = Ie(a13);
      e21 && s17.push(e21);
    }
    if (o10 && "solid" !== o10 && "none" !== o10 && "esriSFSSolid" !== o10 && "esriSFSNull" !== o10) {
      const e21 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: ye(t19), capStyle: U2.Butt, joinStyle: w2.Miter, width: 0.75 }] };
      let a14 = 0;
      const n24 = e2(be(o10) ? 8 : 10);
      switch (o10) {
        case "vertical":
        case "esriSFSVertical":
          a14 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          a14 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          a14 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          a14 = 0;
      }
      s17.push({ type: "CIMHatchFill", lineSymbol: e21, offsetX: 0, offsetY: 0, rotation: a14, separation: n24 }), "cross" === o10 || "esriSFSCross" === o10 ? s17.push({ type: "CIMHatchFill", lineSymbol: a(e21), offsetX: 0, offsetY: 0, rotation: 90, separation: n24 }) : "diagonal-cross" !== o10 && "esriSFSDiagonalCross" !== o10 || s17.push({ type: "CIMHatchFill", lineSymbol: a(e21), offsetX: 0, offsetY: 0, rotation: 45, separation: n24 });
    } else
      !o10 || "solid" !== o10 && "esriSFSSolid" !== o10 || s17.push({ type: "CIMSolidFill", enable: true, color: ye(t19) });
    return n23;
  }
  static fromSimpleLineSymbol(e20) {
    const { cap: t19, color: r16, join: o10, marker: a13, miterLimit: s17, style: i18, width: n23 } = e20;
    let l12 = null;
    "solid" !== i18 && "none" !== i18 && "esriSLSSolid" !== i18 && "esriSLSNull" !== i18 && (l12 = [{ type: "CIMGeometricEffectDashes", dashTemplate: Me(i18, t19), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c8 = [];
    if (a13) {
      let e21;
      switch (a13.placement) {
        case "begin-end":
          e21 = o3.Both;
          break;
        case "begin":
          e21 = o3.JustBegin;
          break;
        case "end":
          e21 = o3.JustEnd;
          break;
        default:
          e21 = o3.None;
      }
      const t20 = _ie.fromSimpleMarker(a13, n23, r16).symbolLayers[0];
      t20.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: e21, offsetAlongLine: 0 }, c8.push(t20);
    }
    return c8.push({ type: "CIMSolidStroke", color: "none" !== i18 && "esriSLSNull" !== i18 ? ye(r16) : [0, 0, 0, 0], capStyle: le(t19), joinStyle: ce(o10), miterLimit: s17, width: n23, effects: l12 }), { type: "CIMLineSymbol", symbolLayers: c8 };
  }
  static fromPictureMarker(e20) {
    const { angle: t19, height: r16, width: o10, xoffset: a13, yoffset: s17 } = e20;
    let i18 = e20.url;
    return "esriPMS" === e20.type && e20.imageData && (i18 = e20.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: ie.Picture, tintColor: null, url: i18, size: r16, width: o10, offsetX: b2(a13), offsetY: b2(s17), rotation: b2(-t19) }] };
  }
  static fromSimpleMarker(e20, t19, r16) {
    const { style: o10 } = e20, a13 = e20.color ?? r16;
    if ("path" === o10) {
      const t20 = [];
      if ("outline" in e20 && e20.outline) {
        const r18 = e20.outline;
        t20.push({ type: "CIMSolidStroke", enable: true, width: u2(Math.round(e2(r18.width))), color: ye(r18.color) });
      }
      t20.push({ type: "CIMSolidFill", enable: true, color: ye(a13), path: e20.path });
      const [r17, o11] = Se("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: b2(-e20.angle), size: b2(e20.size || 6), offsetX: b2(e20.xoffset), offsetY: b2(e20.yoffset), frame: r17, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: o11, symbol: { type: "CIMPolygonSymbol", symbolLayers: t20 } }] }] };
    }
    const [n23, l12] = Se(o10);
    let c8;
    if (l12 && n23) {
      const r17 = [];
      if ("outline" in e20 && e20.outline) {
        const t20 = e20.outline;
        r17.push({ type: "CIMSolidStroke", enable: true, width: null != t20.width && t20.width > 0.667 ? u2(Math.round(e2(t20.width))) : t20.width, color: ye(t20.color) });
      } else
        !t19 || "line-marker" !== e20.type || "cross" !== e20.style && "x" !== e20.style || r17.push({ type: "CIMSolidStroke", enable: true, width: t19, color: ye(a13) });
      r17.push({ type: "CIMSolidFill", enable: true, color: ye(a13) });
      const o11 = { type: "CIMPolygonSymbol", symbolLayers: r17 };
      c8 = { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: b2(-e20.angle), size: b2(e20.size || 6 * t19), offsetX: b2(e20.xoffset), offsetY: b2(e20.yoffset), frame: n23, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: l12, symbol: o11 }] }] };
    }
    return c8;
  }
  static fromCIMHatchFill(e20, t19) {
    var _a;
    const o10 = t19 * (e20.separation ?? Y2), a13 = o10 / 2, s17 = a(e20.lineSymbol);
    (_a = s17.symbolLayers) == null ? void 0 : _a.forEach((e21) => {
      var _a2;
      switch (e21.type) {
        case "CIMSolidStroke":
          null != e21.width && (e21.width *= t19), (_a2 = e21.effects) == null ? void 0 : _a2.forEach((e22) => {
            "CIMGeometricEffectDashes" === e22.type && (e22.dashTemplate = e22.dashTemplate.map((e23) => e23 * t19));
          });
          break;
        case "CIMVectorMarker": {
          null != e21.size && (e21.size *= t19);
          const r16 = e21.markerPlacement;
          null != r16 && "placementTemplate" in r16 && (r16.placementTemplate = r16.placementTemplate.map((e22) => e22 * t19));
          break;
        }
      }
    });
    let i18 = this._getLineSymbolPeriod(s17) || Q2;
    for (; i18 < Q2; )
      i18 *= 2;
    const n23 = i18 / 2;
    return { type: "CIMVectorMarker", frame: { xmin: -n23, xmax: n23, ymin: -a13, ymax: a13 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-n23, 0], [n23, 0]]] }, symbol: s17 }], size: o10 };
  }
  static fetchResources(e20, t19, r16) {
    if (e20 && t19)
      switch (e20.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          const o10 = e20.symbolLayers;
          if (!o10)
            return;
          for (const e21 of o10)
            switch (ge(e21, t19, r16), e21.type) {
              case "CIMPictureFill":
              case "CIMHatchFill":
              case "CIMGradientFill":
              case "CIMPictureStroke":
              case "CIMGradientStroke":
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
                "url" in e21 && e21.url && r16.push(t19.fetchResource(e21.url, null));
                break;
              case "CIMVectorMarker": {
                const o11 = e21.markerGraphics;
                if (!o11)
                  continue;
                for (const e22 of o11)
                  if (e22) {
                    const o12 = e22.symbol;
                    o12 && _ie.fetchResources(o12, t19, r16);
                  }
              }
            }
          break;
        }
      }
  }
  static fetchFonts(e20, t19, r16) {
    if (e20 && t19) {
      if ("symbolLayers" in e20 && e20.symbolLayers) {
        for (const o10 of e20.symbolLayers)
          if ("CIMVectorMarker" === o10.type && o10.markerGraphics)
            for (const e21 of o10.markerGraphics)
              (e21 == null ? void 0 : e21.symbol) && _ie.fetchFonts(e21.symbol, t19, r16);
      } else if ("CIMTextSymbol" === e20.type) {
        const { fontFamilyName: o10, fontStyleName: a13 } = e20;
        if (!o10 || "calcitewebcoreicons" === o10.toLowerCase())
          return;
        const { style: s17, weight: i18 } = S(a13), n23 = k3(e20), l12 = new m3({ family: o10, style: s17, weight: i18, decoration: n23 });
        r16.push(t19.loadFont(l12).catch(() => {
          Z3.error(`Unsupported font ${o10} in CIM symbol`);
        }));
      }
    }
  }
  static _getLineSymbolPeriod(e20) {
    if (e20) {
      const t19 = this._getEffectsRepeat(e20.effects);
      if (t19)
        return t19;
      if (e20.symbolLayers) {
        for (const r16 of e20.symbolLayers)
          if (r16) {
            const e21 = this._getEffectsRepeat(r16.effects);
            if (e21)
              return e21;
            switch (r16.type) {
              case "CIMCharacterMarker":
              case "CIMPictureMarker":
              case "CIMVectorMarker":
              case "CIMObjectMarker3D":
              case "CIMglTFMarker3D": {
                const e22 = this._getPlacementRepeat(r16.markerPlacement);
                if (e22)
                  return e22;
              }
            }
          }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e20) {
    if (e20) {
      for (const t19 of e20)
        if (t19)
          switch (t19.type) {
            case "CIMGeometricEffectDashes": {
              const e21 = t19.dashTemplate;
              if (e21 && e21.length) {
                let t20 = 0;
                for (const r16 of e21)
                  t20 += r16;
                return 1 & e21.length && (t20 *= 2), t20;
              }
              break;
            }
            case "CIMGeometricEffectWave":
              return t19.period;
            default:
              Z3.error(`unsupported geometric effect type ${t19.type}`);
          }
    }
    return 0;
  }
  static _getPlacementRepeat(e20) {
    if (e20)
      switch (e20.type) {
        case "CIMMarkerPlacementAlongLineSameSize":
        case "CIMMarkerPlacementAlongLineRandomSize":
        case "CIMMarkerPlacementAlongLineVariableSize": {
          const t19 = e20.placementTemplate;
          if (t19 && t19.length) {
            let e21 = 0;
            for (const r16 of t19)
              e21 += +r16;
            return 1 & t19.length && (e21 *= 2), e21;
          }
          break;
        }
      }
    return 0;
  }
  static fromCIMInsidePolygon(e20) {
    const t19 = e20.markerPlacement, r16 = { ...e20 };
    r16.markerPlacement = null, r16.anchorPoint = null;
    const o10 = Math.abs(t19.stepX), s17 = Math.abs(t19.stepY), n23 = (t19.randomness ?? 100) / 100;
    let l12, c8, f6, m10;
    if ("Random" === t19.gridType) {
      const e21 = e2(se), r17 = Math.max(Math.floor(e21 / o10), 1), y5 = Math.max(Math.floor(e21 / s17), 1);
      l12 = r17 * o10 / 2, c8 = y5 * s17 / 2, f6 = 2 * c8;
      const u12 = new t(t19.seed), h11 = n23 * o10 / 1.5, p5 = n23 * s17 / 1.5;
      m10 = [];
      for (let t20 = 0; t20 < r17; t20++)
        for (let e22 = 0; e22 < y5; e22++) {
          const r18 = t20 * o10 - l12 + h11 * (0.5 - u12.getFloat()), a13 = e22 * s17 - c8 + p5 * (0.5 - u12.getFloat());
          m10.push({ x: r18, y: a13 }), 0 === t20 && m10.push({ x: r18 + 2 * l12, y: a13 }), 0 === e22 && m10.push({ x: r18, y: a13 + 2 * c8 });
        }
    } else
      true === t19.shiftOddRows ? (l12 = o10 / 2, c8 = s17, f6 = 2 * s17, m10 = [{ x: -l12, y: 0 }, { x: l12, y: 0 }, { x: 0, y: c8 }, { x: 0, y: -c8 }]) : (l12 = o10 / 2, c8 = s17 / 2, f6 = s17, m10 = [{ x: -o10, y: 0 }, { x: 0, y: -s17 }, { x: -o10, y: -s17 }, { x: 0, y: 0 }, { x: o10, y: 0 }, { x: 0, y: s17 }, { x: o10, y: s17 }, { x: -o10, y: s17 }, { x: o10, y: -s17 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -l12, xmax: l12, ymin: -c8, ymax: c8 }, markerGraphics: m10.map((e21) => ({ type: "CIMMarkerGraphic", geometry: e21, symbol: { type: "CIMPointSymbol", symbolLayers: [r16] } })), size: f6 };
  }
  static getSize(e20) {
    if (e20)
      switch (e20.type) {
        case "CIMTextSymbol":
          return e20.height;
        case "CIMPointSymbol": {
          let t19 = 0;
          if (e20.symbolLayers) {
            for (const r16 of e20.symbolLayers)
              if (r16)
                switch (r16.type) {
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D": {
                    const e21 = r16.size;
                    null != e21 && e21 > t19 && (t19 = e21);
                    break;
                  }
                }
          }
          return t19;
        }
        case "CIMLineSymbol":
        case "CIMPolygonSymbol": {
          let t19 = 0;
          if (e20.symbolLayers) {
            for (const r16 of e20.symbolLayers)
              if (r16)
                switch (r16.type) {
                  case "CIMSolidStroke":
                  case "CIMPictureStroke":
                  case "CIMGradientStroke": {
                    const e21 = r16.width;
                    null != e21 && e21 > t19 && (t19 = e21);
                    break;
                  }
                  case "CIMCharacterMarker":
                  case "CIMPictureMarker":
                  case "CIMVectorMarker":
                  case "CIMObjectMarker3D":
                  case "CIMglTFMarker3D":
                    if (r16.markerPlacement && m4(r16.markerPlacement)) {
                      const e21 = r16.size;
                      null != e21 && e21 > t19 && (t19 = e21);
                    }
                }
          }
          return t19;
        }
      }
  }
  static getMarkerScaleRatio(e20) {
    if (e20 && "CIMVectorMarker" === e20.type) {
      if (false !== e20.scaleSymbolsProportionally && e20.frame && null != e20.size) {
        const t19 = e20.frame.ymax - e20.frame.ymin;
        return e20.size / t19;
      }
    }
    return 1;
  }
};
var ne2 = class _ne {
  static findApplicableOverrides(e20, t19, r16) {
    if (e20 && t19) {
      if (e20.primitiveName) {
        let o10 = false;
        for (const t20 of r16)
          if (t20.primitiveName === e20.primitiveName) {
            o10 = true;
            break;
          }
        if (!o10)
          for (const a13 of t19)
            a13.primitiveName === e20.primitiveName && r16.push(a13);
      }
      switch (e20.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          if (e20.effects)
            for (const o10 of e20.effects)
              _ne.findApplicableOverrides(o10, t19, r16);
          if (e20.symbolLayers)
            for (const o10 of e20.symbolLayers)
              _ne.findApplicableOverrides(o10, t19, r16);
          break;
        case "CIMTextSymbol":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke":
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
        case "CIMVectorMarker":
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
          if (e20.effects)
            for (const o10 of e20.effects)
              _ne.findApplicableOverrides(o10, t19, r16);
          if (e20.markerPlacement && _ne.findApplicableOverrides(e20.markerPlacement, t19, r16), "CIMVectorMarker" === e20.type) {
            if (e20.markerGraphics)
              for (const o10 of e20.markerGraphics)
                _ne.findApplicableOverrides(o10, t19, r16), _ne.findApplicableOverrides(o10.symbol, t19, r16);
          } else
            "CIMCharacterMarker" === e20.type ? _ne.findApplicableOverrides(e20.symbol, t19, r16) : "CIMHatchFill" === e20.type ? _ne.findApplicableOverrides(e20.lineSymbol, t19, r16) : "CIMPictureMarker" === e20.type && _ne.findApplicableOverrides(e20.animatedSymbolProperties, t19, r16);
      }
    }
  }
  static findEffectOverrides(e20, t19, r16) {
    if (!t19 || !e20)
      return;
    const o10 = e20.length;
    for (let a13 = 0; a13 < o10; a13++) {
      const o11 = e20[a13], s17 = o11 == null ? void 0 : o11.primitiveName;
      if (s17) {
        let e21 = false;
        for (const t20 of r16)
          if (t20.primitiveName === s17) {
            e21 = true;
            break;
          }
        if (!e21)
          for (const o12 of t19)
            o12.primitiveName === s17 && r16.push(o12);
      }
    }
  }
  static async resolveSymbolOverrides(e20, t19, o10, a13, s17, i18, n23) {
    if (!e20 || !e20.symbol)
      return null;
    let { symbol: l12, primitiveOverrides: c8 } = e20;
    const f6 = !!c8;
    if (!f6 && !a13)
      return l12;
    l12 = a(l12);
    let m10 = true;
    if (t19 || (t19 = { attributes: {} }, m10 = false), f6) {
      if (m10 || (c8 = c8.filter((e21) => {
        var _a;
        return !((_a = e21.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$feature"));
      })), n23 || (c8 = c8.filter((e21) => {
        var _a;
        return !((_a = e21.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$view"));
      })), c8.length > 0) {
        const e21 = A2(t19.attributes);
        await _ne.evaluateOverrides(c8, t19, { spatialReference: o10, fields: e21, geometryType: s17 }, i18, n23);
      }
      _ne.applyOverrides(l12, c8);
    }
    return a13 && _ne.applyDictionaryTextOverrides(l12, t19, a13), l12;
  }
  static async evaluateOverrides(e20, t19, r16, o10, a13) {
    if (!t19)
      return;
    let s17;
    for (const i18 of e20) {
      const e21 = i18.valueExpressionInfo;
      if (e21 && r16 && r16.geometryType) {
        s17 || (s17 = []), i18.value = void 0;
        const n23 = n6(e21.expression, r16.spatialReference, r16.fields).then((e22) => {
          i18.value = s15(e22, t19, { $view: a13 }, r16.geometryType, o10);
        });
        s17.push(n23);
      }
    }
    void 0 !== s17 && s17.length > 0 && await Promise.all(s17);
  }
  static applyDictionaryTextOverrides(e20, t19, r16, o10 = "Normal") {
    if (e20 && e20.type)
      switch (e20.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
        case "CIMTextSymbol":
          {
            const a13 = e20.symbolLayers;
            if (!a13)
              return;
            for (const s17 of a13)
              s17 && "CIMVectorMarker" === s17.type && _ne.applyDictionaryTextOverrides(s17, t19, r16, "CIMTextSymbol" === e20.type ? e20.textCase : o10);
          }
          break;
        case "CIMVectorMarker":
          {
            const o11 = e20.markerGraphics;
            if (!o11)
              return;
            for (const e21 of o11)
              e21 && _ne.applyDictionaryTextOverrides(e21, t19, r16);
          }
          break;
        case "CIMMarkerGraphic": {
          const a13 = e20.textString;
          if (a13 && a13.includes("[")) {
            const s17 = i5(a13, r16);
            e20.textString = l3(t19, s17, o10);
          }
        }
      }
  }
  static applyOverrides(e20, t19, r16, o10) {
    if (e20.primitiveName) {
      for (const a13 of t19)
        if (a13.primitiveName === e20.primitiveName) {
          const t20 = Ce(a13.propertyName);
          if (o10 && o10.push({ cim: e20, nocapPropertyName: t20, value: e20[t20] }), a13.expression && (a13.value = _ne.toValue(a13.propertyName, a13.expression)), r16) {
            let t21 = false;
            for (const o11 of r16)
              o11.primitiveName === e20.primitiveName && (t21 = true);
            t21 || r16.push(a13);
          }
          null != a13.value && (e20[t20] = a13.value);
        }
    }
    switch (e20.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e20.effects)
          for (const a13 of e20.effects)
            _ne.applyOverrides(a13, t19, r16, o10);
        if (e20.symbolLayers)
          for (const a13 of e20.symbolLayers)
            _ne.applyOverrides(a13, t19, r16, o10);
        break;
      case "CIMTextSymbol":
        break;
      case "CIMSolidStroke":
      case "CIMSolidFill":
      case "CIMVectorMarker":
        if (e20.effects)
          for (const a13 of e20.effects)
            _ne.applyOverrides(a13, t19, r16, o10);
        if ("CIMVectorMarker" === e20.type && e20.markerGraphics)
          for (const a13 of e20.markerGraphics)
            _ne.applyOverrides(a13, t19, r16, o10), _ne.applyOverrides(a13.symbol, t19, r16, o10);
    }
  }
  static restoreOverrides(e20) {
    for (const t19 of e20)
      t19.cim[t19.nocapPropertyName] = t19.value;
  }
  static buildOverrideKey(e20) {
    let t19 = "";
    for (const r16 of e20)
      void 0 !== r16.value && (t19 += `${r16.primitiveName}${r16.propertyName}${JSON.stringify(r16.value)}`);
    return t19;
  }
  static toValue(t19, r16) {
    if ("DashTemplate" === t19)
      return r16.split(" ").map((e20) => Number(e20));
    if ("Color" === t19) {
      const t20 = new h2(r16).toRgba();
      return t20[3] *= 255, t20;
    }
    return r16;
  }
};
var le = (e20) => {
  if (!e20)
    return U2.Butt;
  switch (e20) {
    case "butt":
      return U2.Butt;
    case "square":
      return U2.Square;
    case "round":
      return U2.Round;
  }
};
var ce = (e20) => {
  if (!e20)
    return w2.Miter;
  switch (e20) {
    case "miter":
      return w2.Miter;
    case "round":
      return w2.Round;
    case "bevel":
      return w2.Bevel;
  }
};
var fe = (e20) => {
  if (null == e20)
    return "Center";
  switch (e20) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var me = (e20) => {
  if (null == e20)
    return "Center";
  switch (e20) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var ye = (e20) => {
  if (!e20)
    return [0, 0, 0, 0];
  const { r: t19, g: r16, b: o10, a: a13 } = e20;
  return [t19, r16, o10, 255 * a13];
};
var ue = (e20, t19) => {
  const r16 = he(t19), o10 = pe(e20);
  return r16 && o10 ? `${r16}-${o10}` : `${r16}${o10}`;
};
var he = (e20) => {
  if (!e20)
    return "";
  switch (e20.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var pe = (e20) => {
  if (!e20)
    return "";
  switch (e20.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var Me = (e20, t19) => {
  const r16 = "butt" === t19;
  switch (e20) {
    case "dash":
    case "esriSLSDash":
      return r16 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return r16 ? [4, 3, 1, 3] : [3, 4, 0, 4];
    case "dot":
    case "esriSLSDot":
      return r16 ? [1, 3] : [0, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return r16 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return r16 ? [8, 3, 1, 3] : [7, 4, 0, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return r16 ? [8, 3, 1, 3, 1, 3] : [7, 4, 0, 4, 0, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return r16 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return r16 ? [4, 1, 1, 1] : [3, 2, 0, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return r16 ? [4, 1, 1, 1, 1, 1] : [3, 2, 0, 2, 0, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return r16 ? [1, 1] : [0, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return Z3.error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return Z3.error(`Tried to rasterize SLS, but found an unexpected style: ${e20}!`), [0, 0];
  }
};
function de(e20) {
  return void 0 !== e20.symbolLayers;
}
var Se = (e20) => {
  const t19 = 100, r16 = 50;
  let o10, a13;
  const s17 = e20;
  if ("circle" === s17 || "esriSMSCircle" === s17) {
    const e21 = 0.25;
    let t20 = Math.acos(1 - e21 / r16), s18 = Math.ceil(q4 / t20 / 4);
    0 === s18 && (s18 = 1), t20 = W2 / s18, s18 *= 4;
    const i18 = [];
    i18.push([r16, 0]);
    for (let o11 = 1; o11 < s18; o11++)
      i18.push([r16 * Math.cos(o11 * t20), -r16 * Math.sin(o11 * t20)]);
    i18.push([r16, 0]), o10 = { rings: [i18] }, a13 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  } else if ("cross" === s17 || "esriSMSCross" === s17) {
    const e21 = 0;
    o10 = { rings: [[[e21, r16], [e21, e21], [r16, e21], [r16, -e21], [e21, -e21], [e21, -r16], [-e21, -r16], [-e21, -e21], [-r16, -e21], [-r16, e21], [-e21, e21], [-e21, r16], [e21, r16]]] }, a13 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  } else if ("diamond" === s17 || "esriSMSDiamond" === s17)
    o10 = { rings: [[[-r16, 0], [0, r16], [r16, 0], [0, -r16], [-r16, 0]]] }, a13 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  else if ("square" === s17 || "esriSMSSquare" === s17)
    o10 = { rings: [[[-r16, -r16], [-r16, r16], [r16, r16], [r16, -r16], [-r16, -r16]]] }, a13 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  else if ("x" === s17 || "esriSMSX" === s17) {
    const e21 = 0;
    o10 = { rings: [[[0, e21], [r16 - e21, r16], [r16, r16 - e21], [e21, 0], [r16, e21 - r16], [r16 - e21, -r16], [0, -e21], [e21 - r16, -r16], [-r16, e21 - r16], [-e21, 0], [-r16, r16 - e21], [e21 - r16, r16], [0, e21]]] }, a13 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 };
  } else if ("triangle" === s17 || "esriSMSTriangle" === s17) {
    const e21 = t19 * 0.5773502691896257, r17 = -e21, s18 = 2 / 3 * t19, i18 = s18 - t19;
    o10 = { rings: [[[r17, i18], [0, s18], [e21, i18], [r17, i18]]] }, a13 = { xmin: r17, ymin: i18, xmax: e21, ymax: s18 };
  } else
    "arrow" === s17 && (o10 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, a13 = { xmin: -r16, ymin: -r16, xmax: r16, ymax: r16 });
  return [a13, o10];
};
var be = (e20) => "vertical" === e20 || "horizontal" === e20 || "cross" === e20 || "esriSFSCross" === e20 || "esriSFSVertical" === e20 || "esriSFSHorizontal" === e20;
var Ce = (e20) => e20 ? e20.charAt(0).toLowerCase() + e20.substr(1) : e20;
function ge(e20, t19, r16) {
  if (!e20.effects || null != t19.geometryEngine)
    return;
  if (t19.geometryEnginePromise)
    return void r16.push(t19.geometryEnginePromise);
  d(e20.effects) && (t19.geometryEnginePromise = I(), r16.push(t19.geometryEnginePromise), t19.geometryEnginePromise.then((e21) => t19.geometryEngine = e21));
}
function Ie(e20) {
  if (!e20)
    return null;
  let t19 = null;
  const { cap: r16, color: o10, join: a13, miterLimit: s17, style: i18, width: n23 } = e20;
  return "solid" !== i18 && "none" !== i18 && "esriSLSSolid" !== i18 && "esriSLSNull" !== i18 && (t19 = [{ type: "CIMGeometricEffectDashes", dashTemplate: Me(i18, r16), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), { type: "CIMSolidStroke", color: "esriSLSNull" !== i18 && "none" !== i18 ? ye(o10) : [0, 0, 0, 0], capStyle: le(r16), joinStyle: ce(a13), miterLimit: s17, width: n23, effects: t19 };
}

// node_modules/@arcgis/core/symbols/cim/quantizeTime.js
var t18 = 0.05;
function n20(n23) {
  return Math.max(Math.round(n23 / t18), 1) * t18;
}
var e17 = /* @__PURE__ */ new Set(["StartTimeOffset", "Duration", "RepeatDelay"]);
function a11(t19, a13) {
  return e17.has(a13) ? n20(t19) : t19;
}

// node_modules/@arcgis/core/symbols/cim/SDFHelper.js
function l10(t19) {
  var _a;
  if (!t19)
    return null;
  switch (t19.type) {
    case "CIMPointSymbol": {
      const o10 = t19.symbolLayers;
      return o10 && 1 === o10.length ? l10(o10[0]) : null;
    }
    case "CIMVectorMarker": {
      const o10 = t19.markerGraphics;
      if (!o10 || 1 !== o10.length)
        return null;
      const n23 = o10[0];
      if (!n23)
        return null;
      const r16 = n23.geometry;
      if (!r16)
        return null;
      const l12 = n23.symbol;
      return !l12 || "CIMPolygonSymbol" !== l12.type && "CIMLineSymbol" !== l12.type || ((_a = l12.symbolLayers) == null ? void 0 : _a.some((t20) => !!t20.effects)) ? null : { geom: r16, asFill: "CIMPolygonSymbol" === l12.type };
    }
    case "sdf":
      return { geom: t19.geom, asFill: t19.asFill };
  }
  return null;
}
function e18(t19) {
  return t19 ? t19.rings ? t19.rings : t19.paths ? t19.paths : void 0 !== t19.xmin && void 0 !== t19.ymin && void 0 !== t19.xmax && void 0 !== t19.ymax ? [[[t19.xmin, t19.ymin], [t19.xmin, t19.ymax], [t19.xmax, t19.ymax], [t19.xmax, t19.ymin], [t19.xmin, t19.ymin]]] : null : null;
}
function i17(t19) {
  let o10 = 1 / 0, r16 = -1 / 0, l12 = 1 / 0, e20 = -1 / 0;
  for (const n23 of t19)
    for (const t20 of n23)
      t20[0] < o10 && (o10 = t20[0]), t20[0] > r16 && (r16 = t20[0]), t20[1] < l12 && (l12 = t20[1]), t20[1] > e20 && (e20 = t20[1]);
  return new t17(o10, l12, r16 - o10, e20 - l12);
}
function s16(t19) {
  let o10 = 1 / 0, n23 = -1 / 0, r16 = 1 / 0, l12 = -1 / 0;
  for (const e20 of t19)
    for (const t20 of e20)
      t20[0] < o10 && (o10 = t20[0]), t20[0] > n23 && (n23 = t20[0]), t20[1] < r16 && (r16 = t20[1]), t20[1] > l12 && (l12 = t20[1]);
  return [o10, r16, n23, l12];
}
function f5(t19) {
  return t19 ? t19.rings ? s16(t19.rings) : t19.paths ? s16(t19.paths) : m(t19) ? [t19.xmin, t19.ymin, t19.xmax, t19.ymax] : null : null;
}
function m9(t19, o10, n23, l12, e20) {
  const [i18, s17, f6, m10] = t19;
  if (f6 < i18 || m10 < s17)
    return [0, 0, 0];
  const a13 = f6 - i18, u12 = m10 - s17, c8 = 128, h11 = ae, y5 = Math.floor(0.5 * (0.5 * c8 - h11)), x4 = (c8 - 2 * (y5 + h11)) / Math.max(a13, u12), M4 = Math.round(a13 * x4) + 2 * y5, g6 = Math.round(u12 * x4) + 2 * y5;
  let p5 = 1;
  if (o10) {
    p5 = g6 / x4 / (o10.ymax - o10.ymin);
  }
  let d4 = 0, b5 = 0, w7 = 1;
  l12 && (e20 ? o10 && n23 && o10.ymax - o10.ymin > 0 && (w7 = (o10.xmax - o10.xmin) / (o10.ymax - o10.ymin), d4 = l12.x / (n23 * w7), b5 = l12.y / n23) : (d4 = l12.x, b5 = l12.y)), o10 && (d4 = 0.5 * (o10.xmax + o10.xmin) + d4 * (o10.xmax - o10.xmin), b5 = 0.5 * (o10.ymax + o10.ymin) + b5 * (o10.ymax - o10.ymin)), d4 -= i18, b5 -= s17, d4 *= x4, b5 *= x4, d4 += y5, b5 += y5;
  let F2 = d4 / M4 - 0.5, j4 = b5 / g6 - 0.5;
  return e20 && n23 && (F2 *= n23 * w7, j4 *= n23), [p5, F2, j4];
}
function a12(t19) {
  const o10 = e18(t19.geom), n23 = i17(o10), l12 = 128, s17 = ae, f6 = Math.floor(0.5 * (0.5 * l12 - s17)), m10 = (l12 - 2 * (f6 + s17)) / Math.max(n23.width, n23.height), a13 = Math.round(n23.width * m10) + 2 * f6, y5 = Math.round(n23.height * m10) + 2 * f6, x4 = [];
  for (const r16 of o10)
    if (r16 && r16.length > 1) {
      const o11 = [];
      for (const l13 of r16) {
        let [r17, e20] = l13;
        r17 -= n23.x, e20 -= n23.y, r17 *= m10, e20 *= m10, r17 += f6 - 0.5, e20 += f6 - 0.5, t19.asFill ? o11.push([r17, e20]) : o11.push([Math.round(r17), Math.round(e20)]);
      }
      if (t19.asFill) {
        const t20 = o11.length - 1;
        o11[0][0] === o11[t20][0] && o11[0][1] === o11[t20][1] || o11.push(o11[0]);
      }
      x4.push(o11);
    }
  const M4 = u11(x4, a13, y5, f6);
  return t19.asFill && c7(x4, a13, y5, f6, M4), [h10(M4, f6), a13, y5];
}
function u11(t19, o10, n23, r16) {
  const l12 = o10 * n23, e20 = new Array(l12), i18 = r16 * r16 + 1;
  for (let s17 = 0; s17 < l12; ++s17)
    e20[s17] = i18;
  for (const s17 of t19) {
    const t20 = s17.length;
    for (let l13 = 1; l13 < t20; ++l13) {
      const t21 = s17[l13 - 1], i19 = s17[l13];
      let f6, m10, a13, u12;
      t21[0] < i19[0] ? (f6 = t21[0], m10 = i19[0]) : (f6 = i19[0], m10 = t21[0]), t21[1] < i19[1] ? (a13 = t21[1], u12 = i19[1]) : (a13 = i19[1], u12 = t21[1]);
      let c8 = Math.floor(f6) - r16, h11 = Math.floor(m10) + r16, y5 = Math.floor(a13) - r16, x4 = Math.floor(u12) + r16;
      c8 < 0 && (c8 = 0), h11 > o10 && (h11 = o10), y5 < 0 && (y5 = 0), x4 > n23 && (x4 = n23);
      const M4 = i19[0] - t21[0], g6 = i19[1] - t21[1], p5 = M4 * M4 + g6 * g6;
      for (let r17 = c8; r17 < h11; r17++)
        for (let l14 = y5; l14 < x4; l14++) {
          let s18, f7, m11 = (r17 - t21[0]) * M4 + (l14 - t21[1]) * g6;
          m11 < 0 ? (s18 = t21[0], f7 = t21[1]) : m11 > p5 ? (s18 = i19[0], f7 = i19[1]) : (m11 /= p5, s18 = t21[0] + m11 * M4, f7 = t21[1] + m11 * g6);
          const a14 = (r17 - s18) * (r17 - s18) + (l14 - f7) * (l14 - f7), u13 = (n23 - l14 - 1) * o10 + r17;
          a14 < e20[u13] && (e20[u13] = a14);
        }
    }
  }
  for (let s17 = 0; s17 < l12; ++s17)
    e20[s17] = Math.sqrt(e20[s17]);
  return e20;
}
function c7(t19, o10, n23, r16, l12) {
  for (const e20 of t19) {
    const t20 = e20.length;
    for (let i18 = 1; i18 < t20; ++i18) {
      const t21 = e20[i18 - 1], s17 = e20[i18];
      let f6, m10, a13, u12;
      t21[0] < s17[0] ? (f6 = t21[0], m10 = s17[0]) : (f6 = s17[0], m10 = t21[0]), t21[1] < s17[1] ? (a13 = t21[1], u12 = s17[1]) : (a13 = s17[1], u12 = t21[1]);
      let c8 = Math.floor(f6), h11 = Math.floor(m10) + 1, y5 = Math.floor(a13), x4 = Math.floor(u12) + 1;
      c8 < r16 && (c8 = r16), h11 > o10 - r16 && (h11 = o10 - r16), y5 < r16 && (y5 = r16), x4 > n23 - r16 && (x4 = n23 - r16);
      for (let e21 = y5; e21 < x4; ++e21) {
        if (t21[1] > e21 == s17[1] > e21)
          continue;
        const i19 = (n23 - e21 - 1) * o10;
        for (let o11 = c8; o11 < h11; ++o11)
          o11 < (s17[0] - t21[0]) * (e21 - t21[1]) / (s17[1] - t21[1]) + t21[0] && (l12[i19 + o11] = -l12[i19 + o11]);
        for (let t22 = r16; t22 < c8; ++t22)
          l12[i19 + t22] = -l12[i19 + t22];
      }
    }
  }
}
function h10(o10, n23) {
  const r16 = 2 * n23, l12 = o10.length, e20 = new Uint8Array(4 * l12);
  for (let i18 = 0; i18 < l12; ++i18) {
    const n24 = 0.5 - o10[i18] / r16;
    o5(n24, e20, 4 * i18);
  }
  return e20;
}

// node_modules/@arcgis/core/symbols/cim/effects/CIMEffectHelper.js
var n21 = 96 / 72;
var l11 = class {
  static executeEffects(t19, e20, l12, c8) {
    const f6 = n21, m10 = ae2(t19);
    let p5 = new s8(e20);
    for (const o10 of t19) {
      const t20 = A3(o10);
      t20 && (p5 = t20.execute(p5, o10, f6, l12, c8, m10));
    }
    return p5;
  }
  static applyEffects(n23, l12, c8) {
    if (!n23)
      return l12;
    const f6 = ae2(n23);
    let m10, p5 = new s8(a6.fromJSONCIM(l12));
    for (const t19 of n23) {
      const e20 = A3(t19);
      e20 && (p5 = e20.execute(p5, t19, 1, null, c8, f6));
    }
    const u12 = [];
    let i18 = null;
    for (; m10 = p5.next(); )
      u12.push(...t2(m10)), i18 = m10.geometryType;
    return 0 === u12.length || null === i18 ? null : "esriGeometryPolygon" === i18 ? { rings: u12 } : { paths: u12 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/grouping.js
function e19(e20, o10) {
  let r16;
  if ("string" == typeof e20)
    r16 = c(e20 + `-seed(${o10})`);
  else {
    let t19 = 12;
    r16 = e20 ^ o10;
    do {
      r16 = 107 * (r16 >> 8 ^ r16) + t19 | 0;
    } while (0 != --t19);
  }
  return (1 + r16 / (1 << 31)) / 2;
}
function o9(t19) {
  return Math.floor(e19(t19, r15) * n22);
}
var r15 = 53290320;
var n22 = 10;

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var E = s.getLogger("esri.symbols.cim.cimAnalyzer");
function T3(e20) {
  switch (e20) {
    case "Butt":
      return e3.BUTT;
    case "Square":
      return e3.SQUARE;
    default:
      return e3.ROUND;
  }
}
function $2(e20) {
  switch (e20) {
    case "Bevel":
      return n2.BEVEL;
    case "Miter":
      return n2.MITER;
    default:
      return n2.ROUND;
  }
}
function j3(e20) {
  const t19 = e20.markerPlacement;
  return t19 && t19.angleToLine ? i3.MAP : i3.SCREEN;
}
var G3 = class {
  constructor(e20, t19) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], this._resourceManager = e20, this._info = t19;
  }
  async analyzeSymbolReference(e20, t19, i18) {
    if (this._cimLayers = i18 ?? [], !e20)
      return this._cimLayers;
    if (e20.primitiveOverrides) {
      this._primitiveOverrides = e20.primitiveOverrides, this._poMap = {};
      const t20 = [], i19 = this._info;
      for (const e21 of this._primitiveOverrides) {
        const r17 = e21.valueExpressionInfo;
        if (r17 && i19) {
          const o11 = r17.expression, n23 = n6(o11, i19.spatialReference, i19.fields).then((t21) => {
            null != t21 && this._setPoMap(e21.primitiveName, e21.propertyName, t21);
          });
          t20.push(n23);
        } else
          null != e21.value && this._setPoMap(e21.primitiveName, e21.propertyName, e21.value);
        t20.length > 0 && await Promise.all(t20);
      }
    }
    const r16 = e20.symbol, o10 = [];
    return ie2.fetchResources(r16, this._resourceManager, o10), o10.length > 0 && await Promise.all(o10), this._analyzeSymbol(r16, t19), this._cimLayers;
  }
  _analyzeSymbol(e20, t19) {
    switch (e20 == null ? void 0 : e20.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e20, t19, 1, 0, 0, 0);
    }
  }
  _analyzeMultiLayerSymbol(e20, t19, i18, r16, o10, n23) {
    const a13 = e20 == null ? void 0 : e20.symbolLayers;
    if (!a13)
      return;
    const s17 = e20.effects;
    let l12 = i3.SCREEN;
    const c8 = ie2.getSize(e20) ?? 0;
    "CIMPointSymbol" === e20.type && "Map" === e20.angleAlignment && (l12 = i3.MAP);
    const m10 = "CIMPolygonSymbol" === e20.type;
    let f6 = a13.length;
    for (; f6--; ) {
      const h11 = a13[f6];
      if (!h11 || false === h11.enable)
        continue;
      let p5;
      s17 && s17.length && (p5 = [...s17]);
      const u12 = h11.effects;
      u12 && u12.length && (s17 ? p5.push(...u12) : p5 = [...u12]);
      const d4 = [];
      let v3;
      ne2.findEffectOverrides(p5, this._primitiveOverrides, d4), v3 = d4.length > 0 ? this._createEffectsOverrideFunction(p5, d4) : p5;
      const _4 = [];
      switch (ne2.findApplicableOverrides(h11, this._primitiveOverrides, _4), h11.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(h11, v3);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(h11, v3);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(h11, v3);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(h11, v3);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(h11, v3, m10, c8);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(h11, v3, m10, c8);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(h11, v3, m10, c8);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" === e20.type && (l12 = j3(h11));
          const a14 = [], s18 = h11.primitiveName;
          s18 && a14.push(s18), this._analyzeMarker(h11, v3, null, a14, l12, c8, 1, t19, i18, r16, o10, n23);
          break;
        }
        default:
          E.error("Cannot analyze CIM layer", h11.type);
      }
    }
  }
  _analyzeSolidFill(e20, t19) {
    const i18 = e20.primitiveName, r16 = u5(e20.color), [o10, n23] = this._analyzePrimitiveOverrides(i18, t19, null, null), s17 = c(JSON.stringify(e20) + n23).toString();
    this._cimLayers.push({ type: "fill", templateHash: s17, materialHash: o10 ? () => s17 : s17, cim: e20, materialOverrides: null, colorLocked: !!e20.colorLocked, color: this._createOverrideFunction(i18, "Color", r16, U3), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: t19, applyRandomOffset: false, sampleAlphaOnly: true });
  }
  _analyzePictureFill(e20, t19) {
    const i18 = e20.primitiveName, r16 = p(e20), [o10, n23] = this._analyzePrimitiveOverrides(i18, t19, null, null), s17 = c(JSON.stringify(e20) + n23).toString(), l12 = c(`${e20.url}${JSON.stringify(e20.colorSubstitutions)}`).toString(), m10 = b2(e20.height, V);
    let f6 = b2(e20.scaleX, 1);
    if ("width" in e20 && "number" == typeof e20.width) {
      const t20 = e20.width;
      let i19 = 1;
      const r17 = this._resourceManager.getResource(e20.url);
      null != r17 && (i19 = r17.width / r17.height), f6 /= i19 * (m10 / t20);
    }
    this._cimLayers.push({ type: "fill", templateHash: s17, materialHash: o10 ? () => l12 : l12, cim: e20, materialOverrides: null, colorLocked: !!e20.colorLocked, effects: t19, color: this._createOverrideFunction(i18, "TintColor", r16, U3), height: this._createOverrideFunction(i18, "Height", m10), scaleX: this._createOverrideFunction(i18, "ScaleX", f6), angle: this._createOverrideFunction(i18, "Rotation", b2(e20.rotation)), offsetX: this._createOverrideFunction(i18, "OffsetX", b2(e20.offsetX)), offsetY: this._createOverrideFunction(i18, "OffsetY", b2(e20.offsetY)), url: e20.url, applyRandomOffset: false, sampleAlphaOnly: false });
  }
  _analyzeHatchFill(e20, t19) {
    var _a, _b;
    const i18 = e20.primitiveName, r16 = this._analyzeMaterialOverrides(i18, ["Rotation", "OffsetX", "OffsetY"]);
    let [o10, n23] = this._analyzePrimitiveOverrides(i18, t19, null, null);
    const s17 = c(JSON.stringify(e20) + n23).toString(), l12 = c(`${e20.separation}${JSON.stringify(e20.lineSymbol)}`).toString();
    let c8 = { r: 255, g: 255, b: 255, a: 1 }, f6 = false;
    const h11 = (_b = (_a = e20.lineSymbol) == null ? void 0 : _a.symbolLayers) == null ? void 0 : _b.find((e21) => {
      var _a2;
      return "CIMSolidStroke" === e21.type && null != ((_a2 = this._poMap[e21.primitiveName]) == null ? void 0 : _a2.Color);
    });
    if (h11) {
      c8 = u5(h11.color), c8 = this._createOverrideFunction(h11.primitiveName, "Color", c8, U3);
      const e21 = "function" == typeof c8;
      o10 = o10 || e21, f6 = null != h11.color || e21;
    }
    this._cimLayers.push({ type: "fill", templateHash: s17, materialHash: o10 && r16 ? this._createMaterialHashFunction(l12, r16) : l12, cim: e20, materialOverrides: r16, colorLocked: !!e20.colorLocked, effects: t19, color: c8, height: this._createOverrideFunction(i18, "Separation", b2(e20.separation, Y2)), scaleX: 1, angle: this._createOverrideFunction(i18, "Rotation", b2(e20.rotation)), offsetX: this._createOverrideFunction(i18, "OffsetX", b2(e20.offsetX)), offsetY: this._createOverrideFunction(i18, "OffsetY", b2(e20.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !f6 });
  }
  _analyzeGradientFill(e20, t19) {
    const i18 = e20.primitiveName, [r16, o10] = this._analyzePrimitiveOverrides(i18, t19, null, null), n23 = c(JSON.stringify(e20) + o10).toString();
    this._cimLayers.push({ type: "fill", templateHash: n23, materialHash: r16 ? () => n23 : n23, cim: e20, materialOverrides: null, colorLocked: !!e20.colorLocked, effects: t19, color: { r: 128, g: 128, b: 128, a: 1 }, height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false });
  }
  _analyzeSolidStroke(e20, t19, i18, r16) {
    const o10 = e20.primitiveName, n23 = u5(e20.color), s17 = b2(e20.width, O3), l12 = T3(e20.capStyle), c8 = $2(e20.joinStyle), m10 = e20.miterLimit, [h11, p5] = this._analyzePrimitiveOverrides(o10, t19, null, null), u12 = c(JSON.stringify(e20) + p5).toString();
    let y5, d4;
    if (t19 && t19 instanceof Array && t19.length > 0) {
      const e21 = t19[t19.length - 1];
      if ("CIMGeometricEffectDashes" === e21.type && "NoConstraint" === e21.lineDashEnding && null === e21.offsetAlongLine) {
        const e22 = (t19 = [...t19]).pop();
        y5 = e22.dashTemplate, d4 = e22.scaleDash;
      }
    }
    this._cimLayers.push({ type: "line", templateHash: u12, materialHash: h11 ? () => u12 : u12, cim: e20, materialOverrides: null, isOutline: i18, colorLocked: !!e20.colorLocked, effects: t19, color: this._createOverrideFunction(o10, "Color", n23, U3), width: this._createOverrideFunction(o10, "Width", s17), cap: this._createOverrideFunction(o10, "CapStyle", l12), join: this._createOverrideFunction(o10, "JoinStyle", c8), miterLimit: m10 && this._createOverrideFunction(o10, "MiterLimit", m10), referenceWidth: r16, zOrder: D2(e20.name), dashTemplate: y5, scaleDash: d4, sampleAlphaOnly: true });
  }
  _analyzePictureStroke(e20, t19, i18, r16) {
    const o10 = c(`${e20.url}${JSON.stringify(e20.colorSubstitutions)}`).toString(), n23 = e20.primitiveName, s17 = p(e20), l12 = b2(e20.width, O3), c8 = T3(e20.capStyle), m10 = $2(e20.joinStyle), h11 = e20.miterLimit, [p5, u12] = this._analyzePrimitiveOverrides(n23, t19, null, null), y5 = c(JSON.stringify(e20) + u12).toString();
    this._cimLayers.push({ type: "line", templateHash: y5, materialHash: p5 ? () => o10 : o10, cim: e20, materialOverrides: null, isOutline: i18, colorLocked: !!e20.colorLocked, effects: t19, color: this._createOverrideFunction(n23, "TintColor", s17, U3), width: this._createOverrideFunction(n23, "Width", l12), cap: this._createOverrideFunction(n23, "CapStyle", c8), join: this._createOverrideFunction(n23, "JoinStyle", m10), miterLimit: h11 && this._createOverrideFunction(n23, "MiterLimit", h11), referenceWidth: r16, zOrder: D2(e20.name), dashTemplate: null, scaleDash: false, url: e20.url, sampleAlphaOnly: false });
  }
  _analyzeGradientStroke(e20, t19, i18, r16) {
    const o10 = e20.primitiveName, n23 = b2(e20.width, O3), s17 = T3(e20.capStyle), l12 = $2(e20.joinStyle), c8 = e20.miterLimit, [m10, h11] = this._analyzePrimitiveOverrides(o10, t19, null, null), p5 = c(JSON.stringify(e20) + h11).toString();
    this._cimLayers.push({ type: "line", templateHash: p5, materialHash: m10 ? () => p5 : p5, cim: e20, materialOverrides: null, isOutline: i18, colorLocked: !!e20.colorLocked, effects: t19, color: { r: 128, g: 128, b: 128, a: 1 }, width: this._createOverrideFunction(o10, "Width", n23), cap: this._createOverrideFunction(o10, "CapStyle", s17), join: this._createOverrideFunction(o10, "JoinStyle", l12), miterLimit: c8 && this._createOverrideFunction(o10, "MiterLimit", c8), referenceWidth: r16, zOrder: D2(e20.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeMarker(e20, t19, i18, r16, o10, n23, a13, s17, l12, c8, m10, f6, p5 = false) {
    if (this._analyzeMarkerInsidePolygon(e20, t19))
      return;
    const u12 = b2(e20.size, q3), y5 = b2(e20.rotation), d4 = b2(e20.offsetX), v3 = b2(e20.offsetY);
    let _4 = this._createOverrideFunction(e20.primitiveName, "Size", u12), O4 = this._createOverrideFunction(e20.primitiveName, "Rotation", y5), S4 = this._createOverrideFunction(e20.primitiveName, "OffsetX", d4), g6 = this._createOverrideFunction(e20.primitiveName, "OffsetY", v3);
    _4 = this._transformSize(_4, a13), O4 = this._transformRotation(O4, !!e20.rotateClockwise, c8);
    const M4 = this._transformOffsetX(S4, g6, c8, a13, m10), k6 = this._transformOffsetY(S4, g6, c8, a13, f6);
    switch (S4 = M4, g6 = k6, e20.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e20, t19, i18, r16, o10, n23, _4, O4, S4, g6, e20.colorLocked || p5);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e20, t19, i18, r16, o10, n23, a13, s17, _4, O4, S4, g6, e20.colorLocked || p5);
    }
  }
  _analyzeMarkerInsidePolygon(e20, t19) {
    const { markerPlacement: i18, type: r16 } = e20;
    if (!i18 || "CIMMarkerPlacementInsidePolygon" !== i18.type)
      return false;
    if ("CIMVectorMarker" === r16 || "CIMPictureMarker" === r16) {
      const o11 = e20.primitiveName;
      if (o11) {
        const [e21, i19] = this._analyzePrimitiveOverrides([o11], t19, null, null);
        if (e21)
          return false;
      }
      const n23 = i18.primitiveName;
      if (n23) {
        const [e21, i19] = this._analyzePrimitiveOverrides([n23], t19, null, null);
        if (e21)
          return false;
      }
      if ("CIMVectorMarker" === r16) {
        const { markerGraphics: t20 } = e20;
        if (t20)
          for (const e21 of t20) {
            const { symbol: t21 } = e21;
            if ("CIMPolygonSymbol" === (t21 == null ? void 0 : t21.type) && t21.symbolLayers) {
              const { symbolLayers: e22 } = t21;
              for (const t22 of e22)
                if ("CIMSolidStroke" === t22.type)
                  return false;
            }
          }
      } else {
        const { animatedSymbolProperties: t20 } = e20;
        if (t20)
          return false;
      }
    }
    const o10 = i18, s17 = Math.abs(o10.stepX), l12 = Math.abs(o10.stepY);
    if (0 === s17 || 0 === l12)
      return true;
    const c8 = ["Rotation", "OffsetX", "OffsetY"], m10 = this._primitiveOverrides.filter((t20) => t20.primitiveName !== e20.primitiveName || !c8.includes(t20.propertyName)), f6 = "url" in e20 && "string" == typeof e20.url ? e20.url : void 0, h11 = c(JSON.stringify(e20)).toString();
    let p5, u12, y5 = null;
    if ("Random" === i18.gridType) {
      const e21 = e2(se), t20 = Math.max(Math.floor(e21 / s17), 1), i19 = Math.max(Math.floor(e21 / l12), 1);
      p5 = l12 * i19, y5 = (e22) => e22 ? e22 * i19 : 0;
      u12 = t20 * s17 / p5;
    } else
      i18.shiftOddRows ? (p5 = 2 * l12, y5 = (e21) => e21 ? 2 * e21 : 0, u12 = s17 / l12 * 0.5) : (p5 = l12, y5 = null, u12 = s17 / l12);
    const d4 = p(e20);
    return this._cimLayers.push({ type: "fill", templateHash: h11, materialHash: h11, cim: e20, materialOverrides: m10, colorLocked: !!e20.colorLocked, effects: t19, color: d4, height: this._createOverrideFunction(o10.primitiveName, "StepY", p5, y5), scaleX: u12, angle: o10.gridAngle, offsetX: b2(o10.offsetX), offsetY: b2(o10.offsetY), url: f6, applyRandomOffset: "Random" === i18.gridType, sampleAlphaOnly: !f6, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e20, t19, i18, r16, o10, n23, s17, l12, c8, m10, f6) {
    let h11 = b2(e20.scaleX, 1);
    const p5 = p(e20), u12 = c(`${e20.url}${JSON.stringify(e20.colorSubstitutions)}${JSON.stringify(e20.animatedSymbolProperties)}`).toString();
    i18 || (i18 = this._createMarkerPlacementOverrideFunction(e20.markerPlacement));
    const y5 = this._createAnimatedSymbolPropertiesOverrideFunction(e20.animatedSymbolProperties), [d4, v3] = this._analyzePrimitiveOverrides(r16, t19, i18, y5), _4 = c(JSON.stringify(e20) + v3).toString(), O4 = e20.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e20 && "number" == typeof e20.width) {
      const t20 = e20.width;
      let i19 = 1;
      const r17 = this._resourceManager.getResource(e20.url);
      null != r17 && (i19 = r17.width / r17.height);
      h11 /= i19 * (b2(e20.size) / t20);
    }
    function S4(e21, t20) {
      return null != y5 ? t9(y5, e21, t20) : null;
    }
    const g6 = e20.animatedSymbolProperties && true === e20.animatedSymbolProperties.randomizeStartTime ? (e21, t20, i19, r17) => {
      const o11 = o9(r17 ?? 0), n24 = S4(e21, t20);
      return u12 + `-MATERIALGROUP(${o11})-ASP(${JSON.stringify(n24)})`;
    } : d4 ? (e21, t20) => {
      const i19 = S4(e21, t20);
      return u12 + `-ASP(${JSON.stringify(i19)})`;
    } : u12;
    this._cimLayers.push({ type: "marker", templateHash: _4, materialHash: g6, cim: e20, materialOverrides: null, colorLocked: !!e20.colorLocked || !!f6, effects: t19, scaleSymbolsProportionally: false, alignment: o10, size: s17, scaleX: this._createOverrideFunction(e20.primitiveName, "ScaleX", h11), rotation: l12, offsetX: c8, offsetY: m10, color: this._createOverrideFunction(e20.primitiveName, "TintColor", p5, U3), anchorPoint: { x: O4.x, y: O4.y }, isAbsoluteAnchorPoint: "Relative" !== e20.anchorPointUnits, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, frameHeight: 0, rotateClockwise: false, referenceSize: n23, sizeRatio: 1, markerPlacement: i18, url: e20.url, animatedSymbolProperties: y5 });
  }
  _analyzeVectorMarker(e20, t19, i18, r16, o10, n23, a13, s17, l12, c8, m10, f6, h11) {
    const p5 = e20.markerGraphics;
    if (!p5)
      return;
    const u12 = e20.frame;
    let y5 = 0, d4 = 1;
    e20.scaleSymbolsProportionally && u12 && (y5 = u12.ymax - u12.ymin, d4 = this._transformSize(l12, 1 / y5)), d4 = this._transformSize(d4, a13), i18 || (i18 = this._createMarkerPlacementOverrideFunction(e20.markerPlacement));
    for (const v3 of p5)
      if (v3) {
        const a14 = v3.symbol;
        if (!a14)
          continue;
        const p6 = v3.primitiveName;
        p6 && r16.push(p6);
        let _4 = m10, O4 = f6;
        if (("CIMPointSymbol" === a14.type || "CIMTextSymbol" === a14.type) && u12) {
          let t20 = 0, i19 = 0;
          const r17 = v3.geometry;
          "x" in r17 && "y" in r17 && (t20 += r17.x - 0.5 * (u12.xmin + u12.xmax), i19 += r17.y - 0.5 * (u12.ymin + u12.ymax));
          const o11 = e20.anchorPoint;
          o11 && ("Absolute" === e20.anchorPointUnits ? (t20 -= o11.x, i19 -= o11.y) : u12 && (t20 -= (u12.xmax - u12.xmin) * o11.x, i19 -= (u12.ymax - u12.ymin) * o11.y)), _4 = this._transformOffsetX(t20, i19, c8, d4, m10), O4 = this._transformOffsetY(t20, i19, c8, d4, f6);
        }
        switch (a14.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            s17 ? this._analyzeMultiLayerGraphicNonSDF(e20, t19, i18, null, v3, r16, o10, n23, y5, !!h11 || !!e20.colorLocked) : this._analyzeMultiLayerGraphic(e20, t19, i18, null, v3, r16, o10, n23, y5, d4, l12, c8, _4, O4, !!h11 || !!e20.colorLocked);
            break;
          case "CIMTextSymbol":
            this._analyzeTextGraphic(e20, t19, i18, v3, r16, o10, n23, y5, d4, l12, c8, _4, O4, h11);
        }
        p6 && r16.pop();
      }
  }
  _analyzeMultiLayerGraphic(e20, t19, i18, r16, o10, n23, s17, l12, c8, m10, f6, h11, p5, u12, y5) {
    const d4 = o10.symbol, v3 = d4.symbolLayers;
    if (!v3)
      return;
    let _4 = v3.length;
    if (B3(v3))
      return void this._analyzeCompositeMarkerGraphic(e20, t19, i18, r16, o10, v3, n23, s17, l12, c8, f6, h11, p5, u12, !!y5 || !!e20.colorLocked);
    const O4 = this._resourceManager.geometryEngine, k6 = l11.applyEffects(d4.effects, o10.geometry, O4);
    if (k6)
      for (; _4--; ) {
        const d5 = v3[_4];
        if (!d5 || false === d5.enable)
          continue;
        const b5 = d5.primitiveName;
        switch (b5 && n23.push(b5), d5.type) {
          case "CIMSolidFill":
          case "CIMSolidStroke": {
            const m11 = l11.applyEffects(d5.effects, k6, O4), v4 = f5(m11);
            if (!v4)
              continue;
            const _5 = "Relative" !== e20.anchorPointUnits, [C4, F2, I2] = m9(v4, e20.frame, e20.size, e20.anchorPoint, _5), w7 = "CIMSolidFill" === d5.type, x4 = { type: "sdf", geom: m11, asFill: w7 }, A5 = d5.path, R3 = u5(w7 ? P2(d5) : w4(d5)), H = w7 ? { r: 0, g: 0, b: 0, a: 0 } : u5(w4(d5)), J3 = L(d5) ?? 0;
            if (!w7 && !J3)
              break;
            const Y3 = o10.primitiveName;
            let E2 = null;
            !w7 || d5.colorLocked || y5 || (E2 = this._createOverrideFunction(Y3, "FillColor", R3, U3));
            let T4 = null;
            d5.colorLocked || y5 || (T4 = this._createOverrideFunction(Y3, "StrokeColor", H, U3));
            const $3 = this._createOverrideFunction(Y3, "StrokeWidth", J3);
            let j4 = false, G4 = "";
            for (const e21 of this._primitiveOverrides)
              n23.includes(e21.primitiveName) && (null != e21.value ? G4 += `-${e21.primitiveName}-${e21.propertyName}-${JSON.stringify(e21.value)}` : e21.valueExpressionInfo && (j4 = true));
            (null != t19 && "function" == typeof t19 || null != i18 && "function" == typeof i18) && (j4 = true), (e7(f6) || e7(h11) || e7(p5) || e7(u12)) && (j4 = true);
            const D3 = JSON.stringify({ ...e20, markerGraphics: null }), W4 = c(JSON.stringify(x4) + A5).toString(), V3 = c(JSON.stringify(o10) + JSON.stringify(d5) + D3 + G4).toString();
            this._cimLayers.push({ type: "marker", templateHash: V3, materialHash: j4 ? () => W4 : W4, cim: x4, materialOverrides: null, colorLocked: !!d5.colorLocked || !!y5, effects: t19, scaleSymbolsProportionally: !!e20.scaleSymbolsProportionally, alignment: s17, anchorPoint: { x: F2, y: I2 }, isAbsoluteAnchorPoint: _5, size: f6, rotation: h11, offsetX: p5, offsetY: u12, scaleX: 1, frameHeight: c8, rotateClockwise: false, referenceSize: l12, sizeRatio: C4, color: e7(E2) ? E2 : this._createOverrideFunction(b5, "Color", R3, U3), outlineColor: e7(T4) ? T4 : this._createOverrideFunction(b5, "Color", H, U3), outlineWidth: e7($3) ? $3 : this._createOverrideFunction(b5, "Width", J3), markerPlacement: i18, animatedSymbolProperties: r16, path: A5 });
            break;
          }
          case "CIMVectorMarker":
            d5.markerPlacement ? this._analyzeMultiLayerGraphicNonSDF(e20, t19, i18, r16, o10, n23, s17, l12, c8, !!y5 || !!d5.colorLocked) : this._analyzeMarker(d5, t19, i18, n23, s17, l12, m10, false, f6, h11, p5, u12, !!y5 || !!e20.colorLocked);
            break;
          default:
            this._analyzeMultiLayerGraphicNonSDF(e20, t19, i18, r16, o10, n23, s17, l12, c8, !!y5 || !!e20.colorLocked);
        }
        b5 && n23.pop();
      }
  }
  _analyzeTextGraphic(e20, i18, r16, o10, n23, s17, l12, c8, m10, h11, u12, d4, v3, _4) {
    const O4 = [];
    ne2.findApplicableOverrides(o10, this._primitiveOverrides, O4);
    const S4 = o10.geometry;
    if (!("x" in S4) || !("y" in S4))
      return;
    const g6 = o10.symbol, k6 = k3(g6), L3 = S(g6.fontStyleName), X2 = u4(g6.fontFamilyName);
    g6.font = { family: X2, decoration: k6, ...L3 };
    let H = b2(g6.height, W), J3 = b2(g6.angle), Y3 = b2(g6.offsetX), E2 = b2(g6.offsetY);
    H = this._transformSize(H, m10), J3 = this._transformRotation(J3, false, u12);
    const T4 = this._transformOffsetX(Y3, E2, u12, m10, d4), $3 = this._transformOffsetY(Y3, E2, u12, m10, v3);
    Y3 = T4, E2 = $3;
    const j4 = u5(P2(g6));
    let G4 = u5(w4(g6)), D3 = L(g6) ?? 0;
    D3 || (G4 = u5(P2(g6.haloSymbol)), D3 = b2(g6.haloSize)), D3 = this._transformSize(D3, m10);
    let U4 = null, W4 = null, V3 = 0;
    if (g6.callout && "CIMBackgroundCallout" === g6.callout.type) {
      const e21 = g6.callout;
      if (e21.backgroundSymbol) {
        const t19 = e21.backgroundSymbol.symbolLayers;
        if (t19)
          for (const e22 of t19)
            "CIMSolidFill" === e22.type ? U4 = u5(e22.color) : "CIMSolidStroke" === e22.type && (W4 = u5(e22.color), V3 = b2(e22.width, O3));
      }
    }
    const [B4, q5] = this._analyzePrimitiveOverrides(n23, i18, r16, null), K3 = JSON.stringify(e20.effects) + Number(e20.colorLocked || _4).toString() + JSON.stringify(e20.anchorPoint) + e20.anchorPointUnits + JSON.stringify(e20.markerPlacement) + e20.size.toString(), Q3 = c(JSON.stringify(o10) + K3 + q5).toString();
    let Z4 = this._createOverrideFunction(o10.primitiveName, "TextString", o10.textString ?? "", s7, g6.textCase);
    if (null == Z4)
      return;
    const { fontStyleName: ee2 } = g6, te2 = X2 + (ee2 ? "-" + ee2.toLowerCase() : "-regular"), ie3 = te2;
    "string" == typeof Z4 && Z4.includes("[") && g6.fieldMap && (Z4 = c3(g6.fieldMap, Z4, g6.textCase)), this._cimLayers.push({ type: "text", templateHash: Q3, materialHash: B4 || "function" == typeof Z4 || /\[(.*?)\]/.test(Z4) ? (e21, t19, i19) => ie3 + "-" + t9(Z4, e21, t19, i19) : ie3 + "-" + c(Z4), cim: g6, materialOverrides: null, colorLocked: !!e20.colorLocked || !!_4, effects: i18, alignment: s17, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: "Relative" !== e20.anchorPointUnits, fontName: te2, decoration: k6, weight: L3.weight, style: L3.style, size: H, angle: J3, offsetX: Y3, offsetY: E2, horizontalAlignment: x(g6.horizontalAlignment), verticalAlignment: G2(g6.verticalAlignment), text: Z4, color: j4, outlineColor: G4, outlineSize: D3, backgroundColor: U4, borderLineColor: W4, borderLineWidth: V3, referenceSize: l12, sizeRatio: 1, markerPlacement: r16 });
  }
  _analyzeMultiLayerGraphicNonSDF(e20, t19, i18, r16, n23, s17, l12, c8, m10, f6) {
    const p5 = this._buildSimpleMarker(e20, n23), y5 = e20.primitiveName, d4 = this._analyzeMaterialOverrides(y5, ["Rotation", "OffsetX", "OffsetY"]), [v3, _4] = this._analyzePrimitiveOverrides(s17, null, null, null), [O4, S4, g6] = ie2.getTextureAnchor(p5, this._resourceManager), M4 = b2(e20.rotation), k6 = b2(e20.offsetX), N4 = b2(e20.offsetY), P5 = c(JSON.stringify(p5) + _4).toString(), z3 = d4 && d4.length > 0 || null != t19 && "function" == typeof t19;
    this._cimLayers.push({ type: "marker", templateHash: P5, materialHash: z3 && d4 ? this._createMaterialHashFunction(P5, d4) : P5, cim: p5, materialOverrides: d4, colorLocked: !!e20.colorLocked || !!f6, effects: t19, scaleSymbolsProportionally: !!e20.scaleSymbolsProportionally, alignment: l12, anchorPoint: { x: O4, y: S4 }, isAbsoluteAnchorPoint: false, size: b2(e20.size, q3), rotation: this._createOverrideFunction(y5, "Rotation", M4), offsetX: this._createOverrideFunction(y5, "OffsetX", k6), offsetY: this._createOverrideFunction(y5, "OffsetY", N4), color: { r: 255, g: 255, b: 255, a: 1 }, outlineColor: { r: 0, g: 0, b: 0, a: 0 }, outlineWidth: 0, scaleX: 1, frameHeight: m10, rotateClockwise: !!e20.rotateClockwise, referenceSize: c8, sizeRatio: g6 / u2(e20.size), markerPlacement: i18, animatedSymbolProperties: r16, avoidSDFRasterization: true });
  }
  _buildSimpleMarker(e20, t19) {
    return { type: e20.type, enable: true, name: e20.name, colorLocked: e20.colorLocked, primitiveName: e20.primitiveName, anchorPoint: e20.anchorPoint, anchorPointUnits: e20.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e20.rotateClockwise, rotation: 0, size: e20.size, billboardMode3D: e20.billboardMode3D, depth3D: e20.depth3D, frame: e20.frame, markerGraphics: [t19], scaleSymbolsProportionally: e20.scaleSymbolsProportionally, respectFrame: e20.respectFrame, clippingPath: e20.clippingPath };
  }
  _analyzeCompositeMarkerGraphic(e20, t19, i18, r16, o10, n23, s17, l12, c8, m10, h11, p5, u12, y5, d4) {
    const v3 = o10.geometry, _4 = n23[0], O4 = n23[1], k6 = f5(v3);
    if (!k6)
      return;
    const N4 = "Relative" !== e20.anchorPointUnits, [P5, z3, C4] = m9(k6, e20.frame, e20.size, e20.anchorPoint, N4), F2 = { type: "sdf", geom: v3, asFill: true }, I2 = O4.path, w7 = O4.primitiveName, x4 = _4.primitiveName, A5 = u5(O4.color), R3 = u5(_4.color), X2 = b2(_4.width, O3), H = o10.primitiveName;
    let J3 = null;
    O4.colorLocked || d4 || (J3 = this._createOverrideFunction(H, "FillColor", A5, U3));
    let Y3 = null;
    _4.colorLocked || d4 || (Y3 = this._createOverrideFunction(H, "StrokeColor", R3, U3));
    const E2 = this._createOverrideFunction(H, "StrokeWidth", X2);
    let T4 = false, $3 = "";
    for (const a13 of this._primitiveOverrides)
      (a13.primitiveName === w7 || a13.primitiveName === x4 || s17.includes(a13.primitiveName)) && (null != a13.value ? $3 += `-${a13.primitiveName}-${a13.propertyName}-${JSON.stringify(a13.value)}` : a13.valueExpressionInfo && (T4 = true));
    null != i18 && "function" == typeof i18 && (T4 = true), (e7(h11) || e7(p5) || e7(u12) || e7(y5)) && (T4 = true);
    const j4 = JSON.stringify({ ...e20, markerGraphics: null }), G4 = c(JSON.stringify(F2) + I2).toString(), D3 = c(JSON.stringify(o10) + JSON.stringify(O4) + JSON.stringify(_4) + j4 + $3).toString();
    this._cimLayers.push({ type: "marker", templateHash: D3, materialHash: T4 ? () => G4 : G4, cim: F2, materialOverrides: null, colorLocked: !!d4, effects: t19, scaleSymbolsProportionally: !!e20.scaleSymbolsProportionally, alignment: l12, anchorPoint: { x: z3, y: C4 }, isAbsoluteAnchorPoint: N4, size: h11, rotation: p5, offsetX: u12, offsetY: y5, scaleX: 1, frameHeight: m10, rotateClockwise: false, referenceSize: c8, sizeRatio: P5, color: e7(J3) ? J3 : this._createOverrideFunction(w7, "Color", A5, U3), outlineColor: e7(Y3) ? Y3 : this._createOverrideFunction(x4, "Color", R3, U3), outlineWidth: e7(E2) ? E2 : this._createOverrideFunction(x4, "Width", X2), markerPlacement: i18, path: I2, animatedSymbolProperties: r16 });
  }
  _createMaterialHashFunction(e20, t19) {
    var _a;
    const i18 = (_a = this._info) == null ? void 0 : _a.geometryType;
    if (i18) {
      const e21 = this._poMap;
      for (const r16 of t19) {
        if (r16.valueExpressionInfo) {
          const t20 = e21[r16.primitiveName] && e21[r16.primitiveName][r16.propertyName];
          t20 instanceof u6 && (r16.fn = (e22, r17, o10) => s15(t20, e22, { $view: o10 }, i18, r17));
        }
      }
    }
    return (i19, r16, o10) => {
      for (const e21 of t19)
        e21.fn && (e21.value = e21.fn(i19, r16, o10));
      return c(e20 + ne2.buildOverrideKey(t19)).toString();
    };
  }
  _setPoMap(e20, t19, i18) {
    let r16;
    this._poMap[e20] ? r16 = this._poMap[e20] : (r16 = {}, this._poMap[e20] = r16), r16[t19] = i18;
  }
  _createOverrideFunction(e20, t19, i18, r16, o10) {
    var _a;
    if (null == e20)
      return i18;
    const n23 = this._poMap[e20];
    if (null == n23)
      return i18;
    const a13 = n23[t19];
    if ("string" == typeof a13 || "number" == typeof a13 || a13 instanceof Array)
      return r16 ? r16.call(null, a13, o10) : a13;
    const s17 = (_a = this._info) == null ? void 0 : _a.geometryType;
    return null != a13 && a13 instanceof u6 && null != s17 ? (e21, t20, n24) => {
      let l12 = s15(a13, e21, { $view: n24 }, s17, t20);
      return null !== l12 && r16 && (l12 = r16.call(null, l12, o10)), null !== l12 ? l12 : i18;
    } : i18;
  }
  _createEffectsOverrideFunction(e20, t19) {
    var _a;
    const r16 = this._poMap, o10 = (_a = this._info) == null ? void 0 : _a.geometryType;
    for (const i18 of t19) {
      if (i18.valueExpressionInfo && o10) {
        const e21 = r16[i18.primitiveName] && r16[i18.primitiveName][i18.propertyName];
        e21 instanceof u6 && (i18.fn = (t20, i19, r17) => s15(e21, t20, { $view: r17 }, o10, i19));
      }
    }
    return (r17, o11, n23) => {
      for (const e21 of t19)
        e21.fn && (e21.value = e21.fn(r17, o11, n23));
      const a13 = [];
      for (let s17 of e20) {
        const e21 = s17 == null ? void 0 : s17.primitiveName;
        if (e21) {
          let r18 = false;
          for (const o12 of t19)
            if (o12.primitiveName === e21) {
              const e22 = W3(o12.propertyName);
              null != o12.value && o12.value !== s17[e22] && (r18 || (s17 = a(s17), r18 = true), s17[e22] = o12.value);
            }
        }
        a13.push(s17);
      }
      return a13;
    };
  }
  _createMarkerPlacementOverrideFunction(e20) {
    var _a;
    const t19 = [];
    if (ne2.findApplicableOverrides(e20, this._primitiveOverrides, t19), null == e20 || 0 === t19.length)
      return e20;
    const r16 = this._poMap, o10 = (_a = this._info) == null ? void 0 : _a.geometryType;
    for (const i18 of t19) {
      if (i18.valueExpressionInfo && o10) {
        const e21 = r16[i18.primitiveName] && r16[i18.primitiveName][i18.propertyName];
        e21 instanceof u6 && (i18.fn = (t20, i19, r17) => s15(e21, t20, { $view: r17 }, o10, i19));
      }
    }
    return (r17, o11, n23) => {
      for (const e21 of t19)
        e21.fn && (e21.value = e21.fn(r17, o11, n23));
      const a13 = a(e20), s17 = e20.primitiveName;
      for (const e21 of t19)
        if (e21.primitiveName === s17) {
          const t20 = W3(e21.propertyName);
          null != e21.value && e21.value !== a13[t20] && (a13[t20] = e21.value);
        }
      return a13;
    };
  }
  _createAnimatedSymbolPropertiesOverrideFunction(e20) {
    var _a;
    const t19 = [];
    if (ne2.findApplicableOverrides(e20, this._primitiveOverrides, t19), null == e20 || 0 === t19.length)
      return e20;
    const r16 = (_a = this._info) == null ? void 0 : _a.geometryType;
    if (r16) {
      const e21 = this._poMap;
      for (const i18 of t19) {
        if (i18.valueExpressionInfo) {
          const t20 = e21[i18.primitiveName] && e21[i18.primitiveName][i18.propertyName];
          t20 instanceof u6 && (i18.fn = (e22, i19, o10) => s15(t20, e22, { $view: o10 }, r16, i19));
        }
      }
    }
    return (r17, o10, n23) => {
      for (const e21 of t19)
        e21.fn && (e21.value = e21.fn(r17, o10, n23));
      const a13 = a(e20), s17 = e20.primitiveName;
      for (const e21 of t19)
        if (e21.primitiveName === s17) {
          const t20 = W3(e21.propertyName);
          if (null != e21.value) {
            const i18 = a11(e21.value, e21.propertyName);
            i18 !== a13[t20] && (a13[t20] = i18);
          }
        }
      return a13;
    };
  }
  _analyzePrimitiveOverrides(e20, t19, i18, r16) {
    let o10 = false, n23 = "";
    "string" == typeof e20 && (e20 = [e20]);
    for (const a13 of this._primitiveOverrides)
      (e20 == null ? void 0 : e20.includes(a13.primitiveName)) && (null != a13.value ? n23 += `-${a13.primitiveName}-${a13.propertyName}-${JSON.stringify(a13.value)}` : a13.valueExpressionInfo && (o10 = true));
    return null != t19 && "function" == typeof t19 && (o10 = true), null != i18 && "function" == typeof i18 && (o10 = true), null != r16 && "function" == typeof r16 && (o10 = true), [o10, n23];
  }
  _analyzeMaterialOverrides(e20, t19) {
    return this._primitiveOverrides.filter((i18) => i18.primitiveName !== e20 || !t19.includes(i18.propertyName));
  }
  _transformSize(e20, t19) {
    return e7(e20) || e7(t19) ? (i18, r16, o10) => (e7(e20) ? e20(i18, r16, o10) : e20) * (e7(t19) ? t19(i18, r16, o10) : t19) : e20 * t19;
  }
  _transformRotation(e20, t19, i18) {
    return e7(e20) || e7(i18) ? (r16, o10, n23) => {
      const a13 = e7(e20) ? e20(r16, o10, n23) : e20, s17 = e7(i18) ? i18(r16, o10, n23) : i18;
      return t19 ? s17 - a13 : s17 + a13;
    } : t19 ? i18 - e20 : i18 + e20;
  }
  _transformOffsetX(e20, t19, i18, r16, o10) {
    if (!(e7(e20) || e7(t19) || e7(i18) || e7(r16) || e7(o10))) {
      const n23 = i18 * Math.PI / 180;
      if (n23) {
        const i19 = Math.cos(n23), a13 = Math.sin(n23);
        return (i19 * e20 - a13 * t19) * r16 + o10;
      }
      return e20 * r16 + o10;
    }
    return (n23, a13, s17) => {
      let l12 = e7(i18) ? i18(n23, a13, s17) : i18;
      const c8 = e7(r16) ? r16(n23, a13, s17) : r16, m10 = e7(e20) ? e20(n23, a13, s17) : e20, f6 = e7(o10) ? o10(n23, a13, s17) : o10;
      if (l12) {
        l12 *= Math.PI / 180;
        return (Math.cos(l12) * m10 - Math.sin(l12) * (e7(t19) ? t19(n23, a13, s17) : t19)) * c8 + f6;
      }
      return m10 * c8 + f6;
    };
  }
  _transformOffsetY(e20, t19, i18, r16, o10) {
    if (!(e7(e20) || e7(t19) || e7(i18) || e7(r16) || e7(o10))) {
      const n23 = i18 * Math.PI / 180;
      if (n23) {
        const i19 = Math.cos(n23);
        return (Math.sin(n23) * e20 + i19 * t19) * r16 + o10;
      }
      return t19 * r16 + o10;
    }
    return (n23, a13, s17) => {
      let l12 = e7(i18) ? i18(n23, a13, s17) : i18;
      const c8 = e7(r16) ? r16(n23, a13, s17) : r16, m10 = e7(t19) ? t19(n23, a13, s17) : t19, f6 = e7(o10) ? o10(n23, a13, s17) : o10;
      if (l12) {
        l12 *= Math.PI / 180;
        const t20 = Math.cos(l12);
        return (Math.sin(l12) * (e7(e20) ? e20(n23, a13, s17) : e20) + t20 * m10) * c8 + f6;
      }
      return m10 * c8 + f6;
    };
  }
};
function D2(e20) {
  if (e20 && 0 === e20.indexOf("Level_")) {
    const t19 = parseInt(e20.substr(6), 10);
    if (!isNaN(t19))
      return t19;
  }
  return 0;
}
function U3(t19) {
  if (!t19 || 0 === t19.length)
    return null;
  const i18 = new h2(t19).toRgba();
  return { r: i18[0], g: i18[1], b: i18[2], a: i18[3] };
}
function W3(e20) {
  return e20 ? e20.charAt(0).toLowerCase() + e20.substr(1) : e20;
}
function V2(e20, t19) {
  if (!t19 || 0 === t19.length)
    return e20;
  const r16 = a(e20);
  return ne2.applyOverrides(r16, t19), r16;
}
var B3 = (e20) => e20 && 2 === e20.length && e20[0].enable && e20[1].enable && "CIMSolidStroke" === e20[0].type && "CIMSolidFill" === e20[1].type && !e20[0].effects && !e20[1].effects;

export {
  i6 as i,
  a6 as a,
  g4 as g,
  S3 as S,
  t17 as t,
  r14 as r,
  Q,
  tt,
  et,
  s15 as s,
  ee,
  se2 as se,
  ie2 as ie,
  ne2 as ne,
  Me,
  l11 as l,
  l10 as l2,
  a12 as a2,
  e19 as e,
  o9 as o,
  G3 as G,
  V2 as V
};
//# sourceMappingURL=chunk-GTENSI4J.js.map
