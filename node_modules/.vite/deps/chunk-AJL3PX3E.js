import {
  H as H2
} from "./chunk-QOPVYP7U.js";
import {
  O
} from "./chunk-BN6X2OXK.js";
import {
  e as e2
} from "./chunk-7LLYVI2T.js";
import {
  t as t2
} from "./chunk-FF5LS3YE.js";
import {
  C
} from "./chunk-BCDDCNQ2.js";
import {
  M,
  l
} from "./chunk-MOPR7RFH.js";
import {
  H,
  P,
  _2 as _,
  e2 as e,
  n,
  o,
  r2 as r,
  u2 as u,
  x,
  z
} from "./chunk-KW3ZNPTA.js";
import {
  t,
  w
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/3d/support/buffer/glUtil.js
function r2(t4, r4 = 0) {
  const n3 = t4.stride;
  return Array.from(t4.fields.keys()).filter((e4) => {
    var _a;
    const r5 = (_a = t4.fields.get(e4)) == null ? void 0 : _a.optional;
    return !(r5 && r5.glPadding);
  }).map((i) => {
    const s = t4.fields.get(i), f3 = s.constructor.ElementCount, l3 = o2(s.constructor.ElementType), u5 = s.offset, c2 = !(!s.optional || !s.optional.glNormalized);
    return new t2(i, f3, l3, u5, n3, c2, r4);
  });
}
function o2(t4) {
  const e4 = n2[t4];
  if (e4)
    return e4;
  throw new Error("BufferType not supported in WebGL");
}
var n2 = { u8: C.UNSIGNED_BYTE, u16: C.UNSIGNED_SHORT, u32: C.UNSIGNED_INT, i8: C.BYTE, i16: C.SHORT, i32: C.INT, f32: C.FLOAT };

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/bufferLayouts.js
var A = H2().vec3f(O.POSITION).u16(O.COMPONENTINDEX).u16(O.U16PADDING);
var e3 = H2().vec2u8(O.SIDENESS);
var T = r2(e3);
var E = H2().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u8(O.VARIANTOFFSET, { glNormalized: true }).u8(O.VARIANTSTROKE).u8(O.VARIANTEXTENSION, { glNormalized: true }).u8(O.U8PADDING, { glPadding: true }).u16(O.U16PADDING, { glPadding: true });
var S = E.clone().vec3f(O.NORMAL);
var r3 = E.clone().vec3f(O.NORMALA).vec3f(O.NORMALB);
var o3 = /* @__PURE__ */ new Map([[O.POSITION0, 0], [O.POSITION1, 1], [O.COMPONENTINDEX, 2], [O.VARIANTOFFSET, 3], [O.VARIANTSTROKE, 4], [O.VARIANTEXTENSION, 5], [O.NORMAL, 6], [O.NORMALA, 6], [O.NORMALB, 7], [O.SIDENESS, 8]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgePreprocessing.js
var m = -1;
var u2;
function p(n3, a3, i, l3 = V) {
  const f3 = n3.vertices.position, g3 = n3.vertices.componentIndex, u5 = M(l3.anglePlanar), p4 = M(l3.angleSignificantEdge), y3 = Math.cos(p4), E2 = Math.cos(u5), N = I.edge, S2 = N.position0, x2 = N.position1, j = N.faceNormal0, D = N.faceNormal1, F = w2(n3), L = d(n3), b = L.length / 4, k = a3.allocate(b);
  let C2 = 0;
  const H3 = b, K = i.allocate(H3);
  let M2 = 0, O2 = 0, P2 = 0;
  const T2 = w(0, b), U = new Float32Array(b);
  U.forEach((e4, t4, n4) => {
    f3.getVec(L[4 * t4], S2), f3.getVec(L[4 * t4 + 1], x2), n4[t4] = x(S2, x2);
  }), T2.sort((e4, t4) => U[t4] - U[e4]);
  const q = new Array(), z2 = new Array();
  for (let e4 = 0; e4 < b; e4++) {
    const t4 = T2[e4], n4 = U[t4], o4 = L[4 * t4], l4 = L[4 * t4 + 1], p5 = L[4 * t4 + 2], d4 = L[4 * t4 + 3], w4 = d4 === m;
    if (f3.getVec(o4, S2), f3.getVec(l4, x2), w4)
      o(j, F[3 * p5], F[3 * p5 + 1], F[3 * p5 + 2]), r(D, j), N.componentIndex = g3.get(o4), N.cosAngle = P(j, D);
    else {
      if (o(j, F[3 * p5], F[3 * p5 + 1], F[3 * p5 + 2]), o(D, F[3 * d4], F[3 * d4 + 1], F[3 * d4 + 2]), N.componentIndex = g3.get(o4), N.cosAngle = P(j, D), v(N, E2))
        continue;
      N.cosAngle < -0.9999 && r(D, j);
    }
    O2 += n4, P2++, w4 || h(N, y3) ? (a3.write(k, C2++, N), q.push(n4)) : A2(N, u5) && (i.write(K, M2++, N), z2.push(n4));
  }
  const B = new Float32Array(q.reverse()), G = new Float32Array(z2.reverse());
  return { regular: { instancesData: a3.trim(k, C2), lodInfo: { lengths: B } }, silhouette: { instancesData: i.trim(K, M2), lodInfo: { lengths: G } }, averageEdgeLength: O2 / P2 };
}
function h(e4, t4) {
  return e4.cosAngle < t4;
}
function v(e4, t4) {
  return e4.cosAngle > t4;
}
function A2(e4, t4) {
  const o4 = l(e4.cosAngle), r4 = I.fwd, c2 = I.ortho;
  H(r4, e4.position1, e4.position0);
  return o4 * (P(_(c2, e4.faceNormal0, e4.faceNormal1), r4) > 0 ? -1 : 1) > t4;
}
function d(e4) {
  const t4 = e4.faces.length / 3, n3 = e4.faces, o4 = e4.neighbors;
  let r4 = 0;
  for (let a3 = 0; a3 < t4; a3++) {
    const e5 = o4[3 * a3], t5 = o4[3 * a3 + 1], c3 = o4[3 * a3 + 2], s2 = n3[3 * a3], i = n3[3 * a3 + 1], l3 = n3[3 * a3 + 2];
    r4 += e5 === m || s2 < i ? 1 : 0, r4 += t5 === m || i < l3 ? 1 : 0, r4 += c3 === m || l3 < s2 ? 1 : 0;
  }
  const c2 = new Int32Array(4 * r4);
  let s = 0;
  for (let a3 = 0; a3 < t4; a3++) {
    const e5 = o4[3 * a3], t5 = o4[3 * a3 + 1], r5 = o4[3 * a3 + 2], i = n3[3 * a3], l3 = n3[3 * a3 + 1], f3 = n3[3 * a3 + 2];
    (e5 === m || i < l3) && (c2[s++] = i, c2[s++] = l3, c2[s++] = a3, c2[s++] = e5), (t5 === m || l3 < f3) && (c2[s++] = l3, c2[s++] = f3, c2[s++] = a3, c2[s++] = t5), (r5 === m || f3 < i) && (c2[s++] = f3, c2[s++] = i, c2[s++] = a3, c2[s++] = r5);
  }
  return c2;
}
function w2(e4) {
  const t4 = e4.faces.length / 3, n3 = e4.vertices.position, o4 = e4.faces, r4 = y.v0, c2 = y.v1, s = y.v2, a3 = new Float32Array(3 * t4);
  for (let g3 = 0; g3 < t4; g3++) {
    const e5 = o4[3 * g3], t5 = o4[3 * g3 + 1], m4 = o4[3 * g3 + 2];
    n3.getVec(e5, r4), n3.getVec(t5, c2), n3.getVec(m4, s), e(c2, c2, r4), e(s, s, r4), _(r4, c2, s), z(r4, r4), a3[3 * g3] = r4[0], a3[3 * g3 + 1] = r4[1], a3[3 * g3 + 2] = r4[2];
  }
  return a3;
}
!function(e4) {
  e4[e4.SOLID = 0] = "SOLID", e4[e4.SKETCH = 1] = "SKETCH";
}(u2 || (u2 = {}));
var I = { edge: { position0: n(), position1: n(), faceNormal0: n(), faceNormal1: n(), componentIndex: 0, cosAngle: 0 }, ortho: n(), fwd: n() };
var y = { v0: n(), v1: n(), v2: n() };
var V = { anglePlanar: 4, angleSignificantEdge: 35 };

// node_modules/@arcgis/core/views/3d/support/meshProcessing.js
function t3(t4, o4, n3) {
  const r4 = o4 / 3, c2 = new Uint32Array(n3 + 1), e4 = new Uint32Array(n3 + 1), s = (t5, o5) => {
    t5 < o5 ? c2[t5 + 1]++ : e4[o5 + 1]++;
  };
  for (let x2 = 0; x2 < r4; x2++) {
    const o5 = t4[3 * x2], n4 = t4[3 * x2 + 1], r5 = t4[3 * x2 + 2];
    s(o5, n4), s(n4, r5), s(r5, o5);
  }
  let f3 = 0, l3 = 0;
  for (let x2 = 0; x2 < n3; x2++) {
    const t5 = c2[x2 + 1], o5 = e4[x2 + 1];
    c2[x2 + 1] = f3, e4[x2 + 1] = l3, f3 += t5, l3 += o5;
  }
  const i = new Uint32Array(6 * r4), a3 = c2[n3], w4 = (t5, o5, n4) => {
    if (t5 < o5) {
      const r5 = c2[t5 + 1]++;
      i[2 * r5] = o5, i[2 * r5 + 1] = n4;
    } else {
      const r5 = e4[o5 + 1]++;
      i[2 * a3 + 2 * r5] = t5, i[2 * a3 + 2 * r5 + 1] = n4;
    }
  };
  for (let x2 = 0; x2 < r4; x2++) {
    const o5 = t4[3 * x2], n4 = t4[3 * x2 + 1], r5 = t4[3 * x2 + 2];
    w4(o5, n4, x2), w4(n4, r5, x2), w4(r5, o5, x2);
  }
  const y3 = (t5, o5) => {
    const n4 = 2 * t5, r5 = o5 - t5;
    for (let c3 = 1; c3 < r5; c3++) {
      const t6 = i[n4 + 2 * c3], o6 = i[n4 + 2 * c3 + 1];
      let r6 = c3 - 1;
      for (; r6 >= 0 && i[n4 + 2 * r6] > t6; r6--)
        i[n4 + 2 * r6 + 2] = i[n4 + 2 * r6], i[n4 + 2 * r6 + 3] = i[n4 + 2 * r6 + 1];
      i[n4 + 2 * r6 + 2] = t6, i[n4 + 2 * r6 + 3] = o6;
    }
  };
  for (let x2 = 0; x2 < n3; x2++)
    y3(c2[x2], c2[x2 + 1]), y3(a3 + e4[x2], a3 + e4[x2 + 1]);
  const A3 = new Int32Array(3 * r4), U = (o5, n4) => o5 === t4[3 * n4] ? 0 : o5 === t4[3 * n4 + 1] ? 1 : o5 === t4[3 * n4 + 2] ? 2 : -1, u5 = (t5, o5) => {
    const n4 = U(t5, o5);
    A3[3 * o5 + n4] = -1;
  }, p4 = (t5, o5, n4, r5) => {
    const c3 = U(t5, o5);
    A3[3 * o5 + c3] = r5;
    const e5 = U(n4, r5);
    A3[3 * r5 + e5] = o5;
  };
  for (let x2 = 0; x2 < n3; x2++) {
    let t5 = c2[x2];
    const o5 = c2[x2 + 1];
    let n4 = e4[x2];
    const r5 = e4[x2 + 1];
    for (; t5 < o5 && n4 < r5; ) {
      const o6 = i[2 * t5], r6 = i[2 * a3 + 2 * n4];
      o6 === r6 ? (p4(x2, i[2 * t5 + 1], r6, i[2 * a3 + 2 * n4 + 1]), t5++, n4++) : o6 < r6 ? (u5(x2, i[2 * t5 + 1]), t5++) : (u5(r6, i[2 * a3 + 2 * n4 + 1]), n4++);
    }
    for (; t5 < o5; )
      u5(x2, i[2 * t5 + 1]), t5++;
    for (; n4 < r5; ) {
      u5(i[2 * a3 + 2 * n4], i[2 * a3 + 2 * n4 + 1]), n4++;
    }
  }
  return A3;
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeBufferWriters.js
var a = class {
  updateSettings(t4) {
    this.settings = t4, this._edgeHashFunction = t4.reducedPrecision ? f : p2;
  }
  write(t4, o4, e4) {
    const n3 = this._edgeHashFunction(e4);
    y2.seed = n3;
    const i = y2.getIntRange(0, 255), r4 = y2.getIntRange(0, this.settings.variants - 1), s = 0.7, a3 = y2.getFloat(), c2 = 255 * (0.5 * g(-(1 - Math.min(a3 / s, 1)) + Math.max(0, a3 - s) / (1 - s), 1.2) + 0.5);
    t4.position0.setVec(o4, e4.position0), t4.position1.setVec(o4, e4.position1), t4.componentIndex.set(o4, e4.componentIndex), t4.variantOffset.set(o4, i), t4.variantStroke.set(o4, r4), t4.variantExtension.set(o4, c2);
  }
  trim(t4, o4) {
    return t4.slice(0, o4);
  }
};
var c = new Float32Array(6);
var m2 = new Uint32Array(c.buffer);
var u3 = new Uint32Array(1);
function p2(t4) {
  const o4 = c;
  o4[0] = t4.position0[0], o4[1] = t4.position0[1], o4[2] = t4.position0[2], o4[3] = t4.position1[0], o4[4] = t4.position1[1], o4[5] = t4.position1[2], u3[0] = 5381;
  for (let e4 = 0; e4 < m2.length; e4++)
    u3[0] = 31 * u3[0] + m2[e4];
  return u3[0];
}
function f(t4) {
  const o4 = c;
  o4[0] = h2(t4.position0[0]), o4[1] = h2(t4.position0[1]), o4[2] = h2(t4.position0[2]), o4[3] = h2(t4.position1[0]), o4[4] = h2(t4.position1[1]), o4[5] = h2(t4.position1[2]), u3[0] = 5381;
  for (let e4 = 0; e4 < m2.length; e4++)
    u3[0] = 31 * u3[0] + m2[e4];
  return u3[0];
}
var l2 = 1e4;
function h2(t4) {
  return Math.round(t4 * l2) / l2;
}
function g(t4, o4) {
  const e4 = t4 < 0 ? -1 : 1;
  return Math.abs(t4) ** o4 * e4;
}
var d2 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t4) {
    this._commonWriter.updateSettings(t4);
  }
  allocate(t4) {
    return S.createBuffer(t4);
  }
  write(t4, n3, i) {
    this._commonWriter.write(t4, n3, i), u(_2, i.faceNormal0, i.faceNormal1), z(_2, _2), t4.normal.setVec(n3, _2);
  }
  trim(t4, o4) {
    return this._commonWriter.trim(t4, o4);
  }
};
d2.Layout = S, d2.glLayout = r2(S, 1);
var w3 = class {
  constructor() {
    this._commonWriter = new a();
  }
  updateSettings(t4) {
    this._commonWriter.updateSettings(t4);
  }
  allocate(t4) {
    return r3.createBuffer(t4);
  }
  write(t4, o4, e4) {
    this._commonWriter.write(t4, o4, e4), t4.normalA.setVec(o4, e4.faceNormal0), t4.normalB.setVec(o4, e4.faceNormal1);
  }
  trim(t4, o4) {
    return this._commonWriter.trim(t4, o4);
  }
};
w3.Layout = r3, w3.glLayout = r2(r3, 1);
var _2 = n();
var y2 = new t();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/edgeRendering/edgeProcessing.js
function f2(e4) {
  const t4 = u4(e4.data, e4.skipDeduplicate, e4.indices, e4.indicesLength);
  return p3.updateSettings(e4.writerSettings), d3.updateSettings(e4.writerSettings), p(t4, p3, d3);
}
function u4(i, r4, n3, o4) {
  if (r4) {
    const e4 = t3(n3, o4, i.count);
    return new g2(n3, o4, e4, i);
  }
  const c2 = e2(i.buffer, i.stride / 4, { originalIndices: n3, originalIndicesLength: o4 }), f3 = t3(c2.indices, o4, c2.uniqueCount);
  return { faces: c2.indices, facesLength: c2.indices.length, neighbors: f3, vertices: A.createView(c2.buffer) };
}
var g2 = class {
  constructor(e4, t4, i, r4) {
    this.faces = e4, this.facesLength = t4, this.neighbors = i, this.vertices = r4;
  }
};
var p3 = new d2();
var d3 = new w3();
var a2 = H2().vec3f(O.POSITION0).vec3f(O.POSITION1);
var m3 = H2().vec3f(O.POSITION0).vec3f(O.POSITION1).u16(O.COMPONENTINDEX).u16(O.U16PADDING, { glPadding: true });

export {
  A,
  p,
  f2 as f,
  u4 as u,
  a2 as a,
  m3 as m
};
//# sourceMappingURL=chunk-AJL3PX3E.js.map
