import {
  C,
  D,
  O as O2,
  R as R2,
  S as S2,
  S2 as S3,
  T,
  U,
  a as a5,
  b as b2,
  c as c2,
  i as i4,
  j as j5,
  j2 as j6,
  k as k2,
  l as l3,
  l2 as l4,
  m as m3,
  n as n2,
  o as o5,
  o2 as o6,
  r as r2,
  s as s5,
  w,
  y as y4
} from "./chunk-PYW2PGBH.js";
import {
  i as i3
} from "./chunk-T3UXUOZW.js";
import "./chunk-FLVP2XLK.js";
import {
  o as o4
} from "./chunk-E4GDJ764.js";
import "./chunk-Z2T56FN3.js";
import "./chunk-ZMKH5ZRU.js";
import {
  j as j4
} from "./chunk-P46VVEIN.js";
import {
  a as a3
} from "./chunk-5NBE4HDI.js";
import "./chunk-4NLQ63FV.js";
import "./chunk-Y7HVH6RU.js";
import {
  t as t2
} from "./chunk-2HDAD5Q3.js";
import {
  c
} from "./chunk-PPU6QR6F.js";
import {
  O
} from "./chunk-PCVJI7J2.js";
import "./chunk-HZHMZHPT.js";
import "./chunk-NU5WEWCI.js";
import "./chunk-UIVGJZCT.js";
import "./chunk-MVR2W3C6.js";
import {
  d as d2
} from "./chunk-RNXN3MSP.js";
import "./chunk-4NWXO2LT.js";
import "./chunk-6ETVGJDF.js";
import "./chunk-KTII3LWY.js";
import {
  l as l2
} from "./chunk-JDYLSHC3.js";
import "./chunk-QAWS7Y22.js";
import "./chunk-UX5D32RO.js";
import "./chunk-NYLF7BL2.js";
import "./chunk-32JSK7KN.js";
import "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import {
  b
} from "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import {
  f as f2,
  i as i2
} from "./chunk-YBMFRTPB.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import "./chunk-SCOBW7KR.js";
import "./chunk-AHAGGZUI.js";
import {
  h
} from "./chunk-4SARN32Z.js";
import {
  k
} from "./chunk-QA4FMJA6.js";
import {
  S2 as S,
  j2 as j3,
  m as m2,
  y as y3
} from "./chunk-VFQINJTY.js";
import "./chunk-4J6R7QH6.js";
import "./chunk-HB3KZNZ3.js";
import "./chunk-42RWGG3D.js";
import {
  y as y2
} from "./chunk-G5WJIWPP.js";
import {
  a as a4
} from "./chunk-LNMNRMVX.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ZBWBCN2I.js";
import {
  i
} from "./chunk-KTEJJM3A.js";
import {
  Rn,
  nn
} from "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-CGK6BJQA.js";
import {
  b as b3
} from "./chunk-XU2Q4SCK.js";
import "./chunk-KIEN3CY2.js";
import "./chunk-4CZO65BK.js";
import "./chunk-7E3Q7HTF.js";
import "./chunk-FXDEKQIL.js";
import "./chunk-GJ5WE5D3.js";
import "./chunk-KKGH4SRQ.js";
import "./chunk-Y2CLYMXQ.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import {
  x as x2
} from "./chunk-D5MIJ6WT.js";
import {
  j as j7
} from "./chunk-7KX64CAH.js";
import "./chunk-J4R3XNTP.js";
import "./chunk-Y6FRAP2R.js";
import {
  n
} from "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import {
  p as p2
} from "./chunk-T4XWQYGC.js";
import {
  o as o3
} from "./chunk-4H5JODOT.js";
import {
  m2 as m,
  u
} from "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-CWQ6Q3PH.js";
import {
  a as a2
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-N5ULYWRU.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-MOIETNWJ.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  f,
  j,
  o2,
  p,
  r,
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import {
  s as s4
} from "./chunk-VBD33VNW.js";
import {
  l
} from "./chunk-7A5C2EQ3.js";
import {
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import {
  v
} from "./chunk-2YSHZRCT.js";
import {
  j as j2
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  L,
  bt
} from "./chunk-O3CHVGVF.js";
import {
  d
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s,
  s2,
  s3
} from "./chunk-W2N7YT6I.js";
import {
  o,
  t
} from "./chunk-I5JT24BO.js";
import {
  R
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p3 = class extends l {
  constructor(o7) {
    super(o7), this.break = new y3({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y3({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y3({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y3({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y3({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y3({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
e([y({ types: j3 })], p3.prototype, "break", void 0), e([y({ types: j3 })], p3.prototype, "first", void 0), e([y({ types: j3 })], p3.prototype, "unlocated", void 0), e([y({ types: j3 })], p3.prototype, "last", void 0), e([y({ types: j3 })], p3.prototype, "middle", void 0), e([y({ types: j3 })], p3.prototype, "waypoint", void 0), p3 = e([a("esri.layers.support.RouteStopSymbols")], p3);
var l5 = p3;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var c3 = class extends l {
  constructor(o7) {
    super(o7), this.directionLines = new m2({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y3({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y3({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new m2({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new m2({ width: 8, color: [20, 89, 127] }), this.stops = new l5();
  }
};
e([y({ types: j3 })], c3.prototype, "directionLines", void 0), e([y({ types: j3 })], c3.prototype, "directionPoints", void 0), e([y({ types: j3 })], c3.prototype, "pointBarriers", void 0), e([y({ types: j3 })], c3.prototype, "polygonBarriers", void 0), e([y({ types: j3 })], c3.prototype, "polylineBarriers", void 0), e([y({ types: j3 })], c3.prototype, "routeInfo", void 0), e([y({ type: l5 })], c3.prototype, "stops", void 0), c3 = e([a("esri.layers.support.RouteSymbols")], c3);
var n3 = c3;

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var u2 = class extends l {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
e([y({ type: String })], u2.prototype, "dataType", void 0), e([o3(U, { ignoreUnknown: false })], u2.prototype, "name", void 0), e([y({ type: [String] })], u2.prototype, "parameterNames", void 0), e([y({ type: String })], u2.prototype, "restrictionUsageParameterName", void 0), e([o3(y4, { ignoreUnknown: false })], u2.prototype, "timeNeutralAttributeName", void 0), e([y({ type: String })], u2.prototype, "trafficSupport", void 0), e([o3(s5)], u2.prototype, "units", void 0), e([o3(R2)], u2.prototype, "usageType", void 0), u2 = e([a("esri.rest.support.NetworkAttribute")], u2);
var m4 = u2;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p4 = class extends l {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
e([y({ type: Number })], p4.prototype, "buildTime", void 0), e([y({ type: String })], p4.prototype, "name", void 0), e([y({ type: [m4] })], p4.prototype, "networkAttributes", void 0), e([y()], p4.prototype, "networkSources", void 0), e([y({ type: String })], p4.prototype, "state", void 0), p4 = e([a("esri.rest.support.NetworkDataset")], p4);
var i5 = p4;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c4 = class extends l {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => U.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r3) {
    null != t4 && t4.length && (e2[r3] = t4.map((t5) => U.toJSON(t5)));
  }
  readDefaultTravelMode(t4, e2) {
    var _a, _b;
    const r3 = ((_a = e2.supportedTravelModes) == null ? void 0 : _a.find(({ id: t5 }) => t5 === e2.defaultTravelMode)) ?? ((_b = e2.supportedTravelModes) == null ? void 0 : _b.find(({ itemId: t5 }) => t5 === e2.defaultTravelMode));
    return r3 ? j5.fromJSON(r3) : null;
  }
};
e([y()], c4.prototype, "accumulateAttributeNames", void 0), e([o2("accumulateAttributeNames")], c4.prototype, "readAccumulateAttributes", null), e([r("accumulateAttributeNames")], c4.prototype, "writeAccumulateAttributes", null), e([y()], c4.prototype, "attributeParameterValues", void 0), e([y()], c4.prototype, "currentVersion", void 0), e([y()], c4.prototype, "defaultTravelMode", void 0), e([o2("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c4.prototype, "readDefaultTravelMode", null), e([y()], c4.prototype, "directionsLanguage", void 0), e([o3(r2)], c4.prototype, "directionsLengthUnits", void 0), e([y()], c4.prototype, "directionsSupportedLanguages", void 0), e([o3(y4, { ignoreUnknown: false })], c4.prototype, "directionsTimeAttribute", void 0), e([y()], c4.prototype, "hasZ", void 0), e([o3(U, { ignoreUnknown: false })], c4.prototype, "impedance", void 0), e([y({ type: i5 })], c4.prototype, "networkDataset", void 0), e([y({ type: [j5] })], c4.prototype, "supportedTravelModes", void 0), c4 = e([a("esri.rest.support.NetworkServiceDescription")], c4);
var m5 = c4;

// node_modules/@arcgis/core/rest/networkService.js
var l6 = s2.getLogger("esri.rest.networkService");
function u3(e2, r3, t4, o7) {
  o7[t4] = [r3.length, r3.length + e2.length], e2.forEach((e3) => {
    r3.push(e3.geometry);
  });
}
function f3(e2, r3) {
  for (let t4 = 0; t4 < r3.length; t4++) {
    const o7 = e2[r3[t4]];
    if (o7 && o7.length)
      for (const e3 of o7)
        e3.z = void 0;
  }
  l6.warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c5(e2, r3) {
  for (let t4 = 0; t4 < r3.length; t4++) {
    const o7 = e2[r3[t4]];
    if (o7 && o7.length) {
      for (const e3 of o7)
        if (null != e3 && e3.hasZ)
          return true;
    }
  }
  return false;
}
async function d3(t4, o7, s7) {
  if (!t4)
    throw new s3("network-service:missing-url", "Url to Network service is missing");
  const n6 = i2({ f: "json", token: o7 }, s7), { data: l9 } = await j2(t4, n6), u6 = l9.currentVersion >= 10.4 ? p5(t4, o7, s7) : v2(t4, s7), { defaultTravelMode: f4, supportedTravelModes: c15 } = await u6;
  return l9.defaultTravelMode = f4, l9.supportedTravelModes = c15, m5.fromJSON(l9);
}
async function v2(r3, t4) {
  var _a, _b, _c;
  const i9 = i2({ f: "json" }, t4), { data: l9 } = await j2(r3.replace(/\/rest\/.*$/i, "/info"), i9);
  if (!l9 || !l9.owningSystemUrl)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u6 } = l9, f4 = bt(u6) + "/sharing/rest/portals/self", { data: c15 } = await j2(f4, i9), d4 = t("helperServices.routingUtilities.url", c15);
  if (!d4)
    return { supportedTravelModes: [], defaultTravelMode: null };
  const v3 = f2(u6), p11 = /\/solve$/i.test(v3.path) ? "Route" : /\/solveclosestfacility$/i.test(v3.path) ? "ClosestFacility" : "ServiceAreas", m8 = i2({ f: "json", serviceName: p11 }, t4), h2 = bt(d4) + "/GetTravelModes/execute", g = await j2(h2, m8), w2 = [];
  let T2 = null;
  if ((_b = (_a = g == null ? void 0 : g.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e2 = g.data.results;
    for (const r4 of e2)
      if ("supportedTravelModes" === r4.paramName) {
        if ((_c = r4.value) == null ? void 0 : _c.features) {
          for (const { attributes: e3 } of r4.value.features)
            if (e3) {
              const r5 = JSON.parse(e3.TravelMode);
              w2.push(r5);
            }
        }
      } else
        "defaultTravelMode" === r4.paramName && (T2 = r4.value);
  }
  return { supportedTravelModes: w2, defaultTravelMode: T2 };
}
async function p5(t4, o7, n6) {
  try {
    const r3 = i2({ f: "json", token: o7 }, n6), i9 = bt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l9, defaultTravelMode: u6 } } = await j2(i9, r3);
    return { supportedTravelModes: l9, defaultTravelMode: u6 };
  } catch (i9) {
    throw new s3("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i9 });
  }
}

// node_modules/@arcgis/core/rest/support/GPMessage.js
var p6 = new s4({ esriJobMessageTypeInformative: "informative", esriJobMessageTypeProcessDefinition: "process-definition", esriJobMessageTypeProcessStart: "process-start", esriJobMessageTypeProcessStop: "process-stop", esriJobMessageTypeWarning: "warning", esriJobMessageTypeError: "error", esriJobMessageTypeEmpty: "empty", esriJobMessageTypeAbort: "abort" });
var i6 = class extends l {
  constructor(e2) {
    super(e2), this.description = null, this.type = null;
  }
};
e([y({ type: String, json: { write: true } })], i6.prototype, "description", void 0), e([y({ type: String, json: { read: p6.read, write: p6.write } })], i6.prototype, "type", void 0), i6 = e([a("esri.rest.support.GPMessage")], i6);
var a6 = i6;

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p7 = new s4({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c6 = class extends a6 {
  constructor(r3) {
    super(r3), this.type = null;
  }
};
e([y({ type: String, json: { read: p7.read, write: p7.write } })], c6.prototype, "type", void 0), c6 = e([a("esri.rest.support.NAMessage")], c6);
var a7 = c6;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c7 = class extends l {
  constructor(r3) {
    super(r3);
  }
};
e([y({ json: { read: { source: "string" } } })], c7.prototype, "text", void 0), e([o3(b2, { name: "stringType" })], c7.prototype, "type", void 0), c7 = e([a("esri.rest.support.DirectionsString")], c7);
var i7 = c7;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a8 = class extends l {
  constructor(r3) {
    super(r3), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r3, e2) {
    return n2(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r3, e2) {
    return x.fromJSON(e2.point);
  }
};
e([y({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a8.prototype, "arriveTime", void 0), e([y()], a8.prototype, "arriveTimeOffset", void 0), e([o2("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a8.prototype, "readArriveTimeOffset", null), e([y({ type: x })], a8.prototype, "geometry", void 0), e([o2("geometry", ["point"])], a8.prototype, "readGeometry", null), e([y({ type: [i7] })], a8.prototype, "strings", void 0), a8 = e([a("esri.rest.support.DirectionsEvent")], a8);
var c8 = a8;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function i8(r3) {
  if (null == r3 || "" === r3)
    return null;
  let e2 = 0, t4 = 0, s7 = 0, o7 = 0;
  const p11 = [];
  let n6, c15, i9, a10, m8, l9, u6, f4, y6 = 0, d4 = 0, h2 = 0;
  if (m8 = r3.match(/((\+|\-)[^\+\-\|]+|\|)/g), m8 || (m8 = []), 0 === parseInt(m8[y6], 32)) {
    y6 = 2;
    const r4 = parseInt(m8[y6], 32);
    y6++, l9 = parseInt(m8[y6], 32), y6++, 1 & r4 && (d4 = m8.indexOf("|") + 1, u6 = parseInt(m8[d4], 32), d4++), 2 & r4 && (h2 = m8.indexOf("|", d4) + 1, f4 = parseInt(m8[h2], 32), h2++);
  } else
    l9 = parseInt(m8[y6], 32), y6++;
  for (; y6 < m8.length && "|" !== m8[y6]; ) {
    n6 = parseInt(m8[y6], 32) + e2, y6++, e2 = n6, c15 = parseInt(m8[y6], 32) + t4, y6++, t4 = c15;
    const r4 = [n6 / l9, c15 / l9];
    d4 && (a10 = parseInt(m8[d4], 32) + s7, d4++, s7 = a10, r4.push(a10 / u6)), h2 && (i9 = parseInt(m8[h2], 32) + o7, h2++, o7 = i9, r4.push(i9 / f4)), p11.push(r4);
  }
  return { paths: [p11], hasZ: d4 > 0, hasM: h2 > 0 };
}
var a9 = class extends h {
  constructor(r3) {
    super(r3), this.events = null, this.strings = null;
  }
  readGeometry(r3, e2) {
    const t4 = i8(e2.compressedGeometry);
    return null != t4 ? m.fromJSON(t4) : null;
  }
};
e([y({ type: [c8] })], a9.prototype, "events", void 0), e([o2("geometry", ["compressedGeometry"])], a9.prototype, "readGeometry", null), e([y({ type: [i7] })], a9.prototype, "strings", void 0), a9 = e([a("esri.rest.support.DirectionsFeature")], a9);
var m6 = a9;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function u4(e2, t4) {
  if (0 === e2.length)
    return new m({ spatialReference: t4 });
  const r3 = [];
  for (const n6 of e2)
    for (const e3 of n6.paths)
      r3.push(...e3);
  const o7 = [];
  r3.forEach((e3, t5) => {
    0 !== t5 && e3[0] === r3[t5 - 1][0] && e3[1] === r3[t5 - 1][1] || o7.push(e3);
  });
  const { hasM: s7, hasZ: a10 } = e2[0];
  return new m({ hasM: s7, hasZ: a10, paths: [o7], spatialReference: t4 });
}
var m7 = class extends d2 {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t4) {
    if (!e2)
      return [];
    const r3 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o7 = r3 && f.fromJSON(r3);
    return e2.map((e3) => {
      const t5 = m6.fromJSON(e3);
      if (null != t5.geometry && (t5.geometry.spatialReference = o7), null != t5.events)
        for (const r4 of t5.events)
          null != r4.geometry && (r4.geometry.spatialReference = o7);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features)
      return null;
    return u4(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.map(({ strings: e2 }) => e2).flat().filter(R);
  }
};
e([y({ type: M, json: { read: { source: "summary.envelope" } } })], m7.prototype, "extent", void 0), e([y({ nonNullable: true })], m7.prototype, "features", void 0), e([o2("features")], m7.prototype, "readFeatures", null), e([y()], m7.prototype, "geometryType", void 0), e([y({ readOnly: true })], m7.prototype, "mergedGeometry", null), e([y()], m7.prototype, "routeId", void 0), e([y()], m7.prototype, "routeName", void 0), e([y({ value: null, readOnly: true })], m7.prototype, "strings", null), e([y({ json: { read: { source: "summary.totalDriveTime" } } })], m7.prototype, "totalDriveTime", void 0), e([y({ json: { read: { source: "summary.totalLength" } } })], m7.prototype, "totalLength", void 0), e([y({ json: { read: { source: "summary.totalTime" } } })], m7.prototype, "totalTime", void 0), m7 = e([a("esri.rest.support.DirectionsFeatureSet")], m7);
var c9 = m7;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n4 = class extends l {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e([y({ type: d2, json: { write: true } })], n4.prototype, "directionLines", void 0), e([y({ type: d2, json: { write: true } })], n4.prototype, "directionPoints", void 0), e([y({ type: c9, json: { write: true } })], n4.prototype, "directions", void 0), e([y({ type: h, json: { write: true } })], n4.prototype, "route", void 0), e([y({ type: String, json: { write: true } })], n4.prototype, "routeName", void 0), e([y({ type: [h], json: { write: true } })], n4.prototype, "stops", void 0), e([y({ type: d2, json: { write: true } })], n4.prototype, "traversedEdges", void 0), e([y({ type: d2, json: { write: true } })], n4.prototype, "traversedJunctions", void 0), e([y({ type: d2, json: { write: true } })], n4.prototype, "traversedTurns", void 0), n4 = e([a("esri.rest.support.RouteResult")], n4);
var u5 = n4;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function n5(r3) {
  return r3 ? d2.fromJSON(r3).features.filter(R) : [];
}
var c10 = class extends l {
  constructor(r3) {
    super(r3), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r3, o7) {
    return n5(o7.barriers);
  }
  readPolylineBarriers(r3) {
    return n5(r3);
  }
  readPolygonBarriers(r3) {
    return n5(r3);
  }
};
e([y({ type: [a7] })], c10.prototype, "messages", void 0), e([y({ type: [h] })], c10.prototype, "pointBarriers", void 0), e([o2("pointBarriers", ["barriers"])], c10.prototype, "readPointBarriers", null), e([y({ type: [h] })], c10.prototype, "polylineBarriers", void 0), e([o2("polylineBarriers")], c10.prototype, "readPolylineBarriers", null), e([y({ type: [h] })], c10.prototype, "polygonBarriers", void 0), e([o2("polygonBarriers")], c10.prototype, "readPolygonBarriers", null), e([y({ type: [u5] })], c10.prototype, "routeResults", void 0), c10 = e([a("esri.rest.support.RouteSolveResult")], c10);
var y5 = c10;

// node_modules/@arcgis/core/rest/route.js
function p8(e2) {
  return e2 instanceof d2;
}
async function c11(u6, f4, c15) {
  const m8 = [], y6 = [], d4 = {}, g = {}, h2 = f2(u6), { path: R4 } = h2;
  p8(f4.stops) && u3(f4.stops.features, y6, "stops.features", d4), p8(f4.pointBarriers) && u3(f4.pointBarriers.features, y6, "pointBarriers.features", d4), p8(f4.polylineBarriers) && u3(f4.polylineBarriers.features, y6, "polylineBarriers.features", d4), p8(f4.polygonBarriers) && u3(f4.polygonBarriers.features, y6, "polygonBarriers.features", d4);
  const v3 = await b(y6);
  for (const e2 in d4) {
    const r3 = d4[e2];
    m8.push(e2), g[e2] = v3.slice(r3[0], r3[1]);
  }
  if (c5(g, m8)) {
    let e2 = null;
    try {
      e2 = await d3(R4, f4.apiKey, c15);
    } catch {
    }
    e2 && !e2.hasZ && f3(g, m8);
  }
  for (const e2 in g)
    g[e2].forEach((r3, t4) => {
      f4.get(e2)[t4].geometry = r3;
    });
  const B = { ...c15, query: { ...h2.query, ...o6(f4), f: "json" } }, E = R4.endsWith("/solve") ? R4 : `${R4}/solve`, { data: T2 } = await j2(E, B);
  return l7(T2);
}
function l7(e2) {
  const { barriers: r3, directionLines: t4, directionPoints: s7, directions: o7, messages: a10, polygonBarriers: n6, polylineBarriers: i9, routes: u6, stops: p11, traversedEdges: c15, traversedJunctions: l9, traversedTurns: m8 } = e2, y6 = (e3) => {
    const r4 = g.find((r5) => r5.routeName === e3);
    if (null != r4)
      return r4;
    const t5 = { routeId: g.length + 1, routeName: e3 };
    return g.push(t5), t5;
  }, d4 = (e3) => {
    const r4 = g.find((r5) => r5.routeId === e3);
    if (null != r4)
      return r4;
    const t5 = { routeId: e3, routeName: null };
    return g.push(t5), t5;
  }, g = [];
  u6 == null ? void 0 : u6.features.forEach((e3, r4) => {
    e3.geometry.spatialReference = u6.spatialReference ?? void 0;
    const t5 = e3.attributes.Name, s8 = r4 + 1;
    g.push({ routeId: s8, routeName: t5, route: e3 });
  }), o7 == null ? void 0 : o7.forEach((e3) => {
    const { routeName: r4 } = e3;
    y6(r4).directions = e3;
  });
  const h2 = ((p11 == null ? void 0 : p11.features.every((e3) => null == e3.attributes.RouteName)) ?? false) && g.length > 0 ? g[0].routeName : null;
  return p11 == null ? void 0 : p11.features.forEach((e3) => {
    var _a;
    e3.geometry && ((_a = e3.geometry).spatialReference ?? (_a.spatialReference = p11.spatialReference ?? void 0));
    const r4 = h2 ?? e3.attributes.RouteName, t5 = y6(r4);
    t5.stops ?? (t5.stops = []), t5.stops.push(e3);
  }), t4 == null ? void 0 : t4.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, s8 = d4(r4), { geometryType: o8, spatialReference: a11 } = t4;
    s8.directionLines ?? (s8.directionLines = { features: [], geometryType: o8, spatialReference: a11 }), s8.directionLines.features.push(e3);
  }), s7 == null ? void 0 : s7.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d4(r4), { geometryType: o8, spatialReference: a11 } = s7;
    t5.directionPoints ?? (t5.directionPoints = { features: [], geometryType: o8, spatialReference: a11 }), t5.directionPoints.features.push(e3);
  }), c15 == null ? void 0 : c15.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d4(r4), { geometryType: s8, spatialReference: o8 } = c15;
    t5.traversedEdges ?? (t5.traversedEdges = { features: [], geometryType: s8, spatialReference: o8 }), t5.traversedEdges.features.push(e3);
  }), l9 == null ? void 0 : l9.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d4(r4), { geometryType: s8, spatialReference: o8 } = l9;
    t5.traversedJunctions ?? (t5.traversedJunctions = { features: [], geometryType: s8, spatialReference: o8 }), t5.traversedJunctions.features.push(e3);
  }), m8 == null ? void 0 : m8.features.forEach((e3) => {
    const r4 = e3.attributes.RouteID, t5 = d4(r4);
    t5.traversedTurns ?? (t5.traversedTurns = { features: [] }), t5.traversedTurns.features.push(e3);
  }), y5.fromJSON({ routeResults: g, barriers: r3, polygonBarriers: n6, polylineBarriers: i9, messages: a10 });
}

// node_modules/@arcgis/core/rest/support/commonProperties.js
var t3 = { type: String, json: { read: { source: "token" }, write: { target: "token" } } };

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l8 = class extends i(l) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
e([y({ type: Boolean, json: { write: true } })], l8.prototype, "doNotLocateOnRestrictedElements", void 0), e([y({ types: n, json: { read: p2, write: true } })], l8.prototype, "geometry", void 0), e([o3(w)], l8.prototype, "geometryType", void 0), e([y({ type: String, json: { name: "layerName", write: true } })], l8.prototype, "name", void 0), e([o3(S2, { name: "spatialRel" })], l8.prototype, "spatialRelationship", void 0), e([y({ type: String, json: { write: true } })], l8.prototype, "type", void 0), e([y({ type: String, json: { write: true } })], l8.prototype, "where", void 0), l8 = e([a("esri.rest.support.DataLayer")], l8);
var c12 = l8;

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s6;
var c13 = s6 = class extends d2 {
  constructor(e2) {
    super(e2), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s6({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
e([y({ type: Boolean, json: { write: true } })], c13.prototype, "doNotLocateOnRestrictedElements", void 0), c13 = s6 = e([a("esri.rest.support.NetworkFeatureSet")], c13);
var p9 = c13;

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p10 = class extends i(l) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
e([y({ type: Boolean, json: { write: true } })], p10.prototype, "doNotLocateOnRestrictedElements", void 0), e([y({ type: String, json: { write: true } })], p10.prototype, "url", void 0), p10 = e([a("esri.rest.support.NetworkUrl")], p10);
var c14 = p10;

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var N;
var P = N = class extends i(l) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return v(N, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => U.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r3) {
    null != t4 && t4.length && (e2[r3] = t4.map((t5) => U.toJSON(t5)));
  }
  writePointBarriers(t4, e2, r3) {
    D2(t4, e2, r3);
  }
  writePolygonBarrier(t4, e2, r3) {
    D2(t4, e2, r3);
  }
  writePolylineBarrier(t4, e2, r3) {
    D2(t4, e2, r3);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => D.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e2, r3) {
    null != t4 && t4.length && (e2[r3] = t4.map((t5) => D.toJSON(t5)));
  }
  readStartTime(t4, e2) {
    const { startTime: r3 } = e2;
    return null == r3 ? null : "now" === r3 ? "now" : new Date(r3);
  }
  writeStartTime(t4, e2) {
    null != t4 && (e2.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e2) {
    return C2(e2.stops);
  }
  writeStops(t4, e2, r3) {
    D2(t4, e2, r3);
  }
};
e([y({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P.prototype, "accumulateAttributes", void 0), e([o2("accumulateAttributes")], P.prototype, "readAccumulateAttributes", null), e([r("accumulateAttributes")], P.prototype, "writeAccumulateAttributes", null), e([y(t3)], P.prototype, "apiKey", void 0), e([y({ json: { write: true } })], P.prototype, "attributeParameterValues", void 0), e([y({ type: String, json: { write: true } })], P.prototype, "directionsLanguage", void 0), e([o3(r2)], P.prototype, "directionsLengthUnits", void 0), e([o3(a5)], P.prototype, "directionsOutputType", void 0), e([o3(k2)], P.prototype, "directionsStyleName", void 0), e([o3(y4, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P.prototype, "directionsTimeAttribute", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "findBestSequence", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "geometryPrecisionM", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "geometryPrecisionZ", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "ignoreInvalidLocations", void 0), e([o3(U, { name: "impedanceAttributeName", ignoreUnknown: false })], P.prototype, "impedanceAttribute", void 0), e([y({ type: Number, json: { write: true } })], P.prototype, "outputGeometryPrecision", void 0), e([o3(i4)], P.prototype, "outputGeometryPrecisionUnits", void 0), e([o3(o5)], P.prototype, "outputLines", void 0), e([y({ type: f, json: { name: "outSR", write: true } })], P.prototype, "outSpatialReference", void 0), e([y({ json: { write: true } })], P.prototype, "overrides", void 0), e([y({ json: { name: "barriers", write: true } })], P.prototype, "pointBarriers", void 0), e([r("pointBarriers")], P.prototype, "writePointBarriers", null), e([y({ json: { write: true } })], P.prototype, "polygonBarriers", void 0), e([r("polygonBarriers")], P.prototype, "writePolygonBarrier", null), e([y({ json: { write: true } })], P.prototype, "polylineBarriers", void 0), e([r("polylineBarriers")], P.prototype, "writePolylineBarrier", null), e([y({ type: Boolean, json: { write: true } })], P.prototype, "preserveFirstStop", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "preserveLastStop", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "preserveObjectID", void 0), e([y({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P.prototype, "restrictionAttributes", void 0), e([o2("restrictionAttributes")], P.prototype, "readRestrictionAttributes", null), e([r("restrictionAttributes")], P.prototype, "writeRestrictionAttributes", null), e([o3(l3)], P.prototype, "restrictUTurns", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnDirections", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnPolygonBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnPolylineBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnRoutes", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnStops", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedEdges", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedJunctions", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnTraversedTurns", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "returnZ", void 0), e([y({ type: Date, json: { type: Number, write: true } })], P.prototype, "startTime", void 0), e([o2("startTime")], P.prototype, "readStartTime", null), e([r("startTime")], P.prototype, "writeStartTime", null), e([y({ type: Boolean, json: { write: true } })], P.prototype, "startTimeIsUTC", void 0), e([y({ json: { write: true } })], P.prototype, "stops", void 0), e([o2("stops")], P.prototype, "readStops", null), e([r("stops")], P.prototype, "writeStops", null), e([y({ type: Boolean, json: { write: true } })], P.prototype, "timeWindowsAreUTC", void 0), e([y({ type: j5, json: { write: true } })], P.prototype, "travelMode", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "useHierarchy", void 0), e([y({ type: Boolean, json: { write: true } })], P.prototype, "useTimeWindows", void 0), P = N = e([a("esri.rest.support.RouteParameters")], P);
var O3 = P;
function U2(t4) {
  return t4 && "type" in t4;
}
function J(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function L2(t4) {
  return t4 && "url" in t4;
}
function R3(t4) {
  return t4 && "features" in t4;
}
function C2(t4) {
  return U2(t4) ? c12.fromJSON(t4) : L2(t4) ? c14.fromJSON(t4) : J(t4) ? p9.fromJSON(t4) : R3(t4) ? d2.fromJSON(t4) : null;
}
function D2(t4, e2, o7) {
  null != t4 && (e2[o7] = V.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}

// node_modules/@arcgis/core/layers/RouteLayer.js
function z(e2) {
  return e2.length ? e2 : null;
}
function K(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: K("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: K("esriGeometryPolyline") };
  }
}
function Q(e2) {
  return "layers" in e2;
}
function Y(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function Z(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function $(e2, t4, r3) {
  var _a, _b, _c, _d, _e, _f;
  const o7 = (_a = t4.networkDataset) == null ? void 0 : _a.networkAttributes, i9 = (o7 == null ? void 0 : o7.filter(({ usageType: e3 }) => "cost" === e3)) ?? [], s7 = r3.travelMode ?? t4.defaultTravelMode;
  if (null == s7)
    return void pe.warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: l9, distanceAttributeName: a10 } = s7, u6 = i9.find(({ name: e3 }) => e3 === l9), p11 = i9.find(({ name: e3 }) => e3 === a10), c15 = ((_b = r3.travelMode) == null ? void 0 : _b.impedanceAttributeName) ?? r3.impedanceAttribute ?? t4.impedance, m8 = u6 == null ? void 0 : u6.units, y6 = p11 == null ? void 0 : p11.units;
  if (!m8 || !y6)
    throw new s3("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f4 = r3.directionsLanguage ?? t4.directionsLanguage, d4 = r3.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], h2 = new Set(i9.filter(({ name: e3 }) => e3 === l9 || e3 === a10 || e3 === c15 || null != e3 && d4.includes(e3)).map(({ name: e3 }) => e3)), w2 = (e3) => {
    for (const t5 in e3)
      h2.has(t5) || delete e3[t5];
  };
  for (const n6 of e2.pointBarriers)
    null != n6.costs && (n6.addedCost = n6.costs[c15] ?? 0, w2(n6.costs));
  for (const n6 of e2.polygonBarriers)
    null != n6.costs && (n6.scaleFactor = n6.costs[c15] ?? 1, w2(n6.costs));
  for (const n6 of e2.polylineBarriers)
    null != n6.costs && (n6.scaleFactor = n6.costs[c15] ?? 1, w2(n6.costs));
  const { routeInfo: S4 } = e2, { findBestSequence: g, preserveFirstStop: b4, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: P2 } = r3;
  S4.analysisSettings = new l4({ accumulateAttributes: d4, directionsLanguage: f4, findBestSequence: g, preserveFirstStop: b4, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: P2, travelMode: s7 }), S4.totalDuration = ee(((_c = S4.totalCosts) == null ? void 0 : _c[l9]) ?? 0, m8), S4.totalDistance = te(((_d = S4.totalCosts) == null ? void 0 : _d[a10]) ?? 0, y6), S4.totalLateDuration = ee(((_e = S4.totalViolations) == null ? void 0 : _e[l9]) ?? 0, m8), S4.totalWaitDuration = ee(((_f = S4.totalWait) == null ? void 0 : _f[l9]) ?? 0, m8), null != S4.totalCosts && w2(S4.totalCosts), null != S4.totalViolations && w2(S4.totalViolations), null != S4.totalWait && w2(S4.totalWait);
  for (const n6 of e2.stops)
    null != n6.serviceCosts && (n6.serviceDuration = ee(n6.serviceCosts[l9] ?? 0, m8), n6.serviceDistance = te(n6.serviceCosts[a10] ?? 0, y6), w2(n6.serviceCosts)), null != n6.cumulativeCosts && (n6.cumulativeDuration = ee(n6.cumulativeCosts[l9] ?? 0, m8), n6.cumulativeDistance = te(n6.cumulativeCosts[a10] ?? 0, y6), w2(n6.cumulativeCosts)), null != n6.violations && (n6.lateDuration = ee(n6.violations[l9] ?? 0, m8), w2(n6.violations)), null != n6.wait && (n6.waitDuration = ee(n6.wait[l9] ?? 0, m8), w2(n6.wait));
}
async function X(e2) {
  const t4 = f.WGS84;
  return await Rn(e2.spatialReference, t4), nn(e2, t4);
}
function ee(e2, t4) {
  switch (t4) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function te(e2, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e2 : j(e2, t4, "meters");
}
function re(e2) {
  const { attributes: t4, geometry: r3, popupTemplate: o7, symbol: i9 } = e2.toGraphic().toJSON();
  return { attributes: t4, geometry: r3, popupInfo: o7, symbol: i9 };
}
var oe = V.ofType(m3);
var ie = V.ofType(c2);
var se = V.ofType(C);
var ne = V.ofType(T);
var le = V.ofType(j6);
var ae = V.ofType(O2);
var ue = "esri.layers.RouteLayer";
var pe = s2.getLogger(ue);
var ce = class extends a3(t2(c(j4(O(a4(b3)))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new n3(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new se(), this.polygonBarriers = new ne(), this.polylineBarriers = new le(), this.routeInfo = null, this.spatialReference = f.WGS84, this.stops = new ae(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(a2(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e2, t4, r3, o7) {
    const i9 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s7 = i9.map((e3, t5) => t5), n6 = "web-map" === o7.origin ? "featureCollection.layers" : "layers";
    o(n6, i9, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s7;
  }
  readDirectionLines(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e3) => m3.fromGraphic(e3));
  }
  readDirectionPoints(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e3) => c2.fromGraphic(e3));
  }
  get fullExtent() {
    const e2 = new M({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: f.WGS84 });
    if (null != this.routeInfo && null != this.routeInfo.geometry)
      return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops)
      return e2;
    const t4 = this.stops.filter((e3) => null != e3.geometry);
    if (t4.length < 2)
      return e2;
    const { spatialReference: r3 } = t4.at(0).geometry;
    if (null == r3)
      return e2;
    const o7 = t4.toArray().map((e3) => {
      const t5 = e3.geometry;
      return [t5.x, t5.y];
    });
    return new u({ points: o7, spatialReference: r3 }).extent;
  }
  readMaxScale(e2, t4) {
    var _a;
    const r3 = Q(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o7 = r3 == null ? void 0 : r3.find((e3) => null != e3.layerDefinition.maxScale);
    return (o7 == null ? void 0 : o7.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e2, t4) {
    var _a;
    const r3 = Q(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o7 = r3 == null ? void 0 : r3.find((e3) => null != e3.layerDefinition.minScale);
    return (o7 == null ? void 0 : o7.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e3) => C.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e3) => T.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e3) => j6.fromGraphic(e3));
  }
  readRouteInfo(e2, t4) {
    const r3 = this._getNetworkFeatures(t4, "RouteInfo", (e3) => S3.fromGraphic(e3));
    return r3.length > 0 ? r3.at(0) : null;
  }
  readSpatialReference(e2, t4) {
    var _a, _b;
    const r3 = Q(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers;
    if (!(r3 == null ? void 0 : r3.length))
      return f.WGS84;
    const { layerDefinition: o7, featureSet: i9 } = r3[0], s7 = i9.features[0], n6 = ((_b = s7 == null ? void 0 : s7.geometry) == null ? void 0 : _b.spatialReference) ?? i9.spatialReference ?? o7.spatialReference ?? o7.extent.spatialReference ?? p;
    return f.fromJSON(n6);
  }
  readStops(e2, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e3) => O2.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    return null != this.routeInfo && null != this.routeInfo.name ? this.routeInfo.name : "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y2(e2, pe)) : this._set("url", s.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t4 } = this;
    if (!t4)
      throw new s3("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id)
      throw new s3("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type)
      throw new s3("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (null == this.routeInfo)
      throw new s3("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r3 } = t4;
    await r3.signIn(), r3.user || await t4.reload();
    const { itemUrl: o7, itemControl: i9 } = t4;
    if ("admin" !== i9 && "update" !== i9)
      throw new s3("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s7 = { messages: [], origin: "portal-item", portal: r3, url: o7 ? L(o7) : void 0, writtenProperties: [] }, l9 = this.write(void 0, s7);
    return t4.extent = await X(e2), t4.title = this.title, await t4.update({ data: l9 }), t4;
  }
  async saveAs(e2, t4 = {}) {
    var _a;
    if (await this.load(), null == this.routeInfo)
      throw new s3("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r3 = x2.from(e2).clone();
    r3.extent ?? (r3.extent = await X(this.fullExtent)), r3.id = null, r3.portal ?? (r3.portal = j7.getDefault()), r3.title ?? (r3.title = this.title), r3.type = "Feature Collection", r3.typeKeywords = ["Data", "Feature Collection", l2.MULTI_LAYER, "Route Layer"];
    const { portal: o7 } = r3, i9 = { messages: [], origin: "portal-item", portal: o7, url: null, writtenProperties: [] };
    await o7.signIn();
    const s7 = t4 == null ? void 0 : t4.folder, l9 = this.write(void 0, i9);
    return await ((_a = o7.user) == null ? void 0 : _a.addItem({ item: r3, folder: s7, data: l9 })), this.portalItem = r3, i3(i9), i9.portalItem = r3, r3;
  }
  async solve(e2, t4) {
    const r3 = (e2 == null ? void 0 : e2.stops) ?? this.stops, o7 = (e2 == null ? void 0 : e2.pointBarriers) ?? z(this.pointBarriers), i9 = (e2 == null ? void 0 : e2.polylineBarriers) ?? z(this.polylineBarriers), l9 = (e2 == null ? void 0 : e2.polygonBarriers) ?? z(this.polygonBarriers);
    if (null == r3)
      throw new s3("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Y(r3) || Z(r3)) && r3.features.length < 2 || V.isCollection(r3) && r3.length < 2)
      throw new s3("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r3))
      for (const s7 of r3)
        s7.routeName = null;
    const a10 = e2 == null ? void 0 : e2.apiKey, u6 = this.url, p11 = await this._getServiceDescription(u6, a10, t4), m8 = (e2 == null ? void 0 : e2.travelMode) ?? p11.defaultTravelMode, y6 = (e2 == null ? void 0 : e2.accumulateAttributes) ?? [];
    null != m8 && (y6.push(m8.distanceAttributeName), m8.timeAttributeName && y6.push(m8.timeAttributeName));
    const f4 = { startTime: /* @__PURE__ */ new Date() }, d4 = { accumulateAttributes: y6, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o7, polylineBarriers: i9, polygonBarriers: l9, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o7, returnDirections: true, returnPolygonBarriers: !!l9, returnPolylineBarriers: !!i9, returnRoutes: true, returnStops: true, stops: r3 }, h2 = e2 ? O3.from(e2) : new O3();
    for (const s7 in f4)
      null == h2[s7] && (h2[s7] = f4[s7]);
    let w2;
    h2.set(d4);
    try {
      w2 = await c11(u6, h2, t4);
    } catch (g) {
      throw d(g) ? g : new s3("routelayer:failed-route-request", "the routing request failed", { error: g });
    }
    const S4 = this._toRouteLayerSolution(w2);
    return this._isOverridden("title") || (this.title = S4.routeInfo.name ?? "Route"), $(S4, p11, h2), S4;
  }
  update(e2) {
    const { stops: t4, directionLines: r3, directionPoints: o7, pointBarriers: i9, polylineBarriers: s7, polygonBarriers: n6, routeInfo: l9 } = e2;
    this.set({ stops: t4, pointBarriers: i9, polylineBarriers: s7, polygonBarriers: n6 }), this._set("directionLines", r3), this._set("directionPoints", o7), this._set("routeInfo", l9), null != l9.geometry && (this.spatialReference = l9.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t4, n6, l9) {
    var _a;
    const a10 = Q(e2) ? e2.layers : (_a = e2.featureCollection) == null ? void 0 : _a.layers, u6 = a10 == null ? void 0 : a10.find((e3) => e3.layerDefinition.name === t4);
    if (null == u6)
      return new V();
    const { layerDefinition: p11, popupInfo: c15, featureSet: m8 } = u6, y6 = p11.drawingInfo.renderer, { features: f4 } = m8, d4 = m8.spatialReference ?? p11.spatialReference ?? p11.extent.spatialReference ?? p, h2 = y6 && o4(y6), w2 = f.fromJSON(d4), S4 = f4.map((e3) => {
      const i9 = h.fromJSON(e3);
      null != i9.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i9.geometry.spatialReference = w2);
      const s7 = n6(i9);
      return s7.symbol ?? (s7.symbol = (h2 == null ? void 0 : h2.getSymbol(i9)) ?? this._getNetworkSymbol(t4)), s7.popupTemplate ?? (s7.popupTemplate = c15 && k.fromJSON(c15)), s7;
    });
    return l9 && S4.some((e3) => !e3.symbol) && l9(S4), new V(S4);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t4, r3) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2)
      return this._cachedServiceDescription.serviceDescription;
    const o7 = await d3(e2, t4, r3);
    return this._cachedServiceDescription = { serviceDescription: o7, url: e2 }, o7;
  }
  _setStopSymbol(e2) {
    if (!e2 || 0 === e2.length)
      return;
    if (null == this.defaultSymbols.stops)
      return;
    if (e2.every(({ symbol: e3 }) => null != e3))
      return;
    const { first: t4, last: r3, middle: o7, unlocated: i9, waypoint: s7, break: n6 } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e2.length)
      return void e2.forEach((i10, s8) => {
        switch (s8) {
          case 0:
            i10.symbol = t4;
            break;
          case e2.length - 1:
            i10.symbol = r3;
            break;
          default:
            i10.symbol = o7;
        }
      });
    const l9 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), a10 = Math.min(...l9), u6 = Math.max(...l9);
    for (const p11 of e2)
      p11.sequence !== a10 ? p11.sequence !== u6 ? "ok" === p11.status || "not-located-on-closest" === p11.status ? "waypoint" !== p11.locationType ? "break" !== p11.locationType ? p11.symbol = o7 : p11.symbol = n6 : p11.symbol = s7 : p11.symbol = i9 : p11.symbol = r3 : p11.symbol = t4;
  }
  _toRouteLayerSolution(e2) {
    var _a, _b, _c, _d, _e, _f, _g;
    const t4 = (_a = e2.routeResults[0].stops) == null ? void 0 : _a.map((e3) => O2.fromJSON(e3.toJSON()));
    this._setStopSymbol(t4);
    const r3 = new ae(t4), o7 = new ne((_b = e2.polygonBarriers) == null ? void 0 : _b.map((e3) => {
      const t5 = T.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), i9 = new le((_c = e2.polylineBarriers) == null ? void 0 : _c.map((e3) => {
      const t5 = j6.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), s7 = new se((_d = e2.pointBarriers) == null ? void 0 : _d.map((e3) => {
      const t5 = C.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), n6 = (_e = e2.routeResults[0].route) == null ? void 0 : _e.toJSON(), l9 = S3.fromJSON(n6);
    l9.symbol = this.defaultSymbols.routeInfo;
    const a10 = new ie((_f = e2.routeResults[0].directionPoints) == null ? void 0 : _f.features.map((e3) => {
      const t5 = c2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { directionLines: new oe((_g = e2.routeResults[0].directionLines) == null ? void 0 : _g.features.map((e3) => {
      const t5 = m3.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: a10, pointBarriers: s7, polygonBarriers: o7, polylineBarriers: i9, routeInfo: l9, stops: r3 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", m3.fields, m3.popupInfo, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", c2.fields, c2.popupInfo, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t4, r3, o7, i9, s7, n6) {
    if (null == e2 || !e2.length)
      return null;
    const l9 = this.spatialReference.toJSON(), { fullExtent: a10, maxScale: u6, minScale: p11 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => re(e3)), geometryType: r3, spatialReference: l9 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : K(r3) } }, extent: a10.toJSON(), fields: o7, geometryType: r3, hasM: false, hasZ: false, maxScale: u6, minScale: p11, name: s7, objectIdField: "ObjectID", spatialReference: l9, title: n6, type: "Feature Layer", typeIdField: "" }, popupInfo: i9 };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", C.fields, C.popupInfo, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", T.fields, T.popupInfo, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j6.fields, j6.popupInfo, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", S3.fields, S3.popupInfo, "RouteInfo", "Route Details");
  }
  _writeStops() {
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", O2.fields, O2.popupInfo, "Stops", "Stops");
    if (null == e2)
      return null;
    const { stops: t4 } = this.defaultSymbols, r3 = null != t4 && null != t4.first && t4.first.toJSON(), o7 = null != t4 && null != t4.middle && t4.middle.toJSON(), i9 = null != t4 && null != t4.last && t4.last.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o7, uniqueValueInfos: [{ value: "1", symbol: r3, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i9, label: "Last Stop" }] }, e2;
  }
};
e([y({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], ce.prototype, "_featureCollection", void 0), e([r(["web-map", "portal-item"], "_featureCollection")], ce.prototype, "writeFeatureCollectionWebmap", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], ce.prototype, "_type", void 0), e([y({ nonNullable: true, type: n3 })], ce.prototype, "defaultSymbols", void 0), e([y({ readOnly: true })], ce.prototype, "directionLines", void 0), e([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], ce.prototype, "readDirectionLines", null), e([y({ readOnly: true })], ce.prototype, "directionPoints", void 0), e([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], ce.prototype, "readDirectionPoints", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], ce.prototype, "featureCollectionType", void 0), e([y({ readOnly: true })], ce.prototype, "fullExtent", null), e([y({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], ce.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide"] })], ce.prototype, "listMode", void 0), e([y({ type: Number, nonNullable: true, json: { write: false } })], ce.prototype, "maxScale", void 0), e([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], ce.prototype, "readMaxScale", null), e([y({ type: Number, nonNullable: true, json: { write: false } })], ce.prototype, "minScale", void 0), e([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], ce.prototype, "readMinScale", null), e([y({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], ce.prototype, "operationalLayerType", void 0), e([y({ nonNullable: true, type: V.ofType(C) })], ce.prototype, "pointBarriers", void 0), e([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], ce.prototype, "readPointBarriers", null), e([y({ nonNullable: true, type: V.ofType(T) })], ce.prototype, "polygonBarriers", void 0), e([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], ce.prototype, "readPolygonBarriers", null), e([y({ nonNullable: true, type: V.ofType(j6) })], ce.prototype, "polylineBarriers", void 0), e([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], ce.prototype, "readPolylineBarriers", null), e([y({ readOnly: true })], ce.prototype, "routeInfo", void 0), e([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], ce.prototype, "readRouteInfo", null), e([y({ type: f })], ce.prototype, "spatialReference", void 0), e([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], ce.prototype, "readSpatialReference", null), e([y({ nonNullable: true, type: V.ofType(O2) })], ce.prototype, "stops", void 0), e([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], ce.prototype, "readStops", null), e([y()], ce.prototype, "title", null), e([y({ readOnly: true, json: { read: false } })], ce.prototype, "type", void 0), e([y()], ce.prototype, "url", null), ce = e([a(ue)], ce);
var me = ce;
export {
  me as default
};
//# sourceMappingURL=RouteLayer-WODWJQSK.js.map
