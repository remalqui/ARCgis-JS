import {
  B,
  h as h3,
  r as r4
} from "./chunk-FNTT27FW.js";
import "./chunk-HPXPYN62.js";
import {
  X,
  Y,
  b as b3
} from "./chunk-H4E57LVR.js";
import {
  S as S2
} from "./chunk-QLQDVQ2I.js";
import {
  o
} from "./chunk-4OFTYAJJ.js";
import {
  I as I2,
  a as a3,
  r as r3,
  u as u3
} from "./chunk-M46PRYMF.js";
import {
  t as t4
} from "./chunk-PM77FW2O.js";
import {
  I
} from "./chunk-AC3INPLN.js";
import "./chunk-C3ULZZZU.js";
import {
  n as n5,
  s as s6
} from "./chunk-XP6ESZGI.js";
import "./chunk-3VTULECI.js";
import "./chunk-A4HFWKMU.js";
import "./chunk-TDXHXKUI.js";
import "./chunk-TBHRKIAA.js";
import "./chunk-CKK5HS7D.js";
import {
  c as c3
} from "./chunk-JSMUQBPG.js";
import {
  a as a2,
  p,
  s as s5
} from "./chunk-QAWS7Y22.js";
import "./chunk-P34MS5MD.js";
import "./chunk-FHYNSVC4.js";
import "./chunk-FF5LS3YE.js";
import "./chunk-BCDDCNQ2.js";
import {
  f as f4,
  m as m4
} from "./chunk-HTY52TPQ.js";
import {
  b
} from "./chunk-YC4PIRSZ.js";
import "./chunk-MSLDEOHR.js";
import "./chunk-B5TYSRH2.js";
import "./chunk-YIJWIXDP.js";
import {
  b as b2,
  h
} from "./chunk-6DURKJBD.js";
import {
  n as n4
} from "./chunk-FN5LEP6H.js";
import {
  ee
} from "./chunk-R6YQG4NY.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-BKDPNGLX.js";
import {
  f as f3,
  g as g2
} from "./chunk-D5EV57FM.js";
import {
  r as r2
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-YBMFRTPB.js";
import {
  It,
  K,
  L,
  M as M2,
  N,
  at,
  ht,
  it,
  st,
  tt,
  yt
} from "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import {
  e as e2,
  t as t2
} from "./chunk-TDPKDZC3.js";
import {
  t as t3
} from "./chunk-M5UHI5WR.js";
import "./chunk-Z36PKTLY.js";
import "./chunk-YAWND7HF.js";
import "./chunk-RR2V4HRU.js";
import "./chunk-WZAASLQW.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-PRUCXFZ4.js";
import "./chunk-KLV5OJVG.js";
import {
  m as m3
} from "./chunk-TQGXXOXA.js";
import "./chunk-SO7CVIZK.js";
import {
  d as d4
} from "./chunk-OSBD2NL4.js";
import {
  h as h4
} from "./chunk-5K6FTFN4.js";
import {
  i as i3
} from "./chunk-FQZ2JEHK.js";
import "./chunk-CNCZBOLJ.js";
import {
  u as u2
} from "./chunk-PNA6D76Z.js";
import {
  h as h2
} from "./chunk-NDQCNJMM.js";
import "./chunk-R2HXL6HT.js";
import "./chunk-2PAQQUAG.js";
import "./chunk-QXPTMFGZ.js";
import {
  j as j5
} from "./chunk-PX3FFFQ5.js";
import "./chunk-Y2ZDD3I4.js";
import "./chunk-MUO4EIZP.js";
import {
  c
} from "./chunk-42RWGG3D.js";
import {
  w
} from "./chunk-G5WJIWPP.js";
import {
  c as c2,
  d as d3
} from "./chunk-LNMNRMVX.js";
import "./chunk-OO4A3EBQ.js";
import "./chunk-ITRH3PGV.js";
import "./chunk-BRDC7DKL.js";
import {
  i as i2
} from "./chunk-ZBWBCN2I.js";
import "./chunk-GZTLZ6RD.js";
import "./chunk-KTEJJM3A.js";
import "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import "./chunk-EIE3W25Z.js";
import "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import "./chunk-4RFFPIT2.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import {
  j as j4
} from "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import {
  i
} from "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import {
  f as f2,
  j as j2,
  l
} from "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import {
  n as n3
} from "./chunk-WBSPL6CJ.js";
import "./chunk-LQVUN6IS.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  S2 as S,
  d as d2,
  f,
  s as s4
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import {
  m as m2,
  y3 as y2
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a,
  n as n2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j as j3
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import "./chunk-O3CHVGVF.js";
import {
  C,
  P,
  d,
  g,
  j,
  m,
  s as s3,
  y
} from "./chunk-HNHXEGH2.js";
import {
  n,
  r,
  u
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import {
  R,
  has,
  t
} from "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/views/2d/layers/features/processors.js
function o2(o6) {
  return "heatmap" === o6 ? import("./HeatmapProcessor-M2GG2KO4.js") : import("./SymbolProcessor-EZ6GCVJP.js");
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n6 = 268435455;
var o3 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a4(a7, i6, c9 = false) {
  var _a;
  const f8 = 1, d8 = 3, u7 = 9, g5 = 12, l5 = 13, p6 = 15, h8 = a7.asUnsafe(), b4 = h8.pos(), w4 = new o3();
  let m9 = 0, y6 = 0;
  const k2 = 1, x3 = 2, I5 = 4, L4 = 3;
  let A3 = null, F3 = null, C2 = null, S6 = false;
  const j7 = [];
  for (; h8.next(); )
    switch (h8.tag()) {
      case f8:
        A3 = h8.getString();
        break;
      case d8:
        F3 = h8.getString();
        break;
      case g5:
        C2 = h8.processMessage(h);
        break;
      case u7:
        if (w4.exceededTransferLimit = h8.getBool(), w4.exceededTransferLimit) {
          w4.offsets.geometry = c9 ? new Float64Array(8e3) : new Int32Array(8e3), w4.centroid = c9 ? new Float64Array(16e3) : new Int32Array(16e3);
          for (let e3 = 0; e3 < w4.centroid.length; e3++)
            w4.centroid[e3] = n6;
        }
        break;
      case l5: {
        const e3 = h8.processMessage(b2);
        e3.index = m9++, j7.push(e3);
        break;
      }
      case p6: {
        const e3 = h8.getLength(), t6 = h8.pos() + e3;
        if (!w4.exceededTransferLimit) {
          const e4 = w4.offsets.geometry, t7 = w4.centroid;
          e4.push(0), t7.push(n6), t7.push(n6);
        }
        !S6 && w4.exceededTransferLimit && (S6 = true, w4.offsets.attributes = c9 ? new Float64Array(8e3 * m9) : new Uint32Array(8e3 * m9));
        let s10 = y6 * m9;
        for (; h8.pos() < t6 && h8.next(); )
          switch (h8.tag()) {
            case k2: {
              if (S6)
                w4.offsets.attributes[s10++] = h8.pos();
              else {
                w4.offsets.attributes.push(h8.pos());
              }
              const e4 = h8.getLength();
              h8.skipLen(e4);
              break;
            }
            case x3:
              if (i6) {
                const e4 = h8.getLength(), t7 = h8.pos() + e4;
                for (; h8.pos() < t7 && h8.next(); )
                  switch (h8.tag()) {
                    case L4: {
                      h8.getUInt32();
                      const e5 = h8.getSInt64(), t8 = h8.getSInt64();
                      w4.centroid[2 * y6] = e5, w4.centroid[2 * y6 + 1] = t8;
                      break;
                    }
                    default:
                      h8.skip();
                  }
              } else {
                w4.offsets.geometry[y6] = h8.pos();
                const e4 = h8.getLength();
                w4.vertexCount += e4, h8.skipLen(e4);
              }
              break;
            case I5: {
              const e4 = h8.getLength(), t7 = h8.pos() + e4;
              for (; h8.pos() < t7 && h8.next(); )
                switch (h8.tag()) {
                  case L4: {
                    h8.getUInt32();
                    const e5 = h8.getSInt64(), t8 = h8.getSInt64();
                    w4.centroid[2 * y6] = e5, w4.centroid[2 * y6 + 1] = t8;
                    break;
                  }
                  default:
                    h8.skip();
                }
              break;
            }
            default:
              h8.skip();
          }
        y6++, w4.hasFeatures = true;
        break;
      }
      default:
        h8.skip();
    }
  const U2 = A3 || F3;
  if (!U2)
    throw new s2("FeatureSet has no objectId or globalId field name");
  return w4.fields = new r2(j7), w4.featureCount = y6, w4.fieldCount = m9, w4.objectIdFieldIndex = (_a = w4.fields.get(U2)) == null ? void 0 : _a.index, w4.transform = C2, w4.displayIds = new Uint32Array(w4.featureCount), w4.groupIds = new Uint16Array(w4.featureCount), h8.move(b4), w4;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var u4 = true;
var c4 = 268435455;
var g3 = 128;
var l2 = 128e3;
var _ = { small: { delta: new Int32Array(g3), decoded: new Int32Array(g3) }, large: { delta: new Int32Array(l2), decoded: new Int32Array(l2) } };
function f5(e3) {
  return e3 <= _.small.delta.length ? _.small : (e3 <= _.large.delta.length || (_.large.delta = new Int32Array(Math.round(1.25 * e3)), _.large.decoded = new Int32Array(Math.round(1.25 * e3))), _.large);
}
function y3(r6) {
  try {
    const e3 = 2, t6 = new n4(new Uint8Array(r6), new DataView(r6));
    for (; t6.next(); ) {
      if (t6.tag() === e3)
        return I3(t6.getMessage());
      t6.skip();
    }
  } catch (i6) {
    const r7 = new s2("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: i6 });
    s.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r7);
  }
  return null;
}
function I3(e3) {
  const t6 = 1;
  for (; e3.next(); ) {
    if (e3.tag() === t6)
      return e3.getMessage();
    e3.skip();
  }
  return null;
}
function p2(e3) {
  const t6 = 1, r6 = 2, s10 = 3, i6 = 4, n8 = 5, a7 = 6, h8 = 7, o6 = 8, d8 = 9, u7 = e3.getLength(), c9 = e3.pos() + u7;
  for (; e3.pos() < c9 && e3.next(); )
    switch (e3.tag()) {
      case t6:
        return e3.getString();
      case r6:
        return e3.getFloat();
      case s10:
        return e3.getDouble();
      case i6:
        return e3.getSInt32();
      case n8:
        return e3.getUInt32();
      case a7:
        return e3.getInt64();
      case h8:
        return e3.getUInt64();
      case o6:
        return e3.getSInt64();
      case d8:
        return e3.getBool();
      default:
        return e3.skip(), null;
    }
  return null;
}
function m5(e3, t6, r6, s10, i6, n8) {
  return 0.5 * Math.abs(e3 * s10 + r6 * n8 + i6 * t6 - e3 * n8 - r6 * t6 - i6 * s10);
}
function x(e3, t6, r6, s10) {
  return 0 === e3 * s10 - r6 * t6 && e3 * r6 + t6 * s10 > 0;
}
var S3 = class _S extends I {
  static fromBuffer(e3, t6, r6 = false) {
    const s10 = t6.geometryType, i6 = y3(e3), n8 = a4(i6, "esriGeometryPoint" === s10, r6), a7 = I.createInstance();
    return new _S(a7, i6, n8, t6);
  }
  constructor(e3, t6, r6, s10) {
    super(e3, s10), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._geometryType = s10.geometryType, this._reader = t6, this._header = r6, this._hasNext = r6.hasFeatures, this._isPoints = "esriGeometryPoint" === s10.geometryType;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get stride() {
    return 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getQuantizationTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e3) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e3;
  }
  getAttributeHash() {
    let e3 = "";
    for (const t6 of this._header.fields.fields)
      e3 += this._readAttributeAtIndex(t6.index) + ".";
    return e3;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e3) {
    this._header.displayIds[this._featureIndex] = e3;
  }
  getGroupId() {
    return this._header.groupIds[this._featureIndex];
  }
  setGroupId(e3) {
    this._header.groupIds[this._featureIndex] = e3;
  }
  readLegacyFeature() {
    if (void 0 === this._cache.legacyFeature) {
      const e3 = this.readCentroid(), t6 = { attributes: this.readAttributes(), geometry: this._isPoints ? this.readLegacyPointGeometry() : this.readLegacyGeometry(), centroid: (e3 && { x: e3.coords[0], y: e3.coords[1] }) ?? null };
      return this._cache.legacyFeature = t6, t6;
    }
    return this._cache.legacyFeature;
  }
  readOptimizedFeature() {
    if (void 0 === this._cache.optFeature) {
      const e3 = new t2(this.readGeometry(), this.readAttributes(), this.readCentroid());
      return e3.objectId = this.getObjectId(), e3.displayId = this.getDisplayId(), this._cache.optFeature = e3, e3;
    }
    return this._cache.optFeature;
  }
  getXHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex], t6 = this.getQuantizationTransform();
    return null == t6 ? e3 : e3 * t6.scale[0] + t6.translate[0];
  }
  getYHydrated() {
    const e3 = this._header.centroid[2 * this._featureIndex + 1], t6 = this.getQuantizationTransform();
    return null == t6 ? e3 : t6.translate[1] - e3 * t6.scale[1];
  }
  getX() {
    return this._header.centroid[2 * this._featureIndex] * this._sx + this._tx;
  }
  getY() {
    return this._header.centroid[2 * this._featureIndex + 1] * this._sy + this._ty;
  }
  readLegacyPointGeometry() {
    return { x: this.getX(), y: this.getY() };
  }
  readLegacyGeometry(e3) {
    const t6 = this.readUnquantizedGeometry(e3);
    return st(t6, this.geometryType, false, false);
  }
  readLegacyCentroid() {
    const e3 = this.readCentroid();
    if (!e3)
      return null;
    const [t6, r6] = e3.coords;
    return { x: t6, y: r6 };
  }
  readGeometryArea() {
    return this._cache.area || this.readGeometry(true), this._cache.area;
  }
  readUnquantizedGeometry(e3 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t6 = this.readGeometry(e3);
      if (!t6)
        return this._cache.unquantGeometry = void 0, null;
      const r6 = f5(t6.coords.length).decoded, s10 = t6.clone(r6), i6 = s10.coords;
      let n8 = 0;
      for (const e4 of s10.lengths) {
        for (let t7 = 1; t7 < e4; t7++) {
          const e5 = 2 * (n8 + t7), r7 = 2 * (n8 + t7 - 1);
          i6[e5] += i6[r7], i6[e5 + 1] += i6[r7 + 1];
        }
        n8 += e4;
      }
      return this._cache.unquantGeometry = s10, s10;
    }
    return this._cache.unquantGeometry;
  }
  readHydratedGeometry() {
    if (this._isPoints) {
      if (this._header.centroid[2 * this._featureIndex] === c4)
        return null;
      const e4 = this.getXHydrated(), t7 = this.getYHydrated();
      return new t3([], [e4, t7]);
    }
    const e3 = this.readGeometry();
    if (!e3)
      return null;
    const t6 = e3.clone(), r6 = this.getQuantizationTransform();
    return null != r6 && It(t6, t6, this.hasZ, this.hasM, r6), t6;
  }
  readGeometry(e3 = false) {
    if (void 0 === this._cache.geometry) {
      let r6 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === c4)
          return null;
        const e4 = this.getX(), t6 = this.getY();
        r6 = new t3([], [e4, t6]);
      } else {
        const s10 = this._header.offsets.geometry[this._featureIndex], i6 = this._reader;
        if (0 === s10) {
          const e4 = this._readServerCentroid();
          if (!e4)
            return null;
          const [t6, r7] = e4.coords;
          return this.createQuantizedExtrudedQuad(t6, r7);
        }
        i6.move(s10);
        try {
          if (r6 = e3 ? this._parseGeometryForDisplay(i6) : this._parseGeometry(i6), null === r6) {
            const e4 = this._readServerCentroid();
            if (!e4)
              return null;
            const [t6, r7] = e4.coords;
            return this.createQuantizedExtrudedQuad(t6, r7);
          }
        } catch (t6) {
          return console.error("Failed to parse geometry!", t6), null;
        }
      }
      return this._cache.geometry = r6, r6;
    }
    return this._cache.geometry;
  }
  readCentroid() {
    if (void 0 === this._cache.centroid) {
      let e3;
      return e3 = this._computeCentroid(), e3 || (e3 = this._readServerCentroid()), this._cache.centroid = e3 ?? void 0, e3 ?? null;
    }
    return this._cache.centroid;
  }
  copy() {
    const e3 = this._reader.clone(), t6 = new _S(this.instance, e3, this._header, this.fullSchema());
    return this.copyInto(t6), t6;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); )
      ;
    return this._featureIndex < this._size;
  }
  _readAttribute(e3, t6) {
    var _a;
    const r6 = this._header.fields.get(e3);
    if (null == r6)
      return;
    let s10 = this._readAttributeAtIndex(r6.index);
    "esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e3)) == null ? void 0 : _a.type) && (s10 = this.parseTimestampOffset(s10));
    const i6 = this._header.fields.isDateField(r6.name);
    return t6 ? null == s10 ? s10 : i6 ? new Date(s10) : s10 : s10;
  }
  _readAttributes() {
    const e3 = {};
    for (const t6 of this._header.fields.fields)
      e3[t6.name] = this._readAttributeAtIndex(t6.index);
    return e3;
  }
  copyInto(e3) {
    super.copyInto(e3), e3._featureIndex = this._featureIndex, e3._featureOffset = this._featureOffset, e3._hasNext = this._hasNext;
  }
  _readAttributeAtIndex(e3) {
    const t6 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e3], r6 = this._reader;
    return r6.move(t6), p2(r6);
  }
  _readServerCentroid() {
    const e3 = this._header.centroid[2 * this._featureIndex] + this._tx, t6 = this._header.centroid[2 * this._featureIndex + 1] + this._ty;
    return e3 === c4 ? null : new t3([], [e3, t6]);
  }
  _parseGeometry(e3) {
    const t6 = 2, r6 = 3, s10 = e3.asUnsafe(), i6 = s10.getLength(), n8 = s10.pos() + i6, a7 = [], o6 = [];
    for (; s10.pos() < n8 && s10.next(); )
      switch (s10.tag()) {
        case t6: {
          const e4 = s10.getUInt32(), t7 = s10.pos() + e4;
          for (; s10.pos() < t7; )
            o6.push(s10.getUInt32());
          break;
        }
        case r6: {
          const e4 = s10.getUInt32(), t7 = s10.pos() + e4;
          for (a7.push(s10.getSInt32() + this._tx), a7.push(s10.getSInt32() + this._ty), this.hasZ && s10.getSInt32(), this.hasM && s10.getSInt32(); s10.pos() < t7; )
            a7.push(s10.getSInt32()), a7.push(s10.getSInt32()), this.hasZ && s10.getSInt32(), this.hasM && s10.getSInt32();
          break;
        }
        default:
          s10.skip();
      }
    return new t3(o6, a7);
  }
  _parseGeometryForDisplay(e3) {
    const t6 = 2, s10 = 3, i6 = e3.asUnsafe(), n8 = i6.getLength(), a7 = i6.pos() + n8, o6 = [], d8 = [];
    let c9 = 0, g5 = 0, l5 = null, _3 = 0;
    const y6 = "esriGeometryPolygon" === this.geometryType;
    for (; i6.pos() < a7 && i6.next(); )
      switch (i6.tag()) {
        case t6: {
          const e4 = i6.getUInt32(), t7 = i6.pos() + e4;
          for (; i6.pos() < t7; ) {
            const e5 = i6.getUInt32();
            o6.push(e5), c9 += e5;
          }
          l5 = f5(2 * c9).delta;
          break;
        }
        case s10: {
          i6.getUInt32();
          const e4 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
          r(l5);
          for (const t7 of o6)
            if (g5 + e4 * t7 > l5.length)
              for (let e5 = 0; e5 < t7; e5++)
                i6.getSInt32(), i6.getSInt32(), this.hasZ && i6.getSInt32(), this.hasM && i6.getSInt32();
            else if (y6 && u4) {
              const e5 = this.getAreaSimplificationThreshold(t7, this._header.vertexCount);
              let r6 = 2, s11 = 1;
              const n9 = false;
              let a8 = i6.getSInt32(), h8 = i6.getSInt32();
              l5[g5++] = a8, l5[g5++] = h8, this.hasZ && i6.getSInt32(), this.hasM && i6.getSInt32();
              let o7 = i6.getSInt32(), u7 = i6.getSInt32();
              for (this.hasZ && i6.getSInt32(), this.hasM && i6.getSInt32(); r6 < t7; ) {
                let t8 = i6.getSInt32(), n10 = i6.getSInt32();
                this.hasZ && i6.getSInt32(), this.hasM && i6.getSInt32();
                const d9 = a8 + o7, c10 = h8 + u7;
                m5(a8, h8, d9, c10, d9 + t8, c10 + n10) >= e5 ? (_3 += -0.5 * (d9 - a8) * (c10 + h8), s11 > 1 && x(l5[g5 - 2], l5[g5 - 1], o7, u7) ? (l5[g5 - 2] += o7, l5[g5 - 1] += u7) : (l5[g5++] = o7, l5[g5++] = u7, s11++), a8 = d9, h8 = c10) : (t8 += o7, n10 += u7), o7 = t8, u7 = n10, r6++;
              }
              s11 < 3 || n9 ? g5 -= 2 * s11 : (_3 += -0.5 * (a8 + o7 - a8) * (h8 + u7 + h8), x(l5[g5 - 2], l5[g5 - 1], o7, u7) ? (l5[g5 - 2] += o7, l5[g5 - 1] += u7, d8.push(s11)) : (l5[g5++] = o7, l5[g5++] = u7, d8.push(++s11)));
            } else {
              let e5 = 0, r6 = i6.getSInt32(), s11 = i6.getSInt32();
              this.hasZ && i6.getSInt32(), this.hasM && i6.getSInt32(), l5[g5++] = r6, l5[g5++] = s11, e5 += 1;
              for (let n9 = 1; n9 < t7; n9++) {
                const t8 = i6.getSInt32(), a8 = i6.getSInt32(), h8 = r6 + t8, o7 = s11 + a8;
                _3 += -0.5 * (h8 - r6) * (o7 + s11), this.hasZ && i6.getSInt32(), this.hasM && i6.getSInt32(), n9 > 2 && x(l5[g5 - 2], l5[g5 - 1], t8, a8) ? (l5[g5 - 2] += t8, l5[g5 - 1] += a8) : (l5[g5++] = t8, l5[g5++] = a8, e5 += 1), r6 = h8, s11 = o7;
              }
              d8.push(e5);
            }
          break;
        }
        default:
          i6.skip();
      }
    if (this._cache.area = _3, !d8.length)
      return null;
    if (this._tx || this._ty) {
      let e4 = 0;
      r(l5);
      for (const t7 of d8)
        l5[2 * e4] += this._tx, l5[2 * e4 + 1] += this._ty, e4 += t7;
    }
    return new t3(d8, l5);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/support/sourceAdapters.js
var c5 = class {
  constructor(e3) {
    this.service = e3;
  }
  destroy() {
  }
};
function m6(e3) {
  return Array.isArray(e3.source);
}
function p3(e3) {
  return "ogc-source" === (e3 == null ? void 0 : e3.type);
}
function l3(e3) {
  const { capabilities: t6 } = e3;
  return p3(e3.source) ? new v(e3) : m6(e3) ? new y4(e3) : t6.query.supportsFormatPBF && has("featurelayer-pbf") ? new h5(e3) : new d5(e3);
}
async function f6(t6) {
  const r6 = new h4();
  return await r6.open(t6, {}), r6;
}
var y4 = class extends c5 {
  constructor(e3) {
    super(e3), this._portsOpen = f6(e3.source).then((e4) => this.client = e4);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(e3, t6) {
    await this._portsOpen;
    const r6 = await this.client.invoke("queryFeatures", e3.toJSON(), t6);
    return h3.fromFeatureSet(r6, this.service);
  }
};
var h5 = class extends c5 {
  async executeQuery(e3, t6) {
    const { data: r6 } = await f4(this.service.source, e3, t6), s10 = !e3.quantizationParameters;
    return S3.fromBuffer(r6, this.service, s10);
  }
};
var d5 = class extends c5 {
  async executeQuery(e3, i6) {
    var _a;
    const { source: a7, capabilities: u7, spatialReference: c9, objectIdField: m9, geometryType: p6 } = this.service;
    if (null != e3.quantizationParameters && !u7.query.supportsQuantization) {
      const u8 = e3.clone(), p7 = m3(u8.quantizationParameters);
      u8.quantizationParameters = null;
      const { data: l6 } = await m4(a7, u8, c9, i6), f8 = it(l6, m9);
      return at(p7, f8), h3.fromOptimizedFeatureSet(f8, this.service);
    }
    const { data: l5 } = await m4(a7, e3, this.service.spatialReference, i6);
    return "esriGeometryPoint" === p6 && (l5.features = (_a = l5.features) == null ? void 0 : _a.filter((e4) => {
      if (null != e4.geometry) {
        const t6 = e4.geometry;
        return Number.isFinite(t6.x) && Number.isFinite(t6.y);
      }
      return true;
    })), h3.fromFeatureSet(l5, this.service);
  }
};
var v = class extends c5 {
  async executeQuery(e3, r6) {
    const { capabilities: a7 } = this.service;
    if (e3.quantizationParameters && !a7.query.supportsQuantization) {
      const a8 = e3.clone(), o7 = m3(a8.quantizationParameters);
      a8.quantizationParameters = null;
      const u7 = await S2(this.service.source, e3, r6);
      return at(o7, u7), h3.fromOptimizedFeatureSet(u7, this.service);
    }
    const o6 = await S2(this.service.source, e3, r6);
    return h3.fromOptimizedFeatureSet(o6, this.service);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/UpdateToken.js
var t5 = class _t {
  constructor() {
    this.version = 0, this.source = false, this.targets = { feature: false, aggregate: false }, this.storage = { filters: false, data: false }, this.mesh = false, this.queryFilter = false, this.why = { mesh: [], source: [] };
  }
  static create(e3) {
    const s10 = new _t();
    let r6;
    for (r6 in e3) {
      const t6 = e3[r6];
      if ("object" == typeof t6)
        for (const e4 in t6) {
          const a7 = e4, i6 = t6[a7];
          s10[r6][a7] = i6;
        }
      s10[r6] = t6;
    }
    return s10;
  }
  static empty() {
    return _t.create({});
  }
  static all() {
    return _t.create({ source: true, targets: { feature: true, aggregate: true }, storage: { filters: true, data: true }, mesh: true });
  }
  unset(t6) {
    this.version = t6.version, t6.source && (this.source = false), t6.targets.feature && (this.targets.feature = false), t6.targets.aggregate && (this.targets.aggregate = false), t6.storage.filters && (this.storage.filters = false), t6.storage.data && (this.storage.data = false), t6.mesh && (this.mesh = false), t6.queryFilter && (this.queryFilter = false);
  }
  any() {
    return this.source || this.mesh || this.storage.filters || this.storage.data || this.targets.feature || this.targets.aggregate || this.queryFilter;
  }
  describe() {
    let t6 = 0, e3 = "";
    if (this.mesh) {
      t6 += 20, e3 += "-> (20) Mesh needs update\n";
      for (const t7 of this.why.mesh)
        e3 += `    + ${t7}
`;
    }
    if (this.source) {
      t6 += 10, e3 += "-> (10) The source needs update\n";
      for (const t7 of this.why.source)
        e3 += `    + ${t7}
`;
    }
    this.targets.feature && (t6 += 5, e3 += "-> (5) Feature target parameters changed\n"), this.storage.filters && (t6 += 5, e3 += "-> (5) Feature filter parameters changed\n"), this.targets.aggregate && (t6 += 4, e3 += "-> (4) Aggregate target parameters changed\n"), this.storage.data && (t6 += 1, e3 += "-> (1) Texture storage parameters changed");
    const s10 = t6 < 5 ? "Fastest" : t6 < 10 ? "Fast" : t6 < 15 ? "Moderate" : t6 < 20 ? "Slow" : "Very Slow";
    console.debug(`Applying ${s10} update of cost ${t6}/45 `), console.debug(e3);
  }
  toJSON() {
    return { queryFilter: this.queryFilter, source: this.source, targets: this.targets, storage: this.storage, mesh: this.mesh };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSubscription.js
var d6 = class {
  constructor(e3, r6) {
    this.requests = { done: new Array(), stream: new t4(10) }, this._edits = null, this._abortController = new AbortController(), this._version = 0, this._resolver = C(), this._isDone = false, this.didSend = false, this.tile = e3, this._version = r6;
  }
  get signal() {
    return this._abortController.signal;
  }
  get options() {
    return { signal: this._abortController.signal };
  }
  get empty() {
    return !this.requests.done.length && null == this.edits;
  }
  get edits() {
    return this._edits;
  }
  get done() {
    return this._resolver.promise;
  }
  get isDone() {
    return this._isDone;
  }
  resolve() {
    this._isDone = true, this._resolver.resolve();
  }
  clear() {
    this.requests.done = [];
  }
  applyUpdate(e3) {
    this.requests.done.forEach((s10) => s10.message.status.unset(e3)), this._version = e3.version, null != this._edits && this._edits.status.unset(e3);
  }
  add(e3) {
    e3.message.status = e3.message.status ?? t5.empty(), e3.message.status.version = this._version, has("esri-2d-update-debug") && console.debug(this.tile.id, "DataTileSubscription:add", this._version), e3.message.end && (this.requests.done.forEach((e4) => {
      null != e4.message && e4.message.end && (e4.message.end = false);
    }), this._resolver.resolve(), this._isDone = true), this.requests.done.push(e3);
  }
  edit(s10, t6) {
    const d8 = s10.getQuantizationTransform(), o6 = s10.fullSchema(), a7 = Array.from(s10.features()).filter(R), n8 = [...t6, ...a7.map((e3) => e3.objectId)];
    if (this.removeIds(n8), this._invalidate(), null == this._edits)
      return void (this._edits = { type: "append", addOrUpdate: h3.fromOptimizedFeatures(a7, o6, d8), id: this.tile.id, status: t5.empty(), end: true });
    this.requests.done.forEach((e3) => e3.message.end = false);
    this._edits.addOrUpdate.append(s10.features());
  }
  *readers() {
    for (const { message: e3 } of this.requests.done)
      null != e3.addOrUpdate && (yield e3.addOrUpdate);
    null != this._edits && null != this._edits.addOrUpdate && (yield this._edits.addOrUpdate);
  }
  _invalidate() {
    for (const e3 of this.requests.done)
      e3.message.status = t5.empty();
    null != this._edits && (this._edits.status = t5.empty());
  }
  removeIds(e3) {
    this._invalidate();
    for (const { message: s10 } of this.requests.done) {
      const t6 = s10.addOrUpdate;
      null != t6 && (t6.removeIds(e3), t6.isEmpty && (has("esri-2d-update-debug") && console.debug("Removing FeatureSetReader"), s10.addOrUpdate = null));
    }
    null != this._edits && null != this._edits.addOrUpdate && this._edits.addOrUpdate.removeIds(e3), this.requests.done = this.requests.done.filter((e4) => e4.message.addOrUpdate || e4.message.end);
  }
  abort() {
    this._abortController.abort(), this._resolver.reject();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DataTileSource.js
function p4(e3, s10) {
  const t6 = /* @__PURE__ */ new Set();
  return e3 && e3.forEach((e4) => t6.add(e4)), s10 && s10.forEach((e4) => t6.add(e4)), t6.has("*") ? ["*"] : Array.from(t6);
}
var m7 = class {
  constructor(e3) {
    this.updatingHandles = new c2(), this.events = new n3(), this._resolver = C(), this._didEdit = false, this._subscriptions = /* @__PURE__ */ new Map(), this._outSR = e3.outSR, this._serviceInfo = e3.serviceInfo, this._onTileUpdateMessage = e3.onMessage;
  }
  destroy() {
    for (const e3 of this._subscriptions.values())
      e3.abort();
    this.updatingHandles.destroy();
  }
  get subscriptions() {
    return this._subscriptions.values();
  }
  async _onMessage(e3) {
    const s10 = this._subscriptions.get(e3.id);
    if (!s10)
      return;
    const t6 = { ...e3, remove: e3.remove ?? [], status: e3.status ?? t5.empty() };
    return y(this._onTileUpdateMessage(t6, s10.options));
  }
  update(s10, t6) {
    var _a;
    const i6 = t6.fields.length;
    t6.outFields = p4((_a = this._schema) == null ? void 0 : _a.outFields, t6.outFields), t6.outFields = t6.outFields.length >= 0.75 * i6 ? ["*"] : t6.outFields, t6.outFields.sort();
    const r6 = a2(this._schema, t6);
    if (!r6)
      return;
    has("esri-2d-update-debug") && console.debug("Applying Update - Source:", r6);
    const o6 = "orderByFields" in this._serviceInfo && this._serviceInfo.orderByFields ? this._serviceInfo.orderByFields : this._serviceInfo.objectIdField + " ASC", a7 = { returnCentroid: "esriGeometryPolygon" === this._serviceInfo.geometryType, returnGeometry: true, timeReferenceUnknownClient: "stream" !== this._serviceInfo.type && this._serviceInfo.timeReferenceUnknownClient, outFields: t6.outFields, outSpatialReference: this._outSR, orderByFields: [o6], where: t6.definitionExpression || "1=1", gdbVersion: t6.gdbVersion, historicMoment: t6.historicMoment, timeExtent: t6.timeExtent ? c.fromJSON(t6.timeExtent) : null }, d8 = this._schema && s5(r6, "outFields");
    this._schema && p(r6, ["timeExtent", "definitionExpression", "gdbVersion", "historicMoment", "customParameters"]) && (s10.why.mesh.push("Layer filter and/or custom parameters changed"), s10.why.source.push("Layer filter and/or custom parameters changed"), s10.mesh = true, s10.source = true, s10.queryFilter = true), d8 && (s10.why.source.push("Layer required fields changed"), s10.source = true), a2(a7, this._queryInfo) && (this._queryInfo = a7), this._schema = t6, this._resolver.resolve();
  }
  whenInitialized() {
    return this._resolver.promise;
  }
  async applyUpdate(e3) {
    if (e3.queryFilter || e3.source && this._didEdit)
      return this.refresh(e3.version), void (this._didEdit = false);
    this._subscriptions.forEach((s10) => s10.applyUpdate(e3)), await this.resend();
  }
  refresh(e3, s10) {
    for (const t6 of this._tiles())
      this.unsubscribe(t6), this.subscribe(t6, e3);
  }
  subscribe(e3, s10) {
    const t6 = new d6(e3, s10);
    this._subscriptions.set(e3.id, t6), this.updatingHandles.addPromise(t6.done);
  }
  unsubscribe(e3) {
    const s10 = this.getSubscription(e3.id);
    null != s10 && s10.abort(), this._subscriptions.delete(e3.id);
  }
  createQuery(e3 = {}) {
    const s10 = this._queryInfo.historicMoment ? new Date(this._queryInfo.historicMoment) : null;
    return new b({ ...this._queryInfo, historicMoment: s10, ...e3 });
  }
  getSubscription(e3) {
    return this._subscriptions.has(e3) ? this._subscriptions.get(e3) : null;
  }
  async queryLastEditDate() {
    throw new Error("Service does not support query type");
  }
  async query(e3, s10) {
    throw new Error("Service does not support query");
  }
  *_tiles() {
    const e3 = Array.from(this._subscriptions.values());
    for (const s10 of e3)
      yield s10.tile;
  }
  async edit(e3, s10) {
    const t6 = Array.from(this._subscriptions.values()), i6 = t6.map(({ tile: e4 }) => e4);
    for (const r6 of t6)
      r6.removeIds(s10);
    if (e3.length) {
      const t7 = i6.map((s11) => {
        const t8 = this.createTileQuery(s11);
        return t8.objectIds = e3, { tile: s11, query: t8 };
      }).map(async ({ tile: e4, query: s11 }) => ({ tile: e4, result: await this.query(s11, { query: { tile: has("esri-tiles-debug") ? e4.id.replaceAll("/", ".") : void 0 } }), query: s11 })), n8 = (await P(t7)).map(async ({ tile: t8, result: i7 }) => {
        if (!i7.hasFeatures && !s10.length && !e3.length)
          return;
        const r6 = this._subscriptions.get(t8.key.id);
        r6 && r6.edit(i7, e3);
      });
      await j(n8);
    }
    this._didEdit = true;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/BaseFeatureSource.js
var u5 = 4;
var c6 = class extends m7 {
  constructor(e3) {
    super(e3), this.type = "feature", this.mode = "on-demand", this._adapter = l3(e3.serviceInfo), this._queue = new u2({ concurrency: 8, process: async (e4) => {
      var _a, _b;
      if (s3(e4), null != e4.tile) {
        const t6 = e4.tile.key.id, { signal: r6 } = e4, s10 = has("esri-tiles-debug") ? { tile: t6.replaceAll("/", "."), depth: e4.depth } : void 0, i6 = await this._adapter.executeQuery(e4.query, { signal: r6, query: { ...s10, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
        return i6.level = e4.tile.key.level, i6;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: (_b = this._schema) == null ? void 0 : _b.customParameters });
    } }), this._patchQueue = new u2({ concurrency: 8, process: async (e4) => {
      var _a, _b;
      if (s3(e4), null != e4.tile) {
        const t6 = e4.tile.key.id, { signal: r6 } = e4, s10 = has("esri-tiles-debug") ? { tile: t6.replaceAll("/", "."), depth: e4.depth } : void 0, i6 = await this._adapter.executeQuery(e4.query, { signal: r6, query: { ...s10, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
        return i6.level = e4.tile.key.level, i6;
      }
      return this._adapter.executeQuery(e4.query, { ...e4, query: (_b = this._schema) == null ? void 0 : _b.customParameters });
    } });
  }
  destroy() {
    super.destroy(), this._adapter.destroy(), this._queue.destroy(), this._patchQueue.destroy();
  }
  enqueueQuery(e3, t6) {
    return this.updatingHandles.addPromise(this._queue.push(e3, t6));
  }
  enqueuePatchQuery(e3, t6) {
    return this.updatingHandles.addPromise(this._patchQueue.push(e3, t6));
  }
  get maxRecordCountFactor() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return e3.supportsMaxRecordCountFactor ? u5 : null;
  }
  get maxPageSize() {
    const { query: e3 } = this._serviceInfo.capabilities;
    return (e3.maxRecordCount ?? 8e3) * (this.maxRecordCountFactor ?? 1);
  }
  get pageSize() {
    return Math.min(8e3, this.maxPageSize);
  }
  enableEvent(e3, t6) {
  }
  subscribe(e3, s10) {
    super.subscribe(e3, s10), this._fetchDataTile(e3).catch((s11) => {
      d(s11) || s.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource").error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: e3, error: s11 }));
    });
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  readers(e3) {
    return this._subscriptions.get(e3).readers();
  }
  async query(e3, t6 = {}) {
    var _a;
    const r6 = t6.query ?? {};
    return this._adapter.executeQuery(e3, { ...t6, query: { ...r6, ...(_a = this._schema) == null ? void 0 : _a.customParameters } });
  }
  async queryLastEditDate() {
    const t6 = this._serviceInfo.source, r6 = { ...t6.query, f: "json" };
    return (await j3(t6.path, { query: r6, responseType: "json" })).data.editingInfo.lastEditDate;
  }
  createTileQuery(e3, t6 = {}) {
    const r6 = this._serviceInfo.geometryType, s10 = this.createQuery(t6);
    s10.quantizationParameters = t6.quantizationParameters ?? e3.getQuantizationParameters(), s10.resultType = "tile", s10.geometry = e3.extent, this._serviceInfo.capabilities.query.supportsQuantization ? "esriGeometryPolyline" === r6 && (s10.maxAllowableOffset = e3.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== r6 && "esriGeometryPolygon" !== r6 || (s10.maxAllowableOffset = e3.resolution, "esriGeometryPolyline" === r6 && (s10.maxAllowableOffset *= has("feature-polyline-generalization-factor")));
    const i6 = this._serviceInfo.capabilities.query;
    return s10.defaultSpatialReferenceEnabled = i6.supportsDefaultSpatialReference, s10.compactGeometryEnabled = i6.supportsCompactGeometry, s10;
  }
  async _executePatchQuery(e3, t6, r6, s10) {
    const i6 = t6.clone();
    i6.outFields = [this._serviceInfo.objectIdField, ...r6], i6.returnCentroid = false, i6.returnGeometry = false;
    const a7 = null != i6.start ? i6.start / 8e3 : 0, o6 = s10.signal;
    return await this.enqueuePatchQuery({ tile: e3, query: i6, signal: o6, depth: a7 });
  }
  async _resend(e3, t6) {
    const { query: r6, message: i6 } = e3, a7 = null != r6.outFields ? r6.outFields : [], o6 = this._queryInfo.outFields, n8 = o6.filter((e4) => !a7.includes(e4));
    if (null != i6.addOrUpdate)
      if (n8.length)
        try {
          const e4 = this._subscriptions.get(i6.id).tile, a8 = await this._executePatchQuery(e4, r6, n8, t6);
          s3(t6), r6.outFields = o6, i6.addOrUpdate.joinAttributes(a8), this._onMessage({ ...i6, end: i6.end, type: "append" });
        } catch (u7) {
        }
      else
        this._onMessage({ ...i6, type: "append" });
    else
      this._onMessage({ ...i6, type: "append" });
  }
  async _resendSubscription(e3) {
    if (has("esri-2d-update-debug") && console.debug(e3.tile.id, "Resend Subscription"), e3.empty)
      return this._onMessage({ id: e3.tile.id, addOrUpdate: null, end: false, type: "append" });
    const t6 = e3.signal;
    for (const r6 of e3.requests.done)
      await this._resend(r6, { signal: t6 });
    return null != e3.edits ? this._onMessage(e3.edits) : void 0;
  }
  async resend() {
    const e3 = Array.from(this._subscriptions.values());
    await Promise.all(e3.map((e4) => this._resendSubscription(e4)));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/DrillDownFeatureSource.js
var s7 = has("esri-mobile");
var i4 = { maxDrillLevel: s7 ? 1 : 4, maxRecordCountFactor: s7 ? 1 : 3 };
var a5 = class extends c6 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(r6) {
    const s10 = this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor, a7 = this._subscriptions.get(r6.key.id), o6 = a7.signal, n8 = r6.getQuantizationParameters();
    let c9 = 0;
    const d8 = async (u7, l5) => {
      const m9 = this._queryInfo, p6 = this.createTileQuery(u7, { maxRecordCountFactor: s10 ? i4.maxRecordCountFactor : void 0, returnExceededLimitFeatures: false, quantizationParameters: n8 });
      c9++;
      try {
        const t6 = await this.enqueueQuery({ tile: r6, query: p6, signal: o6, depth: l5 });
        if (c9--, s3(o6), !t6)
          return;
        if (m9 !== this._queryInfo)
          return void d8(u7, l5);
        if (t6.exceededTransferLimit && l5 < i4.maxDrillLevel) {
          for (const e3 of u7.createChildTiles())
            d8(e3, l5 + 1);
          return;
        }
        const s11 = { id: r6.id, addOrUpdate: t6, end: 0 === c9, type: "append" };
        a7.add({ query: p6, message: s11 }), this._onMessage(s11);
      } catch (f8) {
        if (!d(f8)) {
          const e3 = { id: r6.id, addOrUpdate: null, end: true, type: "append" };
          a7.add({ query: p6, message: e3 }), this._onMessage(e3);
        }
      }
    };
    d8(r6, 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/PagedFeatureSource.js
var o4 = class extends c6 {
  constructor(e3) {
    super(e3);
  }
  async _fetchDataTile(s10) {
    const i6 = 6, o6 = 20, n8 = this._subscriptions.get(s10.key.id);
    let d8 = false, c9 = 0, u7 = 0;
    const h8 = (e3, t6) => {
      u7--, s3(n8);
      const r6 = s10.id, i7 = e3.reader, o7 = e3.query;
      if (!i7.exceededTransferLimit) {
        if (d8 = true, 0 !== t6 && !i7.hasFeatures) {
          const e5 = { id: r6, addOrUpdate: i7, end: 0 === u7, type: "append" };
          return n8.add({ message: e5, query: o7 }), void this._onMessage(e5);
        }
        const e4 = { id: r6, addOrUpdate: i7, end: 0 === u7, type: "append" };
        return n8.add({ message: e4, query: o7 }), void this._onMessage(e4);
      }
      const c10 = { id: r6, addOrUpdate: i7, end: d8 && 0 === u7, type: "append" };
      n8.add({ message: c10, query: o7 }), this._onMessage(c10);
    };
    let m9 = 0, p6 = 0;
    for (; !d8 && p6++ < o6; ) {
      let o7;
      for (let a7 = 0; a7 < m9 + 1; a7++) {
        const a8 = c9++;
        u7++, o7 = this._fetchDataTilePage(s10, a8, n8).then((e3) => e3 && h8(e3, a8)).catch((a9) => {
          if (d8 = true, !d(a9)) {
            s.getLogger("esri.views.2d.layers.features.sources.PagedFeatureSource").error(new s2("mapview-query-error", "Encountered error when fetching tile", { tile: s10, error: a9 }));
            const r6 = { id: s10.id, addOrUpdate: null, end: d8, type: "append" }, i7 = { start: this.pageSize * c9, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: s10.getQuantizationParameters() };
            null != this.maxRecordCountFactor && (i7.maxRecordCountFactor = this.maxRecordCountFactor);
            const o8 = this.createTileQuery(s10, i7);
            n8.add({ message: r6, query: o8 }), this._onMessage(r6);
          }
        });
      }
      await o7, s3(n8), m9 = Math.min(m9 + 2, i6);
    }
  }
  async _fetchDataTilePage(e3, t6, r6) {
    s3(r6);
    const i6 = this._queryInfo, o6 = { start: this.pageSize * t6, num: this.pageSize, returnExceededLimitFeatures: true, quantizationParameters: e3.getQuantizationParameters() };
    null != this.maxRecordCountFactor && (o6.maxRecordCountFactor = this.maxRecordCountFactor);
    const n8 = this.createTileQuery(e3, o6);
    try {
      const s10 = r6.signal, o7 = await this.enqueueQuery({ tile: e3, query: n8, signal: s10, depth: t6 });
      return s3(r6), o7 ? i6 !== this._queryInfo ? this._fetchDataTilePage(e3, t6, r6) : { reader: o7, query: n8 } : null;
    } catch (d8) {
      return m(d8), null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/SnapshotFeatureSource.js
function l4(e3, t6, s10) {
  const r6 = e3.getXHydrated(), o6 = e3.getYHydrated(), n8 = t6.getColumnForX(r6), a7 = Math.floor(t6.normalizeCol(n8));
  return `${s10}/${Math.floor(t6.getRowForY(o6))}/${a7}`;
}
function h6(e3, t6) {
  if (null == e3)
    return null;
  const s10 = t6.transform, r6 = e3.getQuantizationTransform();
  if (null == r6) {
    const [t7, r7] = s10.scale, [o7, n9] = s10.translate, a8 = -o7 / t7, i7 = 1 / t7, d9 = n9 / r7, u8 = 1 / -r7;
    return e3.transform(a8, d9, i7, u8);
  }
  const [o6, n8] = r6.scale, [a7, i6] = r6.translate, [d8, u7] = s10.scale, [l5, h8] = s10.translate, c9 = o6 / d8, g5 = (a7 - l5) / d8, p6 = n8 / u7, _3 = (-i6 + h8) / u7;
  return e3.transform(g5, _3, c9, p6);
}
var c7 = class extends c6 {
  constructor(e3) {
    super(e3), this.mode = "snapshot", this._loading = true, this._controller = new AbortController(), this._downloadPromise = null, this._didSendEnd = false, this._queries = new Array(), this._invalidated = false, this._hasAggregates = false, this._random = new t(1e3), this._store = e3.store, this._markedIdsBufId = this._store.storage.createBitset();
  }
  destroy() {
    super.destroy(), this._controller.abort();
  }
  get loading() {
    return this._loading;
  }
  get _signal() {
    return this._controller.signal;
  }
  update(e3, t6) {
    var _a;
    super.update(e3, t6), null == this._featureCount && (this._featureCount = t6.initialFeatureCount), null != t6.changedFeatureCount && (this._featureCount = t6.changedFeatureCount), this._hasAggregates = !!((_a = e3.targets) == null ? void 0 : _a.aggregate);
  }
  async resend(e3 = false) {
    if (await this._downloadPromise, this._invalidated || e3) {
      const e4 = u(this._featureCount, "Expected featureCount to be defined");
      return this._invalidated = false, this._subscriptions.forEach((e5) => e5.clear()), this._downloadPromise = this._download(e4), void await this._downloadPromise;
    }
    const t6 = this._queries.map(({ query: e4, reader: t7 }) => this._sendPatchQuery(e4, t7));
    await Promise.all(t6), this._subscriptions.forEach((e4) => {
      e4.requests.done.forEach((e5) => this._onMessage(e5.message));
    });
  }
  async refresh(e3, t6) {
    t6 && (this._featureCount = t6.featureCount), await this.resend(true);
  }
  async _sendPatchQuery(e3, t6) {
    const s10 = null != e3.outFields ? e3.outFields : [], o6 = this._queryInfo.outFields, n8 = o6.filter((e4) => !s10.includes(e4));
    if (!n8.length)
      return;
    const a7 = e3.clone(), i6 = this._signal;
    a7.returnGeometry = false, a7.returnCentroid = false, a7.outFields = n8, e3.outFields = o6;
    const d8 = await this.enqueueQuery({ query: a7, depth: 0, signal: i6 });
    s3({ signal: i6 }), t6.joinAttributes(d8);
  }
  async _fetchDataTile(e3) {
    if (!this._downloadPromise) {
      const e4 = u(this._featureCount, "Expected featureCount to be defined");
      this._downloadPromise = this._download(e4);
    }
    const t6 = this._store.search(e3), r6 = this._subscriptions.get(e3.key.id), n8 = t6.length - 1;
    for (let s10 = 0; s10 < n8; s10++) {
      const n9 = h6(t6[s10], e3), a8 = { type: "append", id: e3.id, addOrUpdate: n9, end: false, status: t5.empty() };
      r6.add({ query: null, message: a8 }), this._hasAggregates || await g(1), this._onMessage(a8);
    }
    const a7 = h6(n8 >= 0 ? t6[n8] : null, e3), i6 = this._didSendEnd, d8 = { type: "append", id: e3.id, addOrUpdate: a7, end: i6, status: t5.empty() };
    r6.add({ query: null, message: d8 }), this._onMessage(d8);
  }
  async _download(e3) {
    try {
      await this.whenInitialized();
      const t6 = this._store.storage.getBitset(this._markedIdsBufId), s10 = /* @__PURE__ */ new Set();
      t6.clear();
      const r6 = Math.ceil(e3 / this.pageSize), o6 = Array.from({ length: r6 }, (e4, t7) => t7).sort((e4, t7) => this._random.getInt() - this._random.getInt()).map((e4) => this._downloadPage(e4, t6, s10));
      await Promise.all(o6), this._store.sweepFeatures(t6, this._store.storage), this._store.sweepFeatureSets(s10);
    } catch (s10) {
      s.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource").error("mapview-snapshot-source", "Encountered and error when downloading feature snapshot", s10);
    }
    this._sendEnd(), this._loading = false;
  }
  async _downloadPage(e3, t6, s10) {
    const o6 = this.pageSize, n8 = { start: e3 * o6, num: o6, cacheHint: true };
    null != this.maxRecordCountFactor && (n8.maxRecordCountFactor = this.maxRecordCountFactor);
    const a7 = this.createQuery(n8), i6 = this._signal, d8 = await this.enqueueQuery({ query: a7, depth: e3, signal: i6 });
    s3({ signal: i6 }), this._queries.push({ query: a7, reader: d8 }), this._store.insert(d8), s10.add(d8.instance);
    const u7 = d8.getCursor();
    for (; u7.next(); )
      t6.set(u7.getDisplayId());
    this._send(d8);
  }
  _send(e3) {
    if (!this._subscriptions.size)
      return;
    let t6 = null;
    const s10 = /* @__PURE__ */ new Map(), r6 = /* @__PURE__ */ new Set(), o6 = /* @__PURE__ */ new Map();
    this._subscriptions.forEach((e4) => {
      const n8 = e4.tile;
      s10.set(n8.key.id, null), t6 = n8.tileInfoView, r6.add(n8.level);
      const { row: a7, col: i6 } = n8.key, d8 = `${n8.level}/${a7}/${i6}`, u7 = o6.get(d8) ?? [];
      u7.push(e4), o6.set(d8, u7);
    });
    for (const n8 of r6) {
      const r7 = t6.getLODInfoAt(n8), a7 = e3.getCursor();
      for (; a7.next(); ) {
        const e4 = l4(a7, r7, n8), t7 = a7.getIndex();
        if (o6.has(e4))
          for (const r8 of o6.get(e4)) {
            const e5 = r8.tile.id;
            let o7 = s10.get(e5);
            null == o7 && (o7 = [], s10.set(e5, o7)), o7.push(t7);
          }
      }
    }
    s10.forEach((t7, s11) => {
      if (null != t7) {
        const r7 = this._subscriptions.get(s11), o7 = { type: "append", id: s11, addOrUpdate: h6(r3.from(e3, t7), r7.tile), end: false, status: t5.empty() };
        r7.add({ query: null, message: o7 }), this._onMessage(o7);
      }
    });
  }
  _sendEnd() {
    this._subscriptions.forEach((e3) => {
      const t6 = { type: "append", id: e3.tile.id, addOrUpdate: null, end: true, status: t5.empty() };
      e3.add({ query: null, message: t6 }), this._onMessage(t6);
    }), this._didSendEnd = true;
  }
};
c7 = e([a("esri.view.2d.layers.features.sources.SnapshotFeatureSource")], c7);

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var s8 = "__esri_stream_id__";
var i5 = "__esri_timestamp__";
var r5 = 1e3;
var o5 = class {
  constructor(t6, e3, i6, r6, o6 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = i6, this._purgeOptions = r6, this.store = t6, this.objectIdField = e3, this.purgeInterval = o6, this._useGeneratedIds = this.objectIdField === s8;
  }
  removeById(t6) {
    this._removed.push(t6);
  }
  removeByTrackId(t6) {
    const e3 = this._trackIdToObservations.get(t6);
    if (e3)
      for (const s10 of e3.entries)
        this._removed.push(s10);
  }
  add(s10) {
    if (this._useGeneratedIds) {
      const t6 = this._nextId();
      s10.attributes[this.objectIdField] = t6, s10.objectId = t6;
    } else
      s10.objectId = s10.attributes[this.objectIdField];
    const i6 = s10.objectId;
    if (this._addOrUpdated.set(i6, s10), this._maxAge = Math.max(this._maxAge, s10.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField)
      return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t4(1e5)), void this._trackIdLessObservations.enqueue(i6);
    const o6 = s10.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(o6)) {
      const s11 = null != this._purgeOptions && null != this._purgeOptions.maxObservations ? this._purgeOptions.maxObservations : r5, i7 = i(s11, 0, r5);
      this._trackIdToObservations.set(o6, new t4(i7));
    }
    const d8 = this._trackIdToObservations.get(o6), a7 = d8 == null ? void 0 : d8.enqueue(i6);
    null != a7 && (this._addOrUpdated.has(a7) ? this._addOrUpdated.delete(a7) : this._removed.push(a7));
  }
  checkForUpdates() {
    const t6 = this._getToAdd(), e3 = this._getToRemove(), s10 = performance.now();
    s10 - this._lastPurge >= this.purgeInterval && (this._purge(s10), this._lastPurge = s10);
    const r6 = [];
    if (null != e3)
      for (const i6 of e3) {
        const t7 = this.store.removeById(i6);
        null != t7 && r6.push(t7);
      }
    const o6 = [];
    if (null != t6) {
      const r7 = new Set(e3 ?? []);
      for (const e4 of t6)
        r7.has(e4.objectId) || (e4.attributes[i5] = s10, this.store.add(e4), o6.push(e4));
    }
    (o6.length || (r6 == null ? void 0 : r6.length)) && this.store.update(o6, r6);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size)
      return null;
    const t6 = new Array(this._addOrUpdated.size);
    let e3 = 0;
    return this._addOrUpdated.forEach((s10) => t6[e3++] = s10), this._addOrUpdated.clear(), t6;
  }
  _getToRemove() {
    const t6 = this._removed;
    return this._removed.length ? (this._removed = [], t6) : null;
  }
  _nextId() {
    const t6 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t6;
  }
  _purge(t6) {
    const e3 = this._purgeOptions;
    null != e3 && (this._purgeSomeByDisplayCount(e3), this._purgeByAge(e3), this._purgeByAgeReceived(t6, e3), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t6) {
    if (!t6.displayCount)
      return;
    let e3 = this.store.size;
    if (e3 > t6.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s10 of this._trackIdToObservations.values())
          if (e3 > t6.displayCount && s10.size) {
            const t7 = s10.dequeue();
            this._removed.push(t7), e3--;
          }
      }
      if (null != this._trackIdLessObservations) {
        let s10 = e3 - t6.displayCount;
        for (; s10-- > 0; ) {
          const t7 = this._trackIdLessObservations.dequeue();
          null != t7 && this._removed.push(t7);
        }
      }
    }
  }
  _purgeByAge(t6) {
    var _a;
    const e3 = (_a = this._timeInfo) == null ? void 0 : _a.startTimeField;
    if (!t6.age || !e3)
      return;
    const s10 = 60 * t6.age * 1e3, i6 = this._maxAge - s10;
    this.store.forEach((t7) => {
      t7.attributes[e3] < i6 && this._removed.push(t7.objectId);
    });
  }
  _purgeByAgeReceived(t6, e3) {
    if (!e3.ageReceived)
      return;
    const s10 = t6 - 60 * e3.ageReceived * 1e3;
    this.store.forEach((t7) => {
      t7.attributes[i5] < s10 && this._removed.push(t7.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t6, e3) => {
      0 === t6.size && this._trackIdToObservations.delete(e3);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s9 = class extends m2 {
  constructor(r6) {
    super(r6);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
e([y2()], s9.prototype, "connection", void 0), e([y2()], s9.prototype, "connectionStatus", null), e([y2()], s9.prototype, "errorString", null), s9 = e([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s9);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamSource.js
var p5 = 2500;
function _2(e3, t6) {
  const s10 = e3.weakClone();
  if (null != e3.geometry) {
    const i6 = M2(t6, e3.geometry.coords[0]), a7 = N(t6, e3.geometry.coords[1]);
    s10.geometry = new t3([], [i6, a7]);
  }
  return s10;
}
function m8(e3) {
  return "esriGeometryPoint" === e3 ? _2 : (t6, s10) => {
    const n8 = t6.weakClone(), r6 = new t3(), a7 = false, d8 = false, c9 = ht(r6, t6.geometry, a7, d8, e3, s10, false, false);
    return n8.geometry = c9, n8;
  };
}
function g4(e3) {
  return "esriGeometryPoint" === e3 ? (e4) => null != e4.geometry ? { minX: e4.geometry.coords[0], minY: e4.geometry.coords[1], maxX: e4.geometry.coords[0], maxY: e4.geometry.coords[1] } : { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } : (e4) => {
    let t6 = 1 / 0, s10 = 1 / 0, i6 = -1 / 0, n8 = -1 / 0;
    return null != e4.geometry && e4.geometry.forEachVertex((e5, r6) => {
      t6 = Math.min(t6, e5), s10 = Math.min(s10, r6), i6 = Math.max(i6, e5), n8 = Math.max(n8, r6);
    }), { minX: t6, minY: s10, maxX: i6, maxY: n8 };
  };
}
function y5(e3, s10) {
  const i6 = i3(9, g4(s10));
  return i6.load(e3), i6;
}
function f7(e3, t6) {
  return e3.search({ minX: t6.bounds[0], minY: t6.bounds[1], maxX: t6.bounds[2], maxY: t6.bounds[3] });
}
var v2 = class {
  constructor(e3, t6) {
    this.onUpdate = e3, this._geometryType = t6, this._objectIdToFeature = /* @__PURE__ */ new Map(), this._index = null;
  }
  get _features() {
    const e3 = [];
    return this._objectIdToFeature.forEach((t6) => e3.push(t6)), e3;
  }
  add(e3) {
    this._objectIdToFeature.set(e3.objectId, e3), this._index = null;
  }
  get(e3) {
    return this._objectIdToFeature.has(e3) ? this._objectIdToFeature.get(e3) : null;
  }
  forEach(e3) {
    this._objectIdToFeature.forEach(e3);
  }
  search(e3) {
    return this._index || (this._index = y5(this._features, this._geometryType)), f7(this._index, e3);
  }
  clear() {
    this._index = null, this._objectIdToFeature.clear();
  }
  removeById(e3) {
    const t6 = this._objectIdToFeature.get(e3);
    return t6 ? (this._objectIdToFeature.delete(e3), this._index = null, t6) : null;
  }
  update(e3, t6) {
    this.onUpdate(e3, t6);
  }
  get size() {
    return this._objectIdToFeature.size;
  }
};
var I4 = class extends m7 {
  constructor(t6) {
    super(t6), this.type = "stream", this._updateIntervalId = 0, this._level = 0, this._isPaused = false, this._updateInfo = { websocket: 0, client: 0 }, this._inUpdate = false;
    const { outSR: s10 } = t6, { geometryType: i6, objectIdField: n8, timeInfo: r6, purgeOptions: o6, source: c9, spatialReference: u7, serviceFilter: l5, maxReconnectionAttempts: _3, maxReconnectionInterval: g5, updateInterval: y6, customParameters: f8, enabledEventTypes: I5 } = t6.serviceInfo, b4 = new v2(this._onUpdate.bind(this), i6), T4 = new o5(b4, n8, r6, o6), j7 = o(c9, u7, s10, i6, l5, _3, g5, f8 ?? {});
    this._connectionState = new s9({ connection: j7 }), this._store = b4, this._manager = T4, this._connection = j7, this._quantize = m8(i6), this._enabledEventTypes = new Set(I5), this._handlesGroup = n2([this._connection.on("data-received", (e3) => this._onFeature(e3)), this._connection.on("message-received", (e3) => this._onWebSocketMessage(e3))]), this._initUpdateInterval = () => {
      let e3 = performance.now();
      this._updateIntervalId = setInterval(() => {
        const s11 = performance.now(), i7 = s11 - e3;
        if (i7 > p5) {
          e3 = s11;
          const t7 = Math.round(this._updateInfo.client / (i7 / 1e3)), n9 = Math.round(this._updateInfo.websocket / (i7 / 1e3));
          this._updateInfo.client = 0, this._updateInfo.websocket = 0, this.events.emit("updateRate", { client: t7, websocket: n9 });
        }
        t6.canAcceptRequest() && !this._inUpdate && this._manager.checkForUpdates();
      }, y6);
    }, this._isPaused = t6.serviceInfo.isPaused, this._isPaused || this._initUpdateInterval();
  }
  destroy() {
    var _a;
    super.destroy(), this._clearUpdateInterval(), this._connection.destroy(), (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  _fetchDataTile() {
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    return this._connectionState.errorString;
  }
  updateCustomParameters(e3) {
    this._connection.updateCustomParameters(e3);
  }
  pauseStream() {
    this._isPaused || (this._isPaused = true, this._clearUpdateInterval());
  }
  resumeStream() {
    this._isPaused && (this._isPaused = false, this._initUpdateInterval());
  }
  sendMessageToSocket(e3) {
    this._connection.sendMessageToSocket(e3);
  }
  sendMessageToClient(e3) {
    this._isPaused && "type" in e3 && "clear" === e3.type ? (this._store.clear(), this._subscriptions.forEach((e4, t6) => {
      e4.didSend && e4.tile.level === this._level && this._onMessage({ type: "append", id: t6, addOrUpdate: null, clear: true, end: true });
    })) : this._connection.sendMessageToClient(e3);
  }
  enableEvent(e3, t6) {
    t6 ? this._enabledEventTypes.add(e3) : this._enabledEventTypes.delete(e3);
  }
  subscribe(e3, t6) {
    super.subscribe(e3, t6);
    const s10 = this._subscriptions.get(e3.id);
    s10.resolve(), this._level = e3.level;
    const i6 = this._getTileFeatures(e3);
    this._onMessage({ type: "append", id: e3.key.id, addOrUpdate: i6, end: true }), s10.didSend = true;
  }
  unsubscribe(e3) {
    super.unsubscribe(e3);
  }
  *readers(e3) {
    const t6 = this._subscriptions.get(e3), { tile: s10 } = t6;
    yield this._getTileFeatures(s10);
  }
  createTileQuery(e3) {
    throw new Error("Service does not support tile  queries");
  }
  async resend() {
    this._subscriptions.forEach((e3) => {
      const { tile: t6 } = e3, s10 = { type: "append", id: t6.id, addOrUpdate: this._getTileFeatures(t6), end: true };
      this._onMessage(s10);
    });
  }
  _getTileFeatures(e3) {
    const t6 = this._store.search(e3).map((t7) => this._quantize(t7, e3.transform));
    return h3.fromOptimizedFeatures(t6, this._serviceInfo, e3.transform);
  }
  _onWebSocketMessage(e3) {
    if (this._enabledEventTypes.has("message-received") && this.events.emit("message-received", e3), "type" in e3)
      switch (e3.type) {
        case "delete":
          if (e3.objectIds)
            for (const t6 of e3.objectIds)
              this._manager.removeById(t6);
          if (e3.trackIds)
            for (const t6 of e3.trackIds)
              this._manager.removeByTrackId(t6);
          break;
        case "clear":
          this._store.forEach((e4) => this._manager.removeById(e4.objectId));
      }
  }
  _onFeature(e3) {
    this._updateInfo.websocket++;
    try {
      this._enabledEventTypes.has("data-received") && this.events.emit("data-received", e3);
      const t6 = tt(e3, this._serviceInfo.geometryType, false, false, this._serviceInfo.objectIdField);
      this._manager.add(t6);
    } catch (t6) {
    }
  }
  _clearUpdateInterval() {
    clearInterval(this._updateIntervalId), this._updateIntervalId = 0;
  }
  async _onUpdate(e3, t6) {
    this._inUpdate = true;
    try {
      null != e3 && (this._updateInfo.client += e3.length), this._subscriptions.forEach((e4, t8) => {
        e4.didSend && e4.tile.level === this._level && this._onMessage({ type: "append", id: t8, addOrUpdate: null, clear: true, end: false });
      });
      const t7 = [];
      this._subscriptions.forEach((e4, s10) => {
        if (!e4.didSend || e4.tile.level !== this._level)
          return;
        const i6 = e4.tile, n8 = { type: "append", id: s10, addOrUpdate: this._getTileFeatures(i6), remove: [], end: false, status: t5.empty() };
        e4.requests.stream.enqueue(n8), t7.push(this._onMessage(n8));
      }), await Promise.all(t7), this._subscriptions.forEach((e4, t8) => {
        e4.didSend && e4.tile.level === this._level && this._onMessage({ type: "append", id: t8, addOrUpdate: null, end: true });
      });
    } catch {
    }
    this._inUpdate = false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/createSource.js
function n7(e3, n8, c9, u7, i6, p6) {
  const f8 = a6(e3, n8, c9, u7, i6, p6);
  switch (f8.type) {
    case "feature":
      switch (f8.origin) {
        case "hosted":
        case "local":
          return new o4(f8);
        case "snapshot":
          return new c7(f8);
        default:
          return new a5(f8);
      }
    case "stream":
      return new I4(f8);
  }
}
function a6(r6, t6, o6, s10, n8, a7) {
  switch (r6.type) {
    case "snapshot":
      return { type: "feature", origin: "snapshot", featureCount: r6.featureCount ?? 0, serviceInfo: r6, onMessage: s10, outSR: t6, tileInfoView: o6, canAcceptRequest: n8, store: a7 };
    case "stream":
      return { type: "stream", serviceInfo: r6, onMessage: s10, outSR: t6, canAcceptRequest: n8 };
    case "memory":
    case "on-demand":
      return { type: "feature", serviceInfo: r6, onMessage: s10, outSR: t6, origin: c9(r6.source), tileInfoView: o6, canAcceptRequest: n8 };
  }
  function c9(r7) {
    return Array.isArray(r7) ? "local" : "path" in r7 && w(r7.path) ? "hosted" : "unknown";
  }
}

// node_modules/@arcgis/core/geohash/GeohashTree.js
var h7 = class {
  constructor(e3 = [], s10, i6 = 8096) {
    this.onRelease = (t6) => {
    }, this._nodes = 0, this._root = new c8(this, 0, 0, 0), this._statisticFields = e3, this._pool = i6 ? new t4(8096) : null, this._serviceInfo = s10;
  }
  destroy() {
    this.clear();
  }
  _acquire(t6, e3, s10) {
    this._nodes++;
    let i6 = null;
    return null != this._pool && (i6 = this._pool.dequeue()), null != i6 ? i6.realloc(t6, e3, s10) : i6 = new c8(this, t6, e3, s10), i6;
  }
  _release(t6) {
    this.onRelease(t6), this._nodes--, null != this._pool && this._pool.enqueue(t6);
  }
  get count() {
    return this._root.count;
  }
  get size() {
    return this._nodes;
  }
  get poolSize() {
    var _a;
    return ((_a = this._pool) == null ? void 0 : _a.size) ?? 0;
  }
  get depth() {
    let t6 = 0;
    return this.forEach((e3) => t6 = Math.max(t6, e3.depth)), t6;
  }
  dropLevels(t6) {
    this.forEach((e3) => {
      if (e3.depth >= t6)
        for (let t7 = 0; t7 < e3.children.length; t7++) {
          const s10 = e3.children[t7];
          s10 && this._release(s10);
        }
    }), this.forEach((e3) => {
      if (e3.depth >= t6)
        for (let t7 = 0; t7 < e3.children.length; t7++)
          e3.children[t7] = null;
    });
  }
  clear() {
    this.forEach((t6) => this._release(t6)), this._root = new c8(this, 0, 0, 0);
  }
  insert(t6, e3, s10 = 0) {
    const i6 = h3.fromOptimizedFeatures([t6], this._serviceInfo).getCursor();
    i6.next();
    const n8 = i6.readGeometry();
    if (!n8)
      return;
    const [o6, a7] = n8.coords, r6 = t6.geohashX, h8 = t6.geohashY;
    this.insertCursor(i6, t6.displayId, o6, a7, r6, h8, e3, s10);
  }
  insertCursor(t6, e3, s10, i6, n8, o6, a7, r6 = 0) {
    let l5 = this._root, h8 = 0, c9 = 0, u7 = 0;
    for (; null !== l5; ) {
      if (l5.depth >= r6 && (l5.count += 1, l5.xTotal += s10, l5.yTotal += i6, l5.xGeohashTotal += n8, l5.yGeohashTotal += o6, l5.referenceId = e3, this._updateStatisticsCursor(t6, l5, 1)), h8 >= a7)
        return void l5.add(e3);
      const d8 = Math.ceil((h8 + 1) / 2), f8 = Math.floor((h8 + 1) / 2), x3 = 1 - h8 % 2, m9 = 30 - (3 * d8 + 2 * f8), g5 = 30 - (2 * d8 + 3 * f8), y6 = (n8 & 7 * x3 + 3 * (1 - x3) << m9) >> m9, p6 = (o6 & 3 * x3 + 7 * (1 - x3) << g5) >> g5, _3 = y6 + p6 * (8 * x3 + 4 * (1 - x3));
      c9 = c9 << 3 * x3 + 2 * (1 - x3) | y6, u7 = u7 << 2 * x3 + 3 * (1 - x3) | p6, null == l5.children[_3] && (l5.children[_3] = this._acquire(c9, u7, h8 + 1)), h8 += 1, l5 = l5.children[_3];
    }
  }
  remove(t6, e3) {
    const s10 = h3.fromOptimizedFeatures([t6], this._serviceInfo).getCursor();
    s10.next();
    const i6 = s10.readGeometry();
    if (!i6)
      return;
    const [n8, o6] = i6.coords, a7 = t6.geohashX, r6 = t6.geohashY;
    this.removeCursor(s10, n8, o6, a7, r6, e3);
  }
  removeCursor(t6, e3, s10, i6, n8, o6) {
    let a7 = this._root, r6 = 0;
    for (; null !== a7; ) {
      if (a7.count -= 1, a7.xTotal -= e3, a7.yTotal -= s10, a7.xGeohashTotal -= i6, a7.yGeohashTotal -= n8, this._updateStatisticsCursor(t6, a7, -1), r6 >= o6)
        return void a7.remove(t6.getDisplayId());
      const l5 = Math.ceil((r6 + 1) / 2), h8 = Math.floor((r6 + 1) / 2), c9 = 1 - r6 % 2, u7 = 30 - (3 * l5 + 2 * h8), d8 = 30 - (2 * l5 + 3 * h8), f8 = ((i6 & 7 * c9 + 3 * (1 - c9) << u7) >> u7) + ((n8 & 3 * c9 + 7 * (1 - c9) << d8) >> d8) * (8 * c9 + 4 * (1 - c9)), x3 = a7.children[f8];
      1 === (x3 == null ? void 0 : x3.count) && (this._release(x3), a7.children[f8] = null), r6 += 1, a7 = x3;
    }
  }
  forEach(t6) {
    let e3 = this._root;
    for (; null !== e3; ) {
      const s10 = this._linkChildren(e3) || e3.next;
      t6(e3), e3 = s10;
    }
  }
  find(t6, e3, s10) {
    return this._root.find(t6, e3, s10, 0, 0, 0);
  }
  findIf(t6) {
    let e3 = null;
    return this.forEach((s10) => {
      t6(s10) && (e3 = s10);
    }), e3;
  }
  findAllIf(t6) {
    const e3 = [];
    return this.forEach((s10) => {
      t6(s10) && e3.push(s10);
    }), e3;
  }
  findSingleOccupancyNode(t6, e3, s10, i6, n8) {
    let o6 = this._root;
    for (; null !== o6; ) {
      const a7 = o6.depth, r6 = o6.xNode, l5 = o6.yNode, h8 = 1 - a7 % 2, c9 = o6.xGeohashTotal / o6.count, u7 = o6.yGeohashTotal / o6.count;
      if (1 === o6.count && t6 < c9 && c9 <= s10 && e3 < u7 && u7 <= i6)
        return o6;
      if (a7 >= n8) {
        o6 = o6.next;
        continue;
      }
      const d8 = Math.ceil((a7 + 1) / 2), f8 = Math.floor((a7 + 1) / 2), x3 = 30 - (3 * d8 + 2 * f8), m9 = 30 - (2 * d8 + 3 * f8), g5 = ~((1 << x3) - 1), y6 = ~((1 << m9) - 1), p6 = (t6 & g5) >> x3, _3 = (e3 & y6) >> m9, v3 = (s10 & g5) >> x3, M3 = (i6 & y6) >> m9, T4 = r6 << 3 * h8 + 2 * (1 - h8), b4 = l5 << 2 * h8 + 3 * (1 - h8), k2 = T4 + 8 * h8 + 4 * (1 - h8), N2 = b4 + 4 * h8 + 8 * (1 - h8), I5 = Math.max(T4, p6), C2 = Math.max(b4, _3), G2 = Math.min(k2, v3), L4 = Math.min(N2, M3);
      let S6 = null, w4 = null;
      for (let t7 = C2; t7 <= L4; t7++)
        for (let e4 = I5; e4 <= G2; e4++) {
          const s11 = e4 - T4 + (t7 - b4) * (8 * h8 + 4 * (1 - h8)), i7 = o6.children[s11];
          i7 && (S6 || (S6 = i7, S6.next = o6.next), w4 && (w4.next = i7), w4 = i7, i7.next = o6.next);
        }
      o6 = S6 || o6.next;
    }
    return null;
  }
  getRegionDisplayIds(t6) {
    let e3 = this._root;
    const { bounds: s10, geohashBounds: i6, level: n8 } = t6, [o6, a7, r6, l5] = s10, h8 = [];
    for (; null !== e3; ) {
      const t7 = e3.depth, s11 = e3.xNode, c9 = e3.yNode;
      if (t7 >= n8) {
        const t8 = e3.xTotal / e3.count, s12 = e3.yTotal / e3.count;
        t8 >= o6 && t8 <= r6 && s12 >= a7 && s12 <= l5 && e3.displayIds.forEach((t9) => h8.push(t9)), e3 = e3.next;
        continue;
      }
      const u7 = Math.ceil((t7 + 1) / 2), d8 = Math.floor((t7 + 1) / 2), f8 = 1 - t7 % 2, x3 = 30 - (3 * u7 + 2 * d8), m9 = 30 - (2 * u7 + 3 * d8), g5 = ~((1 << x3) - 1), y6 = ~((1 << m9) - 1), p6 = (i6.xLL & g5) >> x3, _3 = (i6.yLL & y6) >> m9, v3 = (i6.xTR & g5) >> x3, M3 = (i6.yTR & y6) >> m9, T4 = s11 << 3 * f8 + 2 * (1 - f8), b4 = c9 << 2 * f8 + 3 * (1 - f8), k2 = T4 + 8 * f8 + 4 * (1 - f8), N2 = b4 + 4 * f8 + 8 * (1 - f8), I5 = Math.max(T4, p6), C2 = Math.max(b4, _3), G2 = Math.min(k2, v3), L4 = Math.min(N2, M3);
      let S6 = null, w4 = null;
      for (let i7 = C2; i7 <= L4; i7++)
        for (let t8 = I5; t8 <= G2; t8++) {
          const s12 = t8 - T4 + (i7 - b4) * (8 * f8 + 4 * (1 - f8)), n9 = e3.children[s12];
          n9 && (S6 || (S6 = n9, S6.next = e3.next), w4 && (w4.next = n9), w4 = n9, n9.next = e3.next);
        }
      e3 = S6 || e3.next;
    }
    return h8;
  }
  getRegionStatistics(t6) {
    let e3 = this._root, s10 = 0, i6 = 0, n8 = 0;
    const o6 = {}, { bounds: a7, geohashBounds: r6, level: l5 } = t6, [h8, c9, u7, d8] = a7;
    let f8 = 0;
    for (; null !== e3; ) {
      const t7 = e3.depth, a8 = e3.xNode, x3 = e3.yNode;
      if (t7 >= l5) {
        const t8 = e3.xTotal / e3.count, a9 = e3.yTotal / e3.count;
        t8 > h8 && t8 <= u7 && a9 > c9 && a9 <= d8 && (s10 += e3.count, i6 += e3.xTotal, n8 += e3.yTotal, 1 === e3.count && (f8 = e3.referenceId), this._aggregateStatistics(o6, e3.statistics)), e3 = e3.next;
        continue;
      }
      const m9 = Math.ceil((t7 + 1) / 2), g5 = Math.floor((t7 + 1) / 2), y6 = 1 - t7 % 2, p6 = 30 - (3 * m9 + 2 * g5), _3 = 30 - (2 * m9 + 3 * g5), v3 = ~((1 << p6) - 1), M3 = ~((1 << _3) - 1), T4 = (r6.xLL & v3) >> p6, b4 = (r6.yLL & M3) >> _3, k2 = (r6.xTR & v3) >> p6, N2 = (r6.yTR & M3) >> _3, I5 = a8 << 3 * y6 + 2 * (1 - y6), C2 = x3 << 2 * y6 + 3 * (1 - y6), G2 = I5 + 8 * y6 + 4 * (1 - y6), L4 = C2 + 4 * y6 + 8 * (1 - y6), S6 = Math.max(I5, T4), w4 = Math.max(C2, b4), R4 = Math.min(G2, k2), F3 = Math.min(L4, N2);
      let z = null, j7 = null;
      for (let r7 = w4; r7 <= F3; r7++)
        for (let t8 = S6; t8 <= R4; t8++) {
          const a9 = t8 - I5 + (r7 - C2) * (8 * y6 + 4 * (1 - y6)), l6 = e3.children[a9];
          if (l6) {
            if (r7 !== w4 && r7 !== F3 && t8 !== S6 && t8 !== R4) {
              const t9 = l6.xTotal / l6.count, e4 = l6.yTotal / l6.count;
              t9 > h8 && t9 <= u7 && e4 > c9 && e4 <= d8 && (s10 += l6.count, i6 += l6.xTotal, n8 += l6.yTotal, 1 === l6.count && (f8 = l6.referenceId), this._aggregateStatistics(o6, l6.statistics));
              continue;
            }
            z || (z = l6, z.next = e3.next), j7 && (j7.next = l6), j7 = l6, l6.next = e3.next;
          }
        }
      e3 = z || e3.next;
    }
    return { count: s10, attributes: this.normalizeStatistics(o6, s10), xTotal: i6, yTotal: n8, referenceId: f8 };
  }
  getBins(t6) {
    const e3 = [], { geohashBounds: s10, level: i6 } = t6;
    let n8 = this._root;
    for (; null !== n8; ) {
      const t7 = n8.depth, o6 = n8.xNode, a7 = n8.yNode;
      if (t7 >= i6) {
        e3.push(n8), n8 = n8.next;
        continue;
      }
      const r6 = Math.ceil((t7 + 1) / 2), l5 = Math.floor((t7 + 1) / 2), h8 = 1 - t7 % 2, c9 = 30 - (3 * r6 + 2 * l5), u7 = 30 - (2 * r6 + 3 * l5), d8 = ~((1 << c9) - 1), f8 = ~((1 << u7) - 1), x3 = (s10.xLL & d8) >> c9, m9 = (s10.yLL & f8) >> u7, g5 = (s10.xTR & d8) >> c9, y6 = (s10.yTR & f8) >> u7, p6 = o6 << 3 * h8 + 2 * (1 - h8), _3 = a7 << 2 * h8 + 3 * (1 - h8), v3 = p6 + 8 * h8 + 4 * (1 - h8), M3 = _3 + 4 * h8 + 8 * (1 - h8), T4 = Math.max(p6, x3), b4 = Math.max(_3, m9), k2 = Math.min(v3, g5), N2 = Math.min(M3, y6);
      let I5 = null, C2 = null;
      for (let e4 = b4; e4 <= N2; e4++)
        for (let t8 = T4; t8 <= k2; t8++) {
          const s11 = t8 - p6 + (e4 - _3) * (8 * h8 + 4 * (1 - h8)), i7 = n8.children[s11];
          i7 && (I5 || (I5 = i7, I5.next = n8.next), C2 && (C2.next = i7), C2 = i7, i7.next = n8.next);
        }
      n8 = I5 || n8.next;
    }
    return e3;
  }
  _linkChildren(t6) {
    let e3 = null, s10 = null;
    for (let i6 = 0; i6 <= t6.children.length; i6++) {
      const n8 = t6.children[i6];
      n8 && (e3 || (e3 = n8, e3.next = t6.next), s10 && (s10.next = n8), s10 = n8, n8.next = t6.next);
    }
    return e3;
  }
  _updateStatisticsCursor(t6, e3, s10) {
    for (const i6 of this._statisticFields) {
      const n8 = i6.name, o6 = i6.inField ? t6.readAttribute(i6.inField) : t6.getComputedNumericAtIndex(i6.inFieldIndex);
      switch (i6.statisticType) {
        case "min": {
          if (isNaN(o6))
            break;
          if (!e3.statistics[n8]) {
            e3.statistics[n8] = { value: o6 };
            break;
          }
          const t7 = e3.statistics[n8].value;
          e3.statistics[n8].value = Math.min(t7, o6);
          break;
        }
        case "max": {
          if (isNaN(o6))
            break;
          if (!e3.statistics[n8]) {
            e3.statistics[n8] = { value: o6 };
            break;
          }
          const t7 = e3.statistics[n8].value;
          e3.statistics[n8].value = Math.max(t7, o6);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg": {
          e3.statistics[n8] || (e3.statistics[n8] = { value: 0, nanCount: 0 });
          const t7 = e3.statistics[n8].value, i7 = e3.statistics[n8].nanCount ?? 0;
          null == o6 || isNaN(o6) ? e3.statistics[n8].nanCount = i7 + s10 : e3.statistics[n8].value = t7 + s10 * o6;
          break;
        }
        case "avg_angle": {
          e3.statistics[n8] || (e3.statistics[n8] = { x: 0, y: 0, nanCount: 0 });
          const t7 = e3.statistics[n8].x, i7 = e3.statistics[n8].y, a7 = e3.statistics[n8].nanCount ?? 0, r6 = Math.PI / 180;
          null == o6 || isNaN(o6) ? e3.statistics[n8].nanCount = a7 + s10 : (e3.statistics[n8].x = t7 + s10 * Math.cos(o6 * r6), e3.statistics[n8].y = i7 + s10 * Math.sin(o6 * r6));
          break;
        }
        case "mode": {
          e3.statistics[n8] || (e3.statistics[n8] = {});
          const t7 = e3.statistics[n8][o6] || 0;
          e3.statistics[n8][o6] = t7 + s10;
          break;
        }
      }
    }
  }
  _aggregateStatistics(t6, e3) {
    for (const s10 of this._statisticFields) {
      const i6 = s10.name;
      switch (s10.statisticType) {
        case "min": {
          if (!t6[i6]) {
            t6[i6] = { value: e3[i6].value };
            break;
          }
          const s11 = t6[i6].value;
          t6[i6].value = Math.min(s11, e3[i6].value);
          break;
        }
        case "max": {
          if (!t6[i6]) {
            t6[i6] = { value: e3[i6].value };
            break;
          }
          const s11 = t6[i6].value;
          t6[i6].value = Math.max(s11, e3[i6].value);
          break;
        }
        case "count":
          break;
        case "sum":
        case "avg":
        case "avg_angle":
        case "mode":
          t6[i6] || (t6[i6] = {});
          for (const s11 in e3[i6]) {
            const n8 = t6[i6][s11] || 0;
            t6[i6][s11] = n8 + e3[i6][s11];
          }
      }
    }
  }
  normalizeStatistics(t6, e3) {
    const s10 = {};
    for (const i6 of this._statisticFields) {
      const n8 = i6.name;
      switch (i6.statisticType) {
        case "min":
        case "max": {
          const i7 = t6[n8];
          if (!e3 || !i7)
            break;
          s10[n8] = i7.value;
          break;
        }
        case "count":
          if (!e3)
            break;
          s10[n8] = e3;
          break;
        case "sum": {
          if (!e3)
            break;
          const { value: i7, nanCount: o6 } = t6[n8];
          if (!(e3 - o6))
            break;
          s10[n8] = i7;
          break;
        }
        case "avg": {
          if (!e3)
            break;
          const { value: i7, nanCount: o6 } = t6[n8];
          if (!(e3 - o6))
            break;
          s10[n8] = i7 / (e3 - o6);
          break;
        }
        case "avg_angle": {
          if (!e3)
            break;
          const { x: i7, y: o6, nanCount: a7 } = t6[n8];
          if (!(e3 - a7))
            break;
          const r6 = i7 / (e3 - a7), l5 = o6 / (e3 - a7), h8 = 180 / Math.PI, c9 = Math.atan2(l5, r6) * h8;
          s10[n8] = c9;
          break;
        }
        case "mode": {
          const e4 = t6[n8];
          let i7 = 0, o6 = 0, a7 = null;
          for (const t7 in e4) {
            const s11 = e4[t7];
            s11 === i7 ? o6 += 1 : s11 > i7 && (i7 = s11, o6 = 1, a7 = t7);
          }
          s10[n8] = "null" === a7 || o6 > 1 ? null : a7;
          break;
        }
      }
    }
    return s10;
  }
};
var c8 = class {
  constructor(t6, e3, s10, i6) {
    this.count = 0, this.xTotal = 0, this.yTotal = 0, this.statistics = {}, this.displayId = 0, this.referenceId = 0, this.displayIds = /* @__PURE__ */ new Set(), this.next = null, this.depth = 0, this.xNode = 0, this.yNode = 0, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this._tree = t6, this.children = new Array(32);
    for (let n8 = 0; n8 < this.children.length; n8++)
      this.children[n8] = null;
    this.xNode = e3, this.yNode = s10, this.depth = i6;
  }
  realloc(t6, e3, s10) {
    for (let i6 = 0; i6 < this.children.length; i6++)
      this.children[i6] = null;
    return this.xNode = t6, this.yNode = e3, this.depth = s10, this.next = null, this.xGeohashTotal = 0, this.yGeohashTotal = 0, this.displayId = 0, this.referenceId = 0, this.xTotal = 0, this.yTotal = 0, this.count = 0, this.statistics = {}, this.displayIds.clear(), this;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  add(t6) {
    this.displayIds.add(t6);
  }
  remove(t6) {
    this.displayIds.delete(t6);
  }
  getAttributes() {
    const t6 = this._tree.normalizeStatistics(this.statistics, this.count);
    return t6.referenceId = null, t6.aggregateId = this.id, t6.aggregateCount = this.count, t6;
  }
  getGeometry(t6, e3) {
    const o6 = this.getLngLatBounds(), [l5, h8, c9, u7] = o6, d8 = g2({ rings: [[[l5, h8], [l5, u7], [c9, u7], [c9, h8], [l5, h8]]] }, f.WGS84, t6), f8 = K(new t3(), d8, false, false);
    if (null != e3) {
      return ht(new t3(), f8, false, false, "esriGeometryPolygon", e3, false, false);
    }
    return f8;
  }
  getGeometryCentroid(t6, e3) {
    const i6 = this.getLngLatBounds(), [l5, h8, c9, u7] = i6, d8 = g2({ x: (l5 + c9) / 2, y: (h8 + u7) / 2 }, f.WGS84, t6), f8 = L(new t3(), d8);
    if (null != e3) {
      return ht(new t3(), f8, false, false, "esriGeometryPoint", e3, false, false);
    }
    return f8;
  }
  getLngLatBounds() {
    const t6 = this.depth, s10 = Math.ceil(t6 / 2), i6 = Math.floor(t6 / 2), n8 = 30 - (3 * s10 + 2 * i6), o6 = 30 - (2 * s10 + 3 * i6), a7 = this.xNode << n8, r6 = this.yNode << o6;
    return X({ geohashX: a7, geohashY: r6 }, this.depth);
  }
  find(t6, e3, s10, i6, n8, o6) {
    if (i6 >= s10)
      return this;
    const a7 = 1 - i6 % 2, r6 = 3 * a7 + 2 * (1 - a7), l5 = 2 * a7 + 3 * (1 - a7), h8 = 30 - n8 - r6, c9 = 30 - o6 - l5, u7 = ((t6 & 7 * a7 + 3 * (1 - a7) << h8) >> h8) + ((e3 & 3 * a7 + 7 * (1 - a7) << c9) >> c9) * (8 * a7 + 4 * (1 - a7)), d8 = this.children[u7];
    return null == d8 ? null : d8.find(t6, e3, s10, i6 + 1, n8 + r6, o6 + l5);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/BinStore.js
var S4 = s.getLogger("esri.view.2d.layers.features.support.BinStore");
var F = 12;
var G = 64;
var R2 = i2();
var L2 = 5;
function T(e3) {
  return 57.29577951308232 * e3;
}
var A = class extends a3 {
  constructor(t6, s10, r6, i6) {
    super(t6, r6), this.type = "bin", this.events = new n3(), this.objectIdField = "aggregateId", this.featureAdapter = I2, this._geohashLevel = L2, this._geohashBuf = [], this._serviceInfo = i6, this.geometryInfo = t6.geometryInfo, this._spatialReference = s10, this._projectionSupportCheck = f3(s10, f.WGS84), this._bitsets.geohash = r6.getBitset(r6.createBitset()), this._bitsets.inserted = r6.getBitset(r6.createBitset());
  }
  destroy() {
    this._tree && this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e3, t6) {
    const s10 = this._schema;
    try {
      await super.updateSchema(e3, t6), await this._projectionSupportCheck;
    } catch (h8) {
    }
    this._fields = this._schema.params.fields;
    const a7 = a2(s10, t6);
    t6 && (null != a7 || e3.source || e3.storage.filters) ? ((s5(a7, "params.fields") || s5(a7, "params") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new h7(this._statisticFields, this._serviceInfo), this._tree.onRelease = (e4) => e4.displayId && this._storage.releaseDisplayId(e4.displayId), this._geohashLevel = this._schema.params.fixedBinLevel, this._rebuildTree(), has("esri-2d-update-debug") && S4.info("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && S4.info("Aggregate mesh needs update due to tree changing"), e3.targets[t6.name] = true, e3.mesh = false) : s10 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t6) {
    this._bitsets.inserted.forEachSet((s10) => {
      if (!e3.has(s10)) {
        const e4 = t6.lookupByDisplayIdUnsafe(s10);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t6, s10) {
  }
  onTileData(e3, t6, s10, r6, i6 = true) {
    if (!this._schema || null == t6.addOrUpdate)
      return t6;
    this.events.emit("changed");
    const o6 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t6.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, r6);
    }
    if (t6.status.mesh || !i6)
      return t6;
    const a7 = new Array();
    this._getBinsForTile(a7, e3, o6, s10), t6.addOrUpdate = h3.fromOptimizedFeatures(a7, { fields: this.fields, geometryType: "esriGeometryPolygon", objectIdField: this.objectIdField }), t6.addOrUpdate.attachStorage(s10), t6.end = true, t6.isRepush || (t6.clear = true);
    {
      const r7 = t6.addOrUpdate.getCursor();
      for (; r7.next(); ) {
        const t7 = r7.getDisplayId();
        this._bitsets.computed.unset(t7), this.setComputedAttributes(s10, r7, t7, e3.scale);
      }
    }
    return t6;
  }
  forEachBin(e3) {
    this._tree.forEach(e3);
  }
  forEach(e3) {
    this._tree.forEach((t6) => {
      if (t6.depth !== this._geohashLevel)
        return;
      const s10 = this._toFeatureJSON(t6), r6 = h3.fromFeatures([s10], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields }).getCursor();
      r6.next(), e3(r6);
    });
  }
  forEachInBounds(e3, t6) {
  }
  forEachBounds(e3, t6) {
    const { hasM: s10, hasZ: r6 } = this.geometryInfo;
    for (const i6 of e3) {
      const e4 = yt(R2, i6.readGeometry(), r6, s10);
      null != e4 && t6(e4);
    }
  }
  onTileUpdate(e3) {
  }
  getAggregate(e3) {
    const t6 = s6(e3, true), r6 = this._tree.findIf((e4) => e4.displayId === t6);
    return n(r6, (e4) => this._toFeatureJSON(e4));
  }
  getAggregates() {
    return this._tree.findAllIf((e3) => e3.depth === this._geohashLevel).map(this._toFeatureJSON.bind(this));
  }
  getDisplayId(e3) {
    const t6 = this._tree.findIf((t7) => t7.id === e3);
    return n(t6, (e4) => e4.displayId);
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t6 = this._tree.findIf((t7) => t7.id === e3);
    return null != t6 ? Array.from(t6.displayIds) : [];
  }
  getDisplayIdForReferenceId(e3) {
    const t6 = this._tree.findIf((t7) => 1 === t7.displayIds.size && t7.displayIds.has(e3));
    return n(t6, (e4) => e4.displayId);
  }
  _toFeatureJSON(e3) {
    const t6 = this._spatialReference;
    return { displayId: e3.displayId, attributes: e3.getAttributes(), geometry: st(e3.getGeometry(t6), "esriGeometryPolygon", false, false), centroid: null };
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t6 = e3.getDisplayId(), s10 = e3.getXHydrated(), r6 = e3.getYHydrated(), i6 = this._geohashBuf[2 * t6], o6 = this._geohashBuf[2 * t6 + 1];
    this._bitsets.inserted.has(t6) && (this._bitsets.inserted.unset(t6), this._tree.removeCursor(e3, s10, r6, i6, o6, this._geohashLevel));
  }
  _update(e3, t6) {
    const s10 = e3.getDisplayId(), r6 = this._bitsets.inserted, i6 = t6.isVisible(s10);
    if (i6 === r6.has(s10))
      return;
    if (!i6)
      return void this._remove(e3);
    const o6 = e3.getXHydrated(), a7 = e3.getYHydrated();
    if (!this._setGeohash(s10, o6, a7))
      return;
    const h8 = this._geohashBuf[2 * s10], n8 = this._geohashBuf[2 * s10 + 1];
    this._tree.insertCursor(e3, s10, o6, a7, h8, n8, this._geohashLevel), r6.set(s10);
  }
  _setGeohash(e3, t6, s10) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r6 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const i6 = T(t6 / s4.radius), o6 = i6 - 360 * Math.floor((i6 + 180) / 360), h8 = T(Math.PI / 2 - 2 * Math.atan(Math.exp(-s10 / s4.radius)));
      b3(r6, e3, h8, o6, F);
    } else {
      const i6 = g2({ x: t6, y: s10 }, this._spatialReference, f.WGS84);
      if (!i6)
        return false;
      b3(r6, e3, i6.y, i6.x, F);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getBinsForTile(e3, t6, s10, r6) {
    try {
      const i6 = this._getGeohashBounds(t6), o6 = this._tree.getBins(i6);
      for (const t7 of o6) {
        t7.displayId || (t7.displayId = r6.createDisplayId(true));
        let i7 = null;
        const o7 = t7.getGeometry(this._spatialReference, s10.tile);
        o7 || (i7 = t7.getGeometryCentroid(this._spatialReference, s10.tile));
        const a7 = new t2(o7, t7.getAttributes(), i7);
        a7.objectId = t7.id, a7.displayId = t7.displayId, e3.push(a7);
      }
    } catch (i6) {
      return void S4.error("Unable to get bins for tile", t6.key.id);
    }
  }
  _getGeohash(e3, t6, s10) {
    const r6 = { geohashX: 0, geohashY: 0 };
    return Y(r6, t6, e3, s10), r6;
  }
  _getGeohashBounds(e3) {
    const t6 = this._getGeohashLevel(e3.key.level), s10 = [e3.extent.xmin, e3.extent.ymin, e3.extent.xmax, e3.extent.ymax], r6 = j4.fromExtent(M.fromBounds(s10, this._spatialReference)), i6 = g2(r6, this._spatialReference, f.WGS84, { densificationStep: e3.resolution * G }), o6 = K(new t3(), i6, false, false), a7 = o6.coords.filter((e4, t7) => !(t7 % 2)), h8 = o6.coords.filter((e4, t7) => t7 % 2), n8 = Math.min(...a7), d8 = Math.min(...h8), l5 = Math.max(...a7), g5 = Math.max(...h8), p6 = this._getGeohash(n8, d8, t6), c9 = this._getGeohash(l5, g5, t6);
    return { bounds: s10, geohashBounds: { xLL: p6.geohashX, yLL: p6.geohashY, xTR: c9.geohashX, yTR: c9.geohashY }, level: t6 };
  }
  _getGeohashLevel(e3) {
    return this._schema.params.fixedBinLevel;
  }
  _getTransforms(e3, t6) {
    const s10 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r6 = d2(t6);
    if (!r6)
      return { tile: s10, left: null, right: null };
    const [i6, o6] = r6.valid;
    return { tile: s10, left: { ...s10, translate: [o6, e3.bounds[3]] }, right: { ...s10, translate: [i6 - o6 + e3.bounds[0], e3.bounds[3]] } };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ClusterStore.js
var F2 = 12;
var L3 = 64;
var B2 = 1;
var w2 = i2();
var S5 = class _S extends e2 {
  constructor(e3, t6, s10, r6, o6) {
    super(new t3([], [t6, s10]), r6, null, e3), this.geohashBoundsInfo = o6;
  }
  get count() {
    return this.attributes.cluster_count;
  }
  static create(e3, t6, s10, r6, o6, i6, a7, h8) {
    const n8 = new _S(t6, s10, r6, i6, a7);
    return n8.displayId = e3.createDisplayId(true), n8.referenceId = h8, n8.tileLevel = o6, n8;
  }
  update(e3, t6, s10, r6, o6, i6) {
    return this.geometry.coords[0] = e3, this.geometry.coords[1] = t6, this.tileLevel = s10, this.attributes = r6, this.geohashBoundsInfo = o6, this.referenceId = null, this.referenceId = i6, this;
  }
  toJSON() {
    return { attributes: { ...this.attributes, aggregateId: this.objectId, referenceId: 1 === this.attributes.cluster_count ? this.referenceId : null }, geometry: { x: this.geometry.coords[0], y: this.geometry.coords[1] } };
  }
};
function T2(e3) {
  return 57.29577951308232 * e3;
}
var V = class extends a3 {
  constructor(t6, s10, r6, o6) {
    super(t6, r6), this.type = "cluster", this.events = new n3(), this.objectIdField = "aggregateId", this.featureAdapter = I2, this._geohashLevel = 0, this._tileLevel = 0, this._aggregateValueRanges = {}, this._aggregateValueRangesChanged = false, this._geohashBuf = [], this._clusters = /* @__PURE__ */ new Map(), this._tiles = /* @__PURE__ */ new Map(), this._serviceInfo = o6, this.geometryInfo = t6.geometryInfo, this._spatialReference = s10, this._projectionSupportCheck = f3(s10, f.WGS84), this._bitsets.geohash = r6.getBitset(r6.createBitset()), this._bitsets.inserted = r6.getBitset(r6.createBitset());
  }
  destroy() {
    this._tree.destroy();
  }
  get featureSpatialReference() {
    return this._spatialReference;
  }
  get fields() {
    return this._fields;
  }
  async updateSchema(e3, t6) {
    const i6 = this._schema;
    try {
      await super.updateSchema(e3, t6), await this._projectionSupportCheck;
    } catch (h8) {
    }
    this._fields = [...this._schema.params.fields, { name: "referenceId", alias: "referenceId", type: "esriFieldTypeInteger" }];
    !!this._fields.some((e4) => "cluster_count" === e4.name) || this._fields.push({ name: "cluster_count", alias: "cluster_count", type: "esriFieldTypeInteger" });
    const a7 = a2(i6, t6);
    t6 && (null != a7 || e3.source || e3.storage.filters) ? ((s5(a7, "params.fields") || !this._tree || e3.source) && (this._tree && this._tree.destroy(), this._tree = new h7(this._statisticFields, this._serviceInfo), this._rebuildTree(), has("esri-2d-update-debug") && console.debug("Aggregate mesh needs update due to tree changing")), has("esri-2d-update-debug") && console.debug("Applying Update - ClusterStore:", a7), e3.targets[t6.name] = true, e3.mesh = false, this._aggregateValueRanges = {}) : i6 && (e3.mesh = true);
  }
  clear() {
    this._rebuildTree();
  }
  sweepFeatures(e3, t6) {
    this._bitsets.inserted.forEachSet((s10) => {
      if (!e3.has(s10)) {
        const e4 = t6.lookupByDisplayIdUnsafe(s10);
        this._remove(e4);
      }
    });
  }
  sweepAggregates(e3, t6, s10) {
    this._clusters.forEach((r6, o6) => {
      r6 && r6.tileLevel !== s10 && (e3.releaseDisplayId(r6.displayId), t6.unsetAttributeData(r6.displayId), this._clusters.delete(o6));
    });
  }
  onTileData(e3, t6, s10, r6, o6 = true) {
    if (!this._schema || null == t6.addOrUpdate)
      return t6;
    this.events.emit("changed");
    const i6 = this._getTransforms(e3, this._spatialReference);
    {
      const e4 = t6.addOrUpdate.getCursor();
      for (; e4.next(); )
        this._update(e4, r6);
    }
    if (t6.status.mesh || !o6)
      return t6;
    const a7 = new Array(), h8 = this._schema.params.clusterRadius;
    this._getClustersForTile(a7, e3, h8, s10, i6), t6.addOrUpdate = h3.fromOptimizedFeatures(a7, { fields: this.fields, geometryType: "esriGeometryPoint", objectIdField: this.objectIdField }), t6.addOrUpdate.attachStorage(s10), t6.clear = true, t6.end = true;
    {
      const r7 = t6.addOrUpdate.getCursor();
      for (; r7.next(); ) {
        const t7 = r7.getDisplayId();
        this._bitsets.computed.unset(t7), this.setComputedAttributes(s10, r7, t7, e3.scale);
      }
    }
    return this._aggregateValueRangesChanged && t6.end && (this.events.emit("valueRangesChanged", { valueRanges: this._aggregateValueRanges }), this._aggregateValueRangesChanged = false), t6;
  }
  onTileUpdate({ added: e3, removed: t6 }) {
    if (e3.length) {
      const t7 = e3[0].level;
      this._tileLevel = t7, this._setGeohashLevel(t7);
    }
    if (!this._schema)
      return;
    const s10 = this._schema.params.clusterRadius;
    t6.forEach((e4) => {
      this._tiles.delete(e4.key.id), this._markTileClustersForDeletion(e4, s10);
    });
  }
  getAggregate(e3) {
    for (const t6 of this._clusters.values())
      if (((t6 == null ? void 0 : t6.displayId) & n5) == (e3 & n5))
        return t6.toJSON();
    return null;
  }
  getAggregates() {
    const e3 = [];
    for (const t6 of this._clusters.values())
      (t6 == null ? void 0 : t6.tileLevel) === this._tileLevel && e3.push(t6.toJSON());
    return e3;
  }
  getDisplayId(e3) {
    const t6 = this._clusters.get(e3);
    return t6 ? t6.displayId : null;
  }
  getFeatureDisplayIdsForAggregate(e3) {
    const t6 = this._clusters.get(e3);
    return t6 ? this._tree.getRegionDisplayIds(t6.geohashBoundsInfo) : [];
  }
  getDisplayIdForReferenceId(e3) {
    for (const t6 of this._clusters.values())
      if ((t6 == null ? void 0 : t6.referenceId) === e3)
        return t6.displayId;
    return null;
  }
  getAggregateValueRanges() {
    return this._aggregateValueRanges;
  }
  forEach(e3) {
    this._clusters.forEach((t6) => {
      if (!t6)
        return;
      const s10 = t6.toJSON(), r6 = h3.fromFeatures([s10], { objectIdField: this.objectIdField, globalIdField: null, geometryType: this.geometryInfo.geometryType, fields: this.fields }).getCursor();
      r6.next(), e3(r6);
    });
  }
  forEachInBounds(e3, t6) {
  }
  forEachBounds(e3, t6) {
    const { hasM: s10, hasZ: r6 } = this.geometryInfo;
    for (const o6 of e3) {
      const e4 = yt(w2, o6.readGeometry(), r6, s10);
      null != e4 && t6(e4);
    }
  }
  size() {
    let e3 = 0;
    return this.forEach((t6) => e3++), e3;
  }
  _rebuildTree() {
    this._bitsets.computed.clear(), this._bitsets.inserted.clear(), this._tree && this._tree.clear();
  }
  _remove(e3) {
    const t6 = e3.getDisplayId(), s10 = e3.getXHydrated(), r6 = e3.getYHydrated(), o6 = this._geohashBuf[2 * t6], i6 = this._geohashBuf[2 * t6 + 1];
    this._bitsets.inserted.has(t6) && (this._bitsets.inserted.unset(t6), this._tree.removeCursor(e3, s10, r6, o6, i6, this._geohashLevel));
  }
  _update(e3, t6) {
    const s10 = e3.getDisplayId(), r6 = this._bitsets.inserted, o6 = t6.isVisible(s10);
    if (o6 === r6.has(s10))
      return;
    if (!o6)
      return void this._remove(e3);
    const i6 = e3.getXHydrated(), a7 = e3.getYHydrated();
    if (!this._setGeohash(s10, i6, a7))
      return;
    const h8 = this._geohashBuf[2 * s10], n8 = this._geohashBuf[2 * s10 + 1];
    this._tree.insertCursor(e3, s10, i6, a7, h8, n8, this._geohashLevel), r6.set(s10);
  }
  _setGeohash(e3, t6, s10) {
    if (this._bitsets.geohash.has(e3))
      return true;
    const r6 = this._geohashBuf;
    if (this._spatialReference.isWebMercator) {
      const o6 = T2(t6 / s4.radius), a7 = o6 - 360 * Math.floor((o6 + 180) / 360), h8 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-s10 / s4.radius)));
      b3(r6, e3, h8, a7, F2);
    } else {
      const o6 = g2({ x: t6, y: s10 }, this._spatialReference, f.WGS84);
      if (!o6)
        return false;
      b3(r6, e3, o6.y, o6.x, F2);
    }
    return this._bitsets.geohash.set(e3), true;
  }
  _getClustersForTile(e3, s10, r6, o6, i6, a7 = true) {
    const h8 = this._schema.params.clusterPixelBuffer, n8 = 2 * r6, l5 = Math.ceil(2 ** s10.key.level * c3 / n8) + 1, u7 = Math.ceil(h8 / n8) + 0, d8 = Math.ceil(c3 / n8), { row: f8, col: m9 } = s10.key, _3 = m9 * c3, y6 = f8 * c3, b4 = Math.floor(_3 / n8) - u7, v3 = Math.floor(y6 / n8) - u7, R4 = b4 + d8 + 2 * u7, M3 = v3 + d8 + 2 * u7, x3 = s10.tileInfoView.getLODInfoAt(s10.key.level);
    for (let I5 = b4; I5 <= R4; I5++)
      for (let r7 = v3; r7 <= M3; r7++) {
        let h9 = I5;
        x3.wrap && (h9 = I5 < 0 ? I5 + l5 : I5 % l5);
        const n9 = x3.wrap && I5 < 0, u8 = x3.wrap && I5 % l5 !== I5, d9 = this._lookupCluster(o6, x3, s10.key.level, h9, r7, s10);
        if (null != d9) {
          const s11 = n(i6, (e4) => n9 ? e4.left : u8 ? e4.right : e4.tile);
          if (a7 && null == s11)
            continue;
          if (!d9.count)
            continue;
          if (null != s11 && a7) {
            const t6 = d9.geometry.clone();
            let r8 = d9.attributes;
            t6.coords[0] = M2(s11, t6.coords[0]), t6.coords[1] = N(s11, t6.coords[1]), 1 === d9.count && null != d9.referenceId && (r8 = { ...d9.attributes, referenceId: d9.referenceId });
            const o7 = new t2(t6, r8);
            o7.displayId = d9.displayId, e3.push(o7);
          }
        }
      }
  }
  _getGeohashLevel(e3) {
    return Math.min(Math.ceil(e3 / 2 + 2), F2);
  }
  _setGeohashLevel(e3) {
    const t6 = this._getGeohashLevel(e3), s10 = (Math.floor(t6 / B2) + 1) * B2 - 1;
    if (this._geohashLevel !== s10)
      return this._geohashLevel = s10, this._rebuildTree(), void this._bitsets.geohash.clear();
  }
  _getTransforms(e3, t6) {
    const s10 = { originPosition: "upperLeft", scale: [e3.resolution, e3.resolution], translate: [e3.bounds[0], e3.bounds[3]] }, r6 = d2(t6);
    if (!r6)
      return { tile: s10, left: null, right: null };
    const [o6, i6] = r6.valid;
    return { tile: s10, left: { ...s10, translate: [i6, e3.bounds[3]] }, right: { ...s10, translate: [o6 - i6 + e3.bounds[0], e3.bounds[3]] } };
  }
  _getClusterId(e3, t6, s10) {
    return (15 & e3) << 28 | (16383 & t6) << 14 | 16383 & s10;
  }
  _markForDeletion(e3, t6, s10) {
    const r6 = this._getClusterId(e3, t6, s10);
    this._clusters.delete(r6);
  }
  _getClusterBounds(e3, t6, s10) {
    const r6 = this._schema.params.clusterRadius, o6 = 2 * r6;
    let i6 = s10 % 2 ? t6 * o6 : t6 * o6 - r6;
    const a7 = s10 * o6;
    let h8 = i6 + o6;
    const n8 = a7 - o6, l5 = 2 ** e3.level * c3;
    e3.wrap && i6 < 0 && (i6 = 0), e3.wrap && h8 > l5 && (h8 = l5);
    const u7 = i6 / c3, g5 = a7 / c3, c9 = h8 / c3, d8 = n8 / c3;
    return [e3.getXForColumn(u7), e3.getYForRow(g5), e3.getXForColumn(c9), e3.getYForRow(d8)];
  }
  _getGeohash(e3, t6, s10) {
    const r6 = { geohashX: 0, geohashY: 0 };
    return Y(r6, t6, e3, s10), r6;
  }
  _getGeohashBounds(e3, t6) {
    const s10 = this._getGeohashLevel(e3.key.level);
    if (this._spatialReference.isWebMercator) {
      const [e4, r7, o7, i7] = t6, h9 = { x: e4, y: r7 }, l6 = { x: o7, y: i7 };
      let u8 = 0, g6 = 0, c10 = 0, d8 = 0;
      {
        const e5 = T2(h9.x / s4.radius);
        u8 = e5 - 360 * Math.floor((e5 + 180) / 360), g6 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-h9.y / s4.radius)));
      }
      {
        const e5 = T2(l6.x / s4.radius);
        c10 = e5 - 360 * Math.floor((e5 + 180) / 360), d8 = T2(Math.PI / 2 - 2 * Math.atan(Math.exp(-l6.y / s4.radius)));
      }
      const f9 = { geohashX: 0, geohashY: 0 }, p7 = { geohashX: 0, geohashY: 0 };
      Y(f9, g6, u8, s10), Y(p7, d8, c10, s10);
      return { bounds: [e4, r7, o7, i7], geohashBounds: { xLL: f9.geohashX, yLL: f9.geohashY, xTR: p7.geohashX, yTR: p7.geohashY }, level: s10 };
    }
    const r6 = j4.fromExtent(M.fromBounds(t6, this._spatialReference)), o6 = g2(r6, this._spatialReference, f.WGS84, { densificationStep: e3.resolution * L3 });
    if (!o6)
      return null;
    const i6 = K(new t3(), o6, false, false), h8 = i6.coords.filter((e4, t7) => !(t7 % 2)), l5 = i6.coords.filter((e4, t7) => t7 % 2), u7 = Math.min(...h8), g5 = Math.min(...l5), c9 = Math.max(...h8), f8 = Math.max(...l5), p6 = this._getGeohash(u7, g5, s10), _3 = this._getGeohash(c9, f8, s10);
    return { bounds: t6, geohashBounds: { xLL: p6.geohashX, yLL: p6.geohashY, xTR: _3.geohashX, yTR: _3.geohashY }, level: s10 };
  }
  _lookupCluster(e3, t6, s10, r6, o6, i6) {
    const a7 = this._getClusterId(s10, r6, o6), h8 = this._clusters.get(a7), n8 = this._getClusterBounds(t6, r6, o6), l5 = this._getGeohashBounds(i6, n8);
    if (null == l5)
      return null;
    const u7 = this._tree.getRegionStatistics(l5), { count: g5, xTotal: c9, yTotal: d8, referenceId: f8 } = u7, p6 = g5 ? c9 / g5 : 0, m9 = g5 ? d8 / g5 : 0;
    if (0 === g5)
      return this._clusters.set(a7, null), null;
    const _3 = { cluster_count: g5, ...u7.attributes }, y6 = null != h8 ? h8.update(p6, m9, s10, _3, l5, f8) : S5.create(e3, a7, p6, m9, s10, _3, l5, f8);
    if (0 === g5) {
      const [e4, t7, s11, r7] = n8;
      y6.geometry.coords[0] = (e4 + s11) / 2, y6.geometry.coords[1] = (t7 + r7) / 2;
    }
    return this._clusters.set(a7, y6), this._updateAggregateValueRangeForCluster(y6, y6.tileLevel), y6;
  }
  _updateAggregateValueRangeForCluster(e3, t6) {
    const s10 = this._aggregateValueRanges[t6] || { minValue: 1 / 0, maxValue: 0 }, r6 = s10.minValue, o6 = s10.maxValue;
    s10.minValue = Math.min(r6, e3.count), s10.maxValue = Math.max(o6, e3.count), this._aggregateValueRanges[t6] = s10, r6 === s10.minValue && o6 === s10.maxValue || (this._aggregateValueRangesChanged = true);
  }
  _markTileClustersForDeletion(e3, t6) {
    const s10 = 2 * t6, r6 = Math.ceil(c3 / s10), { row: o6, col: i6 } = e3.key, a7 = i6 * c3, h8 = o6 * c3, n8 = Math.floor(a7 / s10), l5 = Math.floor(h8 / s10);
    for (let u7 = n8; u7 < n8 + r6; u7++)
      for (let t7 = l5; t7 < l5 + r6; t7++)
        this._markForDeletion(e3.key.level, u7, t7);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/controllers/FeatureController2D.js
var E = 5e3;
var w3 = "tileRenderer.featuresView.attributeView.initialize";
var T3 = "tileRenderer.featuresView.attributeView.requestUpdate";
var j6 = "tileRenderer.featuresView.requestRender";
function k(e3) {
  return "worker:port-closed" === e3.name;
}
function A2(e3) {
  if (!d(e3) && !k(e3))
    throw e3;
}
function x2(e3) {
  return "feature" === e3.type && "snapshot" === e3.mode;
}
var U = class extends d3 {
  constructor() {
    super(...arguments), this._storage = new r4(), this._markedIdsBufId = this._storage.createBitset(), this._lastCleanup = performance.now(), this._cleanupNeeded = false, this._invalidated = false, this._tileToResolver = /* @__PURE__ */ new Map(), this._didEdit = false, this._updateVersion = 1, this.tileStore = null, this.config = null, this.processor = null, this.remoteClient = null, this.service = null;
  }
  initialize() {
    this._initStores(), this._initSource(), this._updateQueue = new u2({ concurrency: "stream" === this._source.type ? 1 : 4, process: (e3, t6) => this._onTileMessage(e3, { signal: t6 }) }), this.addHandles([this.tileStore.on("update", this.onTileUpdate.bind(this)), f2(() => !this.updating, () => this.onIdle())]);
  }
  _initSource() {
    const e3 = this.tileStore.tileScheme, t6 = () => this._updateQueue && this._updateQueue.length < 50, r6 = (e4, t7) => (this._invalidated = true, this._patchTile(e4, t7));
    this._source = n7(this.service, this.spatialReference, e3, r6, t6, this.featureStore), this._proxyEvents();
  }
  _setStreamClientProperty(e3, t6) {
    this.remoteClient.invoke("setProperty", { propertyName: e3, value: t6 }).catch(A2);
  }
  _proxyEvents() {
    if ("stream" === this._source.type) {
      const e3 = this._source.events, t6 = this._source;
      this.addHandles([l(() => t6.connectionStatus, (e4) => this._setStreamClientProperty("pipelineConnectionStatus", e4), { initial: true }), l(() => t6.errorString, (e4) => this._setStreamClientProperty("pipelineErrorString", e4), { initial: true }), e3.on("data-received", (e4) => this.remoteClient.invoke("emitEvent", { name: "data-received", event: { attributes: e4.attributes, centroid: e4.centroid, geometry: e4.geometry } }).catch(A2)), e3.on("message-received", (e4) => this.remoteClient.invoke("emitEvent", { name: "message-received", event: e4 }).catch(A2)), e3.on("updateRate", (e4) => this.remoteClient.invoke("emitEvent", { name: "update-rate", event: { ...e4 } }).catch(A2))]);
    }
  }
  _initAttributeStore(e3) {
    this.attributeStore || (this.attributeStore = new B({ type: "remote", initialize: (e4, t6) => y(this.remoteClient.invoke(w3, e4, { signal: t6 }).catch(A2)), update: (e4, t6) => y(this.remoteClient.invoke(T3, e4, { signal: t6 }).catch(A2)), render: (e4) => y(this.remoteClient.invoke(j6, void 0, { signal: e4 }).catch(A2)) }, e3));
  }
  _initStores() {
    const e3 = "snapshot" === this.service.type ? "snapshot" : "on-demand", t6 = { geometryInfo: { geometryType: this.service.geometryType, hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
    this.featureStore = new u3(t6, this._storage, e3);
  }
  _initQueryEngine(e3) {
    var _a;
    const t6 = this;
    (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), this.featureQueryEngine = new ee({ definitionExpression: e3.schema.source.definitionExpression ?? void 0, fields: this.service.fields, geometryType: this.service.geometryType, objectIdField: this.service.objectIdField, hasM: false, hasZ: false, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: true, featureStore: this.featureStore, aggregateAdapter: { getFeatureObjectIds(e4) {
      if (null == t6.aggregateStore)
        return [];
      return t6.aggregateStore.getFeatureDisplayIdsForAggregate(e4).map((e5) => t6.getObjectId(e5));
    } }, timeInfo: this.service.timeInfo });
  }
  _initAggregateQueryEngine(e3, t6) {
    var _a;
    if ((_a = this.aggregateQueryEngine) == null ? void 0 : _a.destroy(), null == e3)
      return;
    const r6 = t6.targets.aggregate.params.fields.slice();
    this.aggregateQueryEngine = new ee({ definitionExpression: void 0, fields: r6, geometryType: e3.geometryInfo.geometryType, objectIdField: e3.objectIdField, hasM: e3.geometryInfo.hasM, hasZ: e3.geometryInfo.hasZ, spatialReference: this.spatialReference.toJSON(), cacheSpatialQueries: false, featureStore: e3, aggregateAdapter: { getFeatureObjectIds: (e4) => [] } });
  }
  destroy() {
    var _a, _b, _c;
    this._updateQueue.destroy(), this._source.destroy(), (_a = this.featureQueryEngine) == null ? void 0 : _a.destroy(), (_b = this.aggregateQueryEngine) == null ? void 0 : _b.destroy(), (_c = this.attributeStore) == null ? void 0 : _c.destroy();
    for (const e3 of this.tileStore.tiles)
      this._source.unsubscribe(e3);
    clearInterval(this._checkUpdating);
  }
  get fieldsIndex() {
    return new r2(this.service.fields);
  }
  get spatialReference() {
    return this.tileStore.tileScheme.spatialReference;
  }
  get updating() {
    return this.isUpdating();
  }
  isUpdating() {
    const e3 = this._source.updatingHandles.updating, t6 = !this.attributeStore || this.attributeStore.updatingHandles.updating, r6 = e3 || t6 || this.updatingHandles.updating;
    if (has("esri-2d-log-updating")) {
      let s10 = `Updating FeatureController2D: ${r6}
`;
      s10 += `  -> updatingSource ${e3}
`;
      for (const e4 of this._source.subscriptions)
        s10 += `     ${e4.tile.id} ${e4.isDone}
`;
      s10 += `  -> updatingAttributeStore ${t6}
`, s10 += `  -> updatingHandles ${this.updatingHandles.updating} (queue: ${this._updateQueue.length})
`, console.log(s10);
    }
    return r6;
  }
  updateCustomParameters(e3) {
    "stream" === this._source.type && this._source.updateCustomParameters(e3);
  }
  enableEvent(e3) {
    this._source.enableEvent(e3.name, e3.value);
  }
  pause() {
    this._updateQueue.pause(), this._updateQueue.clear();
  }
  resume() {
    this._updateQueue.resume();
  }
  pauseStream() {
    "stream" === this._source.type && this._source.pauseStream();
  }
  resumeStream() {
    "stream" === this._source.type && this._source.resumeStream();
  }
  sendMessageToSocket(e3) {
    "stream" === this._source.type && this._source.sendMessageToSocket(e3);
  }
  sendMessageToClient(e3) {
    "stream" === this._source.type && this._source.sendMessageToClient(e3);
  }
  _initAggregateStore(e3) {
    var _a, _b;
    const t6 = (_b = (_a = e3.schema.targets) == null ? void 0 : _a.aggregate) == null ? void 0 : _b.type, r6 = n(this.config, (e4) => {
      var _a2, _b2;
      return (_b2 = (_a2 = e4.schema.targets) == null ? void 0 : _a2.aggregate) == null ? void 0 : _b2.type;
    });
    if (r6 !== t6 && (null != this.aggregateStore && (this.removeHandles("valueRangesChanged"), this.aggregateStore.destroy(), this.aggregateStore = null), t6)) {
      switch (t6) {
        case "cluster": {
          const e4 = { geometryInfo: { geometryType: "esriGeometryPoint", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new V(e4, this.spatialReference, this._storage, this.service), this.addHandles(this.aggregateStore.events.on("valueRangesChanged", (e5) => {
            this.remoteClient.invoke("emitEvent", { name: "valueRangesChanged", event: { valueRanges: e5.valueRanges } }).catch(A2);
          }), "valueRangesChanged");
          break;
        }
        case "bin": {
          const e4 = { geometryInfo: { geometryType: "esriGeometryPolygon", hasM: false, hasZ: false }, spatialReference: this.spatialReference, fieldsIndex: this.fieldsIndex, fields: this.service.fields };
          this.aggregateStore = new A(e4, this.spatialReference, this._storage, this.service);
          break;
        }
      }
      this.aggregateStore.onTileUpdate({ added: this.tileStore.tiles, removed: [] });
    }
  }
  async update(e3, t6) {
    this._updateVersion++, has("esri-2d-update-debug") && console.debug(`FeatureController2D::update: Token version ${this._updateVersion}`), this._initQueryEngine(t6), this._initAttributeStore(t6), this.pause(), await Promise.all([this._source.update(e3, t6.schema.source), this.featureStore.updateSchema(e3, t6.schema.targets.feature), this.attributeStore.update(e3, t6), this.attributeStore.updateFilters(e3, t6, this)]), this._initAggregateStore(t6), null != this.aggregateStore && await this.aggregateStore.updateSchema(e3, t6.schema.targets.aggregate), this._initAggregateQueryEngine(this.aggregateStore, t6.schema), has("esri-2d-update-debug") && e3.describe(), this._set("config", t6);
  }
  async applyUpdate(e3) {
    e3.version = this._updateVersion, has("esri-2d-update-debug") && console.debug(`FeatureController2D::applyUpdate: Token version ${e3.version}`), e3.mesh && this.clearTiles(), this._updateQueue.resume(), await this._source.applyUpdate(e3), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Waiting for source update to finish"), this.notifyChange("updating"), await j2(() => !this.updating), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Source update finsihed"), null != this.aggregateStore && (await g(10), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Waiting for aggregate idle call"), await j2(() => !this.updating), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Aggregate idle called")), has("esri-2d-update-debug") && console.debug("FeatureController2D::applyUpdate Update finished");
  }
  async onEdits({ edits: e3 }) {
    has("esri-2d-update-debug") && console.debug("Applying Edit:", e3), this._didEdit = true;
    try {
      const t6 = e3.removed.map((e4) => e4.objectId && -1 !== e4.objectId ? e4.objectId : this._lookupObjectIdByGlobalId(e4.globalId)), r6 = e3.addOrModified.map(({ objectId: e4 }) => e4);
      this.featureStore.invalidate(), await this._source.edit(r6, t6), this.clearTiles(), this.notifyChange("updating"), null != this.aggregateStore && this.aggregateStore.clear(), await this._source.resend(), await j2(() => !this.updating);
    } catch (t6) {
    }
  }
  async refresh(e3) {
    if (!e3.dataChanged) {
      const e4 = t5.empty();
      return e4.storage.filters = true, this.applyUpdate(e4);
    }
    this.featureStore.invalidate(), this.clearTiles(), this._source.refresh(this._updateVersion, e3), this._cleanupNeeded = true, this.notifyChange("updating"), await j2(() => !this.updating);
  }
  clearTiles() {
    for (const e3 of this.tileStore.tiles)
      this.processor.onTileClear(e3, false);
  }
  onTileUpdate(e3) {
    null != this.aggregateStore && this.aggregateStore.onTileUpdate(e3);
    for (const t6 of e3.added)
      this._source.subscribe(t6, this._updateVersion), this._level = t6.level;
    for (const t6 of e3.removed)
      this._source.unsubscribe(t6), this._cleanupNeeded = true, this._tileToResolver.has(t6.id) && (this._tileToResolver.get(t6.id).resolve(), this._tileToResolver.delete(t6.id));
    this.notifyChange("updating");
  }
  async onIdle() {
    this._invalidated && (this._invalidated = false, null == this.aggregateStore && "heatmap" !== this.processor.type || await this._repushCurrentLevelTiles()), this._markAndSweep();
  }
  async querySummaryStatistics({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForSummaryStatistics(e3, t6);
  }
  async queryAggregateSummaryStatistics({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForSummaryStatistics(this._normalizeAggregateQuery(e3), t6);
  }
  async queryUniqueValues({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForUniqueValues(e3, t6);
  }
  async queryAggregateUniqueValues({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForUniqueValues(this._normalizeAggregateQuery(e3), t6);
  }
  async queryClassBreaks({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForClassBreaks(e3, t6);
  }
  async queryAggregateClassBreaks({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForClassBreaks(this._normalizeAggregateQuery(e3), t6);
  }
  async queryHistogram({ query: e3, params: t6 }) {
    return this.featureQueryEngine.executeQueryForHistogram(e3, t6);
  }
  async queryAggregateHistogram({ query: e3, params: t6 }) {
    return this.aggregateQueryEngine.executeQueryForHistogram(this._normalizeAggregateQuery(e3), t6);
  }
  queryExtent(e3) {
    return this.featureQueryEngine.executeQueryForExtent(e3);
  }
  queryAggregates(e3) {
    return this.aggregateQueryEngine.executeQuery(this._normalizeAggregateQuery(e3));
  }
  queryAggregateCount(e3) {
    return this.aggregateQueryEngine.executeQueryForCount(this._normalizeAggregateQuery(e3));
  }
  queryAggregateIds(e3) {
    return this.aggregateQueryEngine.executeQueryForIds(this._normalizeAggregateQuery(e3));
  }
  queryFeatures(e3) {
    return this.featureQueryEngine.executeQuery(e3);
  }
  async queryVisibleFeatures(e3) {
    const t6 = await this.featureQueryEngine.executeQuery(e3), r6 = t6.objectIdFieldName;
    return t6.features = t6.features.filter((e4) => {
      const t7 = e4.attributes[r6], i6 = this.getDisplayId(t7);
      return n(i6, (e5) => this.attributeStore.isVisible(e5));
    }), t6;
  }
  queryFeatureCount(e3) {
    return this.featureQueryEngine.executeQueryForCount(e3);
  }
  queryLatestObservations(e3) {
    return this.featureQueryEngine.executeQueryForLatestObservations(e3);
  }
  queryObjectIds(e3) {
    return this.featureQueryEngine.executeQueryForIds(e3);
  }
  async queryStatistics() {
    return this.featureStore.storeStatistics;
  }
  getObjectId(e3) {
    return this.featureStore.lookupObjectId(e3, this._storage);
  }
  getDisplayId(e3) {
    if (null != this.aggregateStore) {
      const t6 = this.aggregateStore.getDisplayId(e3);
      if (null == t6) {
        const t7 = this.featureStore.lookupDisplayId(e3);
        return this.aggregateStore.getDisplayIdForReferenceId(t7);
      }
      return t6;
    }
    return this.featureStore.lookupDisplayId(e3);
  }
  getFeatures(e3) {
    const t6 = [], r6 = [];
    for (const s10 of e3) {
      const e4 = null != this.aggregateStore ? this.getAggregate(s10) : null;
      if (null != e4)
        if (null != e4.attributes.referenceId) {
          const r7 = this.getFeature(e4.attributes.referenceId);
          null != r7 && t6.push(r7);
        } else
          r6.push(e4);
      else {
        const e5 = this.getFeature(s10);
        null != e5 && t6.push(e5);
      }
    }
    return { features: t6, aggregates: r6 };
  }
  getFeature(e3) {
    const t6 = this.featureStore.lookupFeatureByDisplayId(e3, this._storage);
    if (null == t6)
      return null;
    const r6 = t6.readHydratedGeometry(), s10 = st(r6, t6.geometryType, t6.hasZ, t6.hasM);
    return { attributes: t6.readAttributes(), geometry: s10 };
  }
  getAggregate(e3) {
    return null == this.aggregateStore ? null : this.aggregateStore.getAggregate(e3);
  }
  getAggregates() {
    return null == this.aggregateStore ? [] : this.aggregateStore.getAggregates();
  }
  async setHighlight(e3) {
    const r6 = e3.map((e4) => this.getDisplayId(e4)).filter(R);
    return this.attributeStore.setHighlight(e3, r6);
  }
  _normalizeAggregateQuery(e3) {
    const t6 = e3.objectIds ?? [];
    for (const r6 of e3.aggregateIds ?? [])
      t6.push(r6);
    return e3.objectIds = t6, e3.aggregateIds = [], e3;
  }
  _lookupObjectIdByGlobalId(e3) {
    const t6 = this.service.globalIdField;
    if (null == t6)
      throw new Error("Expected globalIdField to be defined");
    let r6 = null;
    if (this.featureStore.forEach((s10) => {
      e3 === s10.readAttribute(t6) && (r6 = s10.getObjectId());
    }), null == r6)
      throw new Error(`Expected to find a feature with globalId ${e3}`);
    return r6;
  }
  async _repushCurrentLevelTiles() {
    const e3 = this.tileStore.tiles.filter((e4) => e4.level === this._level);
    e3.map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, clear: true, addOrUpdate: null, end: false }));
    const t6 = e3.map(async (e4) => this._patchTile({ type: "append", id: e4.key.id, addOrUpdate: h3.fromOptimizedFeatures([], this.service), remove: [], end: true, isRepush: true, status: t5.empty() }));
    await Promise.all(t6);
  }
  _maybeForceCleanup() {
    performance.now() - this._lastCleanup > E && this._markAndSweep();
  }
  _patchTile(e3, t6) {
    const r6 = this._updateQueue.push(e3, t6).catch((e4) => {
    });
    return this.updatingHandles.addPromise(r6);
  }
  async _onTileMessage(e3, t6) {
    if (s3(t6), has("esri-2d-update-debug")) {
      const t7 = n(e3.addOrUpdate, (e4) => e4.hasFeatures);
      console.debug(e3.id, `FeatureController:onTileMessage: [clear:${e3.clear}, end:${e3.end}, features: ${t7}]`);
    }
    const r6 = this.tileStore.get(e3.id);
    if (!r6)
      return;
    if (e3.clear)
      return this.processor.onTileClear(r6, e3.end);
    const i6 = e3.status;
    this._cleanupNeeded = true;
    const a7 = [];
    for (const s10 of e3.remove ?? []) {
      const e4 = this.featureStore.lookupDisplayId(s10);
      e4 && a7.push(e4);
    }
    e3.remove = a7;
    try {
      if (null == e3.addOrUpdate)
        return void this.processor.onTileMessage(r6, { ...e3, addOrUpdate: null }, null != this.aggregateStore, t6).catch(m);
      if (e3.addOrUpdate.setArcadeSpatialReference(this.spatialReference), this.featureStore.hasInstance(e3.addOrUpdate.instance) && i6.targets.feature || (i6.targets.feature = true, this.featureStore.onTileData(r6, e3)), !i6.storage.data || !i6.storage.filters) {
        i6.storage.data = true, i6.storage.filters = true, this.attributeStore.onTileData(r6, e3);
        "stream" === this._source.type || this._didEdit ? (await this.attributeStore.sendUpdates(), s3(t6)) : this.attributeStore.sendUpdates();
      }
      if (null != this.aggregateStore && !i6.targets.aggregate) {
        i6.targets.aggregate = true;
        const t7 = x2(this._source) && this._source.loading, s10 = !x2(this._source) || t7 || e3.end;
        if (this.aggregateStore.onTileData(r6, e3, this._storage, this.attributeStore, s10), !s10)
          return;
        i6.mesh || (this.attributeStore.onTileData(r6, e3), await this.attributeStore.sendUpdates());
      }
      if (!i6.mesh) {
        i6.mesh = true;
        const s10 = null != this.aggregateStore && "cluster" === this.aggregateStore.type;
        await this.processor.onTileMessage(r6, e3, s10, t6), s3(t6);
      }
      this._maybeForceCleanup();
    } catch (u7) {
      m(u7);
    }
  }
  _mark(e3, t6, r6) {
    const s10 = (4294901760 & this._storage.getInstanceId(e3)) >>> 16;
    e3 && (t6.add(s10), r6.set(e3));
  }
  _markAndSweep() {
    this._lastCleanup = performance.now();
    if (!(!("feature" === this._source.type && "snapshot" === this._source.mode) && ("stream" === this._source.type || this._cleanupNeeded)))
      return;
    this._cleanupNeeded = false;
    const e3 = this._storage.getBitset(this._markedIdsBufId), t6 = /* @__PURE__ */ new Set();
    e3.clear();
    for (const r6 of this.tileStore.tiles)
      for (const s10 of this._source.readers(r6.id)) {
        const r7 = s10.getCursor();
        for (; r7.next(); ) {
          let s11 = r7.getDisplayId();
          if (!s11) {
            const e4 = r7.getObjectId();
            s11 = this.featureStore.lookupDisplayId(e4);
          }
          this._mark(s11, t6, e3);
        }
      }
    "symbol" === this.processor.type && this.processor.forEachBufferId((r6) => {
      this._mark(r6, t6, e3);
    }), this._updateQueue.forEach((r6) => {
      for (const s10 of r6.remove ?? []) {
        const r7 = this.featureStore.lookupDisplayId(s10);
        this._mark(r7, t6, e3);
      }
    }), null != this.aggregateStore && (this.aggregateStore.sweepFeatures(e3, this.featureStore), "sweepAggregates" in this.aggregateStore && this.aggregateStore.sweepAggregates(this._storage, this.attributeStore, this._level)), this.featureStore.sweepFeatures(e3, this._storage, this.attributeStore), this.featureStore.sweepFeatureSets(t6);
  }
};
e([y2({ constructOnly: true })], U.prototype, "tileStore", void 0), e([y2()], U.prototype, "config", void 0), e([y2({ readOnly: true })], U.prototype, "fieldsIndex", null), e([y2()], U.prototype, "processor", void 0), e([y2({ constructOnly: true })], U.prototype, "remoteClient", void 0), e([y2({ constructOnly: true })], U.prototype, "service", void 0), e([y2()], U.prototype, "spatialReference", null), e([y2()], U.prototype, "updating", null), U = e([a("esri.views.2d.layers.features.controllers.FeatureController2D")], U);
var R3 = U;

// node_modules/@arcgis/core/views/2d/layers/features/Pipeline.js
var d7 = class extends d3 {
  constructor() {
    super(...arguments), this.controller = null, this.processor = null, this.remoteClient = null, this.tileStore = null, this.service = null, this.viewState = null, this._paused = false, this._pendingTileUpdates = [];
  }
  initialize() {
    this.handles.add(l(() => this.updating, (e3) => {
      this.remoteClient.invoke("setUpdating", e3).catch((e4) => {
      });
    }));
  }
  destroy() {
    var _a, _b;
    this.stop(), (_a = this.controller) == null ? void 0 : _a.destroy(), (_b = this.processor) == null ? void 0 : _b.destroy(), this.controller = this.processor = this.tileStore = this.remoteClient = null;
  }
  get updating() {
    return !this.controller || this.controller.updating;
  }
  stop() {
    var _a, _b, _c;
    this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e3) => e3.close()), this.service.source.length = 0), (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e3) => e3.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = null, this._pendingTileUpdates.length = 0;
  }
  async startup({ service: e3, config: t6, tileInfo: r6, tiles: s10 }) {
    var _a, _b, _c;
    if (this._paused = true, Array.isArray((_a = this.service) == null ? void 0 : _a.source) && (this.service.source.forEach((e4) => e4.close()), this.service.source.length = 0), this.service = e3, !this.tileStore || !S(this.tileStore.tileScheme.spatialReference, r6.spatialReference)) {
      const e4 = new h2(j5.fromJSON(r6));
      s10.added.length = s10.removed.length = 0, (_b = this.tileStore) == null ? void 0 : _b.updateTiles({ added: [], removed: this.tileStore.tiles.map((e5) => e5.id) }), (_c = this.tileStore) == null ? void 0 : _c.destroy(), this.tileStore = new d4(e4), this._pendingTileUpdates.length = 0;
    }
    for (await this._createProcessorAndController(t6), await this.update({ config: t6 }), this.controller.resume(), this.tileStore.clear(), this.tileStore.updateTiles(s10), this._paused = false; this._pendingTileUpdates.length; )
      this.tileStore.updateTiles(this._pendingTileUpdates.pop());
  }
  async updateTiles(e3) {
    var _a;
    this._paused ? this._pendingTileUpdates.push(e3) : (_a = this.tileStore) == null ? void 0 : _a.updateTiles(e3);
  }
  async update({ config: e3 }) {
    const t6 = t5.empty();
    return await Promise.all([this.processor.update(t6, e3), this.controller.update(t6, e3)]), t6.toJSON();
  }
  async applyUpdate(e3) {
    return this.controller.applyUpdate(t5.create(e3));
  }
  async _createProcessorAndController(e3) {
    await Promise.all([this._handleControllerConfig(e3), this._handleProcessorConfig(e3)]), this.controller.processor = this.processor;
  }
  async _handleControllerConfig(e3) {
    return this._createController(this.service, e3);
  }
  async _handleProcessorConfig(e3) {
    return this._createProcessor(this.service, e3);
  }
  async _createController(e3, t6) {
    this.controller && this.controller.destroy();
    const { tileStore: r6, remoteClient: s10 } = this, o6 = new R3({ service: e3, tileStore: r6, remoteClient: s10 });
    return this.controller = o6, o6;
  }
  async _createProcessor(e3, t6) {
    const r6 = t6.schema.processors[0].type, s10 = (await o2(r6)).default, { remoteClient: o6, tileStore: i6 } = this, l5 = new s10({ service: e3, config: t6, tileStore: i6, remoteClient: o6 });
    return this.processor && this.processor.destroy(), this.processor = l5, l5;
  }
};
e([y2()], d7.prototype, "controller", void 0), e([y2()], d7.prototype, "processor", void 0), e([y2()], d7.prototype, "updating", null), e([y2()], d7.prototype, "viewState", void 0), d7 = e([a("esri.views.2d.layers.features.Pipeline")], d7);
var u6 = d7;
export {
  u6 as default
};
//# sourceMappingURL=Pipeline-M5POLUK5.js.map
