import {
  n as n7
} from "./chunk-UM5ZV5XB.js";
import {
  r
} from "./chunk-SJ7ZVWCS.js";
import {
  a as a6
} from "./chunk-W7FXZ6Y5.js";
import {
  o as o4
} from "./chunk-M7TZTH7O.js";
import {
  a as a5,
  h2 as h3,
  m as m4,
  n as n5,
  n2 as n6,
  r as r2,
  w as w4
} from "./chunk-TOXOPWS2.js";
import {
  e as e3
} from "./chunk-HSAM6HYE.js";
import {
  d as d6,
  f as f4
} from "./chunk-KPMUAI6T.js";
import {
  w as w3
} from "./chunk-TBMS67KR.js";
import {
  a as a4
} from "./chunk-FZIEP3HG.js";
import {
  o as o3
} from "./chunk-WON6TZX6.js";
import {
  c as c3,
  u as u5
} from "./chunk-PEYWLFGJ.js";
import {
  n as n3,
  p as p2
} from "./chunk-6YPETR6R.js";
import {
  d as d4,
  w as w2
} from "./chunk-PLCQTNGD.js";
import {
  b as b2,
  c,
  d as d5,
  f as f2,
  v
} from "./chunk-YM46NRFF.js";
import {
  b as b4
} from "./chunk-HZHMZHPT.js";
import {
  c as c2
} from "./chunk-HPXPYN62.js";
import {
  t
} from "./chunk-PM77FW2O.js";
import {
  d as d3
} from "./chunk-RNXN3MSP.js";
import {
  te
} from "./chunk-3VTULECI.js";
import {
  E as E2,
  T
} from "./chunk-TBHRKIAA.js";
import {
  i as i3
} from "./chunk-KTII3LWY.js";
import {
  V as V2
} from "./chunk-JSMUQBPG.js";
import {
  F
} from "./chunk-BCDDCNQ2.js";
import {
  b
} from "./chunk-YC4PIRSZ.js";
import {
  m as m3
} from "./chunk-32JSK7KN.js";
import {
  l as l3,
  u as u3
} from "./chunk-SCOBW7KR.js";
import {
  n as n4
} from "./chunk-KKBQS7Z3.js";
import {
  f as f3
} from "./chunk-AF36K5Y6.js";
import {
  n as n2
} from "./chunk-QNFDBY7V.js";
import {
  u as u4
} from "./chunk-PNA6D76Z.js";
import {
  l as l4
} from "./chunk-R2HXL6HT.js";
import {
  e as e2
} from "./chunk-2PAQQUAG.js";
import {
  h as h2
} from "./chunk-4SARN32Z.js";
import {
  d as d2
} from "./chunk-LNMNRMVX.js";
import {
  u as u2
} from "./chunk-EIE3W25Z.js";
import {
  $,
  D,
  Ee,
  F as F2,
  I,
  L,
  b as b3,
  g,
  i as i4,
  q,
  v as v2
} from "./chunk-7KM4XBUC.js";
import {
  E
} from "./chunk-7E3Q7HTF.js";
import {
  V
} from "./chunk-4RFFPIT2.js";
import {
  i as i2
} from "./chunk-5HAVROZG.js";
import {
  i
} from "./chunk-MOPR7RFH.js";
import {
  a as a3,
  h,
  l as l2,
  w
} from "./chunk-XN5VV437.js";
import {
  p
} from "./chunk-N5ULYWRU.js";
import {
  M
} from "./chunk-3GSONYPC.js";
import {
  f,
  o2
} from "./chunk-SFV6XLDZ.js";
import {
  m as m2,
  y3 as y2
} from "./chunk-OYBXMT5R.js";
import {
  a2
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  C,
  d,
  j,
  k,
  m,
  y
} from "./chunk-HNHXEGH2.js";
import {
  l,
  n,
  o,
  u
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  a
} from "./chunk-I5JT24BO.js";
import {
  R,
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p3 = class extends h2 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e5 = false) {
    if (this.popupTemplate)
      return this.popupTemplate;
    const r8 = this.sourceLayer && this.sourceLayer.featureReduction;
    return r8 && "popupTemplate" in r8 && r8.popupEnabled ? r8.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
e([y2({ type: Boolean })], p3.prototype, "isAggregate", void 0), p3 = e([a2("esri.AggregateGraphic")], p3);
var s3 = p3;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c4 = class extends m2 {
  constructor(e5) {
    super(e5), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a4(e5), this._includedEffectView = new a4(e5);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e5) {
    this._get("featureEffect") !== e5 && this._transitionTo(e5);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = this.featureEffect) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e5) {
    this._set("scale", e5), this._excludedEffectView.scale = e5, this._includedEffectView.scale = e5;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  transitionStep(e5, t5) {
    this._set("scale", t5), this.transitioning ? (this._includedEffectView.transitionStep(e5, t5), this._excludedEffectView.transitionStep(e5, t5), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t5, this._includedEffectView.scale = t5);
  }
  endTransitions() {
    this._includedEffectView.endTransitions(), this._excludedEffectView.endTransitions(), this._filter = null;
  }
  _transitionTo(e5) {
    const t5 = this._get("featureEffect"), i9 = e5, s6 = i9 == null ? void 0 : i9.includedEffect, f6 = i9 == null ? void 0 : i9.excludedEffect, c10 = this._includedEffectView.canTransitionTo(s6) && this._excludedEffectView.canTransitionTo(f6);
    this._includedEffectView.effect = s6, this._excludedEffectView.effect = f6, this._set("featureEffect", i9), this._filter = (i9 == null ? void 0 : i9.filter) || (t5 == null ? void 0 : t5.filter) || null, c10 || this.endTransitions();
  }
};
e([y2()], c4.prototype, "_filter", void 0), e([y2()], c4.prototype, "_excludedEffectView", void 0), e([y2()], c4.prototype, "_includedEffectView", void 0), e([y2()], c4.prototype, "duration", void 0), e([y2()], c4.prototype, "excludedEffects", null), e([y2()], c4.prototype, "featureEffect", null), e([y2()], c4.prototype, "filter", null), e([y2()], c4.prototype, "hasEffects", null), e([y2()], c4.prototype, "includedEffects", null), e([y2({ value: 0 })], c4.prototype, "scale", null), e([y2()], c4.prototype, "transitioning", null), c4 = e([a2("esri.layers.effects.FeatureEffectView")], c4);
var r3 = c4;

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c5 = class extends d3 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e5, t5) {
    const o10 = f.fromJSON(t5.spatialReference), s6 = [];
    for (let a11 = 0; a11 < e5.length; a11++) {
      const t6 = e5[a11], p7 = s3.fromJSON(t6), c10 = t6.geometry && t6.geometry.spatialReference;
      null == p7.geometry || c10 || (p7.geometry.spatialReference = o10);
      const i9 = t6.aggregateGeometries, m6 = p7.aggregateGeometries;
      if (i9 && null != m6)
        for (const e6 in m6) {
          const r8 = m6[e6], t7 = i9[e6], s7 = t7 == null ? void 0 : t7.spatialReference;
          null == r8 || s7 || (r8.spatialReference = o10);
        }
      s6.push(p7);
    }
    return s6;
  }
};
e([y2({ type: [s3], json: { write: true } })], c5.prototype, "features", void 0), e([o2("features")], c5.prototype, "readFeatures", null), c5 = e([a2("esri.rest.support.AggregateFeatureSet")], c5);
var i5 = c5;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/BaseTileRenderer.js
var r4 = class extends d2 {
  constructor(e5) {
    super(e5), this.tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    this.tiles.clear(), this.layer = this.layerView = this.tileInfoView = this.tiles = null;
  }
  get updating() {
    return this.isUpdating();
  }
  acquireTile(e5) {
    const t5 = this.createTile(e5);
    return t5.once("isReady", () => this.notifyChange("updating")), this.tiles.set(e5.id, t5), this.notifyChange("updating"), t5;
  }
  forceAttributeTextureUpload() {
  }
  forEachTile(e5) {
    this.tiles.forEach(e5);
  }
  releaseTile(e5) {
    this.tiles.delete(e5.key.id), this.notifyChange("updating"), this.disposeTile(e5);
  }
  isUpdating() {
    let e5 = true;
    this.tiles.forEach((t6) => {
      e5 = e5 && t6.isReady;
    });
    const t5 = !e5;
    if (has("esri-2d-log-updating")) {
      let s6 = "";
      this.tiles.forEach((t6) => {
        const i9 = t6.updateStatus;
        s6 += `-> ${t6.key.id}: isReady: ${t6.isReady} status: ${i9}
`, e5 = e5 && t6.isReady;
      }), console.log(`Updating BaseTileRenderer ${t5}
${s6}`);
    }
    return t5;
  }
  setHighlight() {
  }
  invalidateLabels() {
  }
  requestUpdate() {
    this.layerView.requestUpdate();
  }
};
e([y2()], r4.prototype, "layer", void 0), e([y2()], r4.prototype, "layerView", void 0), e([y2()], r4.prototype, "tileInfoView", void 0), e([y2()], r4.prototype, "updating", null), r4 = e([a2("esri.views.2d.layers.features.tileRenderers.BaseTileRenderer")], r4);
var o5 = r4;

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/HeatmapSource.js
var i6 = class {
  constructor() {
    this.gradient = null, this.height = 512, this.intensities = null, this.width = 512;
  }
  render(i9) {
    l3(i9, 512, this.intensities, this.gradient, this.minDensity, this.maxDensity);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/HeatmapTileRenderer.js
var o6 = class extends o5 {
  constructor(e5) {
    super(e5), this._intensityInfo = { minDensity: 0, maxDensity: 0 }, this.type = "heatmap", this.featuresView = { attributeView: { initialize: () => {
    }, requestUpdate: () => {
    } }, requestRender: () => {
    } }, this._container = new n7(e5.tileInfoView);
  }
  createTile(e5) {
    const t5 = this._container.createTile(e5);
    return this.tileInfoView.getTileCoords(t5.bitmap, e5), t5.bitmap.resolution = this.tileInfoView.getTileResolution(e5), t5;
  }
  onConfigUpdate() {
    const e5 = this.layer.renderer;
    if ("heatmap" === e5.type) {
      const { minDensity: t5, maxDensity: r8, colorStops: s6 } = e5;
      this._intensityInfo.minDensity = t5, this._intensityInfo.maxDensity = r8, this._gradient = u3(s6), this.tiles.forEach((e6) => {
        const i9 = e6.bitmap.source;
        i9 && (i9.minDensity = t5, i9.maxDensity = r8, i9.gradient = this._gradient, e6.bitmap.invalidateTexture(), e6.bitmap.requestRender());
      });
    }
  }
  hitTest() {
    return Promise.resolve([]);
  }
  install(e5) {
    e5.addChild(this._container);
  }
  uninstall(e5) {
    this._container.removeAllChildren(), e5.removeChild(this._container);
  }
  disposeTile(e5) {
    this._container.removeChild(e5), e5.destroy();
  }
  supportsRenderer(e5) {
    return e5 && "heatmap" === e5.type;
  }
  onTileData(e5) {
    const t5 = this.tiles.get(e5.tileKey);
    if (!t5)
      return;
    const i9 = e5.intensityInfo, { minDensity: r8, maxDensity: s6 } = this._intensityInfo, o10 = t5.bitmap.source || new i6();
    o10.intensities = i9 && i9.matrix || null, o10.minDensity = r8, o10.maxDensity = s6, o10.gradient = this._gradient, t5.bitmap.source = o10, this._container.addChild(t5), this._container.requestRender(), this.requestUpdate();
  }
  onTileError(e5) {
    console.error(e5);
  }
  lockGPUUploads() {
  }
  unlockGPUUploads() {
  }
  fetchResource(e5, t5) {
    return console.error(e5), Promise.reject();
  }
};
o6 = e([a2("esri.views.2d.layers.features.tileRenderers.HeatmapTileRenderer")], o6);

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/MetricReader.js
var t2 = 6;
var s4 = 4294967296;
var e4 = class _e {
  constructor(t5) {
    this._savedCursor = null, this._savedOffset = null, this._head = t5, this._cursor = t5;
  }
  static from(t5) {
    const s6 = r5.from(new Float32Array(t5));
    return new _e(s6);
  }
  get id() {
    return this._cursor.id;
  }
  get baseZoom() {
    return this._cursor.baseZoom;
  }
  get anchorX() {
    return this._cursor.anchorX;
  }
  get anchorY() {
    return this._cursor.anchorY;
  }
  get directionX() {
    return this._cursor.directionX;
  }
  get directionY() {
    return this._cursor.directionY;
  }
  get size() {
    return this._cursor.size;
  }
  get materialKey() {
    return this._cursor.materialKey;
  }
  get boundsCount() {
    return this._cursor.boundsCount;
  }
  computedMinZoom() {
    return this._cursor.computedMinZoom();
  }
  setComputedMinZoom(t5) {
    return this._cursor.setComputedMinZoom(t5);
  }
  boundsComputedAnchorX(t5) {
    return this._cursor.boundsComputedAnchorX(t5);
  }
  boundsComputedAnchorY(t5) {
    return this._cursor.boundsComputedAnchorY(t5);
  }
  setBoundsComputedAnchorX(t5, s6) {
    return this._cursor.setBoundsComputedAnchorX(t5, s6);
  }
  setBoundsComputedAnchorY(t5, s6) {
    return this._cursor.setBoundsComputedAnchorY(t5, s6);
  }
  boundsX(t5) {
    return this._cursor.boundsX(t5);
  }
  boundsY(t5) {
    return this._cursor.boundsY(t5);
  }
  boundsWidth(t5) {
    return this._cursor.boundsWidth(t5);
  }
  boundsHeight(t5) {
    return this._cursor.boundsHeight(t5);
  }
  link(t5) {
    if (null != t5._head)
      return this._cursor.link(t5._head);
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    var _a;
    const t5 = new _e((_a = this._head) == null ? void 0 : _a.copy());
    if (!t5._head)
      return t5;
    let s6 = t5._head, r8 = t5._head._link;
    for (; r8; )
      s6._link = r8.copy(), s6 = r8, r8 = s6._link;
    return t5;
  }
  peekId() {
    return this._cursor.peekId() ?? this._cursor._link.peekId();
  }
  nextId() {
    const t5 = this.id;
    for (; t5 === this.id; )
      if (!this.next())
        return false;
    return true;
  }
  save() {
    this._savedCursor = this._cursor, this._savedOffset = this._cursor._offset;
  }
  restore() {
    this._savedCursor && (this._cursor = this._savedCursor), null != this._savedOffset && (this._cursor._offset = this._savedOffset);
  }
  next() {
    if (!this._cursor)
      return false;
    if (!this._cursor.next()) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link, this._cursor._offset = 0;
    }
    return true;
  }
  lookup(t5) {
    for (this._cursor = this._head; this._cursor && !this._cursor.lookup(t5); ) {
      if (!this._cursor._link)
        return false;
      this._cursor = this._cursor._link;
    }
    return !!this._cursor;
  }
  delete(t5) {
    let s6 = this._head, e5 = null;
    for (; s6; ) {
      if (s6.delete(t5))
        return s6.isEmpty() && null != e5 && (e5._link = s6._link), true;
      e5 = s6, s6 = s6._link;
    }
    return false;
  }
};
var r5 = class _r {
  constructor(t5) {
    this._offset = -1, this._link = null, this._count = 0, this._deletedCount = 0, this._offsets = { instance: null }, this._buffer = t5;
  }
  static from(t5) {
    return new _r(new Float32Array(t5));
  }
  isEmpty() {
    return this._deletedCount === this.count;
  }
  get count() {
    return this._count || (this._count = this._computeCount()), this._count;
  }
  get id() {
    return this._buffer[this._offset];
  }
  set id(t5) {
    this._buffer[this._offset] = t5;
  }
  get baseZoom() {
    return this._buffer[this._offset + 1];
  }
  get anchorX() {
    return this._buffer[this._offset + 2];
  }
  get anchorY() {
    return this._buffer[this._offset + 3];
  }
  get directionX() {
    return this._buffer[this._offset + 4];
  }
  get directionY() {
    return this._buffer[this._offset + 5];
  }
  get size() {
    return this._buffer[this._offset + 6];
  }
  get materialKey() {
    return this._buffer[this._offset + 7];
  }
  computedMinZoom() {
    return this._buffer[this._offset + 8];
  }
  setComputedMinZoom(t5) {
    this._buffer[this._offset + 8] = t5;
  }
  get boundsCount() {
    return this._buffer[this._offset + 9];
  }
  boundsComputedAnchorX(s6) {
    return this._buffer[this._offset + 10 + s6 * t2];
  }
  boundsComputedAnchorY(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 1];
  }
  setBoundsComputedAnchorX(s6, e5) {
    this._buffer[this._offset + 10 + s6 * t2] = e5;
  }
  setBoundsComputedAnchorY(s6, e5) {
    this._buffer[this._offset + 10 + s6 * t2 + 1] = e5;
  }
  boundsX(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 2];
  }
  boundsY(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 3];
  }
  boundsWidth(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 4];
  }
  boundsHeight(s6) {
    return this._buffer[this._offset + 10 + s6 * t2 + 5];
  }
  link(t5) {
    let s6 = this;
    for (; s6._link; )
      s6 = s6._link;
    s6._link = t5;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t5 = new _r(this._buffer);
    return t5._link = this._link, t5._offset = this._offset, t5._deletedCount = this._deletedCount, t5._offsets = this._offsets, t5._count = this._count, t5;
  }
  peekId() {
    const s6 = this._offset + 10 + this.boundsCount * t2 + 0;
    return s6 >= this._buffer.length ? 0 : this._buffer[s6];
  }
  next() {
    let e5 = 0;
    for (; this._offset < this._buffer.length && e5++ < 100 && (-1 === this._offset ? this._offset = 0 : this._offset += 10 + this.boundsCount * t2, this.id === s4); )
      ;
    return this.id !== s4 && this._offset < this._buffer.length;
  }
  delete(t5) {
    const s6 = this._offset, e5 = this.lookup(t5);
    if (e5)
      for (this.id = 4294967295, ++this._deletedCount; this.next() && this.id === t5; )
        this.id = 4294967295, ++this._deletedCount;
    return this._offset = s6, e5;
  }
  lookup(t5) {
    const e5 = this._offset;
    if (null == this._offsets.instance) {
      this._offsets.instance = /* @__PURE__ */ new Map();
      const t6 = this.copy();
      t6._offset = -1;
      let s6 = 0;
      for (; t6.next(); )
        t6.id !== s6 && (this._offsets.instance.set(t6.id, t6._offset), s6 = t6.id);
    }
    return !!this._offsets.instance.has(t5) && (this._offset = this._offsets.instance.get(t5), this.id !== s4 || (this._offset = e5, false));
  }
  _computeCount() {
    const t5 = this._offset;
    let s6 = 0;
    for (this._offset = -1; this.next(); )
      s6++;
    return this._offset = t5, s6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Buffer.js
var n8 = 1.25;
var u6 = 32767;
var a7 = u6 << 16 | u6;
var d7 = class {
  constructor(t5, i9, r8, s6) {
    const h5 = r.create(i9 * r8 * Uint32Array.BYTES_PER_ELEMENT, s6);
    this.size = i9, this.strideInt = r8, this.bufferType = t5, this.dirty = { start: 1 / 0, end: 0 }, this._gpu = null, this._cpu = h5, this.clear();
  }
  get elementSize() {
    return this._cpu.length / this.strideInt;
  }
  get invalidated() {
    return this.bufferSize > 0 && !this._gpu;
  }
  get invalidatedComputeBuffer() {
    return this.bufferSize > 0 && !this._gpuComputeTriangles;
  }
  invalidate() {
    this._invalidateTriangleBuffer(), n(this._gpu, (t5) => t5.dispose()), this._gpu = null;
  }
  _invalidateTriangleBuffer() {
    n(this._gpuComputeTriangles, (t5) => t5.dispose()), this._gpuComputeTriangles = null;
  }
  destroy() {
    n(this._gpu, (t5) => t5.dispose()), n(this._gpuComputeTriangles, (t5) => t5.dispose()), n(this._cpu, (t5) => t5.destroy()), n(this._cpu2, (t5) => t5.destroy());
  }
  clear() {
    this.dirty.start = 1 / 0, this.dirty.end = 0, this.freeList = new a5({ start: 0, end: this._cpu.length / this.strideInt }), this.fillPointer = 0;
  }
  ensure(t5) {
    if (this.maxAvailableSpace() >= t5)
      return;
    if (t5 * this.strideInt > this._cpu.length - this.fillPointer) {
      this.invalidate();
      const i9 = this._cpu.length / this.strideInt, e5 = Math.round((i9 + t5) * n8), r8 = e5 * this.strideInt;
      this._cpu.expand(r8 * Uint32Array.BYTES_PER_ELEMENT), this.freeList.free(i9, e5 - i9);
    }
  }
  set(t5, i9) {
    this._cpu.array[t5] !== i9 && (this._cpu.array[t5] = i9, this.dirty.start = Math.min(t5, this.dirty.start), this.dirty.end = Math.max(t5, this.dirty.end));
  }
  getGPUBuffer(t5, i9 = false) {
    if (!this.bufferSize)
      return null;
    if (i9) {
      if ("index" !== this.bufferType)
        throw new Error("Tired to get triangle buffer, but target is not an index buffer");
      return null == this._gpuComputeTriangles && (this._gpuComputeTriangles = this._createComputeBuffer(t5)), this._gpuComputeTriangles;
    }
    return null == this._gpu && (this._gpu = this._createBuffer(t5)), this._gpu;
  }
  getCPUBuffer() {
    if (!this._cpu2) {
      const t5 = this._cpu.slice();
      this._cpu2 = t5;
    }
    return this._cpu2.length !== this._cpu.length && this._cpu2.expand(this._cpu.length * this._cpu.array.BYTES_PER_ELEMENT), this._cpu2.set(this._cpu), this._cpu2;
  }
  get bufferSize() {
    return this._cpu.length / this.strideInt;
  }
  maxAvailableSpace() {
    return this.freeList.maxAvailableSpace();
  }
  insert(t5, e5, r8, s6) {
    const h5 = r8 * this.strideInt;
    if (!h5)
      return 0;
    const n10 = e5 * this.strideInt * Uint32Array.BYTES_PER_ELEMENT, u10 = new Uint32Array(t5, n10, h5), a11 = u(this.freeList.firstFit(r8), "First fit region must be defined") * this.strideInt, d11 = h5, f6 = a11 / this.strideInt - e5;
    if (0 !== s6)
      for (let i9 = 0; i9 < u10.length; i9++)
        u10[i9] += s6;
    return this._cpu.array.set(u10, a11), this.dirty.start = Math.min(this.dirty.start, a11), this.dirty.end = Math.max(this.dirty.end, a11 + d11), this.fillPointer = Math.max(this.fillPointer, a11 + d11), f6;
  }
  free(t5, i9, e5) {
    const r8 = t5 * this.strideInt, s6 = (t5 + i9) * this.strideInt;
    if (true === e5)
      for (let h5 = t5; h5 !== t5 + i9; h5++)
        this._cpu.array[h5 * this.strideInt] = a7;
    this.dirty.start = Math.min(this.dirty.start, r8), this.dirty.end = Math.max(this.dirty.end, s6), this.freeList.free(t5, i9);
  }
  upload() {
    if (this.dirty.end) {
      if (this._invalidateTriangleBuffer(), null == this._gpu)
        return this.dirty.start = 1 / 0, void (this.dirty.end = 0);
      this._gpu.setSubData(this._cpu.array, this.dirty.start, this.dirty.start, this.dirty.end), this.dirty.start = 1 / 0, this.dirty.end = 0;
    }
  }
  _createBuffer(t5) {
    const i9 = F.DYNAMIC_DRAW;
    return "index" === this.bufferType ? c3.createIndex(t5, i9, this._cpu.array) : c3.createVertex(t5, i9, this._cpu.array);
  }
  _createComputeBuffer(t5) {
    const i9 = F.DYNAMIC_DRAW, e5 = new Uint32Array(this.fillPointer / 3);
    for (let r8 = 0; r8 < this.fillPointer; r8 += 3)
      e5[r8 / 3] = this._cpu.array[r8];
    return c3.createIndex(t5, i9, e5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/cpuMapped/Geometry.js
var f5 = 0;
var o7 = 1;
var d8 = class {
  constructor(e5, t5) {
    this._vaos = /* @__PURE__ */ new Map(), this._indicesInvalid = false, this.geometryType = e5, this._stage = t5;
  }
  destroy() {
    for (const [e5, t5] of this._vaos)
      t5 == null ? void 0 : t5.disposeVAOOnly();
    this._indexBuffer = l(this._indexBuffer), this._vertexBuffer = l(this._vertexBuffer);
  }
  get records() {
    return this._records;
  }
  insert(e5, r8, n10) {
    if (!e5.records.byteLength)
      return;
    const f6 = e5.stride;
    if (this._vertexBuffer && this._indexBuffer) {
      const s6 = e5.indices.byteLength / 4, n11 = e5.vertices.byteLength / f6;
      this._indexBuffer.ensure(s6), this._vertexBuffer.ensure(n11);
      const { vertices: o10, indices: d11 } = e5, h5 = r2.from(e5.records), u10 = this._vertexBuffer.insert(o10, 0, o10.byteLength / f6, 0), c10 = this._indexBuffer.insert(d11, 0, d11.byteLength / 4, u10);
      if (h5.forEach((e6) => {
        e6.indexFrom += c10, e6.vertexFrom += u10;
      }), u(this._records, "Expected records to be defined").link(h5), r8)
        this._indicesInvalid = true;
      else if (this._displayList) {
        const e6 = h5.getCursor();
        for (; e6.next(); )
          this._displayList.addRecord(e6);
      }
    } else {
      const t5 = e5.indices.byteLength / 4, n11 = e5.vertices.byteLength / f6, o10 = f6 / Uint32Array.BYTES_PER_ELEMENT, d11 = this._stage.bufferPool;
      this._records = r2.from(e5.records), this._indexBuffer = new d7("index", t5, 1, d11), this._vertexBuffer = new d7("vertex", n11, o10, d11), this._indexBuffer.insert(e5.indices, 0, e5.indices.byteLength / 4, 0), this._vertexBuffer.insert(e5.vertices, 0, e5.vertices.byteLength / f6, 0), r8 && (this._indicesInvalid = true);
    }
  }
  remove(e5) {
    if (null != this._records)
      for (const t5 of e5) {
        const e6 = this._records.getCursor();
        if (!e6.lookup(t5))
          continue;
        const r8 = e6.indexFrom, s6 = e6.vertexFrom;
        let i9 = e6.indexCount, n10 = e6.vertexCount;
        for (; e6.next() && e6.id === t5; )
          i9 += e6.indexCount, n10 += e6.vertexCount;
        this._indexBuffer.free(r8, i9), this._vertexBuffer.free(s6, n10, true), this._records.delete(t5);
      }
  }
  getVAO(e5, t5, r8, s6) {
    if (!this._vertexBuffer || !this._indexBuffer || null == this._records || !this._vertexBuffer.bufferSize)
      return null;
    const i9 = s6 ? o7 : f5;
    let d11 = this._vaos.get(i9);
    (this._vertexBuffer.invalidated || this._indexBuffer.invalidated || s6 && this._indexBuffer.invalidatedComputeBuffer) && (d11 == null ? void 0 : d11.disposeVAOOnly(), d11 = null), this._vertexBuffer.upload(), this._indexBuffer.upload();
    const h5 = this._indexBuffer.getGPUBuffer(e5, 1 === i9), u10 = this._vertexBuffer.getGPUBuffer(e5);
    return d11 || (d11 = new u5(e5, r8, t5, { geometry: u10 }, h5), this._vaos.set(i9, d11)), d11;
  }
  forEachCommand(e5) {
    if (null != this._records) {
      if (this._sortIndices(this._records), !this._displayList) {
        const e6 = this._cursorIndexOrder;
        this._displayList = n5.from(this, this.geometryType, this._records.getCursor(), e6);
      }
      this._displayList.forEach(e5);
    }
  }
  _sortIndices(e5) {
    const t5 = !!this._indexBuffer.bufferSize;
    if (!this._indicesInvalid)
      return;
    this._indicesInvalid = false;
    let r8 = 0;
    const s6 = e5.getCursor(), i9 = [], n10 = [], f6 = [];
    for (; s6.next(); )
      n10.push(s6.index), f6.push(s6.sortKey), i9.push(s6.id);
    n10.sort((e6, t6) => {
      const r9 = f6[t6], s7 = f6[e6];
      return s7 === r9 ? i9[t6] - i9[e6] : r9 - s7;
    });
    const o10 = e5.getCursor(), d11 = t5 ? this._indexBuffer.getCPUBuffer() : this._vertexBuffer.getCPUBuffer();
    for (const h5 of n10) {
      if (!o10.seekIndex(h5))
        throw new Error("Expected to find index");
      if (t5) {
        const { indexFrom: e6, indexCount: t6 } = o10;
        o10.indexFrom = r8;
        for (let s7 = 0; s7 < t6; s7++)
          this._indexBuffer.set(r8++, d11.array[e6 + s7]);
      } else {
        const { vertexFrom: e6, vertexCount: t6 } = o10, s7 = this._vertexBuffer.strideInt, i10 = e6 * s7, n11 = i10 + t6 * s7;
        o10.vertexFrom = r8 / s7;
        for (let f7 = i10; f7 < n11; f7++)
          this._vertexBuffer.set(r8++, d11.array[f7]);
      }
    }
    this._cursorIndexOrder = n10, this._displayList = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FeatureTile.js
var h4 = 50;
var d9 = 4;
var o8 = 100;
var u7 = 0;
var c6 = class extends m4 {
  constructor(r8, s6, i9, a11, n10, h5) {
    super(r8, s6, i9, a11), this.instanceId = u7++, this.patchCount = 0, this._renderState = { current: { geometry: /* @__PURE__ */ new Map(), metrics: null }, next: null, swap: false, swapFrames: 0, locked: false }, this._patches = new t(o8), this._bufferPatches = new t(o8), this._lastCommitTime = 0, this.transforms.labelMat2d = n2(), this._store = n10, this._requestLabelUpdate = h5;
  }
  destroy() {
    super.destroy(), this._renderState.current.geometry.forEach((e5) => e5.destroy()), null != this._renderState.next && this._renderState.next.geometry.forEach((e5) => e5.destroy()), this._renderState.current = null, this._renderState.next = null;
  }
  get labelMetrics() {
    return this._renderState.current.metrics;
  }
  get hasData() {
    return !!this._renderState.current.geometry.size;
  }
  get updateStatus() {
    return `renderState:${!!this._renderState.current}, ${!!this._renderState.next}, hasData:${this.hasData}, queue:${this._patches.size}`;
  }
  getGeometry(e5) {
    return this._renderState.current.geometry.get(e5);
  }
  patch(e5, t5) {
    this.patchCount++, e5.clear && this._patches.size >= h4 && this._dropPatches();
    const r8 = e5, s6 = r8.addOrUpdate && this.key.id !== r8.addOrUpdate.tileKeyOrigin;
    t5 && s6 ? this._bufferPatches.enqueue(r8) : (r8.sort = r8.sort && !t5, this._patches.enqueue(r8)), this.requestRender();
  }
  commit(e5) {
    if (this._lastCommitTime !== e5.time) {
      this._lastCommitTime = e5.time;
      for (let e6 = 0; e6 < d9; e6++)
        this._updateMesh(), this.isReady && this._updateBufferMesh();
      this._renderState.swap && (this._swapRenderStates(), this.requestRender());
    }
  }
  lock() {
    this._renderState.locked = true;
  }
  unlock() {
    this._renderState.locked = false, this._flushUpdates(), this._swap();
  }
  _swapRenderStates() {
    if (this._renderState.next) {
      if (this._renderState.locked)
        return this._renderState.swap = true, void this.requestRender();
      this._renderState.swap = true, this._swap();
    }
  }
  _swap() {
    this._renderState.swap && (this._renderState.swap = false, null != this._renderState.next && (this._renderState.current.geometry.forEach((e5) => e5.destroy()), this._renderState.current = this._renderState.next, this._renderState.next = null, this._requestLabelUpdate()));
  }
  _flushUpdates() {
    let e5 = this._patches.maxSize;
    for (; this._patches.size && e5--; )
      this._updateMesh(), this._swap();
  }
  _updateBufferMesh() {
    const e5 = this._bufferPatches.peek();
    if (null == e5 || !e5.clear || null === this._renderState.next)
      for (; this._bufferPatches.size; ) {
        const e6 = this._bufferPatches.dequeue();
        null != e6 && this._patchBuffer(e6);
      }
  }
  _updateMesh() {
    var _a, _b, _c2, _d;
    const e5 = this._patches.dequeue();
    if (null != e5) {
      if (has("esri-2d-update-debug")) {
        const t5 = e5, r8 = (_a = t5.addOrUpdate) == null ? void 0 : _a.tileKeyOrigin, s6 = this.key.id === r8 ? "SELF" : r8;
        let i9 = "";
        for (let e6 = 0; e6 < 5; e6++)
          i9 += ((_d = (_c2 = (_b = t5.addOrUpdate) == null ? void 0 : _b.data[e6]) == null ? void 0 : _c2.records) == null ? void 0 : _d.byteLength) ? 1 : 0;
        console.debug(this.key.id, "FeatureTile:patch", `[clear: ${t5.clear} origin: ${s6}, end:${t5.end} data:${i9}]`);
      }
      true === e5.clear && (null != this._renderState.next && (this._renderState.next.geometry.forEach((e6) => e6.destroy()), this._renderState.next = null), this._renderState.next = { geometry: /* @__PURE__ */ new Map(), metrics: null }, has("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Creating new renderState")), this.requestRender(), this._patch(e5), e5.end && (has("esri-2d-update-debug") && console.debug(this.key.id, "FeatureTile:_updateMesh - Encountered end message"), this.ready(), this._swapRenderStates());
    }
  }
  _patch(e5) {
    te((t5) => {
      this._remove(t5, e5.remove), this._insert(t5, e5, false);
    });
  }
  _patchBuffer(e5) {
    te((t5) => {
      this._insert(t5, e5, true);
    });
  }
  _insert(e5, t5, s6) {
    var _a, _b;
    try {
      const i9 = this._renderState.next ?? this._renderState.current, a11 = (_a = t5.addOrUpdate) == null ? void 0 : _a.data[e5], h5 = i9.geometry;
      if (null == a11)
        return;
      h5.has(e5) || (has("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Creating geometry buffer ${e5}`), h5.set(e5, new d8(e5, this.stage))), has("esri-2d-update-debug") && console.debug(this.key.id, `FeatureTile:_insert - Inserting into ${e5}, version=${(_b = t5.addOrUpdate) == null ? void 0 : _b.version} stride=${a11.stride}`), h5.get(e5).insert(a11, t5.sort, s6), e5 === E2.LABEL && this._insertLabelMetrics(t5.type, a11.metrics, t5.clear);
    } catch (i9) {
    }
  }
  _insertLabelMetrics(e5, t5, r8) {
    const s6 = this._renderState.next ?? this._renderState.current;
    if (null == t5)
      return;
    const i9 = e4.from(t5);
    if (null != s6.metrics) {
      if ("update" === e5) {
        const e6 = i9.getCursor();
        for (; e6.next(); )
          s6.metrics.delete(e6.id);
      }
      s6.metrics.link(i9);
    } else
      s6.metrics = i9;
  }
  _remove(e5, t5) {
    const r8 = (this._renderState.next ?? this._renderState.current).geometry.get(e5);
    t5 && t5.length && r8 && (r8.remove(t5), this._removeLabelMetrics(t5));
  }
  _removeLabelMetrics(e5) {
    const { metrics: t5 } = this._renderState.next ?? this._renderState.current;
    if (null != t5 && e5.length)
      for (const r8 of e5)
        for (; t5.delete(r8); )
          ;
  }
  _dropPatches() {
    const e5 = new Array();
    let t5 = false;
    for (; this._patches.size; ) {
      const r8 = this._patches.dequeue();
      if (null == r8)
        break;
      if (r8.clear) {
        if (t5)
          break;
        t5 = true;
      }
      e5.push(r8);
    }
    this._patches.clear(), e5.forEach((e6) => this._patches.enqueue(e6));
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/support/WGLFeatureView.js
var r6 = has("featurelayer-order-by-server-enabled");
var a8 = class extends o4 {
  constructor(e5, t5, s6, i9) {
    super(e5), this._hitTestsRequests = [], this._layer = s6, this._layerView = t5, this._onUpdate = i9;
  }
  renderChildren(e5) {
    if (this.attributeView.update(), this.hasAnimation) {
      e5.painter.effects.integrate.draw(e5, e5.attributeView);
    }
    super.renderChildren(e5);
  }
  hasEmptyAttributeView() {
    return this.attributeView.isEmpty();
  }
  isUpdating() {
    return this.attributeView.isUpdating();
  }
  hitTest(t5) {
    let s6 = this._hitTestsRequests.find(({ x: e5, y: s7 }) => e5 === t5.x && s7 === t5.y);
    const i9 = C();
    return s6 ? s6.resolvers.push(i9) : (s6 = { x: t5.x, y: t5.y, resolvers: [i9] }, this._hitTestsRequests.push(s6)), this.requestRender(), i9.promise;
  }
  onTileData(e5, t5) {
    const s6 = r6 && "orderBy" in this._layer && this._layer.orderBy, i9 = s6 && (s6 == null ? void 0 : s6.length) && !s6[0].valueExpression && s6[0].field, a11 = !!s6 && this._layerView.orderByFields === i9;
    e5.patch(t5, a11), this.contains(e5) || this.addChild(e5), this.requestRender();
  }
  onTileError(e5) {
    this.contains(e5) || this.addChild(e5);
  }
  updateTransitionProperties(e5, t5) {
    super.updateTransitionProperties(e5, t5), this._layerView.featureEffectView.transitionStep(e5, t5), this._layerView.featureEffectView.transitioning && this.requestRender();
  }
  doRender(e5) {
    const { minScale: t5, maxScale: s6 } = this._layer.effectiveScaleRange, i9 = e5.state.scale;
    i9 <= (t5 || 1 / 0) && i9 >= s6 && super.doRender(e5);
  }
  afterRender(e5) {
    super.afterRender(e5), this._hitTestsRequests.length && this.requestRender();
  }
  onAttributeStoreUpdate() {
    this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this._onUpdate();
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  setStencilReference(e5) {
    const { rendererSchema: t5 } = e5.rendererInfo;
    if ("dot-density" === (t5 == null ? void 0 : t5.type) && (t5 == null ? void 0 : t5.dotSize) > 1 || "heatmap" === (t5 == null ? void 0 : t5.type)) {
      const e6 = 1;
      for (const t6 of this.children)
        t6.stencilRef = t6.key.level + e6;
    } else
      super.setStencilReference(e5);
  }
  get hasLabels() {
    if ("sublayers" in this._layer)
      return this._layer.sublayers.some((e6) => {
        var _a2;
        return !!((_a2 = e6.labelingInfo) == null ? void 0 : _a2.length) && e6.labelsVisible;
      });
    const e5 = this._layer.featureReduction, t5 = e5 && "labelingInfo" in e5 && e5.labelsVisible && e5.labelingInfo && e5.labelingInfo.length;
    return this._layer.labelingInfo && this._layer.labelingInfo.length && this._layer.labelsVisible || !!t5;
  }
  prepareRenderPasses(e5) {
    const s6 = super.prepareRenderPasses(e5), r8 = e5.registerRenderPass({ name: "label", brushes: [w3.label], target: () => this.hasLabels ? this.children : null, drawPhase: T.LABEL | T.LABEL_ALPHA });
    if (has("featurelayer-force-marker-text-draw-order")) {
      const i9 = e5.registerRenderPass({ name: "geometry", brushes: [w3.fill, w3.dotDensity, w3.line, w3.heatmap, w3.pieChart], target: () => this.children, forceDrawByDisplayOrder: true, enableDefaultDraw: () => !this._layerView.featureEffectView.hasEffects, effects: [{ apply: e5.effects.outsideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.excludedEffects }, { apply: e5.effects.insideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.includedEffects }, { apply: e5.effects.hittest, enable: () => !!this._hitTestsRequests.length, args: () => this._hitTestsRequests }] });
      s6.push(i9);
    } else {
      const i9 = e5.registerRenderPass({ name: "geometry", brushes: [w3.fill, w3.dotDensity, w3.line, w3.marker, w3.heatmap, w3.pieChart, w3.text], target: () => this.children, enableDefaultDraw: () => !this._layerView.featureEffectView.hasEffects, effects: [{ apply: e5.effects.outsideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.excludedEffects }, { apply: e5.effects.insideEffect, enable: () => this._layerView.featureEffectView.hasEffects, args: () => this._layerView.featureEffectView.includedEffects }, { apply: e5.effects.hittest, enable: () => !!this._hitTestsRequests.length, args: () => this._hitTestsRequests }] });
      s6.push(i9);
    }
    const a11 = e5.registerRenderPass({ name: "highlight", brushes: [w3.fill, w3.dotDensity, w3.line, w3.marker, w3.pieChart, w3.text], target: () => this.children, drawPhase: T.HIGHLIGHT, enableDefaultDraw: () => false, effects: [{ apply: e5.effects.highlight, enable: () => !!this._layerView.hasHighlight() }] });
    return s6.push(a11), s6.push(r8), s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers/SymbolTileRenderer.js
var p4 = class extends o5 {
  constructor() {
    super(...arguments), this.type = "symbol";
  }
  install(e5) {
    const t5 = () => this.notifyChange("updating"), i9 = new a8(this.tileInfoView, this.layerView, this.layer, t5);
    this.featuresView = i9, e5.addChild(i9);
  }
  uninstall(e5) {
    e5.removeChild(this.featuresView), this.featuresView = l(this.featuresView);
  }
  fetchResource(e5, t5) {
    const { url: r8 } = e5, s6 = this.featuresView.stage;
    try {
      return s6.resourceManager.fetchResource(r8, { signal: t5.signal });
    } catch (a11) {
      return d(a11) ? Promise.resolve({ width: 0, height: 0 }) : Promise.reject(a11);
    }
  }
  isUpdating() {
    var _a;
    const e5 = super.isUpdating(), t5 = !this.featuresView || this.featuresView.isUpdating(), i9 = (_a = this.featuresView) == null ? void 0 : _a.hasEmptyAttributeView(), r8 = e5 || t5 || e5 && i9;
    return has("esri-2d-log-updating") && console.log(`Updating SymbolTileRenderer ${r8}
  -> updatingTiles ${e5}
  -> hasFeaturesView ${!!this.featuresView}
  -> updatingFeaturesView ${t5}`), r8;
  }
  hitTest(e5) {
    return this.featuresView.hitTest(e5);
  }
  supportsRenderer(e5) {
    return null != e5 && ["simple", "class-breaks", "unique-value", "dot-density", "dictionary", "heatmap", "pie-chart"].includes(e5.type);
  }
  onConfigUpdate(e5) {
    let t5 = null;
    if (e5 && "visualVariables" in e5) {
      const i9 = (n6(e5).visualVariables || []).map((e6) => {
        const t6 = e6.clone();
        return "normalizationField" in e6 && (t6.normalizationField = null), e6.valueExpression && "$view.scale" !== e6.valueExpression && (t6.valueExpression = null, t6.field = "nop"), t6;
      });
      t5 = c2(i9);
    }
    this.featuresView.setRendererInfo(e5, t5, this.layerView.featureEffect);
  }
  onTileData(e5) {
    const t5 = this.tiles.get(e5.tileKey);
    t5 && e5.data && this.featuresView.onTileData(t5, e5.data), this.layerView.view.labelManager.requestUpdate();
  }
  onTileError(e5) {
    const t5 = this.tiles.get(e5.tileKey);
    t5 && this.featuresView.onTileError(t5);
  }
  forceAttributeTextureUpload() {
    this.featuresView.attributeView.forceTextureUpload();
  }
  lockGPUUploads() {
    this.featuresView.attributeView.lockTextureUpload(), this.tiles.forEach((e5) => e5.lock());
  }
  unlockGPUUploads() {
    this.featuresView.attributeView.unlockTextureUpload(), this.tiles.forEach((e5) => e5.unlock());
  }
  async getMaterialItems(e5) {
    return this.featuresView.getMaterialItems(e5);
  }
  invalidateLabels() {
    this.featuresView.hasLabels && this.layerView.view.labelManager.requestUpdate();
  }
  createTile(e5) {
    const t5 = this.tileInfoView.getTileBounds(i2(), e5), i9 = () => this.layerView.view.labelManager.requestUpdate(), r8 = this.tileInfoView.getTileResolution(e5.level), o10 = this.featuresView.attributeView;
    return new c6(e5, r8, t5[0], t5[3], o10, i9);
  }
  disposeTile(e5) {
    this.featuresView.removeChild(e5), e5.destroy(), this.layerView.view.labelManager.requestUpdate();
  }
};
p4 = e([a2("esri.views.2d.layers.features.tileRenderers.SymbolTileRenderer")], p4);

// node_modules/@arcgis/core/views/2d/layers/features/tileRenderers.js
function t3(t5, n10) {
  if (!t5)
    return null;
  switch (t5.type) {
    case "symbol":
      return new p4(n10);
    case "heatmap":
      return new o6(n10);
  }
}

// node_modules/@arcgis/core/views/2d/layers/support/FeatureCommandQueue.js
function i7(e5) {
  return e5.some((e6) => e6.globalId);
}
function n9(e5) {
  return e5.filter((e6) => !e6.error).map((e6) => e6.objectId ?? e6.globalId).filter((e6) => null != e6);
}
function d10(e5, t5) {
  const s6 = new Set(e5);
  for (const r8 of t5.values())
    s6.add(r8);
  return s6;
}
function a9(e5, t5) {
  const s6 = new Set(e5);
  for (const r8 of t5.values())
    s6.delete(r8);
  return s6;
}
var c7 = class extends m2 {
  constructor(e5) {
    super(e5), this._hasGlobalIds = false, this._notifyUpdating = () => {
      this.notifyChange("updating");
    };
  }
  normalizeCtorArgs(e5) {
    return this._queueProcessor = new u4({ concurrency: 1, process: e5.process }), {};
  }
  destroy() {
    this.clear();
  }
  get updating() {
    return this._queueProcessor.length > 0;
  }
  clear() {
    this._queueProcessor.clear();
  }
  push(e5) {
    const t5 = this._queueProcessor, s6 = t5.last();
    switch (e5.type) {
      case "update":
      case "refresh":
        if ((s6 == null ? void 0 : s6.type) === e5.type)
          return;
        t5.push(e5).then(this._notifyUpdating, this._notifyUpdating);
        break;
      case "edit": {
        const r8 = "processed-edit" === (s6 == null ? void 0 : s6.type) ? s6 : null;
        r8 && t5.popLast();
        const o10 = this._mergeEdits(r8, e5);
        for (const e6 of o10)
          e6 && t5.push(e6).then(this._notifyUpdating, this._notifyUpdating);
        break;
      }
    }
    this.notifyChange("updating");
  }
  _mergeEdits(e5, t5) {
    const { addedFeatures: s6, deletedFeatures: r8, updatedFeatures: o10 } = t5.edits;
    if (this._hasGlobalIds = this._hasGlobalIds || i7(s6) || i7(o10) || i7(r8), this._hasGlobalIds) {
      return [e5, { type: "processed-edit", edits: { addOrModified: [...s6, ...o10], removed: r8 } }];
    }
    const c10 = new Set(n9((e5 == null ? void 0 : e5.edits.addOrModified) ?? [])), p7 = new Set(n9((e5 == null ? void 0 : e5.edits.removed) ?? [])), u10 = /* @__PURE__ */ new Set([...n9(s6), ...n9(o10)]), l8 = new Set(n9(r8));
    return [{ type: "processed-edit", edits: { addOrModified: Array.from(d10(a9(c10, l8), u10)).map((e6) => ({ objectId: e6 })), removed: Array.from(d10(a9(p7, u10), l8)).map((e6) => ({ objectId: e6 })) } }];
  }
};
e([y2({ readOnly: true })], c7.prototype, "updating", null), e([y2()], c7.prototype, "process", void 0), c7 = e([a2("esri.views.2d.layers.support.FeatureCommandQueue")], c7);
var p5 = c7;

// node_modules/@arcgis/core/views/2d/layers/support/FeatureLayerProxy.js
function c8(e5) {
  return Array.isArray(e5);
}
var u8 = class extends p {
  constructor(e5) {
    super(e5), this._startupResolver = C(), this.isReady = false;
  }
  initialize() {
    this._controller = new AbortController(), this.addResolvingPromise(this._startWorker(this._controller.signal));
  }
  destroy() {
    this._controller.abort(), this._connection && this._connection.close();
  }
  set tileRenderer(e5) {
    this.client.tileRenderer = e5;
  }
  get closed() {
    return this._connection.closed;
  }
  async startup(e5, t5, r8, s6) {
    await this.when();
    const o10 = this._controller.signal, i9 = c8(r8.source) ? { transferList: r8.source, signal: o10 } : void 0, n10 = { service: r8, config: t5, tileInfo: e5.tileInfo.toJSON(), tiles: s6 };
    await this._connection.invoke("startup", n10, i9), this._startupResolver.resolve(), this._set("isReady", true);
  }
  async updateTiles(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("updateTiles", e5));
  }
  async update(e5) {
    const t5 = { config: e5 };
    return await this._startupResolver.promise, this._connection.invoke("update", t5);
  }
  async applyUpdate(e5) {
    return await this._startupResolver.promise, this._connection.invoke("applyUpdate", e5);
  }
  async setHighlight(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.setHighlight", e5));
  }
  async stop() {
    if (await this._startupResolver.promise, !this.closed)
      return y(this._connection.invoke("stop"));
  }
  async refresh(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.refresh", e5));
  }
  async querySummaryStatistics(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.querySummaryStatistics", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateSummaryStatistics(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateSummaryStatistics", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryUniqueValues(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryUniqueValues", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateUniqueValues(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateUniqueValues", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryClassBreaks(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryClassBreaks", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateClassBreaks(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateClassBreaks", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryHistogram(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryHistogram", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryAggregateHistogram(e5, t5, r8) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateHistogram", { query: e5.toJSON(), params: t5 }, r8);
  }
  async queryFeatures(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatures", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryVisibleFeatures(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryVisibleFeatures", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryObjectIds(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryObjectIds", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryFeatureCount(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryFeatureCount", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryExtent(e5, t5) {
    return this._connection.invoke("controller.queryExtent", e5.toJSON(), t5);
  }
  async queryLatestObservations(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryLatestObservations", e5.toJSON(), t5);
  }
  async queryStatistics(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryStatistics", e5);
  }
  async queryAggregates(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregates", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryAggregateCount(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateCount", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async queryAggregateIds(e5, t5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.queryAggregateIds", e5 == null ? void 0 : e5.toJSON(), t5);
  }
  async getObjectId(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getObjectId", e5);
  }
  async getDisplayId(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getDisplayId", e5);
  }
  async getFeatures(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.getFeatures", e5);
  }
  async getAggregates() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregates");
  }
  async getAggregateValueRanges() {
    return await this._startupResolver.promise, this._connection.invoke("controller.getAggregateValueRanges");
  }
  async mapValidDisplayIds(e5) {
    return await this._startupResolver.promise, this._connection.invoke("controller.mapValidDisplayIds", e5);
  }
  async onEdits(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.onEdits", e5));
  }
  async enableEvent(e5, t5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.enableEvent", { name: e5, value: t5 }));
  }
  async pauseStream() {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.pauseStream"));
  }
  async resumeStream() {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.resumeStream"));
  }
  async sendMessageToSocket(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.sendMessageToSocket", e5));
  }
  async sendMessageToClient(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.sendMessageToClient", e5));
  }
  async updateCustomParameters(e5) {
    return await this._startupResolver.promise, y(this._connection.invoke("controller.updateCustomParameters", e5));
  }
  async _startWorker(e5) {
    try {
      this._connection = await f3("Pipeline", { client: this.client, strategy: "dedicated", signal: e5 });
    } catch (t5) {
      m(t5);
    }
  }
};
e([y2()], u8.prototype, "isReady", void 0), e([y2({ constructOnly: true })], u8.prototype, "client", void 0), e([y2()], u8.prototype, "tileRenderer", null), u8 = e([a2("esri.views.2d.layers.support.FeatureLayerProxy")], u8);
var l5 = u8;

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r7 = Math.PI;
function i8(e5, t5) {
  switch (t5.transformationType) {
    case i3.Additive:
      return s5(e5, t5);
    case i3.Constant:
      return o9(t5, e5);
    case i3.ClampedLinear:
      return u9(e5, t5);
    case i3.Proportional:
      return l6(e5, t5);
    case i3.Stops:
      return c9(e5, t5);
    case i3.RealWorldSize:
      return m5(e5, t5);
    case i3.Identity:
      return e5;
    case i3.Unknown:
      return null;
  }
}
function a10(e5, t5) {
  return "number" == typeof e5 ? e5 : i8(t5, e5);
}
function s5(e5, t5) {
  return e5 + (a10(t5.minSize, e5) || t5.minDataValue);
}
function o9(e5, t5) {
  const n10 = e5.stops;
  let r8 = n10 && n10.length && n10[0].size;
  return null == r8 && (r8 = e5.minSize), a10(r8, t5);
}
function u9(e5, t5) {
  const n10 = t5.minDataValue, r8 = t5.maxDataValue, i9 = (e5 - n10) / (r8 - n10), s6 = a10(t5.minSize, e5), o10 = a10(t5.maxSize, e5);
  return e5 <= n10 ? s6 : e5 >= r8 ? o10 : s6 + i9 * (o10 - s6);
}
function l6(t5, n10) {
  const r8 = t5 / n10.minDataValue, i9 = a10(n10.minSize, t5), s6 = a10(n10.maxSize, t5);
  let o10 = null;
  return o10 = r8 * i9, i(o10, i9, s6);
}
function c9(e5, t5) {
  const [n10, r8, i9] = p6(e5, t5.cache.ipData);
  if (n10 === r8)
    return a10(t5.stops[n10].size, e5);
  {
    const s6 = a10(t5.stops[n10].size, e5);
    return s6 + (a10(t5.stops[r8].size, e5) - s6) * i9;
  }
}
function m5(n10, i9) {
  const s6 = m3[i9.valueUnit], o10 = a10(i9.minSize, n10), u10 = a10(i9.maxSize, n10), { valueRepresentation: l8 } = i9;
  let c10 = null;
  return c10 = "area" === l8 ? 2 * Math.sqrt(n10 / r7) / s6 : "radius" === l8 || "distance" === l8 ? 2 * n10 / s6 : n10 / s6, i(c10, o10, u10);
}
function p6(e5, t5) {
  if (!t5)
    return;
  let n10 = 0, r8 = t5.length - 1;
  return t5.some((t6, i9) => e5 < t6 ? (r8 = i9, true) : (n10 = i9, false)), [n10, r8, (e5 - t5[n10]) / (t5[r8] - t5[n10])];
}

// node_modules/@arcgis/core/views/2d/tiling/TileManager.js
var t4 = 1e-6;
var l7 = class {
  constructor(e5) {
    this._tiles = /* @__PURE__ */ new Map(), this.buffer = 0, this.acquireTile = e5.acquireTile, this.releaseTile = e5.releaseTile, this.tileInfoView = e5.tileInfoView, this.buffer = e5.buffer;
  }
  destroy() {
  }
  clear() {
    this._tiles.forEach((e5) => this._releaseTile(e5));
  }
  tileKeys() {
    const e5 = [];
    return this._tiles.forEach((i9, t5) => e5.push(t5)), e5;
  }
  update(t5) {
    const l8 = this.tileInfoView.getTileCoverage(t5.state, this.buffer, true, "closest"), { spans: s6, lodInfo: r8 } = l8, { level: a11 } = r8, o10 = [], d11 = [], h5 = /* @__PURE__ */ new Set(), n10 = /* @__PURE__ */ new Set();
    for (const { row: e5, colFrom: c10, colTo: f6 } of s6)
      for (let t6 = c10; t6 <= f6; t6++) {
        const l9 = e2.getId(a11, e5, r8.normalizeCol(t6), r8.getWorldForColumn(t6)), s7 = this._getOrAcquireTile(o10, l9);
        h5.add(l9), s7.isReady ? s7.visible = true : n10.add(s7.key);
      }
    n10.forEach((e5) => this._addPlaceholders(h5, e5)), this._tiles.forEach((e5) => {
      h5.has(e5.key.id) || (d11.push(e5.key.id), this._releaseTile(e5));
    }), l4.pool.release(l8);
    return { hasMissingTiles: n10.size > 0, added: o10, removed: d11 };
  }
  _getOrAcquireTile(e5, t5) {
    if (!this._tiles.has(t5)) {
      const l8 = this.acquireTile(new e2(t5));
      e5.push(t5), this._tiles.set(t5, l8), l8.visible = false;
    }
    return this._tiles.get(t5);
  }
  _getTile(e5) {
    return this._tiles.get(e5);
  }
  _releaseTile(e5) {
    this._tiles.delete(e5.key.id), this.releaseTile(e5);
  }
  _addPlaceholders(e5, i9) {
    const l8 = this._addPlaceholderChildren(e5, i9);
    if (!(Math.abs(1 - l8) < t4)) {
      if (!this._addPlaceholderParent(e5, i9)) {
        this._getTile(i9.id).visible = true;
      }
    }
  }
  _addPlaceholderChildren(e5, i9) {
    let t5 = 0;
    return this._tiles.forEach((l8) => {
      t5 += this._addPlaceholderChild(e5, l8, i9);
    }), t5;
  }
  _addPlaceholderChild(e5, i9, t5) {
    if (i9.key.level <= t5.level || !i9.hasData || !t5.contains(i9.key))
      return 0;
    i9.visible = true, e5.add(i9.key.id);
    return 1 / (1 << 2 * (i9.key.level - t5.level));
  }
  _addPlaceholderParent(e5, i9) {
    let t5 = i9.getParentKey(), l8 = 0, s6 = null;
    for (; null != t5; ) {
      if (e5.has(t5.id))
        return true;
      const i10 = this._getTile(t5.id);
      if (i10 == null ? void 0 : i10.isReady) {
        for (const i11 of e5) {
          const e6 = this._getTile(i11);
          e6 && t5.contains(e6.key) && (e6.visible = false);
        }
        return i10.visible = true, e5.add(i10.key.id), true;
      }
      (i10 == null ? void 0 : i10.hasData) && i10.patchCount > l8 && (l8 = i10.patchCount, s6 = i10), t5 = t5.getParentKey();
    }
    return !!s6 && (s6.visible = true, e5.add(s6.key.id), true);
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var q2 = "esri.views.layers.FeatureLayerView";
var P = s.getLogger(q2);
var _ = (r8) => {
  let _2 = class extends r8 {
    constructor(...e5) {
      super(...e5), this._updatingRequiredFieldsPromise = null, this.filter = null, this.timeExtent = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.handles.add([l2(() => {
        var _a;
        const e5 = this.layer;
        return [(_a = e5 == null ? void 0 : e5.elevationInfo) == null ? void 0 : _a.featureExpressionInfo, e5 && "displayField" in e5 ? e5.displayField : null, e5 && "timeInfo" in e5 && e5.timeInfo, e5 && "renderer" in e5 && e5.renderer, e5 && "labelingInfo" in e5 && e5.labelingInfo, e5 && "floorInfo" in e5 && e5.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), w), a3(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), a3(() => {
        const e5 = this.layer;
        return e5 && "sublayers" in e5 ? e5.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      const { layer: e5, layer: { fieldsIndex: t5 }, requiredFields: r9 } = this;
      return "outFields" in e5 && e5.outFields ? g(t5, [...b3(t5, e5.outFields), ...r9]) : g(t5, r9);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e5) {
      this._override("featureEffect", e5);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e5) {
      P.error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e5) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e5 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t5 = null != this.filter ? this.filter.createQuery(e5) : new b(e5);
      if ("feature" === this.layer.type) {
        const e6 = o3(this);
        null != e6 && (t5.where = t5.where ? `(${t5.where}) AND (${e6})` : e6);
      }
      return null != this.timeExtent && (t5.timeExtent = null != t5.timeExtent ? t5.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t5;
    }
    createAggregateQuery() {
      const e5 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b(e5);
    }
    queryFeatures(e5, t5) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e5, t5) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e5, t5) {
      throw new Error("missing implementation");
    }
    queryExtent(e5, t5) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeatures(e5, t5) {
      const r9 = this.validateFetchPopupFeatures(t5);
      if (r9)
        throw r9;
      return this.fetchClientPopupFeatures(t5);
    }
    _loadArcadeModules(e5) {
      return e5.get("expressionInfos.length") || Array.isArray(e5.content) && e5.content.some((e6) => "expression" === e6.type) ? i4() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e5 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e5), e5.then(() => {
        this._updatingRequiredFieldsPromise === e5 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view)
        return;
      const e5 = "3d" === this.view.type, { layer: t5, layer: { fieldsIndex: r9, objectIdField: s6 } } = this, o10 = "renderer" in t5 && t5.renderer, n10 = "orderBy" in t5 && t5.orderBy, l8 = "featureReduction" in t5 ? t5.featureReduction : null, a11 = /* @__PURE__ */ new Set(), u10 = await j([o10 ? o10.collectRequiredFields(a11, r9) : null, q(a11, t5), e5 ? v2(a11, t5) : null, null != this.filter ? L(a11, t5, this.filter) : null, null != this.featureEffect ? L(a11, t5, this.featureEffect.filter) : null, l8 ? $(a11, t5, l8) : null, n10 ? D(a11, t5, n10) : null]);
      if ("timeInfo" in t5 && t5.timeInfo && this.timeExtent && F2(a11, t5.fieldsIndex, [t5.timeInfo.startField, t5.timeInfo.endField]), "feature" === t5.type && (t5.floorInfo && F2(a11, t5.fieldsIndex, [t5.floorInfo.floorField]), e5 && null != t5.infoFor3D && (null == t5.globalIdField && P.error("globalIdField missing on 3DObjectFeatureLayer"), F2(a11, t5.fieldsIndex, [t5.globalIdField]))), "subtype-group" === t5.type) {
        I(a11, r9, t5.subtypeField);
        const e6 = t5.sublayers.map((e7) => {
          var _a;
          return Promise.all([(_a = e7.renderer) == null ? void 0 : _a.collectRequiredFields(a11, r9), q(a11, e7)]);
        });
        await j(e6);
      }
      for (const i9 of u10)
        i9.error && P.error(i9.error);
      I(a11, r9, s6), e5 && "displayField" in t5 && t5.displayField && I(a11, r9, t5.displayField);
      const p7 = Array.from(a11).sort();
      this._set("requiredFields", p7);
    }
    validateFetchPopupFeatures(e5) {
      if (null == e5)
        return null;
      for (const r9 of e5.clientGraphics ?? []) {
        const i9 = r9.layer;
        if ("popupEnabled" in i9 && !i9.popupEnabled)
          return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i9 });
        if (r9.isAggregate) {
          const e6 = "featureReduction" in i9 ? i9.featureReduction : null;
          if (!(e6 && "popupTemplate" in e6 && e6.popupEnabled && e6.popupTemplate))
            return new s2("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: i9 });
        } else if ("popupTemplate" in i9) {
          if (!p2(i9, e5))
            return new s2("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: i9 });
        }
      }
    }
    async fetchClientPopupFeatures(e5) {
      const t5 = null != e5 ? e5.clientGraphics : null;
      if (!t5 || 0 === t5.length)
        return [];
      const r9 = new Array(t5.length), i9 = /* @__PURE__ */ new Map(), s6 = await this.createPopupQuery(e5);
      for (let o10 = 0; o10 < t5.length; o10++) {
        const n10 = t5[o10];
        if (n10.isAggregate) {
          r9[o10] = n10;
          continue;
        }
        const l8 = n10.layer;
        if (!("popupEnabled" in l8))
          continue;
        const a11 = b3(this.layer.fieldsIndex, s6.outFields), u10 = p2(l8, e5);
        if (null == u10)
          continue;
        const p7 = await this._loadArcadeModules(u10);
        p7 && p7.arcadeUtils.hasGeometryOperations(u10) || !Ee(a11, n10) ? i9.set(n10.getObjectId(), { graphic: n10, index: o10 }) : r9[o10] = n10;
      }
      if ("stream" === this.layer.type || 0 === i9.size)
        return r9.filter(Boolean);
      s6.objectIds = Array.from(i9.keys());
      try {
        const e6 = await this.layer.queryFeatures(s6);
        for (const t6 of e6.features) {
          const { graphic: { geometry: e7 }, index: s7 } = i9.get(t6.getObjectId());
          t6.geometry || (t6.geometry = e7), r9[s7] = t6;
        }
      } catch {
      }
      return r9.filter(Boolean);
    }
    async createPopupQuery(e5) {
      const t5 = this.layer.createQuery(), r9 = /* @__PURE__ */ new Set();
      let i9 = false;
      const s6 = null != e5 && e5.clientGraphics ? e5.clientGraphics.map((e6) => e6.layer) : [this.layer];
      for (const o10 of s6) {
        if (!("popupEnabled" in o10))
          continue;
        const t6 = p2(o10, e5);
        if (null == t6)
          continue;
        const s7 = await this._loadArcadeModules(t6), n10 = s7 && s7.arcadeUtils.hasGeometryOperations(t6);
        i9 = !("point" !== this.layer.geometryType && !n10);
        const l8 = await n3(this.layer, t6);
        for (const e6 of l8)
          r9.add(e6);
      }
      if (t5.returnGeometry = i9, t5.returnZ = i9, t5.returnM = i9, t5.outFields = Array.from(r9), t5.outSpatialReference = this.view.spatialReference, "feature" === this.layer.type) {
        const e6 = o3(this);
        null != e6 && (t5.where = t5.where ? `(${t5.where}) AND (${e6})` : e6);
      }
      return t5;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
  };
  return e([y2()], _2.prototype, "_updatingRequiredFieldsPromise", void 0), e([y2({ readOnly: true })], _2.prototype, "availableFields", null), e([y2({ type: w2 })], _2.prototype, "featureEffect", null), e([y2({ type: d4 })], _2.prototype, "filter", void 0), e([y2(b4)], _2.prototype, "timeExtent", void 0), e([y2()], _2.prototype, "layer", void 0), e([y2({ type: Number })], _2.prototype, "maximumNumberOfFeatures", null), e([y2({ readOnly: true, type: Boolean })], _2.prototype, "maximumNumberOfFeaturesExceeded", null), e([y2({ readOnly: true })], _2.prototype, "requiredFields", void 0), e([y2()], _2.prototype, "suspended", void 0), e([y2()], _2.prototype, "view", void 0), _2 = e([a2(q2)], _2), _2;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function M2(e5) {
  return e5 && "openPorts" in e5;
}
function B(e5) {
  for (const t5 of e5) {
    const e6 = "featureReduction" in t5 && t5.featureReduction && "labelingInfo" in t5.featureReduction ? t5.featureReduction : void 0, r8 = [...t5.labelingInfo || [], ...(e6 == null ? void 0 : e6.labelingInfo) || []];
    if (!t5.labelsVisible || !r8.length)
      continue;
    if (r8.some((e7) => "none" === e7.deconflictionStrategy))
      return true;
  }
  return false;
}
function $2(e5) {
  return (t5) => u2(i8(t5, e5));
}
function G(e5) {
  const t5 = null != e5 && "visualVariables" in e5 && e5.visualVariables;
  if (!t5)
    return null;
  for (const r8 of t5)
    if ("size" === r8.type)
      return $2(r8);
  return null;
}
var K = class extends _(a6(f4(d6))) {
  constructor() {
    super(...arguments), this._pipelineIsUpdating = true, this._commandsQueue = new p5({ process: (e5) => {
      switch (e5.type) {
        case "processed-edit":
          return this._doEdit(e5);
        case "refresh":
          return this._doRefresh(e5.dataChanged);
        case "update":
          return this._doUpdate();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightIds = /* @__PURE__ */ new Map(), this._updateHighlight = k(async () => this._proxy.setHighlight(Array.from(this._highlightIds.keys()))), this._uploadsLocked = false, this._needsClusterSizeUpdate = false, this.featureEffectView = new r3(), this._lastDefinitionExpression = null;
  }
  destroy() {
    var _a;
    n(this._updateClusterSizeTask, (e5) => e5.remove()), (_a = this._proxy) == null ? void 0 : _a.destroy(), this._commandsQueue.destroy();
  }
  initialize() {
    this.addResolvingPromise(Promise.all([this._initProxy(), this._initServiceOptions()])), this.addHandles([this.on("valueRangesChanged", (e5) => {
      this._set("_aggregateValueRanges", e5.valueRanges);
    }), l2(() => this.featureEffect, (e5) => {
      this.featureEffectView.featureEffect = e5;
    }, w)], "constructor"), this.featureEffectView.endTransitions();
  }
  async _initProxy() {
    var _a;
    const e5 = this.layer;
    if ("isTable" in e5 && e5.isTable)
      throw new s2("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: this.layer });
    if (("feature" === e5.type || "subtype-group" === e5.type) && !((_a = E(e5)) == null ? void 0 : _a.operations.supportsQuery))
      throw new s2("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e5 });
    this._proxy && this._proxy.destroy();
    const t5 = this._createClientOptions();
    return this._set("_proxy", new l5({ client: t5 })), this._proxy.when();
  }
  async _initServiceOptions() {
    return this._set("_serviceOptions", await this._createServiceOptions()), this._serviceOptions;
  }
  get _effectiveFeatureReduction() {
    if (!("featureReduction" in this.layer))
      return null;
    const e5 = this.layer.featureReduction;
    return e5 && (!("maxScale" in e5) || !e5.maxScale || e5.maxScale < this.view.scale) ? e5 : null;
  }
  get orderByFields() {
    var _a, _b;
    return "stream" !== ((_a = this._serviceOptions) == null ? void 0 : _a.type) ? (_b = this._serviceOptions) == null ? void 0 : _b.orderByFields : void 0;
  }
  get labelsVisible() {
    const e5 = "subtype-group" === this.layer.type ? this.layer.sublayers.items : [this.layer];
    return !this.suspended && e5.some((e6) => e6.labelingInfo && e6.labelsVisible);
  }
  get labelingCollisionInfos() {
    const { tileRenderer: e5, layer: t5 } = this;
    if (null == e5)
      return null;
    const r8 = "subtype-group" === this.layer.type ? this.layer.sublayers.items : [this.layer], i9 = t5.geometryType, s6 = !B(r8), a11 = {};
    if ("subtype-group" !== t5.type) {
      if ("heatmap" === (e5 == null ? void 0 : e5.type))
        return null;
      const r9 = G(t5.renderer);
      a11[0] = r9;
    }
    return [{ tileRenderer: e5, vvEvaluators: a11, deconflictionEnabled: s6, geometryType: i9, visible: !this.suspended }];
  }
  get queryMode() {
    var _a;
    return (_a = this._serviceOptions) == null ? void 0 : _a.type;
  }
  get renderingConfigHash() {
    var _a, _b;
    if (!this.layer)
      return null;
    const e5 = this.availableFields, t5 = this.layer, r8 = this.view.floors, { definitionExpression: i9 } = t5, s6 = "subtype-group" !== this.layer.type && this.layer.labelsVisible && this.layer.labelingInfo, a11 = "renderer" in t5 && t5.renderer, n10 = "gdbVersion" in t5 ? t5.gdbVersion : void 0, o10 = "historicMoment" in t5 ? (_a = t5.historicMoment) == null ? void 0 : _a.getTime() : void 0, { timeExtent: l8 } = this, u10 = "customParameters" in t5 ? JSON.stringify(t5.customParameters) : void 0, d11 = "apiKey" in t5 ? t5.apiKey : void 0, h5 = "stream" === t5.type ? `${JSON.stringify(t5.geometryDefinition)}${t5.definitionExpression}` : null, p7 = JSON.stringify(this.clips), c10 = (_b = this._effectiveFeatureReduction) == null ? void 0 : _b.toJSON(), y3 = "orderBy" in this.layer && JSON.stringify(this.layer.orderBy), g2 = "sublayers" in this.layer && this.layer.sublayers.items.reduce((e6, t6) => e6 + `${t6.visible ? 1 : 0}.${JSON.stringify(t6.renderer)}.${t6.labelsVisible}
.${JSON.stringify(t6.labelingInfo)}`, ""), f6 = "subtypeCode" in this.layer && this.layer.subtypeCode;
    return JSON.stringify({ orderBy: y3, sublayerHash: g2, subtypeCode: f6, filterHash: null != this.filter && this.filter.toJSON(), effectHash: null != this.featureEffect && this.featureEffect.toJSON(), streamFilter: h5, gdbVersion: n10, definitionExpression: i9, historicMoment: o10, availableFields: e5, renderer: a11, labelingInfo: s6, timeExtent: l8, floors: r8, clipsHash: p7, featureReduction: c10, customParameters: u10, apiKey: d11 });
  }
  highlight(e5) {
    let t5;
    e5 instanceof h2 ? t5 = [e5.getObjectId()] : "number" == typeof e5 || "string" == typeof e5 ? t5 = [e5] : V.isCollection(e5) && e5.length > 0 ? t5 = e5.map((e6) => e6 == null ? void 0 : e6.getObjectId()).toArray() : Array.isArray(e5) && e5.length > 0 && (t5 = "number" == typeof e5[0] || "string" == typeof e5[0] ? e5 : e5.map((e6) => e6 == null ? void 0 : e6.getObjectId()));
    const a11 = t5 == null ? void 0 : t5.filter(R);
    return a11 && a11.length ? (this._addHighlight(a11), { remove: () => this._removeHighlight(a11) }) : { remove: () => {
    } };
  }
  hasHighlight() {
    return !!this._highlightIds.size;
  }
  async hitTest(e5, i9) {
    if (!this.tileRenderer)
      return null;
    const s6 = await this.tileRenderer.hitTest(i9);
    if (0 === s6.length)
      return null;
    has("featurelayer-force-marker-text-draw-order") && s6.sort((e6, t5) => e6 - t5);
    const { features: a11, aggregates: n10 } = await this._proxy.getFeatures(s6);
    return [...n10.map((r8) => this._createGraphicHit(e5, s3.fromJSON(r8))), ...a11.map((t5) => this._createGraphicHit(e5, h2.fromJSON(t5)))];
  }
  queryStatistics() {
    return this._proxy.queryStatistics();
  }
  async querySummaryStatistics(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.querySummaryStatistics(this._cleanUpQuery(e5), i9, r8);
  }
  async queryAggregateSummaryStatistics(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateSummaryStatistics(this._cleanUpAggregateQuery(e5), i9, r8);
  }
  async queryUniqueValues(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryUniqueValues(this._cleanUpQuery(e5), i9, r8);
  }
  async queryAggregateUniqueValues(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateUniqueValues(this._cleanUpAggregateQuery(e5), i9, r8);
  }
  async queryClassBreaks(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryClassBreaks(this._cleanUpQuery(e5), i9, r8);
  }
  async queryAggregateClassBreaks(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateClassBreaks(this._cleanUpAggregateQuery(e5), i9, r8);
  }
  async queryHistogram(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryHistogram(this._cleanUpQuery(e5), i9, r8);
  }
  async queryAggregateHistogram(e5, t5, r8) {
    const i9 = { ...t5, scale: this.view.scale };
    return this._proxy.queryAggregateHistogram(this._cleanUpAggregateQuery(e5), i9, r8);
  }
  queryFeatures(e5, t5) {
    return this.queryFeaturesJSON(e5, t5).then((e6) => {
      const t6 = d3.fromJSON(e6);
      return t6.features.forEach((e7) => this._setLayersForFeature(e7)), t6;
    });
  }
  queryVisibleFeatures(e5, t5) {
    return this._proxy.queryVisibleFeatures(this._cleanUpQuery(e5), t5).then((e6) => {
      const t6 = d3.fromJSON(e6);
      return t6.features.forEach((e7) => this._setLayersForFeature(e7)), t6;
    });
  }
  async queryAggregates(e5, t5) {
    const r8 = await this._proxy.queryAggregates(this._cleanUpAggregateQuery(e5), t5), i9 = i5.fromJSON(r8);
    return i9.features.forEach((e6) => this._setLayersForFeature(e6)), i9;
  }
  queryAggregateIds(e5, t5) {
    return this._proxy.queryAggregateIds(this._cleanUpAggregateQuery(e5), t5);
  }
  queryAggregateCount(e5, t5) {
    return this._proxy.queryAggregateCount(this._cleanUpAggregateQuery(e5), t5);
  }
  queryAggregateJSON(e5, t5) {
    return this._proxy.queryAggregates(this._cleanUpAggregateQuery(e5), t5);
  }
  queryFeaturesJSON(e5, t5) {
    return this._proxy.queryFeatures(this._cleanUpQuery(e5), t5);
  }
  queryObjectIds(e5, t5) {
    return this._proxy.queryObjectIds(this._cleanUpQuery(e5), t5);
  }
  queryFeatureCount(e5, t5) {
    return this._proxy.queryFeatureCount(this._cleanUpQuery(e5), t5);
  }
  queryExtent(e5, t5) {
    return this._proxy.queryExtent(this._cleanUpQuery(e5), t5).then((e6) => ({ count: e6.count, extent: M.fromJSON(e6.extent) }));
  }
  setVisibility(e5, t5) {
    t5 ? this._visibilityOverrides.delete(e5) : this._visibilityOverrides.add(e5), this._update();
  }
  update(e5) {
    if (!this._tileStrategy || !this.tileRenderer)
      return;
    const { hasMissingTiles: t5, added: r8, removed: i9 } = this._tileStrategy.update(e5);
    (r8.length || i9.length) && this._proxy.updateTiles({ added: r8, removed: i9 }), t5 && this.requestUpdate(), this.notifyChange("updating");
  }
  attach() {
    this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._tileStrategy = new l7({ acquireTile: (e5) => this._acquireTile(e5), releaseTile: (e5) => this._releaseTile(e5), tileInfoView: this.view.featuresTilingScheme, buffer: 0 }), this.addAttachHandles(l2(() => this.renderingConfigHash, () => this._update(), h)), "stream" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e5) => this._edit(e5)));
  }
  detach() {
    var _a, _b;
    this._commandsQueue.clear(), (_a = this._proxy) == null ? void 0 : _a.stop(), this.container.removeAllChildren(), (_b = this.tileRenderer) == null ? void 0 : _b.uninstall(this.container), this.tileRenderer = null, this._tileStrategy = l(this._tileStrategy), this._tileRendererHash = null;
  }
  moveStart() {
    this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    var _a;
    const e5 = "renderer" in this.layer && null != this.layer.renderer, t5 = this._commandsQueue.updating, r8 = null != this._updatingRequiredFieldsPromise, i9 = !this._proxy || !this._proxy.isReady, s6 = this._pipelineIsUpdating, a11 = null == this.tileRenderer || ((_a = this.tileRenderer) == null ? void 0 : _a.updating), n10 = e5 && (t5 || r8 || i9 || s6 || a11);
    return has("esri-2d-log-updating") && console.log(`Updating FLV2D (${this.layer.id}): ${n10}
  -> hasRenderer ${e5}
  -> hasPendingCommand ${t5}
  -> updatingRequiredFields ${r8}
  -> updatingProxy ${i9}
  -> updatingPipeline ${s6}
  -> updatingTileRenderer ${a11}
`), n10;
  }
  _createClientOptions() {
    return { setUpdating: (e5) => {
      this._set("_pipelineIsUpdating", e5);
    }, emitEvent: (e5) => {
      this.emit(e5.name, e5.event);
    } };
  }
  async _detectQueryMode(e5) {
    var _a;
    const t5 = "path" in e5, { layer: r8 } = this, i9 = "editingInfo" in r8 && ((_a = r8.editingInfo) == null ? void 0 : _a.lastEditDate), s6 = "refreshInterval" in r8 && !!r8.refreshInterval, a11 = !i9 && s6, n10 = E(r8);
    if (t5 && ("feature" === r8.type || "subtype-group" === r8.type) && "point" === r8.geometryType && (n10 == null ? void 0 : n10.query.supportsPagination) && !(n10 == null ? void 0 : n10.operations.supportsEditing) && !a11 && has("featurelayer-snapshot-enabled"))
      try {
        const e6 = await r8.queryFeatureCount();
        if (e6 <= has("featurelayer-snapshot-point-min-threshold"))
          return { mode: "snapshot", featureCount: e6 };
        const t6 = has("featurelayer-snapshot-point-max-threshold"), i10 = has("featurelayer-snapshot-point-coverage"), s7 = this.view.extent, a12 = r8.fullExtent, n11 = a12 == null ? void 0 : a12.clone().intersection(s7), o10 = null != n11 ? n11.width * n11.height : 0, l8 = (a12 == null ? void 0 : a12.width) * (a12 == null ? void 0 : a12.height);
        if (e6 <= t6 && (0 === l8 ? 0 : o10 / l8) >= i10)
          return { mode: "snapshot", featureCount: e6 };
      } catch (l8) {
        s.getLogger(this).warn("mapview-feature-layer", "Encountered an error when querying for featureCount", { error: l8 });
      }
    return { mode: "on-demand" };
  }
  async _createServiceOptions() {
    var _a, _b, _c;
    const e5 = this.layer;
    if ("stream" === e5.type)
      return null;
    const t5 = E(e5), { capabilities: r8, objectIdField: i9 } = e5, s6 = e5.fields.map((e6) => e6.toJSON()), a11 = null != e5.fullExtent ? e5.fullExtent.toJSON() : null, o10 = e3(e5.geometryType), l8 = "timeInfo" in e5 && e5.timeInfo && e5.timeInfo.toJSON() || null, u10 = e5.spatialReference ? e5.spatialReference.toJSON() : null, d11 = "feature" === e5.type ? e5.globalIdField : null;
    let h5;
    "ogc-feature" === e5.type ? h5 = e5.source.getSource() : M2(e5.source) ? h5 = await e5.source.openPorts() : e5.parsedUrl && (h5 = a(e5.parsedUrl), "dynamicDataSource" in e5 && e5.dynamicDataSource && (h5.query = { layer: JSON.stringify({ source: e5.dynamicDataSource }) }));
    const p7 = "datesInUnknownTimezone" in this.layer && this.layer.datesInUnknownTimezone, c10 = ("subtypeField" in this.layer ? this.layer.subtypeField : null) ?? null, { mode: y3, featureCount: g2 } = await this._detectQueryMode(h5);
    let f6 = this.layer.objectIdField;
    if ("feature" === this.layer.type && null != this.layer.orderBy && this.layer.orderBy.length) {
      const e6 = !this.layer.orderBy[0].valueExpression && this.layer.orderBy[0].field;
      e6 && (f6 = e6);
    }
    return { type: y3, timeReferenceUnknownClient: p7, subtypeField: c10, featureCount: g2, globalIdField: d11, maxRecordCount: r8.query.maxRecordCount, tileMaxRecordCount: r8.query.tileMaxRecordCount, capabilities: r8, effectiveCapabilities: t5, fields: s6, fullExtent: a11, geometryType: o10, objectIdField: i9, source: h5, timeInfo: l8, spatialReference: u10, orderByFields: f6, datesInUnknownTimezone: p7, dateFieldsTimeReference: ("dateFieldsTimeReference" in this.layer ? (_a = this.layer.dateFieldsTimeReference) == null ? void 0 : _a.toJSON() : null) || null, preferredTimeReference: ("preferredTimeReference" in this.layer ? (_b = this.layer.preferredTimeReference) == null ? void 0 : _b.toJSON() : null) || null, editFieldsInfo: "editFieldsInfo" in this.layer ? (_c = this.layer.editFieldsInfo) == null ? void 0 : _c.toJSON() : null };
  }
  async _createMemoryServiceOptions(e5) {
    const t5 = await e5.openPorts();
    return { ...this._createServiceOptions(), type: "memory", source: t5 };
  }
  _cleanUpQuery(e5) {
    const t5 = b.from(e5) || this.createQuery();
    return t5.outSpatialReference || (t5.outSpatialReference = this.view.spatialReference), t5;
  }
  _cleanUpAggregateQuery(e5) {
    const t5 = b.from(e5) || this.createAggregateQuery();
    return t5.outSpatialReference || (t5.outSpatialReference = this.view.spatialReference), t5;
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e5) {
    if (this.suspended)
      return void this._clearTiles();
    return this._validateEdit(e5) ? this._commandsQueue.push({ type: "edit", edits: e5 }) : void 0;
  }
  async doRefresh(e5) {
    if (this.attached && this._tileStrategy.tileKeys().length)
      return this.suspended && e5 ? void this._clearTiles() : this._commandsQueue.push({ type: "refresh", dataChanged: e5 });
  }
  _clearTiles() {
    this._tileStrategy.tileKeys().length && (this._proxy.updateTiles({ added: [], removed: this._tileStrategy.tileKeys() }), this._tileStrategy.clear(), this.requestUpdate(), this._commandsQueue.clear(), this._update());
  }
  _validateEdit(e5) {
    const t5 = "globalIdField" in this.layer && this.layer.globalIdField, r8 = e5.deletedFeatures.some((e6) => -1 === e6.objectId || !e6.objectId), i9 = t5 && this.availableFields.includes(t5);
    return r8 && !i9 ? (s.getLogger(this).error(new s2("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t5} to be included the layer's outFields for updates to be reflected on the map`)), null) : e5;
  }
  async _doUpdate() {
    var _a, _b;
    try {
      if (this.destroyed || !this._hasRequiredSupport(this.layer) || !this._tileStrategy)
        return;
      const { featureEffectView: t5, filter: r8 } = this;
      if (await this._updateRequiredFields(), this.destroyed)
        return;
      const { renderer: i9 } = this._getEffectiveRenderer();
      this._set("_effectiveRenderer", i9);
      const s6 = this._createSchemaConfig(), a11 = this._createConfiguration(s6, r8, t5.filter), n10 = this._lastDefinitionExpression !== a11.schema.source.definitionExpression;
      this._lastDefinitionExpression = a11.schema.source.definitionExpression;
      const l8 = a11.schema.tileRenderer, u10 = this._createTileRendererHash(l8);
      if ("snapshot" === this._serviceOptions.type && (a11.schema.source.initialFeatureCount = this._serviceOptions.featureCount), u10 !== this._tileRendererHash) {
        this._initTileRenderer(l8, i9);
        const e5 = this.layer, t6 = "stream" === e5.type ? await this._initServiceOptions() : this._serviceOptions;
        this.tileRenderer.onConfigUpdate(i9), "stream" !== e5.type && M2(e5.source) && (t6.source = await e5.source.openPorts());
        const r9 = { added: this._tileStrategy.tileKeys(), removed: [] };
        has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Proxy startup"), await this._proxy.startup(this.view.featuresTilingScheme, a11, t6, r9), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished proxy startup"), this.hasHighlight() && (has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Updating highlight"), await this._proxy.setHighlight(Array.from(this._highlightIds.keys())), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished highlight update")), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: onConfigUpdate start"), this.tileRenderer.onConfigUpdate(i9), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: onConfigUpdate end");
      } else {
        "snapshot" === this._serviceOptions.type && n10 && (a11.schema.source.changedFeatureCount = await this.layer.queryFeatureCount()), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Updating proxy");
        const t6 = await this._proxy.update(a11);
        has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished proxy update"), (t6.mesh || ((_a = t6.targets) == null ? void 0 : _a.aggregate)) && (has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Locking GPU Uploads"), this._lockGPUUploads());
        try {
          has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Applying update to proxy"), await this._proxy.applyUpdate(t6), has("esri-2d-update-debug") && console.debug("FeatureLayerView2D: Finished applying update to proxy");
        } catch (e5) {
          d(e5) || s.getLogger(this).error(e5);
        }
        (t6.mesh || ((_b = t6.targets) == null ? void 0 : _b.aggregate)) && this._unlockGPUUploads(), this.tileRenderer.onConfigUpdate(i9), this._updateClusterSizeVariable(), this._forceAttributeTextureUpload();
      }
      this._tileRendererHash = u10, this.tileRenderer.invalidateLabels(), this.requestUpdate();
    } catch (e5) {
    }
  }
  async _doEdit(e5) {
    try {
      await this._proxy.onEdits(e5);
    } catch (t5) {
      d(t5), 0;
    }
  }
  async _doRefresh(e5) {
    this._lockGPUUploads();
    try {
      let t5;
      e5 && "snapshot" === this.queryMode && "queryFeatureCount" in this.layer && (t5 = await this.layer.queryFeatureCount()), await this._proxy.refresh({ dataChanged: e5, featureCount: t5 });
    } catch (t5) {
      d(t5), 0;
    }
    this._unlockGPUUploads(), this._effectiveFeatureReduction && this._updateClusterSizeVariable();
  }
  _updateClusterSizeVariable() {
    this._needsClusterSizeUpdate && (this.tileRenderer.onConfigUpdate(this._effectiveRenderer), this._needsClusterSizeUpdate = false);
  }
  _createUpdateClusterSizeTask(e5, t5) {
    return l2(() => this._aggregateValueRanges, (r8) => {
      this._updateClusterEffectiveRendererSizeVariable(e5, t5, r8), this._needsClusterSizeUpdate = true, this._uploadsLocked || this._updateClusterSizeVariable();
    });
  }
  async _updateClusterEffectiveRendererSizeVariable(e5, t5, r8) {
    if (e5.dynamicClusterSize && "visualVariables" in e5 && e5.visualVariables) {
      const i9 = d5(e5.visualVariables);
      if (null != i9 && "cluster_count" === i9.field) {
        const s6 = e5.visualVariables.indexOf(i9);
        e5.visualVariables[s6] = v(t5, r8);
        const a11 = e5.clone();
        a11.dynamicClusterSize = true, this._set("_effectiveRenderer", a11);
      }
    }
  }
  _getEffectiveRenderer() {
    var _a;
    const e5 = this.layer, t5 = "renderer" in e5 ? e5.renderer : null, r8 = this._effectiveFeatureReduction;
    if (this._updateClusterSizeTask = o(this._updateClusterSizeTask), r8 && "renderer" in r8 && r8.renderer && !((_a = r8.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated)) {
      const e6 = r8.fields;
      if ("cluster" === r8.type) {
        const { renderer: t6, didInject: i9 } = f2(r8.renderer, r8, this._aggregateValueRanges);
        return i9 && (this._updateClusterSizeTask = this._createUpdateClusterSizeTask(t6, r8)), { renderer: t6, aggregateFields: e6, featureReduction: r8 };
      }
      return { renderer: r8.renderer, aggregateFields: e6, featureReduction: r8 };
    }
    if (r8 && "cluster" === r8.type && t5 && b2(t5)) {
      const e6 = r8, i9 = [], s6 = c(i9, t5, e6, this._aggregateValueRanges, true);
      return this._updateClusterSizeTask = this._createUpdateClusterSizeTask(s6, e6), { renderer: s6, aggregateFields: i9, featureReduction: r8 };
    }
    return { renderer: t5, aggregateFields: [], featureReduction: null };
  }
  _acquireTile(e5) {
    const t5 = this.tileRenderer.acquireTile(e5);
    return t5.once("attach", () => {
      this.requestUpdate();
    }), t5;
  }
  _releaseTile(e5) {
    this.tileRenderer.releaseTile(e5);
  }
  _initTileRenderer(e5, t5) {
    const r8 = t3(e5, { layerView: this, tileInfoView: this.view.featuresTilingScheme, layer: this.layer });
    return this.tileRenderer && (this._tileStrategy.clear(), this.tileRenderer.uninstall(this.container), this.tileRenderer = l(this.tileRenderer)), this.destroyed ? null : (this._proxy.tileRenderer = r8, this._set("tileRenderer", r8), this.tileRenderer.install(this.container), this.tileRenderer.onConfigUpdate(t5), this.requestUpdate(), this.tileRenderer);
  }
  _createTileRendererHash(e5) {
    return `${e5.type}`;
  }
  get hasFilter() {
    const e5 = !!("floorInfo" in this.layer && this.layer.floorInfo && this.view.floors && this.view.floors.length);
    return !!this.filter || e5 || !!this._visibilityOverrides.size || !!this.timeExtent;
  }
  _injectOverrides(e5) {
    const t5 = null != e5 ? e5.timeExtent : null, r8 = null != this.timeExtent && null != t5 ? this.timeExtent.intersection(t5) : this.timeExtent || t5;
    let i9 = null;
    const s6 = "floorInfo" in this.layer && this.layer.floorInfo;
    if (s6) {
      const t6 = null != e5 ? e5.where : null;
      i9 = this._addFloorFilterClause(t6);
    }
    if (!this._visibilityOverrides.size && !r8 && !s6)
      return null != e5 ? e5.toJSON() : null;
    (e5 = null != e5 && e5.clone() || new d4()).timeExtent = r8, i9 && (e5.where = i9);
    const a11 = e5.toJSON();
    return a11.hiddenIds = Array.from(this._visibilityOverrides), a11;
  }
  _addFloorFilterClause(e5) {
    var _a;
    const t5 = this.layer;
    let r8 = e5 || "";
    if ("floorInfo" in t5 && t5.floorInfo) {
      let e6 = this.view.floors;
      if (!e6 || !e6.length)
        return r8;
      ((_a = t5.floorInfo.viewAllLevelIds) == null ? void 0 : _a.length) && (e6 = t5.floorInfo.viewAllLevelIds);
      const i9 = e6.filter((e7) => "" !== e7).map((e7) => "'" + e7 + "'");
      i9.push("''");
      const s6 = t5.floorInfo.floorField;
      let a11 = "(" + s6 + " IN ({ids}) OR " + s6 + " IS NULL)";
      if (a11 = a11.replace("{ids}", i9.join(", ")), null != r8 && r8.includes(s6)) {
        let e7 = new RegExp("AND \\(" + s6 + ".*NULL\\)", "g");
        r8 = r8.replace(e7, ""), e7 = new RegExp("\\(" + s6 + ".*NULL\\)", "g"), r8 = r8.replace(e7, ""), r8 = r8.replaceAll(/\s+/g, " ").trim();
      }
      r8 = "" !== r8 ? "(" + r8 + ") AND " + a11 : a11;
    }
    return "" !== r8 ? r8 : null;
  }
  _createConfiguration(e5, t5, r8) {
    const i9 = "feature" === this.layer.type && this.layer.historicMoment ? this.layer.historicMoment.getTime() : void 0, s6 = "feature" === this.layer.type ? this.layer.gdbVersion ?? void 0 : void 0, a11 = new Array(V2), n10 = this._injectOverrides(t5);
    a11[0] = n10, a11[1] = null != r8 ? r8.toJSON() : null;
    const o10 = w4(e5);
    if (null == o10)
      return null;
    const l8 = n4("2d");
    return { availableFields: this.availableFields, gdbVersion: s6, historicMoment: i9, devicePixelRatio: window.devicePixelRatio || 1, filters: a11, schema: o10, supportsTextureFloat: l8.supportsTextureFloat, maxTextureSize: l8.maxTextureSize };
  }
  _hasRequiredSupport(e5) {
    return !("renderer" in e5) || h3(e5.renderer);
  }
  _lockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = true, this.tileRenderer.lockGPUUploads());
  }
  _unlockGPUUploads() {
    this.tileRenderer && (this._uploadsLocked = false, this.tileRenderer.unlockGPUUploads());
  }
  _forceAttributeTextureUpload() {
    this.tileRenderer && this.tileRenderer.forceAttributeTextureUpload();
  }
  _createSchemaConfig() {
    const e5 = this.layer;
    return { renderer: "renderer" in e5 ? e5.renderer : null, spatialReference: e5.spatialReference, timeExtent: "timeExtent" in e5 ? e5.timeExtent : null, definitionExpression: e5.definitionExpression, featureReduction: this._effectiveFeatureReduction, fields: e5.fields, geometryType: e5.geometryType, historicMoment: "historicMoment" in e5 ? e5.historicMoment : null, labelsVisible: "labelsVisible" in e5 && e5.labelsVisible, labelingInfo: "labelingInfo" in e5 ? e5.labelingInfo : null, availableFields: this.availableFields, featureEffect: this.featureEffect, filter: this.filter, gdbVersion: "gdbVersion" in e5 ? e5.gdbVersion : null, pixelBuffer: 0, orderBy: "orderBy" in e5 && e5.orderBy ? e5.orderBy : null, customParameters: { ..."customParameters" in e5 ? e5.customParameters : void 0, token: "apiKey" in e5 ? e5.apiKey ?? void 0 : void 0 }, subtypeCode: "subtypeCode" in e5 ? e5.subtypeCode : void 0, subtypeField: "subtypeField" in e5 ? e5.subtypeField : void 0 };
  }
  _addHighlight(e5) {
    for (const t5 of e5)
      if (this._highlightIds.has(t5)) {
        const e6 = this._highlightIds.get(t5);
        this._highlightIds.set(t5, e6 + 1);
      } else
        this._highlightIds.set(t5, 1);
    this._updateHighlight().catch((e6) => {
      d(e6) || s.getLogger(this).error(e6);
    });
  }
  _removeHighlight(e5) {
    for (const t5 of e5)
      if (this._highlightIds.has(t5)) {
        const e6 = this._highlightIds.get(t5) - 1;
        0 === e6 ? this._highlightIds.delete(t5) : this._highlightIds.set(t5, e6);
      }
    this._updateHighlight().catch((e6) => {
      d(e6) || s.getLogger(this).error(e6);
    });
  }
  _setLayersForFeature(e5) {
    const t5 = this.layer;
    e5.layer = t5, e5.sourceLayer = t5;
  }
  _createGraphicHit(e5, t5) {
    return this._setLayersForFeature(t5), null != t5.geometry && (t5.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t5, layer: this.layer, mapPoint: e5 };
  }
};
e([y2()], K.prototype, "_serviceOptions", void 0), e([y2()], K.prototype, "_proxy", void 0), e([y2()], K.prototype, "_pipelineIsUpdating", void 0), e([y2()], K.prototype, "_effectiveRenderer", void 0), e([y2()], K.prototype, "_effectiveFeatureReduction", null), e([y2()], K.prototype, "_aggregateValueRanges", void 0), e([y2()], K.prototype, "_commandsQueue", void 0), e([y2()], K.prototype, "featureEffectView", void 0), e([y2()], K.prototype, "labelsVisible", null), e([y2()], K.prototype, "labelingCollisionInfos", null), e([y2({ readOnly: true })], K.prototype, "queryMode", null), e([y2()], K.prototype, "renderingConfigHash", null), e([y2()], K.prototype, "tileRenderer", void 0), e([y2()], K.prototype, "updating", void 0), K = e([a2("esri.views.2d.layers.FeatureLayerView2D")], K);
var W = K;

export {
  W
};
//# sourceMappingURL=chunk-X3DVWI3B.js.map
