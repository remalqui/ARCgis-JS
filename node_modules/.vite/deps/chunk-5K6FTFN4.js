import {
  i
} from "./chunk-QXPTMFGZ.js";
import {
  n
} from "./chunk-CIDWM2UN.js";
import {
  a as a2,
  b,
  s as s4
} from "./chunk-MH2LNFJK.js";
import {
  C,
  T,
  a,
  c,
  d,
  r,
  s as s3,
  w
} from "./chunk-HNHXEGH2.js";
import {
  o
} from "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/core/workers/registry.js
var r2 = { statsWorker: () => import("./statsWorker-VRYHN5LB.js"), geometryEngineWorker: () => import("./geometryEngineWorker-BLQGI4CT.js"), CSVSourceWorker: () => import("./CSVSourceWorker-MARWFI7M.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker-RVNXO3LE.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker-3ZNBN2ER.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker-L3RWT7M4.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker-OFNHN3KE.js"), LercWorker: () => import("./LercWorker-RACRKCD5.js"), MemorySourceWorker: () => import("./MemorySourceWorker-JSF74MMG.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker-UVABGDWT.js"), Pipeline: () => import("./Pipeline-M5POLUK5.js"), PointCloudWorker: () => import("./PointCloudWorker-HV4DTS4D.js"), RasterWorker: () => import("./RasterWorker-PFSVCPN4.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker-6T3GMV24.js"), SceneLayerWorker: () => import("./SceneLayerWorker-WE5QJR36.js"), WFSSourceWorker: () => import("./WFSSourceWorker-JAFSOTKR.js"), WorkerTileHandler: () => import("./WorkerTileHandler-VAWJPYZU.js") };

// node_modules/@arcgis/core/core/workers/utils.js
var t;
!function(t2) {
  t2[t2.HANDSHAKE = 0] = "HANDSHAKE", t2[t2.OPEN = 1] = "OPEN", t2[t2.OPENED = 2] = "OPENED", t2[t2.RESPONSE = 3] = "RESPONSE", t2[t2.INVOKE = 4] = "INVOKE", t2[t2.ABORT = 5] = "ABORT", t2[t2.CLOSE = 6] = "CLOSE", t2[t2.OPEN_PORT = 7] = "OPEN_PORT", t2[t2.ON = 8] = "ON";
}(t || (t = {}));
var e = 0;
function r3() {
  return e++;
}
function n2(t2) {
  return t2 && "object" == typeof t2 && ("result" in t2 || "transferList" in t2);
}
function s5(t2) {
  return t2 ? "string" == typeof t2 ? JSON.stringify({ name: "message", message: t2 }) : t2.toJSON ? JSON.stringify(t2) : JSON.stringify({ name: t2.name, message: t2.message, details: t2.details || { stack: t2.stack } }) : null;
}
function f(e2, r4, i3, a4) {
  if (r4.type === t.OPEN_PORT)
    return void e2.postMessage(r4, [r4.port]);
  if (r4.type !== t.INVOKE && r4.type !== t.RESPONSE)
    return void e2.postMessage(r4);
  let u;
  if (n2(i3) ? (u = o2(i3.transferList), r4.data = i3.result) : (u = o2(a4), r4.data = i3), u) {
    if (has("ff")) {
      for (const n3 of u)
        if ("byteLength" in n3 && n3.byteLength > 267386880) {
          const n4 = "Worker call with large ArrayBuffer would crash Firefox";
          switch (r4.type) {
            case t.INVOKE:
              throw n4;
            case t.RESPONSE:
              return void f(e2, { type: t.RESPONSE, jobId: r4.jobId, error: s5(n4) });
          }
        }
    }
    e2.postMessage(r4, u);
  } else
    e2.postMessage(r4);
}
function i2(t2) {
  if (!t2)
    return null;
  const e2 = t2.data;
  return e2 ? "string" == typeof e2 ? JSON.parse(e2) : e2 : null;
}
function o2(t2) {
  if (!t2 || !t2.length)
    return null;
  if (has("esri-workers-arraybuffer-transfer"))
    return t2;
  const e2 = t2.filter((t3) => !a3(t3));
  return e2.length ? e2 : null;
}
function a3(t2) {
  var _a;
  return t2 instanceof ArrayBuffer || "ArrayBuffer" === ((_a = t2 == null ? void 0 : t2.constructor) == null ? void 0 : _a.name);
}

// node_modules/@arcgis/core/core/workers/RemoteClient.js
var { CLOSE: m, ABORT: f2, INVOKE: v, RESPONSE: M, OPEN_PORT: k, ON: j } = t;
var y = 2;
var I = class {
  constructor(e2) {
    this._timer = null, this._cancelledJobIds = /* @__PURE__ */ new Set(), this._invokeMessages = [], this._invoke = e2, this._timer = null, this._process = this._process.bind(this);
  }
  push(e2) {
    e2.type === t.ABORT ? this._cancelledJobIds.add(e2.jobId) : (this._invokeMessages.push(e2), null === this._timer && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e2 of this._invokeMessages)
      this._cancelledJobIds.has(e2.jobId) || this._invoke(e2);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
};
var J = class _J {
  static connect(e2) {
    const s6 = new MessageChannel();
    let t2;
    t2 = "function" == typeof e2 ? new e2() : "default" in e2 && "function" == typeof e2.default ? new e2.default() : e2;
    const o3 = new _J(s6.port1, { channel: s6, client: t2 }, () => null);
    return "object" == typeof t2 && "remoteClient" in t2 && (t2.remoteClient = o3), _J.clients.set(o3, t2), s6.port2;
  }
  static loadWorker(e2) {
    const s6 = r2[e2];
    return s6 ? s6() : Promise.resolve(null);
  }
  constructor(e2, s6, t2) {
    this._port = e2, this._getNextJob = t2, this._outJobs = /* @__PURE__ */ new Map(), this._inJobs = /* @__PURE__ */ new Map(), this._invokeQueue = new I((e3) => this._onInvokeMessage(e3)), this._client = s6.client, this._onMessage = this._onMessage.bind(this), this._channel = s6.channel, this._schedule = s6.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  close() {
    this._post({ type: m }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e2, t2, l) {
    const a4 = l == null ? void 0 : l.signal, h2 = l == null ? void 0 : l.transferList;
    if (!this._port)
      return Promise.reject(new s2("worker:port-closed", `Cannot call invoke('${e2}'), port is closed`, { methodName: e2, data: t2 }));
    const _ = r3();
    return new Promise((s6, l2) => {
      if (a(a4))
        return this._processWork(), void l2(c());
      const c2 = w(a4, () => {
        const e3 = this._outJobs.get(_);
        e3 && (this._outJobs.delete(_), this._processWork(), o(e3.abortHandle), this._post({ type: f2, jobId: _ }), l2(c()));
      }), p = { resolve: s6, reject: l2, abortHandle: c2, debugInfo: e2 };
      this._outJobs.set(_, p), this._post({ type: v, jobId: _, methodName: e2, abortable: null != a4 }, t2, h2);
    });
  }
  on(e2, s6) {
    const t2 = new MessageChannel();
    function o3(e3) {
      s6(e3.data);
    }
    return this._port.postMessage({ type: t.ON, eventType: e2, port: t2.port2 }, [t2.port2]), t2.port1.addEventListener("message", o3), t2.port1.start(), { remove() {
      t2.port1.postMessage({ type: t.CLOSE }), t2.port1.close(), t2.port1.removeEventListener("message", o3);
    } };
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e2 = new MessageChannel();
    return this._post({ type: k, port: e2.port2 }), e2.port1;
  }
  _processWork() {
    if (this._outJobs.size >= y)
      return;
    const e2 = this._getNextJob();
    if (!e2)
      return;
    const { methodName: s6, data: t2, invokeOptions: o3, resolver: n3 } = e2;
    this.invoke(s6, t2, o3).then((e3) => n3.resolve(e3)).catch((e3) => n3.reject(e3));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e2) => {
      o(e2.abortHandle), e2.reject(c(`Worker closing, aborting job calling '${e2.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = null, this._client = null, this._schedule = null;
  }
  _onMessage(e2) {
    null != this._schedule ? this._schedule(() => this._processMessage(e2)) : this._processMessage(e2);
  }
  _processMessage(e2) {
    const s6 = i2(e2);
    if (s6)
      switch (s6.type) {
        case M:
          this._onResponseMessage(s6);
          break;
        case v:
          this._invokeQueue.push(s6);
          break;
        case f2:
          this._onAbortMessage(s6);
          break;
        case m:
          this._onCloseMessage();
          break;
        case k:
          this._onOpenPortMessage(s6);
          break;
        case j:
          this._onOnMessage(s6);
      }
  }
  _onAbortMessage(e2) {
    const s6 = this._inJobs, t2 = e2.jobId, o3 = s6.get(t2);
    this._invokeQueue.push(e2), o3 && (o3.controller && o3.controller.abort(), s6.delete(t2));
  }
  _onCloseMessage() {
    const e2 = this._client;
    this._close(), e2 && "destroy" in e2 && _J.clients.get(this) === e2 && e2.destroy(), _J.clients.delete(this), (e2 == null ? void 0 : e2.remoteClient) && (e2.remoteClient = null);
  }
  _onInvokeMessage(e2) {
    const { methodName: s6, jobId: t2, data: o3, abortable: n3 } = e2, r4 = n3 ? new AbortController() : null, i3 = this._inJobs;
    let h2, c2 = this._client, _ = c2[s6];
    try {
      if (!_ && s6 && s6.includes(".")) {
        const e3 = s6.split(".");
        for (let s7 = 0; s7 < e3.length - 1; s7++)
          c2 = c2[e3[s7]], _ = c2[e3[s7 + 1]];
      }
      if ("function" != typeof _)
        throw new TypeError(`${s6} is not a function`);
      h2 = _.call(c2, o3, { client: this, signal: r4 ? r4.signal : null });
    } catch (p) {
      return void this._post({ type: M, jobId: t2, error: s5(p) });
    }
    T(h2) ? (i3.set(t2, { controller: r4, promise: h2 }), h2.then((e3) => {
      i3.has(t2) && (i3.delete(t2), this._post({ type: M, jobId: t2 }, e3));
    }, (e3) => {
      i3.has(t2) && (i3.delete(t2), d(e3) || this._post({ type: M, jobId: t2, error: s5(e3 || { message: `Error encountered at method ${s6}` }) }));
    })) : this._post({ type: M, jobId: t2 }, h2);
  }
  _onOpenPortMessage(e2) {
    new _J(e2.port, { client: this._client }, () => null);
  }
  _onOnMessage(e2) {
    const { port: s6 } = e2, o3 = this._client.on(e2.eventType, (e3) => {
      s6.postMessage(e3);
    }), n3 = r(e2.port, "message", (e3) => {
      const t2 = i2(e3);
      (t2 == null ? void 0 : t2.type) === t.CLOSE && (n3.remove(), o3.remove(), s6.close());
    });
  }
  _onResponseMessage(e2) {
    const { jobId: t2, error: n3, data: r4 } = e2, i3 = this._outJobs;
    if (!i3.has(t2))
      return;
    const l = i3.get(t2);
    i3.delete(t2), this._processWork(), o(l.abortHandle), n3 ? l.reject(s2.fromJSON(JSON.parse(n3))) : l.resolve(r4);
  }
  _post(e2, s6, t2) {
    return f(this._port, e2, s6, t2);
  }
};
J.kernelInfo = { buildDate: b, fullVersion: s4, revision: a2 }, J.clients = /* @__PURE__ */ new Map();

// node_modules/@arcgis/core/core/workers/Connection.js
var h = class {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new i();
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients || !this._clients.length;
  }
  open(e2, t2) {
    return new Promise((n3, i3) => {
      let r4 = true;
      const h2 = (e3) => {
        s3(t2.signal), r4 && (r4 = false, e3());
      };
      this._clients.length = e2.length, this._clientPromises.length = e2.length, this._inUseClients.length = e2.length;
      for (let o3 = 0; o3 < e2.length; ++o3) {
        const r5 = e2[o3];
        T(r5) ? this._clientPromises[o3] = r5.then((e3) => (this._clients[o3] = new J(e3, t2, () => this._ongoingJobsQueue.pop() ?? null), h2(n3), this._clients[o3]), () => (h2(i3), null)) : (this._clients[o3] = new J(r5, t2, () => this._ongoingJobsQueue.pop() ?? null), this._clientPromises[o3] = Promise.resolve(this._clients[o3]), h2(n3));
      }
    });
  }
  broadcast(e2, t2, s6) {
    const n3 = new Array(this._clientPromises.length);
    for (let i3 = 0; i3 < this._clientPromises.length; ++i3) {
      const o3 = this._clientPromises[i3];
      n3[i3] = o3.then((n4) => n4 == null ? void 0 : n4.invoke(e2, t2, s6));
    }
    return n3;
  }
  close() {
    let e2;
    for (; e2 = this._ongoingJobsQueue.pop(); )
      e2.resolver.reject(c(`Worker closing, aborting job calling '${e2.methodName}'`));
    for (const t2 of this._clientPromises)
      t2.then((e3) => e3 == null ? void 0 : e3.close());
    this._clients.length = 0, this._clientPromises.length = 0, this._inUseClients.length = 0;
  }
  invoke(e2, s6, n3) {
    let o3;
    Array.isArray(n3) ? (s.getLogger("esri.core.workers.Connection").warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), o3 = { transferList: n3 }) : o3 = n3;
    const r4 = C();
    this._ongoingJobsQueue.push({ methodName: e2, data: s6, invokeOptions: o3, resolver: r4 });
    for (let t2 = 0; t2 < this._clientPromises.length; t2++) {
      const e3 = this._clients[t2];
      e3 ? e3.jobAdded() : this._clientPromises[t2].then((e4) => e4 == null ? void 0 : e4.jobAdded());
    }
    return r4.promise;
  }
  on(t2, s6) {
    return Promise.all(this._clientPromises).then(() => n(this._clients.map((e2) => e2.on(t2, s6))));
  }
  openPorts() {
    return new Promise((e2) => {
      const t2 = new Array(this._clientPromises.length);
      let s6 = t2.length;
      for (let n3 = 0; n3 < this._clientPromises.length; ++n3) {
        this._clientPromises[n3].then((i3) => {
          i3 && (t2[n3] = i3.openPort()), 0 == --s6 && e2(t2);
        });
      }
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
};

export {
  t,
  r3 as r,
  s5 as s,
  f,
  i2 as i,
  J,
  h
};
//# sourceMappingURL=chunk-5K6FTFN4.js.map
