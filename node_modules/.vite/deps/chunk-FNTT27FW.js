import {
  l,
  l3 as l2,
  n as n3
} from "./chunk-HPXPYN62.js";
import {
  I,
  t as t2
} from "./chunk-AC3INPLN.js";
import {
  c as c2,
  e,
  f,
  i as i2,
  n as n2,
  s as s5,
  u
} from "./chunk-XP6ESZGI.js";
import {
  W as W2
} from "./chunk-3VTULECI.js";
import {
  Q,
  R,
  S,
  V,
  W,
  t
} from "./chunk-JSMUQBPG.js";
import {
  a as a2
} from "./chunk-QAWS7Y22.js";
import {
  U
} from "./chunk-BCDDCNQ2.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import {
  It,
  Nt,
  et,
  it,
  nt,
  st
} from "./chunk-KKGVORR5.js";
import {
  s as s4
} from "./chunk-TDPKDZC3.js";
import {
  c
} from "./chunk-LNMNRMVX.js";
import {
  i
} from "./chunk-MOPR7RFH.js";
import {
  C,
  d
} from "./chunk-HNHXEGH2.js";
import {
  a,
  n,
  s
} from "./chunk-DWOEYHKS.js";
import {
  s2,
  s3
} from "./chunk-W2N7YT6I.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
function d2({ coords: t3, lengths: e2 }) {
  let r4 = 0;
  for (const s6 of e2) {
    for (let e3 = 1; e3 < s6; e3++)
      t3[2 * (r4 + e3)] += t3[2 * (r4 + e3) - 2], t3[2 * (r4 + e3) + 1] += t3[2 * (r4 + e3) - 1];
    r4 += s6;
  }
}
var h = class _h extends I {
  static fromFeatures(e2, r4) {
    const { objectIdField: s6, geometryType: i3 } = r4, n5 = et([], e2, i3, false, false, s6);
    for (let t3 = 0; t3 < n5.length; t3++)
      n5[t3].displayId = e2[t3].displayId;
    return _h.fromOptimizedFeatures(n5, r4);
  }
  static fromFeatureSet(t3, r4) {
    const s6 = it(t3, r4.objectIdField);
    return _h.fromOptimizedFeatureSet(s6, r4);
  }
  static fromOptimizedFeatureSet(t3, e2) {
    const { features: r4 } = t3, s6 = _h.fromOptimizedFeatures(r4, e2);
    return s6._exceededTransferLimit = t3.exceededTransferLimit, s6._transform = t3.transform, s6._fieldsIndex = new r(e2.fields), s6;
  }
  static fromOptimizedFeatures(t3, e2, r4) {
    const s6 = I.createInstance(), i3 = new _h(s6, t3, e2);
    return i3._fieldsIndex = new r(e2.fields), i3._transform = r4, i3;
  }
  constructor(t3, e2, r4) {
    super(t3, r4), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = r4 == null ? void 0 : r4.geometryType, this._features = e2;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  removeIds(t3) {
    const e2 = new Set(t3);
    this._features = this._features.filter((t4) => !(null != t4.objectId && e2.has(t4.objectId)));
  }
  append(t3) {
    for (const e2 of t3)
      this._features.push(e2);
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getQuantizationTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let t3 = "";
    for (const e2 in this._current.attributes)
      t3 += this._current.attributes[e2];
    return t3;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(t3) {
    this._featureIndex = t3;
  }
  getObjectId() {
    var _a;
    return (_a = this._current) == null ? void 0 : _a.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t3) {
    this._current.displayId = t3;
  }
  getGroupId() {
    return this._current.groupId;
  }
  setGroupId(t3) {
    this._current.groupId = t3;
  }
  copy() {
    const t3 = new _h(this.instance, this._features, this.fullSchema());
    return this.copyInto(t3), t3;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); )
      ;
    return this._featureIndex < this._features.length;
  }
  readLegacyFeature() {
    return nt(this._current, this.geometryType, this.hasZ, this.hasM);
  }
  readOptimizedFeature() {
    return this._current;
  }
  readLegacyPointGeometry() {
    return this.readGeometry() ? { x: this.getX(), y: this.getY() } : null;
  }
  readLegacyGeometry() {
    const t3 = this.readUnquantizedGeometry();
    return st(t3, this.geometryType, this.hasZ, this.hasM);
  }
  readLegacyCentroid() {
    const t3 = this.readCentroid();
    return null == t3 ? null : { x: t3.coords[0] * this._sx + this._tx, y: t3.coords[1] * this._sy + this._ty };
  }
  readGeometryArea() {
    return s4(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  readUnquantizedGeometry() {
    const t3 = this.readGeometry();
    if ("esriGeometryPoint" === this.geometryType || !t3)
      return t3;
    const e2 = t3.clone();
    return d2(e2), e2;
  }
  readHydratedGeometry() {
    const t3 = this._current.geometry;
    if (null == t3)
      return null;
    const e2 = t3.clone();
    return null != this._transform && It(e2, e2, this.hasZ, this.hasM, this._transform), e2;
  }
  getXHydrated() {
    if (!s4(this._current))
      return 0;
    const t3 = this._current.geometry.coords[0], e2 = this.getQuantizationTransform();
    return null == e2 ? t3 : t3 * e2.scale[0] + e2.translate[0];
  }
  getYHydrated() {
    if (!s4(this._current))
      return 0;
    const t3 = this._current.geometry.coords[1], e2 = this.getQuantizationTransform();
    return null == e2 ? t3 : e2.translate[1] - t3 * e2.scale[1];
  }
  getX() {
    return s4(this._current) ? this._current.geometry.coords[0] * this._sx + this._tx : 0;
  }
  getY() {
    return s4(this._current) ? this._current.geometry.coords[1] * this._sy + this._ty : 0;
  }
  readGeometry() {
    if (!s4(this._current)) {
      if (null != this._current.centroid) {
        const [t4, e3] = this._current.centroid.coords;
        return this.createQuantizedExtrudedQuad(t4, e3);
      }
      return null;
    }
    const t3 = this._current.geometry.clone();
    if (t3.isPoint)
      return t3.coords[0] = t3.coords[0] * this._sx + this._tx, t3.coords[1] = t3.coords[1] * this._sy + this._ty, t3;
    let e2 = 0;
    for (const r4 of t3.lengths)
      t3.coords[2 * e2] = t3.coords[2 * e2] * this._sx + this._tx, t3.coords[2 * e2 + 1] = t3.coords[2 * e2 + 1] * this._sy + this._ty, e2 += r4;
    return t3;
  }
  readCentroid() {
    return s4(this._current) ? this._computeCentroid() : this._current.centroid;
  }
  _readAttribute(t3, e2) {
    var _a;
    const r4 = this._fieldsIndex.get(t3);
    if (!r4)
      return;
    let s6 = this._current.attributes[r4.name];
    return null == s6 ? s6 : ("esriFieldTypeTimestampOffset" === ((_a = this.fields.get(t3)) == null ? void 0 : _a.type) && (s6 = this.parseTimestampOffset(s6)), e2 && this.fields.isDateField(t3) ? new Date(s6) : s6);
  }
  copyInto(t3) {
    super.copyInto(t3), t3._featureIndex = this._featureIndex, t3._transform = this._transform, t3._fieldsIndex = this._fieldsIndex;
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
var E = s2.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var k = n3(l, E);
var D = { sharedArrayBuffer: has("esri-shared-array-buffer"), atomics: has("esri-atomics") };
function F(t3, e2) {
  return (i3) => e2(t3(i3));
}
var I2 = class {
  constructor(t3, e2, i3, s6) {
    this.size = 0, this.texelSize = 4, this.dirtyStart = 0, this.dirtyEnd = 0;
    const { pixelType: r4, layout: a3, textureOnly: n5 } = s6;
    this.textureOnly = n5 || false, this.pixelType = r4, this._ctype = e2, this.layout = a3, this._resetRange(), this._shared = t3, this.size = i3, n5 || (this.data = this._initData(r4, i3, t3, e2));
  }
  get buffer() {
    return n(this.data, (t3) => t3.buffer);
  }
  unsetComponentAllTexels(t3, e2) {
    const i3 = this.data;
    for (let s6 = 0; s6 < this.size * this.size; s6++)
      i3[s6 * this.texelSize + t3] &= ~e2;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t3, e2) {
    const i3 = this.data;
    for (let s6 = 0; s6 < this.size * this.size; s6++)
      i3[s6 * this.texelSize + t3] |= 255 & e2;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t3, e2, i3) {
    const s6 = this.data;
    for (const r4 of i3)
      s6[r4 * this.texelSize + t3] |= e2, this.dirtyStart = Math.min(this.dirtyStart, r4), this.dirtyEnd = Math.max(this.dirtyEnd, r4);
  }
  setComponentTexel(t3, e2, i3) {
    this.data[i3 * this.texelSize + t3] |= e2, this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, i3);
  }
  unsetComponentTexel(t3, e2, i3) {
    this.data[i3 * this.texelSize + t3] &= ~e2, this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, i3);
  }
  getData(t3, e2) {
    const i3 = f(t3);
    return this.data[i3 * this.texelSize + e2];
  }
  setData(t3, e2, i3) {
    const s6 = f(t3), r4 = 1 << e2;
    0 != (this.layout & r4) ? null != this.data && (this.data[s6 * this.texelSize + e2] = i3, this.dirtyStart = Math.min(this.dirtyStart, s6), this.dirtyEnd = Math.max(this.dirtyEnd, s6)) : E.error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  lock() {
    this.pixelType === U.UNSIGNED_BYTE && this._shared && D.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 1);
  }
  unlock() {
    this.pixelType === U.UNSIGNED_BYTE && this._shared && D.atomics && "local" !== this._ctype && Atomics.store(this.data, 0, 0);
  }
  expand(t3) {
    if (this.size = t3, !this.textureOnly) {
      const e2 = this._initData(this.pixelType, t3, this._shared, this._ctype), i3 = this.data;
      e2.set(i3), this.data = e2;
    }
  }
  toMessage() {
    const t3 = this.dirtyStart, e2 = this.dirtyEnd, i3 = this.texelSize;
    if (t3 > e2)
      return null;
    this._resetRange();
    const s6 = !(this._shared || "local" === this._ctype), r4 = this.pixelType, a3 = this.layout, n5 = this.data;
    return { start: t3, end: e2, data: s6 && n5.slice(t3 * i3, (e2 + 1) * i3) || null, pixelType: r4, layout: a3 };
  }
  _initData(t3, e2, i3, s6) {
    const r4 = i3 && "local" !== s6 ? SharedArrayBuffer : ArrayBuffer, a3 = W2(t3), n5 = new a3(new r4(e2 * e2 * 4 * a3.BYTES_PER_ELEMENT));
    for (let o = 0; o < n5.length; o += 4)
      n5[o + 1] = 255;
    return n5;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var B = class {
  constructor(t3, e2) {
    this._client = t3, this.config = e2, this.updatingHandles = new c(), this._blocks = new Array(), this._filters = new Array(V), this._attributeComputeInfo = null, this._targetType = 0, this._abortController = new AbortController(), this._hasScaleExpr = false, this._size = 32, this._nextUpdate = null, this._currUpdate = null, this._idsToHighlight = /* @__PURE__ */ new Set();
    const i3 = e2.supportsTextureFloat ? U.FLOAT : U.UNSIGNED_BYTE;
    k(`Creating AttributeStore ${D.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: U.UNSIGNED_BYTE, layout: 1 }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: i3, layout: 15 }, { pixelType: i3, layout: 15 }, { pixelType: i3, layout: 15 }, { pixelType: i3, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  destroy() {
    this._abortController.abort(), this.updatingHandles.destroy();
  }
  get hasScaleExpr() {
    return this._hasScaleExpr;
  }
  get _signal() {
    return this._abortController.signal;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  isUpdating() {
    const t3 = this.updatingHandles.updating || !!this._nextUpdate;
    return has("esri-2d-log-updating") && console.log(`Updating AttributeStore: ${t3}
  -> updatingHandles ${this.updatingHandles.updating} (currUpdate: ${!!this._currUpdate})
  -> nextUpdate: ${!!this._nextUpdate}
`), t3;
  }
  update(t3, e2) {
    this.config = e2;
    const i3 = e2.schema.processors[0].storage, s6 = a2(this._schema, i3);
    if ((t3.targets.feature || t3.targets.aggregate) && (t3.storage.data = true), s6 && (has("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", s6), t3.storage.data = true, this._schema = i3, this._attributeComputeInfo = null, null != i3)) {
      switch (i3.target) {
        case "feature":
          this._targetType = u;
          break;
        case "aggregate":
          this._targetType = c2;
      }
      if ("subtype" === i3.type) {
        this._attributeComputeInfo = { isSubtype: true, subtypeField: i3.subtypeField, map: /* @__PURE__ */ new Map() };
        for (const t4 in i3.mapping) {
          const e3 = i3.mapping[t4];
          if (null != e3 && null != e3.vvMapping)
            for (const i4 of e3.vvMapping)
              this._bindAttribute(i4, parseInt(t4, 10));
        }
      } else {
        if (this._attributeComputeInfo = { isSubtype: false, map: /* @__PURE__ */ new Map() }, null != i3.vvMapping)
          for (const t4 of i3.vvMapping)
            this._bindAttribute(t4);
        if (null != i3.attributeMapping)
          for (const t4 of i3.attributeMapping)
            this._bindAttribute(t4);
      }
    }
  }
  onTileData(t3, e2) {
    if (null == e2.addOrUpdate)
      return;
    const i3 = e2.addOrUpdate.getCursor();
    for (; i3.next(); ) {
      const t4 = i3.getDisplayId();
      this.setAttributeData(t4, i3);
    }
  }
  async setHighlight(t3, e2) {
    const i3 = 1, s6 = this._getBlock(0), r4 = e2.map((t4) => f(t4));
    s6.lock(), s6.unsetComponentAllTexels(0, i3), s6.setComponent(0, i3, r4), s6.unlock(), this._idsToHighlight.clear();
    for (const a3 of t3)
      this._idsToHighlight.add(a3);
    await this.sendUpdates();
  }
  async updateFilters(t3, e2, i3) {
    has("esri-2d-update-debug") && console.debug("AttributeStore::updateFilters");
    const { service: s6, spatialReference: r4 } = i3, { filters: a3 } = e2, n5 = a3.map((t4, e3) => this._updateFilter(t4, e3, s6, r4)), o = (await Promise.all(n5)).some((t4) => t4);
    has("esri-2d-update-debug") && console.debug("AttributeStore::updateFilters - finsihed"), o && (t3.storage.filters = true, has("esri-2d-update-debug") && console.debug("Applying Update - AttributeStore:", "Filters changed"));
  }
  setData(t3, e2, i3, s6) {
    const r4 = f(t3);
    this._ensureSizeForTexel(r4), this._getBlock(e2).setData(t3, i3, s6);
  }
  getData(t3, e2, i3) {
    return this._getBlock(e2).getData(t3, i3);
  }
  getHighlightFlag(t3) {
    return this._idsToHighlight.has(t3) ? W : 0;
  }
  unsetAttributeData(t3) {
    const e2 = f(t3);
    this._getBlock(0).setData(e2, 0, 0);
  }
  setAttributeData(t3, e2) {
    const s6 = f(t3);
    if (this._ensureSizeForTexel(s6), this._getBlock(0).setData(s6, 0, this.getFilterFlags(e2)), this._targetType !== e(t3))
      return;
    const r4 = this._attributeComputeInfo, a3 = this.config.supportsTextureFloat ? 1 : 2, n5 = 4;
    let o = null;
    r4 && (o = r4.isSubtype ? r4.map.get(e2.readAttribute(r4.subtypeField)) : r4.map, o && o.size && o.forEach((t4, r5) => {
      const o2 = r5 * a3 % n5, l3 = Math.floor(r5 * a3 / n5), h2 = this._getBlock(l3 + S), u2 = t4(e2);
      if (this.config.supportsTextureFloat)
        h2.setData(s6, o2, u2);
      else if (u2 === t)
        h2.setData(s6, o2, 255), h2.setData(s6, o2 + 1, 255);
      else {
        const t5 = i(Math.round(u2), -32767, 32766) + 32768, e3 = 255 & t5, r6 = (65280 & t5) >> 8;
        h2.setData(s6, o2, e3), h2.setData(s6, o2 + 1, r6);
      }
    }));
  }
  sendUpdates() {
    if (has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate"), this._nextUpdate)
      return this._nextUpdate.promise;
    if (this._currUpdate)
      return this._nextUpdate = C(), this.updatingHandles.addPromise(this._nextUpdate.promise), this._nextUpdate.promise;
    const e2 = { blocks: this._blocks.map((t3) => null != t3 ? t3.toMessage() : null) };
    return this._currUpdate = this._createResources().then(() => {
      const t3 = () => {
        if (this._currUpdate = null, this._nextUpdate) {
          const t4 = this._nextUpdate;
          this._nextUpdate = null, this.sendUpdates().then(() => t4.resolve());
        } else
          has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::No additional updates queued");
      };
      has("esri-2d-update-debug") && console.debug("AttributeStore::sendUpdate::client.update");
      const i3 = this.updatingHandles.addPromise(this._client.update(e2, this._signal).then(t3).catch(t3));
      return this._client.render(this._signal), i3;
    }).catch((e3) => {
      if (d(e3))
        return this._createResourcesPromise = null, this._createResources();
      E.error(new s3("mapview-attribute-store", "Encountered an error during client update", e3));
    }), this._currUpdate;
  }
  _ensureSizeForTexel(t3) {
    for (; t3 >= this._size * this._size; )
      if (this._expand())
        return;
  }
  _bindAttribute(t3, e2) {
    function i3() {
      const { normalizationField: e3 } = t3;
      return e3 ? (i4) => {
        const s7 = i4.readAttribute(e3);
        if (!s7)
          return null;
        return i4.readAttribute(t3.field) / s7;
      } : (e4) => e4.readAttribute(t3.field);
    }
    function s6() {
      return t3.normalizationField && E.warn("mapview-arcade", "Ignoring normalizationField specified with an arcade expression which is not supported."), (e3) => e3.getComputedNumericAtIndex(t3.fieldIndex);
    }
    let r4;
    if (null != t3.fieldIndex)
      r4 = s6();
    else {
      if (!t3.field)
        return;
      r4 = i3();
    }
    const { valueRepresentation: a3 } = t3;
    if (a3) {
      r4 = F(r4, (t4) => l2(t4, a3));
    }
    const n5 = (t4) => null === t4 || isNaN(t4) || t4 === 1 / 0 || t4 === -1 / 0 ? t : t4, o = this._attributeComputeInfo;
    if (o.isSubtype) {
      const i4 = o.map.get(e2) ?? /* @__PURE__ */ new Map();
      i4.set(t3.binding, F(r4, n5)), o.map.set(e2, i4);
    } else
      o.map.set(t3.binding, F(r4, n5));
  }
  _createResources() {
    if (null != this._createResourcesPromise)
      return this._createResourcesPromise;
    this._getBlock(Q), this._getBlock(R), k("Initializing AttributeStore");
    const e2 = { shared: D.sharedArrayBuffer && !("local" === this._client.type), size: this._size, blocks: s(this._blocks, (t3) => ({ textureOnly: t3.textureOnly, buffer: t3.buffer, pixelType: t3.pixelType })) }, i3 = this._client.initialize(e2, this._signal).catch((e3) => {
      d(e3) ? this._createResourcesPromise = null : E.error(new s3("mapview-attribute-store", "Encountered an error during client initialization", e3));
    });
    return this._createResourcesPromise = i3, i3.then(() => null == this._createResourcesPromise ? this._createResources() : void 0), i3;
  }
  _getBlock(t3) {
    const e2 = this._blocks[t3];
    if (null != e2)
      return e2;
    k(`Initializing AttributeBlock at index ${t3}`);
    const i3 = D.sharedArrayBuffer, s6 = this._client.type, r4 = new I2(i3, s6, this._size, this._blockDescriptors[t3]);
    return this._blocks[t3] = r4, this._createResourcesPromise = null, r4;
  }
  _expand() {
    if (this._size < this.config.maxTextureSize) {
      const t3 = this._size <<= 1;
      return k("Expanding block size to", t3, this._blocks), a(this._blocks, (e2) => e2.expand(t3)), this._createResourcesPromise = null, this._size = t3, 0;
    }
    return E.error(new s3("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  async _updateFilter(t3, e2, i3, s6) {
    const r4 = this._filters[e2], a3 = null != r4 && r4.hash;
    if (!r4 && !t3)
      return false;
    if (a3 === JSON.stringify(t3))
      return false;
    if (null == t3) {
      if (!r4)
        return false;
      const t4 = 1 << e2 + 1, i4 = this._getBlock(0);
      return this._filters[e2] = null, i4.setComponentAllTexels(0, t4), this.sendUpdates(), true;
    }
    const n5 = await this._getFilter(e2, i3);
    return await n5.update(t3, s6), true;
  }
  async _getFilter(t3, e2) {
    const i3 = this._filters[t3];
    if (null != i3)
      return i3;
    const { default: s6 } = await import("./FeatureFilter-UXSR7QSS.js"), r4 = new s6({ geometryType: e2.geometryType, hasM: false, hasZ: false, timeInfo: e2.timeInfo, fieldsIndex: new r(e2.fields) });
    return this._filters[t3] = r4, r4;
  }
  isVisible(t3) {
    return !!(2 & this._getBlock(0).getData(t3, 0));
  }
  getFilterFlags(t3) {
    let e2 = 0;
    const i3 = i2(t3.getDisplayId());
    for (let r4 = 0; r4 < this._filters.length; r4++) {
      const s7 = !!(i3 & 1 << r4), a3 = this._filters[r4];
      e2 |= (!s7 || null == a3 || a3.check(t3) ? 1 : 0) << r4;
    }
    let s6 = 0;
    if (this._idsToHighlight.size) {
      const e3 = t3.getObjectId();
      s6 = this.getHighlightFlag(e3);
    }
    return e2 << 1 | s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var r2 = class {
  constructor() {
    this._freeIds = [], this._idCounter = 1;
  }
  createId(r4 = false) {
    return s5(this._getFreeId(), r4);
  }
  releaseId(e2) {
    this._freeIds.push(e2);
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
function n4(t3, e2, s6) {
  if (!(t3.length > e2))
    for (; t3.length <= e2; )
      t3.push(s6);
}
var r3 = class {
  constructor() {
    this._numerics = [], this._strings = [], this._idGenerator = new r2(), this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [];
  }
  createBitset() {
    const e2 = this._bitsets.length;
    return this._bitsets.push(t2.create(this._allocatedSize, n2)), e2 + 1;
  }
  getBitset(t3) {
    return this._bitsets[t3 - 1];
  }
  _expand() {
    this._allocatedSize <<= 1;
    for (const t3 of this._bitsets)
      t3.resize(this._allocatedSize);
  }
  _ensureNumeric(t3, e2) {
    this._numerics[t3] || (this._numerics[t3] = []);
    n4(this._numerics[t3], e2, 0);
  }
  _ensureInstanceId(t3) {
    n4(this._instanceIds, t3, 0);
  }
  _ensureString(t3, e2) {
    this._strings[t3] || (this._strings[t3] = []);
    n4(this._strings[t3], e2, null);
  }
  createDisplayId(t3 = false) {
    const s6 = this._idGenerator.createId();
    return s6 > this._allocatedSize && this._expand(), s5(s6, t3);
  }
  releaseDisplayId(e2) {
    for (const t3 of this._bitsets)
      t3.unset(e2);
    return this._idGenerator.releaseId(e2 & n2);
  }
  getComputedNumeric(e2, s6) {
    return this.getComputedNumericAtIndex(e2 & n2, 0);
  }
  setComputedNumeric(e2, s6, i3) {
    return this.setComputedNumericAtIndex(e2 & n2, i3, 0);
  }
  getComputedString(e2, s6) {
    return this.getComputedStringAtIndex(e2 & n2, 0);
  }
  setComputedString(e2, s6, i3) {
    return this.setComputedStringAtIndex(e2 & n2, 0, i3);
  }
  getComputedNumericAtIndex(e2, s6) {
    const i3 = e2 & n2;
    return this._ensureNumeric(s6, i3), this._numerics[s6][i3];
  }
  setComputedNumericAtIndex(e2, s6, i3) {
    const n5 = e2 & n2;
    this._ensureNumeric(s6, n5), this._numerics[s6][n5] = i3;
  }
  getInstanceId(e2) {
    const s6 = e2 & n2;
    return this._ensureInstanceId(s6), this._instanceIds[s6];
  }
  setInstanceId(e2, s6) {
    const i3 = e2 & n2;
    this._ensureInstanceId(i3), this._instanceIds[i3] = s6;
  }
  getComputedStringAtIndex(e2, s6) {
    const i3 = e2 & n2;
    return this._ensureString(s6, i3), this._strings[s6][i3];
  }
  setComputedStringAtIndex(e2, s6, i3) {
    const n5 = e2 & n2;
    this._ensureString(s6, n5), this._strings[s6][n5] = i3;
  }
  getXMin(e2) {
    return this._bounds[4 * (e2 & n2)];
  }
  getYMin(e2) {
    return this._bounds[4 * (e2 & n2) + 1];
  }
  getXMax(e2) {
    return this._bounds[4 * (e2 & n2) + 2];
  }
  getYMax(e2) {
    return this._bounds[4 * (e2 & n2) + 3];
  }
  setBounds(e2, s6) {
    const i3 = s6.readHydratedGeometry();
    if (!i3 || !i3.coords.length)
      return false;
    let r4 = 1 / 0, u2 = 1 / 0, o = -1 / 0, h2 = -1 / 0;
    i3.forEachVertex((t3, e3) => {
      r4 = Math.min(r4, t3), u2 = Math.min(u2, e3), o = Math.max(o, t3), h2 = Math.max(h2, e3);
    });
    const d3 = e2 & n2;
    return n4(this._bounds, 4 * d3 + 4, 0), this._bounds[4 * d3] = r4, this._bounds[4 * d3 + 1] = u2, this._bounds[4 * d3 + 2] = o, this._bounds[4 * d3 + 3] = h2, true;
  }
};

export {
  h,
  B,
  r3 as r
};
//# sourceMappingURL=chunk-FNTT27FW.js.map
