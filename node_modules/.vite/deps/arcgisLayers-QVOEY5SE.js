import {
  a
} from "./chunk-X3B7R5MJ.js";
import {
  r,
  t
} from "./chunk-2SVUAH2L.js";
import {
  d,
  p
} from "./chunk-G5WJIWPP.js";
import "./chunk-OO4A3EBQ.js";
import {
  c
} from "./chunk-7E3Q7HTF.js";
import "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  Ct,
  L
} from "./chunk-O3CHVGVF.js";
import "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s3 as s
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/support/arcgisLayers.js
var c2 = { FeatureLayer: true, SceneLayer: true };
async function i(e) {
  var _a;
  const r2 = (_a = e.properties) == null ? void 0 : _a.customParameters, a2 = await p2(e.url, r2), t2 = { ...e.properties, url: e.url };
  if (!a2.sublayerIds)
    return null != a2.layerOrTableId && (t2.layerId = a2.layerOrTableId, t2.sourceJSON = a2.sourceJSON), new a2.Constructor(t2);
  const s2 = new (0, (await import("./GroupLayer-GOUK65IP.js")).default)({ title: a2.parsedUrl.title });
  return m(s2, a2, t2), s2;
}
function y(e, r2) {
  return e ? e.find((e2) => e2.id === r2) : null;
}
function m(e, r2, a2) {
  function t2(e2, t3) {
    const s2 = { ...a2, layerId: e2, sublayerTitleMode: "service-name" };
    return null != t3 && (s2.sourceJSON = t3), new r2.Constructor(s2);
  }
  r2.sublayerIds.forEach((a3) => {
    const s2 = t2(a3, y(r2.sublayerInfos, a3));
    e.add(s2);
  }), r2.tableIds.forEach((a3) => {
    const s2 = t2(a3, y(r2.tableInfos, a3));
    e.tables.add(s2);
  });
}
async function p2(r2, a2) {
  var _a, _b, _c, _d;
  let s2 = p(r2);
  if (null == s2 && (s2 = await d2(r2, a2)), null == s2)
    throw new s("arcgis-layers:url-mismatch", "The url '${url}' is not a valid arcgis resource", { url: r2 });
  const { serverType: l, sublayer: o } = s2;
  let i2;
  const y2 = { FeatureServer: "FeatureLayer", StreamServer: "StreamLayer", VectorTileServer: "VectorTileLayer" };
  switch (l) {
    case "MapServer":
      if (null != o)
        i2 = "FeatureLayer";
      else {
        i2 = await S(r2, a2) ? "TileLayer" : "MapImageLayer";
      }
      break;
    case "ImageServer": {
      const e = await t(r2, { customParameters: a2 }), { tileInfo: t2, cacheType: s3 } = e;
      i2 = t2 ? "LERC" !== ((_a = t2 == null ? void 0 : t2.format) == null ? void 0 : _a.toUpperCase()) || s3 && "elevation" !== s3.toLowerCase() ? "ImageryTileLayer" : "ElevationLayer" : "ImageryLayer";
      break;
    }
    case "SceneServer": {
      const e = await t(s2.url.path, { customParameters: a2 });
      if (i2 = "SceneLayer", e) {
        const r3 = e == null ? void 0 : e.layers;
        if ("Voxel" === (e == null ? void 0 : e.layerType))
          i2 = "VoxelLayer";
        else if (r3 == null ? void 0 : r3.length) {
          const e2 = (_b = r3[0]) == null ? void 0 : _b.layerType;
          null != e2 && null != c[e2] && (i2 = c[e2]);
        }
      }
      break;
    }
    default:
      i2 = y2[l];
  }
  const m2 = "FeatureServer" === l, p3 = { parsedUrl: s2, Constructor: null, layerOrTableId: m2 ? o : void 0, sublayerIds: null, tableIds: null };
  if (c2[i2] && null == o) {
    const e = await I(r2, l, a2);
    m2 && (p3.sublayerInfos = e.layerInfos, p3.tableInfos = e.tableInfos);
    1 !== e.layerIds.length + e.tableIds.length ? (p3.sublayerIds = e.layerIds, p3.tableIds = e.tableIds) : m2 && (p3.layerOrTableId = e.layerIds[0] ?? e.tableIds[0], p3.sourceJSON = ((_c = e.layerInfos) == null ? void 0 : _c[0]) ?? ((_d = e.tableInfos) == null ? void 0 : _d[0]));
  }
  return p3.Constructor = await b(i2), p3;
}
async function d2(e, t2) {
  var _a;
  const l = await t(e, { customParameters: t2 });
  let n = null, o = null;
  const c3 = l.type;
  if ("Feature Layer" === c3 || "Table" === c3 ? (n = "FeatureServer", o = l.id ?? null) : "indexedVector" === c3 ? n = "VectorTileServer" : l.hasOwnProperty("mapName") ? n = "MapServer" : l.hasOwnProperty("bandCount") && l.hasOwnProperty("pixelSizeX") ? n = "ImageServer" : l.hasOwnProperty("maxRecordCount") && l.hasOwnProperty("allowGeometryUpdates") ? n = "FeatureServer" : l.hasOwnProperty("streamUrls") ? n = "StreamServer" : f(l) ? (n = "SceneServer", o = l.id) : l.hasOwnProperty("layers") && f((_a = l.layers) == null ? void 0 : _a[0]) && (n = "SceneServer"), !n)
    return null;
  const i2 = null != o ? d(e) : null;
  return { title: null != i2 && l.name || Ct(e), serverType: n, sublayer: o, url: { path: null != i2 ? i2.serviceUrl : L(e).path } };
}
function f(e) {
  return null != e && e.hasOwnProperty("store") && e.hasOwnProperty("id") && "number" == typeof e.id;
}
async function I(e, r2, a2) {
  let t2, s2 = false;
  if ("FeatureServer" === r2) {
    const r3 = await r(e, { customParameters: a2 });
    s2 = !!r3.layersJSON, t2 = r3.layersJSON || r3.serviceJSON;
  } else
    t2 = await t(e, { customParameters: a2 });
  const n = t2 == null ? void 0 : t2.layers, o = t2 == null ? void 0 : t2.tables;
  return { layerIds: (n == null ? void 0 : n.map((e2) => e2.id).reverse()) || [], tableIds: (o == null ? void 0 : o.map((e2) => e2.id).reverse()) || [], layerInfos: s2 ? n : [], tableInfos: s2 ? o : [] };
}
async function b(e) {
  return (0, a[e])();
}
async function S(e, r2) {
  return (await t(e, { customParameters: r2 })).tileInfo;
}
export {
  i as fromUrl
};
//# sourceMappingURL=arcgisLayers-QVOEY5SE.js.map
