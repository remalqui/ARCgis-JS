import {
  o as o3,
  r as r4
} from "./chunk-Z2RTGLQI.js";
import {
  W,
  _ as _2
} from "./chunk-FE2XXDCR.js";
import {
  a as a2
} from "./chunk-NE5U5H4D.js";
import {
  s as s3,
  u as u2
} from "./chunk-EGAMWXMG.js";
import {
  e as e7,
  v
} from "./chunk-4CHHKHL6.js";
import {
  a as a3,
  a2 as a4,
  a3 as a5,
  e as e6,
  i as i5,
  o as o5,
  s as s4
} from "./chunk-Q6HUS3IU.js";
import {
  n as n5,
  o as o4
} from "./chunk-V66LHQVK.js";
import {
  n as n4
} from "./chunk-HLVYJZGQ.js";
import {
  N,
  i as i4
} from "./chunk-MT6BDG6P.js";
import {
  s as s2
} from "./chunk-VD2BLFWE.js";
import {
  O as O2
} from "./chunk-BN6X2OXK.js";
import {
  t as t2
} from "./chunk-FF5LS3YE.js";
import {
  C,
  E
} from "./chunk-BCDDCNQ2.js";
import {
  e as e4
} from "./chunk-EF6YPOUN.js";
import {
  e as e5,
  o as o2
} from "./chunk-AYMF6OMA.js";
import {
  n as n2,
  r as r3
} from "./chunk-AHAGGZUI.js";
import {
  g
} from "./chunk-SS33L3LC.js";
import {
  A,
  G,
  i as i3
} from "./chunk-ZBWBCN2I.js";
import {
  i as i2
} from "./chunk-KTSEQWMB.js";
import {
  n as n3
} from "./chunk-4CZO65BK.js";
import {
  M,
  i,
  s
} from "./chunk-MOPR7RFH.js";
import {
  O2 as O,
  _2 as _,
  e2 as e3,
  f as f2,
  n,
  o,
  r,
  u2 as u,
  z
} from "./chunk-KW3ZNPTA.js";
import {
  r2
} from "./chunk-TJB4CGOM.js";
import {
  e as e2,
  m,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a,
  l
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  T
} from "./chunk-HNHXEGH2.js";
import {
  f,
  t
} from "./chunk-DWOEYHKS.js";
import {
  h
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js
var h2;
!function(h8) {
  h8[h8.Color = 0] = "Color", h8[h8.Depth = 1] = "Depth", h8[h8.Normal = 2] = "Normal", h8[h8.Shadow = 3] = "Shadow", h8[h8.ShadowHighlight = 4] = "ShadowHighlight", h8[h8.ShadowExcludeHighlight = 5] = "ShadowExcludeHighlight", h8[h8.Highlight = 6] = "Highlight", h8[h8.Alpha = 7] = "Alpha", h8[h8.ObjectAndLayerIdColor = 8] = "ObjectAndLayerIdColor", h8[h8.COUNT = 9] = "COUNT";
}(h2 || (h2 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js
function t3(t16, s10) {
  switch (s10.normalType) {
    case a6.Compressed:
      t16.attributes.add(O2.NORMALCOMPRESSED, "vec2"), t16.vertex.code.add(o4`vec3 normalModel() {
float z = 1.0 - abs(normalCompressed.x) - abs(normalCompressed.y);
return vec3(normalCompressed + sign(normalCompressed) * min(z, 0.0), z);
}`);
      break;
    case a6.Attribute:
      t16.attributes.add(O2.NORMAL, "vec3"), t16.vertex.code.add(o4`vec3 normalModel() {
return normal;
}`);
      break;
    case a6.ScreenDerivative:
      t16.fragment.code.add(o4`vec3 screenDerivativeNormal(vec3 positionView) {
return normalize(cross(dFdx(positionView), dFdy(positionView)));
}`);
      break;
    default:
      n3(s10.normalType);
    case a6.COUNT:
    case a6.Ground:
  }
}
var a6;
!function(e27) {
  e27[e27.Attribute = 0] = "Attribute", e27[e27.Compressed = 1] = "Compressed", e27[e27.Ground = 2] = "Ground", e27[e27.ScreenDerivative = 3] = "ScreenDerivative", e27[e27.COUNT = 4] = "COUNT";
}(a6 || (a6 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js
var d;
function o6(o22, v8) {
  switch (v8.textureCoordinateType) {
    case d.Default:
      return o22.attributes.add(O2.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), void o22.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
}`);
    case d.Compressed:
      return o22.attributes.add(O2.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), void o22.vertex.code.add(o4`vec2 getUV0() {
return uv0 / 16384.0;
}
void forwardTextureCoordinates() {
vuv0 = getUV0();
}`);
    case d.Atlas:
      return o22.attributes.add(O2.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), o22.attributes.add(O2.UVREGION, "vec4"), o22.varyings.add("vuvRegion", "vec4"), void o22.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
vuvRegion = uvRegion;
}`);
    default:
      n3(v8.textureCoordinateType);
    case d.None:
      return void o22.vertex.code.add(o4`void forwardTextureCoordinates() {}`);
    case d.COUNT:
      return;
  }
}
!function(e27) {
  e27[e27.None = 0] = "None", e27[e27.Default = 1] = "Default", e27[e27.Atlas = 2] = "Atlas", e27[e27.Compressed = 3] = "Compressed", e27[e27.COUNT = 4] = "COUNT";
}(d || (d = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js
var e8 = class extends i5 {
  constructor(r17, e27) {
    super(r17, "vec3", a3.Pass, (s10, o22, t16) => s10.setUniform3fv(r17, e27(o22, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function e9(e27) {
  e27.fragment.code.add(o4`vec4 textureAtlasLookup(sampler2D tex, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
return textureGrad(tex, uvAtlas, dUVdx, dUVdy);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function s5(s10, a11) {
  switch (s10.include(o6, a11), a11.textureCoordinateType) {
    case d.Default:
    case d.Compressed:
      return void s10.fragment.code.add(o4`vec4 textureLookup(sampler2D tex, vec2 uv) {
return texture(tex, uv);
}`);
    case d.Atlas:
      return s10.include(e9), void s10.fragment.code.add(o4`vec4 textureLookup(sampler2D tex, vec2 uv) {
return textureAtlasLookup(tex, uv, vuvRegion);
}`);
    default:
      n3(a11.textureCoordinateType);
    case d.None:
    case d.COUNT:
      return;
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float3DrawUniform.js
var o7 = class extends i5 {
  constructor(r17, o22) {
    super(r17, "vec3", a3.Draw, (e27, s10, t16, i15) => e27.setUniform3fv(r17, o22(s10, t16, i15)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterial.js
var t4 = class {
  constructor(e27) {
    this._material = e27.material, this._techniqueRepository = e27.techniqueRep, this._output = e27.output;
  }
  dispose() {
    this._techniqueRepository.release(this._technique);
  }
  get technique() {
    return this._technique;
  }
  get _stippleTextureRepository() {
    return this._techniqueRepository.constructionContext.stippleTextureRepository;
  }
  get _markerTextureRepository() {
    return this._techniqueRepository.constructionContext.markerTextureRepository;
  }
  ensureTechnique(e27, t16) {
    return this._technique = this._techniqueRepository.releaseAndAcquire(e27, this._material.getConfiguration(this._output, t16), this._technique), this._technique;
  }
  ensureResources(t16) {
    return N.LOADED;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLTextureMaterial.js
var r5 = class extends t4 {
  constructor(t16) {
    super(t16), this._numLoading = 0, this._disposed = false, this._textureRepository = t16.textureRep, this._textureId = t16.textureId, this._acquire(t16.textureId, (t17) => this._texture = t17), this._acquire(t16.normalTextureId, (t17) => this._textureNormal = t17), this._acquire(t16.emissiveTextureId, (t17) => this._textureEmissive = t17), this._acquire(t16.occlusionTextureId, (t17) => this._textureOcclusion = t17), this._acquire(t16.metallicRoughnessTextureId, (t17) => this._textureMetallicRoughness = t17);
  }
  dispose() {
    this._texture = f(this._texture), this._textureNormal = f(this._textureNormal), this._textureEmissive = f(this._textureEmissive), this._textureOcclusion = f(this._textureOcclusion), this._textureMetallicRoughness = f(this._textureMetallicRoughness), this._disposed = true;
  }
  ensureResources(t16) {
    return 0 === this._numLoading ? N.LOADED : N.LOADING;
  }
  get textureBindParameters() {
    return new l2(null != this._texture ? this._texture.glTexture : null, null != this._textureNormal ? this._textureNormal.glTexture : null, null != this._textureEmissive ? this._textureEmissive.glTexture : null, null != this._textureOcclusion ? this._textureOcclusion.glTexture : null, null != this._textureMetallicRoughness ? this._textureMetallicRoughness.glTexture : null);
  }
  updateTexture(e27) {
    null != this._texture && e27 === this._texture.id || (this._texture = f(this._texture), this._textureId = e27, this._acquire(this._textureId, (t16) => this._texture = t16));
  }
  _acquire(s10, i15) {
    if (null == s10)
      return void i15(null);
    const u7 = this._textureRepository.acquire(s10);
    if (T(u7))
      return ++this._numLoading, void u7.then((e27) => {
        if (this._disposed)
          return f(e27), void i15(null);
        i15(e27);
      }).finally(() => --this._numLoading);
    i15(u7);
  }
};
var l2 = class extends n5 {
  constructor(t16 = null, e27 = null, s10 = null, i15 = null, u7 = null) {
    super(), this.texture = t16, this.textureNormal = e27, this.textureEmissive = s10, this.textureOcclusion = i15, this.textureMetallicRoughness = u7;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var c;
!function(e27) {
  e27[e27.Disabled = 0] = "Disabled", e27[e27.Normal = 1] = "Normal", e27[e27.Schematic = 2] = "Schematic", e27[e27.Water = 3] = "Water", e27[e27.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e27[e27.Terrain = 5] = "Terrain", e27[e27.TerrainWithWater = 6] = "TerrainWithWater", e27[e27.COUNT = 7] = "COUNT";
}(c || (c = {}));
function l3(n18, u7) {
  const l13 = n18.fragment, m8 = u7.hasMetallicRoughnessTexture || u7.hasEmissionTexture || u7.hasOcclusionTexture;
  if (u7.pbrMode === c.Normal && m8 && n18.include(s5, u7), u7.pbrMode !== c.Schematic)
    if (u7.pbrMode !== c.Disabled) {
      if (u7.pbrMode === c.Normal) {
        l13.code.add(o4`vec3 mrr;
vec3 emission;
float occlusion;`);
        const e27 = u7.pbrTextureBindType;
        u7.hasMetallicRoughnessTexture && (l13.uniforms.add(e27 === a3.Pass ? new s4("texMetallicRoughness", (e28) => e28.textureMetallicRoughness) : new s3("texMetallicRoughness", (e28) => e28.textureMetallicRoughness)), l13.code.add(o4`void applyMetallnessAndRoughness(vec2 uv) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), u7.hasEmissionTexture && (l13.uniforms.add(e27 === a3.Pass ? new s4("texEmission", (e28) => e28.textureEmissive) : new s3("texEmission", (e28) => e28.textureEmissive)), l13.code.add(o4`void applyEmission(vec2 uv) {
emission *= textureLookup(texEmission, uv).rgb;
}`)), u7.hasOcclusionTexture ? (l13.uniforms.add(e27 === a3.Pass ? new s4("texOcclusion", (e28) => e28.textureOcclusion) : new s3("texOcclusion", (e28) => e28.textureOcclusion)), l13.code.add(o4`void applyOcclusion(vec2 uv) {
occlusion *= textureLookup(texOcclusion, uv).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : l13.code.add(o4`float getBakedOcclusion() { return 1.0; }`), e27 === a3.Pass ? l13.uniforms.add(new e8("emissionFactor", (e28) => e28.emissiveFactor), new e8("mrrFactors", (e28) => e28.mrrFactors)) : l13.uniforms.add(new o7("emissionFactor", (e28) => e28.emissiveFactor), new o7("mrrFactors", (e28) => e28.mrrFactors)), l13.code.add(o4`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;

      ${u7.hasMetallicRoughnessTexture ? o4`applyMetallnessAndRoughness(${u7.hasMetallicRoughnessTextureTransform ? o4`metallicRoughnessUV` : "vuv0"});` : ""}

      ${u7.hasEmissionTexture ? o4`applyEmission(${u7.hasEmissiveTextureTransform ? o4`emissiveUV` : "vuv0"});` : ""}

      ${u7.hasOcclusionTexture ? o4`applyOcclusion(${u7.hasOcclusionTextureTransform ? o4`occlusionUV` : "vuv0"});` : ""}
    }
  `);
      }
    } else
      l13.code.add(o4`float getBakedOcclusion() { return 1.0; }`);
  else
    l13.code.add(o4`vec3 mrr = vec3(0.0, 0.6, 0.2);
vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o8(o22) {
  o22.attributes.add(O2.POSITION, "vec3"), o22.vertex.code.add(o4`vec3 positionModel() { return position; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3PassUniform.js
var e10 = class extends i5 {
  constructor(r17, e27) {
    super(r17, "mat3", a3.Pass, (s10, o22, t16) => s10.setUniformMatrix3fv(r17, e27(o22, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4PassUniform.js
var e11 = class extends i5 {
  constructor(r17, e27) {
    super(r17, "mat4", a3.Pass, (s10, o22, t16) => s10.setUniformMatrix4fv(r17, e27(o22, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DoublePrecision.glsl.js
function c2({ code: c10 }, i15) {
  i15.doublePrecisionRequiresObfuscation ? c10.add(o4`vec3 dpPlusFrc(vec3 a, vec3 b) {
return mix(a, a + b, vec3(notEqual(b, vec3(0))));
}
vec3 dpMinusFrc(vec3 a, vec3 b) {
return mix(vec3(0), a - b, vec3(notEqual(a, b)));
}
vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = dpPlusFrc(hiA, hiB);
vec3 e = dpMinusFrc(t1, hiA);
vec3 t2 = dpMinusFrc(hiB, e) + dpMinusFrc(hiA, dpMinusFrc(t1, e)) + loA + loB;
return t1 + t2;
}`) : c10.add(o4`vec3 dpAdd(vec3 hiA, vec3 loA, vec3 hiB, vec3 loB) {
vec3 t1 = hiA + hiB;
vec3 e = t1 - hiA;
vec3 t2 = ((hiB - e) + (hiA - (t1 - e))) + loA + loB;
return t1 + t2;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix3DrawUniform.js
var o9 = class extends i5 {
  constructor(r17, o22) {
    super(r17, "mat3", a3.Draw, (e27, s10, t16) => e27.setUniformMatrix3fv(r17, o22(s10, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function v2(r17, o22) {
  r17.include(o8);
  const e27 = r17.vertex;
  e27.include(c2, o22), r17.varyings.add("vPositionWorldCameraRelative", "vec3"), r17.varyings.add("vPosition_view", "vec3"), e27.uniforms.add(new e8("transformWorldFromViewTH", (r18) => r18.transformWorldFromViewTH), new e8("transformWorldFromViewTL", (r18) => r18.transformWorldFromViewTL), new e10("transformViewFromCameraRelativeRS", (r18) => r18.transformViewFromCameraRelativeRS), new e11("transformProjFromView", (r18) => r18.transformProjFromView), new o9("transformWorldFromModelRS", (r18) => r18.transformWorldFromModelRS), new o7("transformWorldFromModelTH", (r18) => r18.transformWorldFromModelTH), new o7("transformWorldFromModelTL", (r18) => r18.transformWorldFromModelTL)), e27.code.add(o4`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e27.code.add(o4`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o22.spherical ? o4`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : o4`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r17.fragment.uniforms.add(new e8("transformWorldFromViewTL", (r18) => r18.transformWorldFromViewTL)), e27.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r17.fragment.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var F = class extends n5 {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n(), this.transformWorldFromViewTL = n(), this.transformViewFromCameraRelativeRS = e4(), this.transformProjFromView = e5();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js
function c3(o22, a11) {
  switch (a11.normalType) {
    case a6.Attribute:
    case a6.Compressed:
      o22.include(t3, a11), o22.varyings.add("vNormalWorld", "vec3"), o22.varyings.add("vNormalView", "vec3"), o22.vertex.uniforms.add(new o9("transformNormalGlobalFromModel", (r17) => r17.transformNormalGlobalFromModel), new e10("transformNormalViewFromGlobal", (r17) => r17.transformNormalViewFromGlobal)), o22.vertex.code.add(o4`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);
      break;
    case a6.Ground:
      o22.include(v2, a11), o22.varyings.add("vNormalWorld", "vec3"), o22.vertex.code.add(o4`
        void forwardNormal() {
          vNormalWorld = ${a11.spherical ? o4`normalize(vPositionWorldCameraRelative);` : o4`vec3(0.0, 0.0, 1.0);`}
        }
        `);
      break;
    case a6.ScreenDerivative:
      o22.vertex.code.add(o4`void forwardNormal() {}`);
      break;
    default:
      n3(a11.normalType);
    case a6.COUNT:
  }
}
var f3 = class extends F {
  constructor() {
    super(...arguments), this.transformNormalViewFromGlobal = e4();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js
var o10 = 0.1;
var t5 = 1e-3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js
function t6(e27) {
  e27.varyings.add("linearDepth", "float");
}
function i6(e27) {
  e27.vertex.uniforms.add(new e6("nearFar", (e28, r17) => r17.camera.nearFar));
}
function n6(e27) {
  e27.vertex.code.add(o4`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`);
}
function d2(a11, d8) {
  const { vertex: s10 } = a11;
  switch (d8.output) {
    case h2.Color:
      if (d8.receiveShadows)
        return t6(a11), void s10.code.add(o4`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);
      break;
    case h2.Depth:
    case h2.Shadow:
    case h2.ShadowHighlight:
    case h2.ShadowExcludeHighlight:
      return a11.include(v2, d8), t6(a11), i6(a11), n6(a11), void s10.code.add(o4`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`);
  }
  s10.code.add(o4`void forwardLinearDepth() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e12(e27) {
  e27.vertex.code.add(o4`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js
function P(e27, s10) {
  h3(e27, s10, new o7("slicePlaneOrigin", (e28, i15) => g2(s10, e28, i15)), new o7("slicePlaneBasis1", (e28, i15) => {
    var _a;
    return I(s10, e28, i15, (_a = i15.slicePlane) == null ? void 0 : _a.basis1);
  }), new o7("slicePlaneBasis2", (e28, i15) => {
    var _a;
    return I(s10, e28, i15, (_a = i15.slicePlane) == null ? void 0 : _a.basis2);
  }));
}
function h3(e27, s10, ...i15) {
  if (!s10.hasSlicePlane) {
    const i16 = o4`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;
    return s10.hasSliceInVertexProgram && e27.vertex.code.add(i16), void e27.fragment.code.add(i16);
  }
  s10.hasSliceInVertexProgram && e27.vertex.uniforms.add(...i15), e27.fragment.uniforms.add(...i15);
  const a11 = o4`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`, l13 = o4`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
if (sliceByFactors(factors)) {
return color;
}
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`, c10 = s10.hasSliceHighlight ? o4`
        ${l13}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      ` : o4`#define highlightSlice(_color_, _pos_) (_color_)`;
  s10.hasSliceInVertexProgram && e27.vertex.code.add(a11), e27.fragment.code.add(a11), e27.fragment.code.add(c10);
}
function p(e27, s10, i15) {
  return e27.instancedDoublePrecision ? o(b, i15.camera.viewInverseTransposeMatrix[3], i15.camera.viewInverseTransposeMatrix[7], i15.camera.viewInverseTransposeMatrix[11]) : s10.slicePlaneLocalOrigin;
}
function m2(e27, s10) {
  return null != e27 ? e3(v3, s10.origin, e27) : s10.origin;
}
function H(s10, i15, a11) {
  return s10.hasSliceTranslatedView ? null != i15 ? i2(S, a11.camera.viewMatrix, i15) : a11.camera.viewMatrix : null;
}
function g2(e27, s10, a11) {
  if (null == a11.slicePlane)
    return f2;
  const l13 = p(e27, s10, a11), c10 = m2(l13, a11.slicePlane), r17 = H(e27, l13, a11);
  return null != r17 ? O(v3, c10, r17) : c10;
}
function I(e27, s10, c10, r17) {
  if (null == r17 || null == c10.slicePlane)
    return f2;
  const t16 = p(e27, s10, c10), n18 = m2(t16, c10.slicePlane), f9 = H(e27, t16, c10);
  return null != f9 ? (u(B, r17, n18), O(v3, n18, f9), O(B, B, f9), e3(B, B, v3)) : r17;
}
var b = n();
var v3 = n();
var B = n();
var S = e5();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js
function o11(o22) {
  n6(o22), o22.vertex.code.add(o4`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`), o22.vertex.code.add(o4`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`);
}

// node_modules/@arcgis/core/views/3d/terrain/interfaces.js
var O3;
var o12;
var E2;
var A2;
var r6;
!function(O6) {
  O6[O6.INNER = 0] = "INNER", O6[O6.OUTER = 1] = "OUTER";
}(O3 || (O3 = {})), function(O6) {
  O6[O6.REGULAR = 0] = "REGULAR", O6[O6.HAS_NORTH_POLE = 1] = "HAS_NORTH_POLE", O6[O6.HAS_SOUTH_POLE = 2] = "HAS_SOUTH_POLE", O6[O6.HAS_BOTH_POLES = 3] = "HAS_BOTH_POLES";
}(o12 || (o12 = {})), function(O6) {
  O6[O6.OFF = 0] = "OFF", O6[O6.ON = 1] = "ON";
}(E2 || (E2 = {})), function(O6) {
  O6[O6.Color = 0] = "Color", O6[O6.ColorNoRasterImage = 1] = "ColorNoRasterImage", O6[O6.Highlight = 2] = "Highlight", O6[O6.Water = 3] = "Water", O6[O6.Occluded = 4] = "Occluded", O6[O6.ObjectAndLayerIdColor = 5] = "ObjectAndLayerIdColor";
}(A2 || (A2 = {})), function(O6) {
  O6[O6.FADING = 0] = "FADING", O6[O6.IMMEDIATE = 1] = "IMMEDIATE", O6[O6.UNFADED = 2] = "UNFADED";
}(r6 || (r6 = {}));

// node_modules/@arcgis/core/views/3d/terrain/Overlay.js
var n7;
!function(e27) {
  e27[e27.None = 0] = "None", e27[e27.ColorAndWater = 1] = "ColorAndWater", e27[e27.Highlight = 2] = "Highlight", e27[e27.Occluded = 3] = "Occluded", e27[e27.ObjectAndLayerIdColor = 4] = "ObjectAndLayerIdColor";
}(n7 || (n7 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js
var o13 = class extends i5 {
  constructor(r17, o22) {
    super(r17, "mat4", a3.Draw, (e27, s10, t16) => e27.setUniformMatrix4fv(r17, o22(s10, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js
function f4(r17, a11) {
  a11.instancedDoublePrecision ? r17.constants.add("cameraPosition", "vec3", f2) : r17.uniforms.add(new o7("cameraPosition", (r18, a12) => o(w, a12.camera.viewInverseTransposeMatrix[3] - r18.origin[0], a12.camera.viewInverseTransposeMatrix[7] - r18.origin[1], a12.camera.viewInverseTransposeMatrix[11] - r18.origin[2])));
}
function p2(a11, i15) {
  if (!i15.instancedDoublePrecision)
    return void a11.uniforms.add(new e11("proj", (r17, a12) => a12.camera.projectionMatrix), new o13("view", (a12, e27) => i2(v5, e27.camera.viewMatrix, a12.origin)), new o7("localOrigin", (r17) => r17.origin));
  const o22 = (r17) => o(w, r17.camera.viewInverseTransposeMatrix[3], r17.camera.viewInverseTransposeMatrix[7], r17.camera.viewInverseTransposeMatrix[11]);
  a11.uniforms.add(new e11("proj", (r17, a12) => a12.camera.projectionMatrix), new e11("view", (a12, e27) => i2(v5, e27.camera.viewMatrix, o22(e27))), new e8("localOrigin", (r17, a12) => o22(a12)));
}
var v5 = e5();
var w = n();
function u3(r17) {
  r17.uniforms.add(new e11("viewNormal", (r18, a11) => a11.camera.viewInverseTransposeMatrix));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js
var t7 = class extends n5 {
  constructor() {
    super(), this._key = "", this._keyDirty = false, this._parameterBits = this._parameterBits ? this._parameterBits.map(() => 0) : [], this._parameterNames || (this._parameterNames = []);
  }
  get key() {
    return this._keyDirty && (this._keyDirty = false, this._key = String.fromCharCode.apply(String, this._parameterBits)), this._key;
  }
  snapshot() {
    const e27 = this._parameterNames, t16 = { key: this.key };
    for (const r17 of e27)
      t16[r17] = this[r17];
    return t16;
  }
};
function r7(e27 = {}) {
  return (t16, r17) => {
    if (t16._parameterNames = t16._parameterNames ?? [], t16._parameterNames.push(r17), null != e27.constValue)
      Object.defineProperty(t16, r17, { get: () => e27.constValue });
    else {
      const s10 = t16._parameterNames.length - 1, a11 = e27.count || 2, i15 = Math.ceil(Math.log2(a11)), o22 = t16._parameterBits ?? [0];
      let h8 = 0;
      for (; o22[h8] + i15 > 16; )
        h8++, h8 >= o22.length && o22.push(0);
      t16._parameterBits = o22;
      const n18 = o22[h8], m8 = (1 << i15) - 1 << n18;
      o22[h8] += i15, Object.defineProperty(t16, r17, { get() {
        return this[s10];
      }, set(e28) {
        if (this[s10] !== e28 && (this[s10] = e28, this._keyDirty = true, this._parameterBits[h8] = this._parameterBits[h8] & ~m8 | +e28 << n18 & m8, "number" != typeof e28 && "boolean" != typeof e28))
          throw new Error("Configuration value for " + r17 + " must be boolean or number, got " + typeof e28);
      } });
    }
  };
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var v6 = class extends t7 {
  constructor() {
    super(...arguments), this.instancedDoublePrecision = false;
  }
};
function p3(e27, i15) {
  i15.instanced && i15.instancedDoublePrecision && (e27.attributes.add(O2.MODELORIGINHI, "vec3"), e27.attributes.add(O2.MODELORIGINLO, "vec3"), e27.attributes.add(O2.MODEL, "mat3"), e27.attributes.add(O2.MODELNORMAL, "mat3"));
  const c10 = e27.vertex;
  i15.instancedDoublePrecision && (c10.include(c2, i15), c10.uniforms.add(new o7("viewOriginHi", (e28, i16) => o3(o(b2, i16.camera.viewInverseTransposeMatrix[3], i16.camera.viewInverseTransposeMatrix[7], i16.camera.viewInverseTransposeMatrix[11]), b2)), new o7("viewOriginLo", (e28, i16) => r4(o(b2, i16.camera.viewInverseTransposeMatrix[3], i16.camera.viewInverseTransposeMatrix[7], i16.camera.viewInverseTransposeMatrix[11]), b2)))), c10.code.add(o4`
    vec3 calculateVPos() {
      ${i15.instancedDoublePrecision ? "return model * localPosition().xyz;" : "return localPosition().xyz;"}
    }
    `), c10.code.add(o4`
    vec3 subtractOrigin(vec3 _pos) {
      ${i15.instancedDoublePrecision ? o4`
          vec3 originDelta = dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), c10.code.add(o4`
    vec3 dpNormal(vec4 _normal) {
      ${i15.instancedDoublePrecision ? "return normalize(modelNormal * _normal.xyz);" : "return normalize(_normal.xyz);"}
    }
    `), i15.output === h2.Normal && (u3(c10), c10.code.add(o4`
    vec3 dpNormalView(vec4 _normal) {
      ${i15.instancedDoublePrecision ? "return normalize((viewNormal * vec4(modelNormal * _normal.xyz, 1.0)).xyz);" : "return normalize((viewNormal * _normal).xyz);"}
    }
    `)), i15.hasVertexTangents && c10.code.add(o4`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i15.instancedDoublePrecision ? "return vec4(modelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}

    }
    `);
}
e([r7()], v6.prototype, "instancedDoublePrecision", void 0);
var b2 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/collections/Component/Material/shader/DecodeSymbolColor.glsl.js
function e14(e27) {
  e27.vertex.code.add(o4`
    vec4 decodeSymbolColor(vec4 symbolColor, out int colorMixMode) {
      float symbolAlpha = 0.0;

      const float maxTint = 85.0;
      const float maxReplace = 170.0;
      const float scaleAlpha = 3.0;

      if (symbolColor.a > maxReplace) {
        colorMixMode = ${o4.int(n4.Multiply)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxReplace);
      } else if (symbolColor.a > maxTint) {
        colorMixMode = ${o4.int(n4.Replace)};
        symbolAlpha = scaleAlpha * (symbolColor.a - maxTint);
      } else if (symbolColor.a > 0.0) {
        colorMixMode = ${o4.int(n4.Tint)};
        symbolAlpha = scaleAlpha * symbolColor.a;
      } else {
        colorMixMode = ${o4.int(n4.Multiply)};
        symbolAlpha = 0.0;
      }

      return vec4(symbolColor.r, symbolColor.g, symbolColor.b, symbolAlpha);
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js
var e15 = class extends i5 {
  constructor(r17, e27) {
    super(r17, "int", a3.Pass, (s10, o22, i15) => s10.setUniform1i(r17, e27(o22, i15)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObjectType.js
var e16;
!function(e27) {
  e27[e27.Layer = 0] = "Layer", e27[e27.Object = 1] = "Object", e27[e27.Mesh = 2] = "Mesh", e27[e27.Line = 3] = "Line", e27[e27.Point = 4] = "Point", e27[e27.Material = 5] = "Material", e27[e27.Texture = 6] = "Texture", e27[e27.COUNT = 7] = "COUNT";
}(e16 || (e16 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/screenSizePerspectiveUtils.js
function l5(e27) {
  return Math.abs(e27 * e27 * e27);
}
function s6(e27, t16, a11) {
  const i15 = a11.parameters, r17 = a11.paddingPixelsOverride;
  return x.scale = Math.min(i15.divisor / (t16 - i15.offset), 1), x.factor = l5(e27), x.minPixelSize = i15.minPixelSize, x.paddingPixels = r17, x;
}
function c5(e27, t16) {
  return 0 === e27 ? t16.minPixelSize : t16.minPixelSize * (1 + 2 * t16.paddingPixels / e27);
}
function o14(t16, a11) {
  return Math.max(s(t16 * a11.scale, t16, a11.factor), c5(t16, a11));
}
function m3(e27, t16, a11, i15) {
  return o14(e27, s6(t16, a11, i15));
}
var h5 = { curvatureDependent: { min: { curvature: M(10), tiltAngle: M(12), scaleFallOffFactor: 0.5 }, max: { curvature: M(70), tiltAngle: M(40), scaleFallOffFactor: 0.8 } }, scaleStart: 0.3, scaleFallOffRange: 0.65, minPixelSize: 0 };
var x = { scale: 0, factor: 0, minPixelSize: 0, paddingPixels: 0 };

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/MaterialUtil.js
var p4 = i3();
function h6(t16, n18, e27, o22, i15, r17) {
  if (t16.visible)
    if (t16.boundingInfo) {
      s2(t16.type === e16.Mesh);
      const s10 = n18.tolerance;
      x2(t16.boundingInfo, e27, o22, s10, i15, r17);
    } else {
      const n19 = t16.indices.get(O2.POSITION), s10 = t16.vertexAttributes.get(O2.POSITION);
      g3(e27, o22, 0, n19.length / 3, n19, s10, void 0, i15, r17);
    }
}
var b3 = n();
function x2(t16, n18, e27, o22, i15, r17) {
  if (null == t16)
    return;
  const s10 = T2(n18, e27, b3);
  if (A(p4, t16.bbMin), G(p4, t16.bbMax), null != i15 && i15.applyToAabb(p4), I2(p4, n18, s10, o22)) {
    const { primitiveIndices: s11, indices: c10, position: l13 } = t16, f9 = s11 ? s11.length : c10.length / 3;
    if (f9 > S2) {
      const s12 = t16.getChildren();
      if (void 0 !== s12) {
        for (const t17 of s12)
          x2(t17, n18, e27, o22, i15, r17);
        return;
      }
    }
    g3(n18, e27, 0, f9, c10, l13, s11, i15, r17);
  }
}
var d3 = n();
function g3(t16, n18, e27, o22, i15, r17, s10, c10, l13) {
  if (s10)
    return M2(t16, n18, e27, o22, i15, r17, s10, c10, l13);
  const { data: f9, stride: u7 } = r17, a11 = t16[0], m8 = t16[1], p6 = t16[2], h8 = n18[0] - a11, b5 = n18[1] - m8, x6 = n18[2] - p6;
  for (let g6 = e27, M4 = 3 * e27; g6 < o22; ++g6) {
    let t17 = u7 * i15[M4++], n19 = f9[t17++], e28 = f9[t17++], o23 = f9[t17];
    t17 = u7 * i15[M4++];
    let r18 = f9[t17++], s11 = f9[t17++], y4 = f9[t17];
    t17 = u7 * i15[M4++];
    let j3 = f9[t17++], T5 = f9[t17++], I4 = f9[t17];
    null != c10 && ([n19, e28, o23] = c10.applyToVertex(n19, e28, o23, g6), [r18, s11, y4] = c10.applyToVertex(r18, s11, y4, g6), [j3, T5, I4] = c10.applyToVertex(j3, T5, I4, g6));
    const O6 = r18 - n19, V2 = s11 - e28, L4 = y4 - o23, N3 = j3 - n19, A6 = T5 - e28, P4 = I4 - o23, S4 = b5 * P4 - A6 * x6, E4 = x6 * N3 - P4 * h8, U = h8 * A6 - N3 * b5, W3 = O6 * S4 + V2 * E4 + L4 * U;
    if (Math.abs(W3) <= Number.EPSILON)
      continue;
    const k = a11 - n19, B2 = m8 - e28, C2 = p6 - o23, z2 = k * S4 + B2 * E4 + C2 * U;
    if (W3 > 0) {
      if (z2 < 0 || z2 > W3)
        continue;
    } else if (z2 > 0 || z2 < W3)
      continue;
    const H2 = B2 * L4 - V2 * C2, R = C2 * O6 - L4 * k, Y2 = k * V2 - O6 * B2, q = h8 * H2 + b5 * R + x6 * Y2;
    if (W3 > 0) {
      if (q < 0 || z2 + q > W3)
        continue;
    } else if (q > 0 || z2 + q < W3)
      continue;
    const w3 = (N3 * H2 + A6 * R + P4 * Y2) / W3;
    if (w3 >= 0) {
      l13(w3, v7(O6, V2, L4, N3, A6, P4, d3), g6, false);
    }
  }
}
function M2(t16, n18, e27, o22, i15, r17, s10, c10, l13) {
  const { data: f9, stride: u7 } = r17, a11 = t16[0], m8 = t16[1], p6 = t16[2], h8 = n18[0] - a11, b5 = n18[1] - m8, x6 = n18[2] - p6;
  for (let g6 = e27; g6 < o22; ++g6) {
    const t17 = s10[g6];
    let n19 = 3 * t17, e28 = u7 * i15[n19++], o23 = f9[e28++], r18 = f9[e28++], M4 = f9[e28];
    e28 = u7 * i15[n19++];
    let y4 = f9[e28++], j3 = f9[e28++], T5 = f9[e28];
    e28 = u7 * i15[n19];
    let I4 = f9[e28++], O6 = f9[e28++], V2 = f9[e28];
    null != c10 && ([o23, r18, M4] = c10.applyToVertex(o23, r18, M4, g6), [y4, j3, T5] = c10.applyToVertex(y4, j3, T5, g6), [I4, O6, V2] = c10.applyToVertex(I4, O6, V2, g6));
    const L4 = y4 - o23, N3 = j3 - r18, A6 = T5 - M4, P4 = I4 - o23, S4 = O6 - r18, E4 = V2 - M4, U = b5 * E4 - S4 * x6, W3 = x6 * P4 - E4 * h8, k = h8 * S4 - P4 * b5, B2 = L4 * U + N3 * W3 + A6 * k;
    if (Math.abs(B2) <= Number.EPSILON)
      continue;
    const C2 = a11 - o23, z2 = m8 - r18, H2 = p6 - M4, R = C2 * U + z2 * W3 + H2 * k;
    if (B2 > 0) {
      if (R < 0 || R > B2)
        continue;
    } else if (R > 0 || R < B2)
      continue;
    const Y2 = z2 * A6 - N3 * H2, q = H2 * L4 - A6 * C2, w3 = C2 * N3 - L4 * z2, D3 = h8 * Y2 + b5 * q + x6 * w3;
    if (B2 > 0) {
      if (D3 < 0 || R + D3 > B2)
        continue;
    } else if (D3 > 0 || R + D3 < B2)
      continue;
    const F3 = (P4 * Y2 + S4 * q + E4 * w3) / B2;
    if (F3 >= 0) {
      l13(F3, v7(L4, N3, A6, P4, S4, E4, d3), t17, false);
    }
  }
}
var y2 = n();
var j = n();
function v7(t16, n18, r17, s10, c10, l13, f9) {
  return o(y2, t16, n18, r17), o(j, s10, c10, l13), _(f9, y2, j), z(f9, f9), f9;
}
function T2(t16, n18, o22) {
  return o(o22, 1 / (n18[0] - t16[0]), 1 / (n18[1] - t16[1]), 1 / (n18[2] - t16[2]));
}
function I2(t16, n18, e27, o22) {
  return O4(t16, n18, e27, o22, 1 / 0);
}
function O4(t16, n18, e27, o22, i15) {
  const r17 = (t16[0] - o22 - n18[0]) * e27[0], s10 = (t16[3] + o22 - n18[0]) * e27[0];
  let c10 = Math.min(r17, s10), l13 = Math.max(r17, s10);
  const f9 = (t16[1] - o22 - n18[1]) * e27[1], u7 = (t16[4] + o22 - n18[1]) * e27[1];
  if (l13 = Math.min(l13, Math.max(f9, u7)), l13 < 0)
    return false;
  if (c10 = Math.max(c10, Math.min(f9, u7)), c10 > l13)
    return false;
  const a11 = (t16[2] - o22 - n18[2]) * e27[2], m8 = (t16[5] + o22 - n18[2]) * e27[2];
  return l13 = Math.min(l13, Math.max(a11, m8)), !(l13 < 0) && (c10 = Math.max(c10, Math.min(a11, m8)), !(c10 > l13) && c10 < i15);
}
function V(t16, e27, o22, i15, r17) {
  let s10 = (o22.screenLength || 0) * t16.pixelRatio;
  null != r17 && (s10 = m3(s10, i15, e27, r17));
  const c10 = s10 * Math.tan(0.5 * t16.fovY) / (0.5 * t16.fullHeight);
  return i(c10 * e27, o22.minWorldLength || 0, null != o22.maxWorldLength ? o22.maxWorldLength : 1 / 0);
}
function L(t16, n18) {
  const e27 = n18 ? L(n18) : {};
  for (const o22 in t16) {
    let n19 = t16[o22];
    n19 && n19.forEach && (n19 = A3(n19)), null == n19 && o22 in e27 || (e27[o22] = n19);
  }
  return e27;
}
function N2(n18, e27) {
  let o22 = false;
  for (const i15 in e27) {
    const r17 = e27[i15];
    void 0 !== r17 && (Array.isArray(r17) ? null === n18[i15] ? (n18[i15] = r17.slice(), o22 = true) : h(n18[i15], r17) && (o22 = true) : n18[i15] !== r17 && (o22 = true, n18[i15] = r17));
  }
  return o22;
}
function A3(t16) {
  const n18 = [];
  return t16.forEach((t17) => n18.push(t17)), n18;
}
var P2 = { multiply: 1, ignore: 2, replace: 3, tint: 4 };
var S2 = 1e3;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i8(i15, t16) {
  t16.hasSymbolColors ? (i15.include(e14), i15.attributes.add(O2.SYMBOLCOLOR, "vec4"), i15.varyings.add("colorMixMode", "mediump float"), i15.vertex.code.add(o4`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i15.fragment.uniforms.add(new e15("colorMixMode", (o22) => P2[o22.colorMixMode])), i15.vertex.code.add(o4`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js
function e17(e27, d8) {
  d8.hasVertexColors ? (e27.attributes.add(O2.COLOR, "vec4"), e27.varyings.add("vColor", "vec4"), e27.vertex.code.add(o4`void forwardVertexColor() { vColor = color; }`), e27.vertex.code.add(o4`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)) : e27.vertex.code.add(o4`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js
function c6(e27) {
  e27.vertex.code.add(o4`float screenSizePerspectiveMinSize(float size, vec4 factor) {
float nonZeroSize = 1.0 - step(size, 0.0);
return (
factor.z * (
1.0 +
nonZeroSize *
2.0 * factor.w / (
size + (1.0 - nonZeroSize)
)
)
);
}`), e27.vertex.code.add(o4`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`), e27.vertex.code.add(o4`vec4 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec4 params) {
return vec4(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z,
params.w
);
}`), e27.vertex.code.add(o4`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec4 factor) {
return max(mix(size * factor.x, size, factor.y), screenSizePerspectiveMinSize(size, factor));
}`), e27.vertex.code.add(o4`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`), e27.vertex.code.add(o4`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec4 factor) {
return mix(size * clamp(factor.x, screenSizePerspectiveMinSize(size.y, factor) / max(1e-5, size.y), 1.0), size, factor.y);
}`), e27.vertex.code.add(o4`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec4 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`);
}
function i9(e27) {
  e27.uniforms.add(new e7("screenSizePerspectiveAlignment", (e28) => o15(e28.screenSizePerspectiveAlignment || e28.screenSizePerspective)));
}
function o15(a11) {
  return r2(n8, a11.parameters.divisor, a11.parameters.offset, a11.parameters.minPixelSize, a11.paddingPixelsOverride);
}
var n8 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js
function a7(e27, r17) {
  const c10 = e27.vertex;
  r17.hasVerticalOffset ? (f5(c10), r17.hasScreenSizePerspective && (e27.include(c6), i9(c10), f4(e27.vertex, r17)), c10.code.add(o4`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${r17.spherical ? o4`vec3 worldNormal = normalize(worldPos + localOrigin);` : o4`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${r17.hasScreenSizePerspective ? o4`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : o4`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)) : c10.code.add(o4`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);
}
var i10 = n2();
function f5(r17) {
  r17.uniforms.add(new e7("verticalOffset", (r18, t16) => {
    const { minWorldLength: l13, maxWorldLength: o22, screenLength: c10 } = r18.verticalOffset, s10 = Math.tan(0.5 * t16.camera.fovY) / (0.5 * t16.camera.fullViewport[3]), a11 = t16.camera.pixelRatio || 1;
    return r2(i10, c10 * a11, s10, l13, o22);
  }));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4sPassUniform.js
var e18 = class extends i5 {
  constructor(r17, e27, o22) {
    super(r17, "vec4", a3.Pass, (s10, o23, t16) => s10.setUniform4fv(r17, e27(o23, t16)), o22);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js
var o16 = class extends i5 {
  constructor(r17, o22, e27) {
    super(r17, "float", a3.Pass, (s10, e28, t16) => s10.setUniform1fv(r17, o22(e28, t16)), e27);
  }
};

// node_modules/@arcgis/core/views/3d/support/debugFlags.js
var T3 = class extends m {
  constructor() {
    super(...arguments), this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = false, this.DECONFLICTOR_SHOW_VISIBLE = false, this.DECONFLICTOR_SHOW_INVISIBLE = false, this.DECONFLICTOR_SHOW_GRID = false, this.LABELS_SHOW_BORDER = false, this.TEXT_SHOW_BASELINE = false, this.TEXT_SHOW_BORDER = false, this.OVERLAY_DRAW_DEBUG_TEXTURE = false, this.OVERLAY_SHOW_CENTER = false, this.SHOW_POI = false, this.TESTS_DISABLE_OPTIMIZATIONS = false, this.TESTS_DISABLE_FAST_UPDATES = false, this.DRAW_MESH_GEOMETRY_NORMALS = false, this.FEATURE_TILE_FETCH_SHOW_TILES = false, this.FEATURE_TILE_TREE_SHOW_TILES = false, this.TERRAIN_TILE_TREE_SHOW_TILES = false, this.I3S_TREE_SHOW_TILES = false, this.I3S_SHOW_MODIFICATIONS = false, this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = false, this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = false, this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = false, this.LINE_WIREFRAMES = false;
  }
};
e([y()], T3.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0), e([y()], T3.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0), e([y()], T3.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0), e([y()], T3.prototype, "DECONFLICTOR_SHOW_GRID", void 0), e([y()], T3.prototype, "LABELS_SHOW_BORDER", void 0), e([y()], T3.prototype, "TEXT_SHOW_BASELINE", void 0), e([y()], T3.prototype, "TEXT_SHOW_BORDER", void 0), e([y()], T3.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0), e([y()], T3.prototype, "OVERLAY_SHOW_CENTER", void 0), e([y()], T3.prototype, "SHOW_POI", void 0), e([y()], T3.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0), e([y()], T3.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0), e([y()], T3.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0), e([y()], T3.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0), e([y()], T3.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0), e([y()], T3.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0), e([y()], T3.prototype, "I3S_TREE_SHOW_TILES", void 0), e([y()], T3.prototype, "I3S_SHOW_MODIFICATIONS", void 0), e([y()], T3.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0), e([y()], T3.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0), e([y()], T3.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0), e([y()], T3.prototype, "LINE_WIREFRAMES", void 0), T3 = e([a("esri.views.3d.support.DebugFlags")], T3);
var t8 = new T3();

// node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var S3;
var y3;
!function(e27) {
  e27[e27.Undefined = 0] = "Undefined", e27[e27.DefinedSize = 1] = "DefinedSize", e27[e27.DefinedScale = 2] = "DefinedScale";
}(S3 || (S3 = {})), function(e27) {
  e27[e27.Undefined = 0] = "Undefined", e27[e27.DefinedAngle = 1] = "DefinedAngle";
}(y3 || (y3 = {}));
var Y = e5();
var Z = n();
var ee = e5();

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObject.js
var r9 = class {
  constructor() {
    this.id = e2();
  }
  unload() {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations.js
var E3 = /* @__PURE__ */ new Map([[O2.POSITION, 0], [O2.NORMAL, 1], [O2.NORMALCOMPRESSED, 1], [O2.UV0, 2], [O2.COLOR, 3], [O2.COLORFEATUREATTRIBUTE, 3], [O2.SIZE, 4], [O2.TANGENT, 4], [O2.AUXPOS1, 5], [O2.SYMBOLCOLOR, 5], [O2.AUXPOS2, 6], [O2.FEATUREATTRIBUTE, 6], [O2.INSTANCEFEATUREATTRIBUTE, 6], [O2.INSTANCECOLOR, 7], [O2.OBJECTANDLAYERIDCOLOR, 7], [O2.INSTANCEOBJECTANDLAYERIDCOLOR, 7], [O2.MODEL, 8], [O2.MODELNORMAL, 12], [O2.MODELORIGINHI, 11], [O2.MODELORIGINLO, 15]]);

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Material.js
var d4 = class extends r9 {
  constructor(t16, r17) {
    super(), this.type = e16.Material, this.supportsEdges = false, this._visible = true, this._renderPriority = 0, this._insertOrder = 0, this._vertexAttributeLocations = E3, this._pp0 = r(0, 0, 1), this._pp1 = r(0, 0, 0), this._parameters = L(t16, r17), this.validateParameters(this._parameters);
  }
  dispose() {
  }
  get parameters() {
    return this._parameters;
  }
  update(e27) {
    return false;
  }
  setParameters(e27, t16 = true) {
    N2(this._parameters, e27) && (this.validateParameters(this._parameters), t16 && this.parametersChanged());
  }
  validateParameters(e27) {
  }
  get visible() {
    return this._visible;
  }
  set visible(e27) {
    e27 !== this._visible && (this._visible = e27, this.parametersChanged());
  }
  shouldRender(e27) {
    return this.isVisible() && this.isVisibleForOutput(e27.output) && 0 != (this.renderOccluded & e27.renderOccludedMask);
  }
  isVisibleForOutput(e27) {
    return true;
  }
  get renderOccluded() {
    return this.parameters.renderOccluded;
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(e27) {
    e27 !== this._renderPriority && (this._renderPriority = e27, this.parametersChanged());
  }
  get insertOrder() {
    return this._insertOrder;
  }
  set insertOrder(e27) {
    e27 !== this._insertOrder && (this._insertOrder = e27, this.parametersChanged());
  }
  get vertexAttributeLocations() {
    return this._vertexAttributeLocations;
  }
  isVisible() {
    return this._visible;
  }
  parametersChanged() {
    null != this.repository && this.repository.materialChanged(this);
  }
  intersectDraped(e27, t16, r17, s10, i15, a11) {
    return this._pp0[0] = this._pp1[0] = s10[0], this._pp0[1] = this._pp1[1] = s10[1], this.intersect(e27, t16, r17, this._pp0, this._pp1, i15);
  }
};
var o17;
!function(e27) {
  e27[e27.None = 0] = "None", e27[e27.Occlude = 1] = "Occlude", e27[e27.Transparent = 2] = "Transparent", e27[e27.OccludeAndTransparent = 4] = "OccludeAndTransparent", e27[e27.OccludeAndTransparentStencil = 8] = "OccludeAndTransparentStencil", e27[e27.Opaque = 16] = "Opaque";
}(o17 || (o17 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/VisualVariablePassParameters.js
var e19 = 8;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js
function l7(l13, n18) {
  const { vertex: s10, attributes: u7 } = l13;
  n18.hasVvInstancing && (n18.vvSize || n18.vvColor) && u7.add(O2.INSTANCEFEATUREATTRIBUTE, "vec4"), n18.vvSize ? (s10.uniforms.add(new e8("vvSizeMinSize", (e27) => e27.vvSize.minSize)), s10.uniforms.add(new e8("vvSizeMaxSize", (e27) => e27.vvSize.maxSize)), s10.uniforms.add(new e8("vvSizeOffset", (e27) => e27.vvSize.offset)), s10.uniforms.add(new e8("vvSizeFactor", (e27) => e27.vvSize.factor)), s10.uniforms.add(new e10("vvSymbolRotationMatrix", (e27) => e27.vvSymbolRotationMatrix)), s10.uniforms.add(new e8("vvSymbolAnchor", (e27) => e27.vvSymbolAnchor)), s10.code.add(o4`vec3 vvScale(vec4 _featureAttribute) {
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`), s10.code.add(o4`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);
        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);
      }

      ${n18.hasVvInstancing ? o4`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }` : ""}
    `)) : s10.code.add(o4`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`), n18.vvColor ? (s10.constants.add("vvColorNumber", "int", e19), s10.uniforms.add(new o16("vvColorValues", (e27) => e27.vvColor.values, e19), new e18("vvColorColors", (e27) => e27.vvColor.colors, e19)), s10.code.add(o4`
      vec4 interpolateVVColor(float value) {
        if (value <= vvColorValues[0]) {
          return vvColorColors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (vvColorValues[i] >= value) {
            float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
            return mix(vvColorColors[i-1], vvColorColors[i], f);
          }
        }
        return vvColorColors[vvColorNumber - 1];
      }

      vec4 vvGetColor(vec4 featureAttribute) {
        return interpolateVVColor(featureAttribute.y);
      }

      ${n18.hasVvInstancing ? o4`
            vec4 vvColor() {
              return vvGetColor(instanceFeatureAttribute);
            }` : "vec4 vvColor() { return vec4(1.0); }"}
    `)) : s10.code.add(o4`vec4 vvColor() { return vec4(1.0); }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlphaBlend.glsl.js
function d5(d8) {
  d8.fragment.code.add(o4`
    #define discardOrAdjustAlpha(color) { if (color.a < ${o4.float(t5)}) { discard; } }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js
function s8(a11, e27) {
  l8(a11, e27, new o5("textureAlphaCutoff", (a12) => a12.textureAlphaCutoff));
}
function l8(e27, r17, s10) {
  const t16 = e27.fragment;
  switch (r17.alphaDiscardMode !== i4.Mask && r17.alphaDiscardMode !== i4.MaskBlend || t16.uniforms.add(s10), r17.alphaDiscardMode) {
    case i4.Blend:
      return e27.include(d5);
    case i4.Opaque:
      t16.code.add(o4`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case i4.Mask:
      t16.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case i4.MaskBlend:
      e27.fragment.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js
function d6(d8, t16) {
  const a11 = t16.output === h2.ObjectAndLayerIdColor, n18 = t16.objectAndLayerIdColorInstanced;
  a11 && (d8.varyings.add("objectAndLayerIdColorVarying", "vec4"), n18 ? d8.attributes.add(O2.INSTANCEOBJECTANDLAYERIDCOLOR, "vec4") : d8.attributes.add(O2.OBJECTANDLAYERIDCOLOR, "vec4")), d8.vertex.code.add(o4`
     void forwardObjectAndLayerIdColor() {
      ${a11 ? n18 ? o4`objectAndLayerIdColorVarying = instanceObjectAndLayerIdColor * 0.003921568627451;` : o4`objectAndLayerIdColorVarying = objectAndLayerIdColor * 0.003921568627451;` : o4``} }`), d8.fragment.code.add(o4`
      void outputObjectAndLayerIdColor() {
        ${a11 ? o4`fragColor = objectAndLayerIdColorVarying;` : o4``} }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js
function o18(o22, l13) {
  switch (o22.fragment.include(a4), l13.output) {
    case h2.Shadow:
    case h2.ShadowHighlight:
    case h2.ShadowExcludeHighlight:
      o22.fragment.code.add(o4`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
float result = depth + SLOPE_SCALE * m + BIAS;
return clamp(result, .0, .999999);
}
void outputDepth(float _linearDepth) {
fragColor = float2rgba(_calculateFragDepth(_linearDepth));
}`);
      break;
    case h2.Depth:
      o22.fragment.code.add(o4`void outputDepth(float _linearDepth) {
fragColor = float2rgba(_linearDepth);
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js
var r10 = r3(1, 1, 0, 1);
var d7 = r3(1, 0, 1, 1);
function g4(e27) {
  e27.fragment.uniforms.add(new s4("depthTexture", (e28, t16) => t16.highlightDepthTexture)), e27.fragment.constants.add("occludedHighlightFlag", "vec4", r10).add("unoccludedHighlightFlag", "vec4", d7), e27.fragment.code.add(o4`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function b4(b5, C2) {
  const { vertex: O6, fragment: y4 } = b5, V2 = C2.hasModelTransformation;
  if (V2) {
    const t16 = e4();
    O6.uniforms.add(new e11("model", (o22) => o22.modelTransformation ?? o2)), O6.uniforms.add(new e10("normalTransform", (r17) => (g(t16, r17.modelTransformation ?? o2), t16)));
  }
  const A6 = C2.hasColorTexture && C2.alphaDiscardMode !== i4.Opaque;
  switch (C2.output) {
    case h2.Depth:
    case h2.Shadow:
    case h2.ShadowHighlight:
    case h2.ShadowExcludeHighlight:
    case h2.ObjectAndLayerIdColor:
      p2(O6, C2), b5.include(o11, C2), b5.include(o6, C2), b5.include(l7, C2), b5.include(o18, C2), b5.include(P, C2), b5.include(d6, C2), i6(b5), b5.varyings.add("depth", "float"), A6 && y4.uniforms.add(new s4("tex", (o22) => o22.texture)), O6.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            ${V2 ? "vpos = (model * vec4(vpos, 1.0)).xyz;" : ""}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
            forwardTextureCoordinates();
            forwardObjectAndLayerIdColor();
          }
        `), b5.include(s8, C2), y4.code.add(o4`
          void main(void) {
            discardBySlice(vpos);
            ${A6 ? o4`
                    vec4 texColor = texture(tex, ${C2.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${C2.output === h2.ObjectAndLayerIdColor ? o4`outputObjectAndLayerIdColor();` : o4`outputDepth(depth);`}
          }
        `);
      break;
    case h2.Normal: {
      p2(O6, C2), b5.include(o11, C2), b5.include(t3, C2), b5.include(c3, C2), b5.include(o6, C2), b5.include(l7, C2), A6 && y4.uniforms.add(new s4("tex", (o23) => o23.texture)), C2.normalType === a6.ScreenDerivative && b5.varyings.add("vPositionView", "vec3");
      const o22 = C2.normalType === a6.Attribute || C2.normalType === a6.Compressed;
      O6.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            ${V2 ? "vpos = (model * vec4(vpos, 1.0)).xyz;" : ""}

            ${o22 ? o4`vNormalWorld = ${V2 ? "normalize(normalTransform * dpNormal(vvLocalNormal(normalModel())))" : "dpNormalView(vvLocalNormal(normalModel()))"};` : o4`
                  // Get vertex position in camera space for screen-space derivative normals
                  vPositionView = (view * vec4(vpos, 1.0)).xyz;
                `}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), b5.include(P, C2), b5.include(s8, C2), y4.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${A6 ? o4`
                    vec4 texColor = texture(tex, ${C2.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${C2.normalType === a6.ScreenDerivative ? o4`vec3 normal = screenDerivativeNormal(vPositionView);` : o4`
                  vec3 normal = normalize(vNormalWorld);
                  if (gl_FrontFacing == false){
                    normal = -normal;
                  }`}
            fragColor = vec4(0.5 + 0.5 * normal, 1.0);
          }
        `);
      break;
    }
    case h2.Highlight:
      p2(O6, C2), b5.include(o11, C2), b5.include(o6, C2), b5.include(l7, C2), A6 && y4.uniforms.add(new s4("tex", (o22) => o22.texture)), O6.code.add(o4`
          void main(void) {
            vpos = calculateVPos();
            ${V2 ? "vpos = (model * vec4(vpos, 1.0)).xyz;" : ""}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), b5.include(P, C2), b5.include(s8, C2), b5.include(g4, C2), y4.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${A6 ? o4`
                    vec4 texColor = texture(tex, ${C2.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexBufferLayouts.js
var n11 = [new t2(O2.POSITION, 3, C.FLOAT, 0, 12)];
var w2 = [new t2(O2.POSITION, 3, C.FLOAT, 0, 20), new t2(O2.UV0, 2, C.FLOAT, 12, 20)];
var I3 = [new t2(O2.POSITION, 3, C.FLOAT, 0, 32), new t2(O2.NORMAL, 3, C.FLOAT, 12, 32), new t2(O2.UV0, 2, C.FLOAT, 24, 32)];
var r11 = [new t2(O2.POSITION, 3, C.FLOAT, 0, 16), new t2(O2.COLOR, 4, C.UNSIGNED_BYTE, 12, 16)];
var t9 = [new t2(O2.POSITION, 2, C.FLOAT, 0, 8)];
var A4 = [new t2(O2.POSITION, 2, C.FLOAT, 0, 16), new t2(O2.UV0, 2, C.FLOAT, 8, 16)];

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t10 = class {
  constructor(t16, o22) {
    this._module = t16, this._loadModule = o22;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._loadModule(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var e22 = class {
  constructor(i15, t16, e27) {
    this.release = e27, this.initializeConfiguration(i15, t16), this._configuration = t16.snapshot(), this._program = this.initializeProgram(i15), this._pipeline = this.initializePipeline(i15.rctx.capabilities);
  }
  destroy() {
    this._program = t(this._program), this._pipeline = this._configuration = null;
  }
  reload(t16) {
    t(this._program), this._program = this.initializeProgram(t16), this._pipeline = this.initializePipeline(t16.rctx.capabilities);
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  get key() {
    return this._configuration.key;
  }
  get configuration() {
    return this._configuration;
  }
  bindPipelineState(i15, t16 = null, e27) {
    i15.setPipelineState(this.getPipelineState(t16, e27));
  }
  ensureAttributeLocations(i15) {
    this.program.assertCompatibleVertexAttributeLocations(i15);
  }
  get primitiveType() {
    return E.TRIANGLES;
  }
  getPipelineState(i15, t16) {
    return this._pipeline;
  }
  initializeConfiguration(i15, t16) {
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var i12 = class {
  constructor(i15, s10, o22) {
    this._context = i15, this._locations = o22, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new l({ deallocator: null }), this._glProgram = i15.programCache.acquire(s10.generate("vertex"), s10.generate("fragment"), o22), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = s10.generateBind(a3.Pass, this), this.bindDraw = s10.generateBind(a3.Draw, this), this._fragmentUniforms = a2() ? s10.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t16, e27) {
    this._glProgram.setUniform1i(t16, e27 ? 1 : 0);
  }
  setUniform1i(t16, e27) {
    this._glProgram.setUniform1i(t16, e27);
  }
  setUniform1f(t16, e27) {
    this._glProgram.setUniform1f(t16, e27);
  }
  setUniform2fv(t16, e27) {
    this._glProgram.setUniform2fv(t16, e27);
  }
  setUniform3fv(t16, e27) {
    this._glProgram.setUniform3fv(t16, e27);
  }
  setUniform4fv(t16, e27) {
    this._glProgram.setUniform4fv(t16, e27);
  }
  setUniformMatrix3fv(t16, e27) {
    this._glProgram.setUniformMatrix3fv(t16, e27);
  }
  setUniformMatrix4fv(t16, e27) {
    this._glProgram.setUniformMatrix4fv(t16, e27);
  }
  setUniform1fv(t16, e27) {
    this._glProgram.setUniform1fv(t16, e27);
  }
  setUniform1iv(t16, e27) {
    this._glProgram.setUniform1iv(t16, e27);
  }
  setUniform2iv(t16, e27) {
    this._glProgram.setUniform3iv(t16, e27);
  }
  setUniform3iv(t16, e27) {
    this._glProgram.setUniform3iv(t16, e27);
  }
  setUniform4iv(t16, e27) {
    this._glProgram.setUniform4iv(t16, e27);
  }
  assertCompatibleVertexAttributeLocations(t16) {
    t16.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(t16, e27) {
    if (null == e27 || null == e27.glName) {
      const e28 = this._textures.get(t16);
      return e28 && (this._context.bindTexture(null, e28.unit), this._freeTextureUnit(e28), this._textures.delete(t16)), null;
    }
    let r17 = this._textures.get(t16);
    return null == r17 ? (r17 = this._allocTextureUnit(e27), this._textures.set(t16, r17)) : r17.texture = e27, this._context.useProgram(this), this.setUniform1i(t16, r17.unit), this._context.bindTexture(e27, r17.unit), r17.unit;
  }
  rebindTextures() {
    this._context.useProgram(this), this._textures.forEach((t16, e27) => {
      this._context.bindTexture(t16.texture, t16.unit), this.setUniform1i(e27, t16.unit);
    }), null != this._fragmentUniforms && this._fragmentUniforms.forEach((t16) => {
      "sampler2D" !== t16.type && "samplerCube" !== t16.type || this._textures.has(t16.name) || console.error(`Texture sampler ${t16.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t16) {
    return { texture: t16, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t16) {
    this._freeTextureUnits.push(t16.unit);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOBlurTechnique.js
var l9 = class _l extends e22 {
  initializeProgram(r17) {
    return new i12(r17.rctx, _l.shader.get().build(), E3);
  }
  initializePipeline() {
    return W({ colorWrite: _2 });
  }
};
l9.shader = new t10(u2, () => import("./SSAOBlur.glsl-AUMNNSC3.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOTechnique.js
var l10 = class _l extends e22 {
  initializeProgram(e27) {
    return new i12(e27.rctx, _l.shader.get().build(), E3);
  }
  initializePipeline() {
    return W({ colorWrite: _2 });
  }
};
l10.shader = new t10(v, () => import("./SSAO.glsl-5NNBSSHT.js"));

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/SSAOHelper.js
var O5 = 2;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js
function t12(t16, o22) {
  const a11 = t16.fragment;
  o22.receiveAmbientOcclusion ? (a11.uniforms.add(new s4("ssaoTex", (e27, r17) => r17.ssaoHelper.colorTexture)), a11.constants.add("blurSizePixelsInverse", "float", 1 / O5), a11.code.add(o4`float evaluateAmbientOcclusionInverse() {
vec2 ssaoTextureSizeInverse = 1.0 / vec2(textureSize(ssaoTex, 0));
return texture(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).a;
}
float evaluateAmbientOcclusion() {
return 1.0 - evaluateAmbientOcclusionInverse();
}`)) : a11.code.add(o4`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function t13(n18) {
  n18.uniforms.add(new e8("mainLightDirection", (i15, n19) => n19.lighting.mainLight.direction));
}
function a9(n18) {
  n18.uniforms.add(new e8("mainLightIntensity", (i15, n19) => n19.lighting.mainLight.intensity));
}
function o20(i15) {
  t13(i15.fragment), a9(i15.fragment), i15.fragment.code.add(o4`vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {
float dotVal = clamp(dot(normal_global, mainLightDirection), 0.0, 1.0);
return mainLightIntensity * ((1.0 - shadowing) * dotVal);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t14(t16) {
  const a11 = t16.fragment.code;
  a11.add(o4`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), a11.add(o4`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), a11.add(o4`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js
function t15(t16) {
  t16.vertex.code.add(o4`const float PI = 3.141592653589793;`), t16.fragment.code.add(o4`const float PI = 3.141592653589793;
const float LIGHT_NORMALIZATION = 1.0 / PI;
const float INV_PI = 0.3183098861837907;
const float HALF_PI = 1.570796326794897;`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n14(n18, r17) {
  const l13 = n18.fragment.code;
  n18.include(t15), r17.pbrMode !== c.Normal && r17.pbrMode !== c.Schematic && r17.pbrMode !== c.Terrain && r17.pbrMode !== c.TerrainWithWater || (l13.add(o4`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), l13.add(o4`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)), r17.pbrMode !== c.Normal && r17.pbrMode !== c.Schematic || (n18.include(t14), l13.add(o4`struct PBRShadingInfo
{
float NdotL;
float NdotV;
float NdotH;
float VdotH;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), l13.add(o4`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), l13.add(o4`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), l13.add(o4`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function m7(n18, g6) {
  const m8 = n18.fragment, o22 = void 0 !== g6.lightingSphericalHarmonicsOrder ? g6.lightingSphericalHarmonicsOrder : 2;
  0 === o22 ? (m8.uniforms.add(new e8("lightingAmbientSH0", (n19, t16) => o(a10, t16.lighting.sh.r[0], t16.lighting.sh.g[0], t16.lighting.sh.b[0]))), m8.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o22 ? (m8.uniforms.add(new e7("lightingAmbientSH_R", (i15, n19) => r2(r14, n19.lighting.sh.r[0], n19.lighting.sh.r[1], n19.lighting.sh.r[2], n19.lighting.sh.r[3])), new e7("lightingAmbientSH_G", (i15, n19) => r2(r14, n19.lighting.sh.g[0], n19.lighting.sh.g[1], n19.lighting.sh.g[2], n19.lighting.sh.g[3])), new e7("lightingAmbientSH_B", (i15, n19) => r2(r14, n19.lighting.sh.b[0], n19.lighting.sh.b[1], n19.lighting.sh.b[2], n19.lighting.sh.b[3]))), m8.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o22 && (m8.uniforms.add(new e8("lightingAmbientSH0", (n19, t16) => o(a10, t16.lighting.sh.r[0], t16.lighting.sh.g[0], t16.lighting.sh.b[0])), new e7("lightingAmbientSH_R1", (i15, n19) => r2(r14, n19.lighting.sh.r[1], n19.lighting.sh.r[2], n19.lighting.sh.r[3], n19.lighting.sh.r[4])), new e7("lightingAmbientSH_G1", (i15, n19) => r2(r14, n19.lighting.sh.g[1], n19.lighting.sh.g[2], n19.lighting.sh.g[3], n19.lighting.sh.g[4])), new e7("lightingAmbientSH_B1", (i15, n19) => r2(r14, n19.lighting.sh.b[1], n19.lighting.sh.b[2], n19.lighting.sh.b[3], n19.lighting.sh.b[4])), new e7("lightingAmbientSH_R2", (i15, n19) => r2(r14, n19.lighting.sh.r[5], n19.lighting.sh.r[6], n19.lighting.sh.r[7], n19.lighting.sh.r[8])), new e7("lightingAmbientSH_G2", (i15, n19) => r2(r14, n19.lighting.sh.g[5], n19.lighting.sh.g[6], n19.lighting.sh.g[7], n19.lighting.sh.g[8])), new e7("lightingAmbientSH_B2", (i15, n19) => r2(r14, n19.lighting.sh.b[5], n19.lighting.sh.b[6], n19.lighting.sh.b[7], n19.lighting.sh.b[8]))), m8.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g6.pbrMode !== c.Normal && g6.pbrMode !== c.Schematic || m8.code.add(o4`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a10 = n();
var r14 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js
var s9 = class extends i5 {
  constructor(o22, s10) {
    super(o22, "bool", a3.Pass, (r17, e27, t16) => r17.setUniform1b(o22, s10(e27, t16)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SphericalHarmonics.js
var P3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SceneLighting.js
var l12 = 0.4;
var L3 = n();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js
function h7(n18) {
  n18.constants.add("ambientBoostFactor", "float", l12);
}
function u5(n18) {
  n18.uniforms.add(new o5("lightingGlobalFactor", (n19, i15) => i15.lighting.globalFactor));
}
function p5(g6, p6) {
  const v8 = g6.fragment;
  switch (g6.include(t12, p6), p6.pbrMode !== c.Disabled && g6.include(n14, p6), g6.include(m7, p6), g6.include(t15), v8.code.add(o4`
    const float GAMMA_SRGB = 2.1;
    const float INV_GAMMA_SRGB = 0.4761904;
    ${p6.pbrMode === c.Disabled ? "" : "const vec3 GROUND_REFLECTANCE = vec3(0.2);"}
  `), h7(v8), u5(v8), t13(v8), v8.code.add(o4`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${p6.spherical ? o4`normalize(vPosWorld)` : o4`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `), a9(v8), v8.code.add(o4`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`), p6.pbrMode) {
    case c.Disabled:
    case c.WaterOnIntegratedMesh:
    case c.Water:
      g6.include(o20), v8.code.add(o4`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)
{
vec3 mainLighting = evaluateMainLighting(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);
      break;
    case c.Normal:
    case c.Schematic:
      v8.code.add(o4`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)
{
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);
inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);
inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v8.code.add(o4`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p6.useFillLights ? v8.uniforms.add(new s9("hasFillLights", (n18, i15) => i15.enableFillLights)) : v8.constants.add("hasFillLights", "bool", false), v8.code.add(o4`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);
ambientDir = ambientDir != vec3(0.0)? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
vec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v8.uniforms.add(new o5("lightingSpecularStrength", (n18, i15) => i15.lighting.mainLight.specularStrength), new o5("lightingEnvironmentStrength", (n18, i15) => i15.lighting.mainLight.environmentStrength)), v8.code.add(o4`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
inputs.skyRadianceToSurface = ambientLightRadianceComponent + mainLightRadianceComponent + horizonLightRadianceComponent;
inputs.groundRadianceToSurface = GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v8.code.add(o4`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 emissionComponent = pow(_emission, vec3(GAMMA_SRGB));
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;
        ${p6.pbrMode === c.Schematic ? o4`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));` : o4`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);
      break;
    case c.Terrain:
    case c.TerrainWithWater:
      g6.include(o20), v8.code.add(o4`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluateTerrainLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`);
      break;
    default:
      n3(p6.pbrMode);
    case c.COUNT:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js
function n17(n18, o22) {
  o22.hasMultipassTerrain && (n18.fragment.include(a5), n18.fragment.uniforms.add(new s4("terrainDepthTexture", (e27, r17) => r17.multipassTerrain.linearDepthTexture)), n18.fragment.uniforms.add(new e6("nearFar", (e27, r17) => r17.camera.nearFar)), n18.fragment.uniforms.add(new e6("inverseViewport", (e27, r17) => r17.inverseViewport)), n18.fragment.code.add(o4`
    void terrainDepthTest(vec4 fragCoord, float fragmentDepth){
      float terrainDepth = linearDepthFromTexture(terrainDepthTexture, fragCoord.xy * inverseViewport, nearFar);
      if(fragmentDepth ${o22.cullAboveGround ? ">" : "<="} terrainDepth){
        discard;
      }
    }
  `));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js
var o21 = class extends i5 {
  constructor(r17, o22, s10) {
    super(r17, "mat4", a3.Draw, (e27, s11, t16, i15) => e27.setUniformMatrix4fv(r17, o22(s11, t16, i15)), s10);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js
var e25 = class extends i5 {
  constructor(r17, e27, o22) {
    super(r17, "mat4", a3.Pass, (s10, o23, t16) => s10.setUniformMatrix4fv(r17, e27(o23, t16)), o22);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
function f8(e27, a11) {
  a11.receiveShadows && (e27.fragment.uniforms.add(new e25("shadowMapMatrix", (e28, a12) => a12.shadowMap.getShadowMapMatrices(e28.origin), 4)), x5(e27));
}
function u6(e27, a11) {
  a11.receiveShadows && (e27.fragment.uniforms.add(new o21("shadowMapMatrix", (e28, a12) => a12.shadowMap.getShadowMapMatrices(e28.origin), 4)), x5(e27));
}
function x5(e27) {
  const a11 = e27.fragment;
  a11.include(a4), a11.uniforms.add(new s4("shadowMapTex", (e28, a12) => a12.shadowMap.depthTexture), new e15("numCascades", (e28, a12) => a12.shadowMap.numCascades), new e7("cascadeDistances", (e28, a12) => a12.shadowMap.cascadeDistances)), a11.code.add(o4`int chooseCascade(float depth, out mat4 mat) {
vec4 distance = cascadeDistances;
int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;
mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
return i;
}
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, vec3 lvpos) {
return vec2(float(i - 2 * (i / 2)) * 0.5, float(i / 2) * 0.5) + (numCascades == 1 ? 1.0 : 0.5) * lvpos.xy;
}
float readShadowMapDepth(vec2 uv, sampler2D _depthTex) {
return rgba2float(texture(_depthTex, uv));
}
float posIsInShadow(vec2 uv, vec3 lvpos, sampler2D _depthTex) {
return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
}
float filterShadow(vec2 uv, vec3 lvpos, float texSize, sampler2D _depthTex) {
float halfPixelSize = 0.5 / texSize;
vec2 st = fract((vec2(halfPixelSize) + uv) * texSize);
float s00 = posIsInShadow(uv + vec2(-halfPixelSize, -halfPixelSize), lvpos, _depthTex);
float s10 = posIsInShadow(uv + vec2(halfPixelSize, -halfPixelSize), lvpos, _depthTex);
float s11 = posIsInShadow(uv + vec2(halfPixelSize, halfPixelSize), lvpos, _depthTex);
float s01 = posIsInShadow(uv + vec2(-halfPixelSize, halfPixelSize), lvpos, _depthTex);
return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
}
float readShadowMap(const in vec3 _vpos, float _linearDepth) {
mat4 mat;
int i = chooseCascade(_linearDepth, mat);
if (i >= numCascades) { return 0.0; }
vec3 lvpos = lightSpacePosition(_vpos, mat);
if (lvpos.z >= 1.0) { return 0.0; }
if (lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }
vec2 uv = cascadeCoordinates(i, lvpos);
return filterShadow(uv, lvpos, float(textureSize(shadowMapTex, 0).x), shadowMapTex);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js
function e26(e27) {
  e27.code.add(o4`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i14(i15) {
  i15.include(e26), i15.code.add(o4`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${o4.int(n4.Multiply)}) {
        return allMixed;
      }
      if (mode == ${o4.int(n4.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(n4.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${o4.int(n4.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(n4.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  r9 as r,
  e16 as e,
  h2 as h,
  t3 as t,
  a6 as a,
  d,
  o6 as o,
  s5 as s,
  e8 as e2,
  r5 as r2,
  c,
  l3 as l,
  E3 as E,
  h6 as h2,
  V,
  d4 as d2,
  o17 as o2,
  o8 as o3,
  e10 as e3,
  e11 as e4,
  c3 as c2,
  f3 as f,
  o10 as o4,
  t5 as t2,
  t10 as t3,
  e22 as e5,
  i12 as i,
  d2 as d3,
  e12 as e6,
  P,
  o11 as o5,
  f4 as f2,
  p2 as p,
  t7 as t4,
  r7 as r3,
  p3 as p2,
  i8 as i2,
  e17 as e7,
  a7 as a2,
  l7 as l2,
  s8 as s2,
  b4 as b,
  t12 as t5,
  t13 as t6,
  a9 as a3,
  n14 as n,
  h7 as h3,
  u5 as u,
  p5 as p3,
  n17 as n2,
  f8 as f3,
  u6 as u2,
  i14 as i3
};
//# sourceMappingURL=chunk-K6WYK3GP.js.map
