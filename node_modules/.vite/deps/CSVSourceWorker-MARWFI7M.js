import {
  i,
  o
} from "./chunk-P34MS5MD.js";
import "./chunk-FHYNSVC4.js";
import {
  m
} from "./chunk-M72PBKGH.js";
import "./chunk-APDPMAO5.js";
import {
  ee
} from "./chunk-R6YQG4NY.js";
import "./chunk-LLQHB2ZB.js";
import "./chunk-BKDPNGLX.js";
import {
  f as f2
} from "./chunk-D5EV57FM.js";
import {
  r
} from "./chunk-EISDT6B4.js";
import "./chunk-LREUW66K.js";
import "./chunk-PM3CFO6N.js";
import "./chunk-6VJWKAPY.js";
import "./chunk-UQOM5GR4.js";
import "./chunk-YBMFRTPB.js";
import "./chunk-KKGVORR5.js";
import "./chunk-WTKN55TU.js";
import {
  t
} from "./chunk-TDPKDZC3.js";
import {
  t as t2
} from "./chunk-M5UHI5WR.js";
import "./chunk-Z36PKTLY.js";
import "./chunk-S2P7FTAG.js";
import {
  a
} from "./chunk-5CIVT7RW.js";
import "./chunk-FJYIB7HF.js";
import "./chunk-PRUCXFZ4.js";
import "./chunk-KLV5OJVG.js";
import "./chunk-TQGXXOXA.js";
import {
  t as t3
} from "./chunk-SO7CVIZK.js";
import "./chunk-ITRH3PGV.js";
import "./chunk-BRDC7DKL.js";
import "./chunk-ZBWBCN2I.js";
import "./chunk-GZTLZ6RD.js";
import {
  en
} from "./chunk-SO6DBMQG.js";
import "./chunk-KTSEQWMB.js";
import "./chunk-QXGO5RRL.js";
import {
  B,
  u2 as u
} from "./chunk-7KM4XBUC.js";
import "./chunk-OZXJDVTE.js";
import {
  d as d2
} from "./chunk-UKJF25H6.js";
import "./chunk-KSQTM6XI.js";
import "./chunk-BVNZ3ETW.js";
import "./chunk-FJQ7HIY7.js";
import "./chunk-T4XWQYGC.js";
import "./chunk-4H5JODOT.js";
import "./chunk-TCASQSKO.js";
import "./chunk-5HAVROZG.js";
import "./chunk-MOPR7RFH.js";
import "./chunk-KW3ZNPTA.js";
import "./chunk-TJB4CGOM.js";
import "./chunk-XN5VV437.js";
import "./chunk-ODFH3BSN.js";
import "./chunk-WBSPL6CJ.js";
import "./chunk-LQVUN6IS.js";
import "./chunk-JZM5YUHA.js";
import "./chunk-3GSONYPC.js";
import {
  A,
  M,
  S2 as S,
  f,
  p
} from "./chunk-SFV6XLDZ.js";
import "./chunk-3PLRSFLA.js";
import "./chunk-VBD33VNW.js";
import "./chunk-7A5C2EQ3.js";
import "./chunk-OYBXMT5R.js";
import "./chunk-CIDWM2UN.js";
import "./chunk-PD5Q7TDW.js";
import "./chunk-SHJI4PR4.js";
import "./chunk-2YSHZRCT.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import "./chunk-MH2LNFJK.js";
import {
  Ct,
  L
} from "./chunk-O3CHVGVF.js";
import {
  d
} from "./chunk-HNHXEGH2.js";
import "./chunk-DWOEYHKS.js";
import {
  s2 as s,
  s3 as s2
} from "./chunk-W2N7YT6I.js";
import "./chunk-I5JT24BO.js";
import "./chunk-I4U7MQNO.js";
import "./chunk-76J2PTFD.js";

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var n = /^\s*"([\S\s]*)"\s*$/;
var i2 = /""/g;
var r2 = "\n";
var l = [",", " ", ";", "|", "	"];
function* o2(e, t4, n2) {
  let i3 = 0;
  for (; i3 <= e.length; ) {
    const r3 = e.indexOf(t4, i3), l2 = e.substring(i3, r3 > -1 ? r3 : void 0);
    i3 += l2.length + t4.length, n2 && !l2.trim() || (yield l2);
  }
}
function s3(e) {
  const t4 = e.includes("\r\n") ? "\r\n" : r2;
  return o2(e, t4, true);
}
function u2(e, t4) {
  return o2(e, t4, false);
}
function c(e, t4, n2) {
  e = e.trim(), t4 = t4 == null ? void 0 : t4.trim();
  const i3 = [], r3 = Array.from(/* @__PURE__ */ new Set([n2 == null ? void 0 : n2.delimiter, ...l])).filter((e2) => null != e2);
  for (const l2 of r3) {
    const n3 = d3(e, l2).length, r4 = d3(t4, l2).length ?? n3;
    n3 > 1 && i3.push({ weight: Math.min(n3, r4), delimiter: l2 });
  }
  const o3 = i3.sort(({ weight: e2 }, { weight: t5 }) => t5 - e2).map(({ delimiter: e2 }) => e2);
  for (const l2 of o3) {
    const t5 = m2(f3(e, l2).names, n2 == null ? void 0 : n2.longitudeField, n2 == null ? void 0 : n2.latitudeField);
    if (t5.longitudeFieldName && t5.latitudeFieldName)
      return { delimiter: l2, locationInfo: t5 };
  }
  return { delimiter: o3[0], locationInfo: null };
}
function* a2(e, t4, l2, o3 = () => /* @__PURE__ */ Object.create(null)) {
  const c2 = s3(e);
  c2.next();
  let a3 = "", f4 = "", d4 = 0, m3 = o3(), p3 = 0;
  e:
    for (const s4 of c2) {
      const e2 = u2(s4, l2);
      for (const r3 of e2)
        if (a3 += f4 + r3, f4 = "", d4 += g(r3), d4 % 2 == 0) {
          if (d4 > 0) {
            const e3 = n.exec(a3);
            if (!e3) {
              m3 = o3(), p3 = 0, a3 = "", d4 = 0;
              continue e;
            }
            m3[t4[p3]] = e3[1].replaceAll(i2, '"'), p3++;
          } else
            m3[t4[p3]] = a3, p3++;
          a3 = "", d4 = 0;
        } else
          f4 = l2;
      0 === d4 ? (yield m3, m3 = o3(), p3 = 0) : f4 = r2;
    }
}
function f3(e, n2) {
  const i3 = d3(e, n2).filter((e2) => null != e2), r3 = i3.map((e2) => u(e2));
  for (let t4 = r3.length - 1; t4 >= 0; t4--)
    r3[t4] || (r3.splice(t4, 1), i3.splice(t4, 1));
  return { names: r3, aliases: i3 };
}
function d3(e, t4) {
  if (!(e == null ? void 0 : e.length))
    return [];
  const r3 = [];
  let l2 = "", o3 = "", s4 = 0;
  const c2 = u2(e, t4);
  for (const u3 of c2)
    if (l2 += o3 + u3, o3 = "", s4 += g(u3), s4 % 2 == 0) {
      if (s4 > 0) {
        const e2 = n.exec(l2);
        e2 && r3.push(e2[1].replaceAll(i2, '"'));
      } else
        r3.push(l2);
      l2 = "", s4 = 0;
    } else
      o3 = t4;
  return r3;
}
function g(e) {
  let t4 = 0, n2 = 0;
  for (n2 = e.indexOf('"', n2); n2 >= 0; )
    t4++, n2 = e.indexOf('"', n2 + 1);
  return t4;
}
function m2(e, n2, i3) {
  var _a, _b;
  n2 = (_a = u(n2)) == null ? void 0 : _a.toLowerCase(), i3 = (_b = u(i3)) == null ? void 0 : _b.toLowerCase();
  const r3 = e.map((e2) => e2.toLowerCase()), l2 = n2 ? e[r3.indexOf(n2)] : null, o3 = i3 ? e[r3.indexOf(i3)] : null;
  return { longitudeFieldName: l2 || e[r3.indexOf(w.find((e2) => r3.includes(e2)))], latitudeFieldName: o3 || e[r3.indexOf(F.find((e2) => r3.includes(e2)))] };
}
function p2(e, t4, n2, i3, r3) {
  const l2 = [], o3 = a2(e, n2, t4), s4 = [];
  for (const u3 of o3) {
    if (10 === s4.length)
      break;
    s4.push(u3);
  }
  for (let u3 = 0; u3 < n2.length; u3++) {
    const e2 = n2[u3], t5 = i3[u3];
    if (e2 === r3.longitudeFieldName || e2 === r3.latitudeFieldName)
      l2.push({ name: e2, type: "esriFieldTypeDouble", alias: t5 });
    else {
      let n3, i4;
      switch (b(s4.map((t6) => t6[e2]))) {
        case "integer":
          n3 = "esriFieldTypeInteger";
          break;
        case "double":
          n3 = "esriFieldTypeDouble";
          break;
        case "date":
          n3 = "esriFieldTypeDate", i4 = 36;
          break;
        default:
          n3 = "esriFieldTypeString", i4 = 255;
      }
      l2.push({ name: e2, type: n3, alias: t5, length: i4 });
    }
  }
  return l2;
}
function b(e) {
  if (!e.length)
    return "string";
  const t4 = /[^+-.,0-9]/;
  return e.map((e2) => {
    let n2 = false;
    if ("" !== e2) {
      if (t4.test(e2))
        n2 = true;
      else {
        let t5 = N(e2);
        if (!isNaN(t5))
          return /[.,]/.test(e2) || !Number.isInteger(t5) || t5 > 214783647 || t5 < -214783648 ? "double" : "integer";
        if (e2.includes("E")) {
          if (t5 = Number(e2), !isNaN(t5))
            return "double";
          if (e2.includes(",")) {
            if (e2 = e2.replace(",", "."), t5 = Number(e2), !isNaN(t5))
              return "double";
            n2 = true;
          } else
            n2 = true;
        } else
          n2 = true;
      }
      if (n2) {
        if (!/^[-]?\d*[.,]?\d*$/.test(e2)) {
          return h(new Date(e2), e2) ? "date" : "string";
        }
        return "string";
      }
      return "string";
    }
  }).reduce((e2, t5) => void 0 === e2 ? t5 : void 0 === t5 ? e2 : e2 === t5 ? t5 : "string" === e2 || "string" === t5 ? "string" : "double" === e2 || "double" === t5 ? "double" : void 0);
}
function h(e, t4) {
  if (!e || "[object Date]" !== Object.prototype.toString.call(e) || isNaN(e.getTime()))
    return false;
  let n2 = true;
  if (!y && /\d+\W*$/.test(t4)) {
    const e2 = t4.match(/[a-zA-Z]{2,}/);
    if (e2) {
      let t5 = false, i3 = 0;
      for (; !t5 && i3 <= e2.length; )
        t5 = !x.test(e2[i3]), i3++;
      n2 = !t5;
    }
  }
  return n2;
}
var N = function() {
  const t4 = a(), n2 = new RegExp("^" + t4.regexp + "$"), i3 = new RegExp("[" + t4.group + "\\s\\xa0]", "g"), r3 = t4.factor;
  return (e) => {
    const l2 = n2.exec(e);
    if (t4.factor = r3, !l2)
      return NaN;
    let o3 = l2[1];
    if (!l2[1]) {
      if (!l2[2])
        return NaN;
      o3 = l2[2], t4.factor *= -1;
    }
    return o3 = o3.replace(i3, "").replace(t4.decimal, "."), +o3 * t4.factor;
  };
}();
var x = /^((jan(uary)?)|(feb(ruary)?)|(mar(ch)?)|(apr(il)?)|(may)|(jun(e)?)|(jul(y)?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)|(am)|(pm)|(gmt)|(utc))$/i;
var y = Number.isNaN((/* @__PURE__ */ new Date("technology 10")).getTime());
var F = ["lat", "latitude", "latitude83", "latdecdeg", "lat_dd", "y", "ycenter", "point_y"];
var w = ["lon", "lng", "long", "longitude", "longitude83", "longdecdeg", "long_dd", "x", "xcenter", "point_x"];

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var C = o("esriGeometryPoint");
var v = ["csv"];
var O = [0, 0];
var D = class {
  constructor(e, t4) {
    this.x = e, this.y = t4;
  }
};
var k = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t4 = await this._fetch(e);
      return this._createFeatures(t4);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e, t4 = {}) {
    var _a;
    this._loadOptions = e;
    const [i3] = await Promise.all([this._fetch(t4.signal), this._checkProjection((_a = e == null ? void 0 : e.parsingOptions) == null ? void 0 : _a.spatialReference)]), n2 = P(i3, e);
    this._locationInfo = n2.locationInfo, this._delimiter = n2.delimiter, this._queryEngine = this._createQueryEngine(n2);
    const r3 = await this._createFeatures(i3);
    this._queryEngine.featureStore.addMany(r3);
    const { fullExtent: s4, timeExtent: o3 } = await this._queryEngine.fetchRecomputedExtents();
    if (n2.layerDefinition.extent = s4, o3) {
      const { start: e2, end: t5 } = o3;
      n2.layerDefinition.timeInfo.timeExtent = [e2, t5];
    }
    return n2;
  }
  async applyEdits() {
    throw new s2("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t4.signal);
  }
  async queryFeatureCount(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t4.signal);
  }
  async queryObjectIds(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t4.signal);
  }
  async queryExtent(e = {}, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t4.signal);
  }
  async querySnapping(e, t4 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t4.signal);
  }
  async refresh(e) {
    var _a;
    this._loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d2(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), e2 && this._queryEngine.featureStore.addMany(e2);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), d(e2) || s.getLogger("esri.layers.CSVLayer").error(new s2("csv-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: s4, timeExtent: o3 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: s4, timeExtent: o3 };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t4) {
    const { url: n2, customParameters: r3 } = this._loadOptions;
    if (!n2)
      throw new s2("csv-layer:invalid-source", "url not defined");
    const o3 = L(n2);
    return (await j(o3.path, { query: { ...o3.query, ...r3 }, responseType: "text", signal: t4 })).data;
  }
  _createQueryEngine(e) {
    const { objectIdField: t4, fields: i3, extent: n2, timeInfo: r3 } = e.layerDefinition, s4 = new m({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false });
    return new ee({ fields: i3, geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r3, objectIdField: t4, spatialReference: n2.spatialReference || { wkid: 4326 }, cacheSpatialQueries: true, featureStore: s4 });
  }
  async _createFeatures(e) {
    const { latitudeFieldName: t4, longitudeFieldName: i3 } = this._locationInfo, { objectIdField: n2, fieldsIndex: r3, spatialReference: s4 } = this._queryEngine;
    let o3 = [];
    const d4 = [], y2 = r3.fields.filter((e2) => e2.name !== n2).map((e2) => e2.name);
    let h2 = 0;
    const g2 = {};
    for (const a3 of r3.fields)
      if ("esriFieldTypeOID" !== a3.type && "esriFieldTypeGlobalID" !== a3.type) {
        const e2 = B(a3);
        void 0 !== e2 && (g2[a3.name] = e2);
      }
    const w2 = a2(e, y2, this._delimiter, i(g2, n2));
    for (const a3 of w2) {
      const e2 = this._parseCoordinateValue(a3[t4]), s5 = this._parseCoordinateValue(a3[i3]);
      if (null != s5 && null != e2 && !isNaN(e2) && !isNaN(s5)) {
        a3[t4] = e2, a3[i3] = s5;
        for (const e3 in a3)
          if (e3 !== t4 && e3 !== i3) {
            if (r3.isDateField(e3)) {
              const t5 = new Date(a3[e3]);
              a3[e3] = h(t5, a3[e3]) ? t5.getTime() : null;
            } else if (r3.isNumericField(e3)) {
              const t5 = N(a3[e3]);
              isNaN(t5) ? a3[e3] = null : a3[e3] = t5;
            }
          }
        a3[n2] = h2, h2++, o3.push(new D(s5, e2)), d4.push(a3);
      }
    }
    if (!S({ wkid: 4326 }, s4))
      if (A(s4))
        for (const a3 of o3)
          [a3.x, a3.y] = M(a3.x, a3.y, O);
      else
        o3 = en(t3, o3, f.WGS84, s4, null, null);
    const E = [];
    for (let a3 = 0; a3 < o3.length; a3++) {
      const { x: e2, y: t5 } = o3[a3], i4 = d4[a3];
      i4[n2] = a3 + 1, E.push(new t(new t2([], [e2, t5]), i4, null, i4[n2]));
    }
    return E;
  }
  _parseCoordinateValue(e) {
    if (null == e || "" === e)
      return null;
    let t4 = N(e);
    return (isNaN(t4) || Math.abs(t4) > 181) && (t4 = parseFloat(e)), t4;
  }
  async _checkProjection(e) {
    try {
      await f2(p, e);
    } catch {
      throw new s2("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function P(e, t4) {
  var _a, _b, _c;
  const n2 = t4.parsingOptions || {}, r3 = { delimiter: n2.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: n2.latitudeField, longitudeFieldName: n2.longitudeField } }, s4 = r3.layerDefinition = { name: Ct(t4.url, v) || "csv", drawingInfo: C, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: n2.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: n2.spatialReference || { wkid: 4326 } } }, a3 = s3(e), l2 = (_a = a3.next().value) == null ? void 0 : _a.trim(), c2 = (_b = a3.next().value) == null ? void 0 : _b.trim();
  if (!l2)
    throw new s2("csv-layer:empty-csv", "CSV is empty", { csv: e });
  const { delimiter: m3, locationInfo: d4 } = c(l2, c2, n2);
  if (!m3)
    throw new s2("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l2, secondLine: c2, parsingOptions: n2 });
  if (!d4)
    throw new s2("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l2, secondLine: c2, parsingOptions: n2 });
  r3.locationInfo = d4, r3.delimiter = m3;
  const { names: u3, aliases: p3 } = f3(l2, m3), f4 = p2(e, r3.delimiter, u3, p3, r3.locationInfo);
  if ((_c = n2.fields) == null ? void 0 : _c.length) {
    const e2 = new r(n2.fields);
    for (const t5 of f4) {
      const i3 = e2.get(t5.name);
      i3 && Object.assign(t5, i3);
    }
  }
  if (!f4.some((e2) => "esriFieldTypeOID" === e2.type && (s4.objectIdField = e2.name, true))) {
    const e2 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s4.objectIdField = e2.name, f4.unshift(e2);
  }
  s4.fields = f4;
  const y2 = new r(s4.fields);
  if (r3.locationInfo && (r3.locationInfo.latitudeFieldName = y2.get(r3.locationInfo.latitudeFieldName).name, r3.locationInfo.longitudeFieldName = y2.get(r3.locationInfo.longitudeFieldName).name), s4.timeInfo) {
    const e2 = s4.timeInfo;
    if (e2.startTimeField) {
      const t5 = y2.get(e2.startTimeField);
      t5 ? (e2.startTimeField = t5.name, t5.type = "esriFieldTypeDate") : e2.startTimeField = null;
    }
    if (e2.endTimeField) {
      const t5 = y2.get(e2.endTimeField);
      t5 ? (e2.endTimeField = t5.name, t5.type = "esriFieldTypeDate") : e2.endTimeField = null;
    }
    if (e2.trackIdField) {
      const t5 = y2.get(e2.trackIdField);
      e2.trackIdField = t5 ? t5.name : null;
    }
    e2.startTimeField || e2.endTimeField || (s4.timeInfo = null);
  }
  return r3;
}
export {
  k as default
};
//# sourceMappingURL=CSVSourceWorker-MARWFI7M.js.map
