import {
  T,
  _,
  c as c2,
  f as f5,
  g as g2,
  h as h2,
  m as m3,
  p as p2,
  r as r4,
  u as u5,
  x as x3
} from "./chunk-TOXOPWS2.js";
import {
  a as a5
} from "./chunk-55E4WCHV.js";
import {
  c,
  u as u4
} from "./chunk-PEYWLFGJ.js";
import {
  N,
  O,
  y as y2
} from "./chunk-TNXVIMSN.js";
import {
  B,
  h,
  r as r3
} from "./chunk-FNTT27FW.js";
import {
  I
} from "./chunk-AC3INPLN.js";
import {
  o as o2
} from "./chunk-A6DRT2G4.js";
import {
  E,
  a as a4,
  e as e2,
  o as o3,
  x as x2
} from "./chunk-4BRWSSYR.js";
import {
  r as r2
} from "./chunk-C7U2SKSO.js";
import {
  ee,
  i as i2,
  se,
  tt
} from "./chunk-GTENSI4J.js";
import {
  F as F2,
  H,
  P,
  R as R2,
  Y,
  j,
  te,
  x
} from "./chunk-3VTULECI.js";
import {
  U
} from "./chunk-PJP6JTP7.js";
import {
  S
} from "./chunk-TBHRKIAA.js";
import {
  X
} from "./chunk-JSMUQBPG.js";
import {
  F
} from "./chunk-BCDDCNQ2.js";
import {
  f as f4,
  g
} from "./chunk-D5EV57FM.js";
import {
  v as v2
} from "./chunk-PM3CFO6N.js";
import {
  $,
  C,
  dt,
  ht,
  ot
} from "./chunk-KKGVORR5.js";
import {
  t
} from "./chunk-M5UHI5WR.js";
import {
  L,
  d as d3
} from "./chunk-TQGXXOXA.js";
import {
  n as n2
} from "./chunk-KKBQS7Z3.js";
import {
  i as i3
} from "./chunk-FQZ2JEHK.js";
import {
  a as a3
} from "./chunk-LNMNRMVX.js";
import {
  u as u3
} from "./chunk-EIE3W25Z.js";
import {
  s as s4
} from "./chunk-KIEN3CY2.js";
import {
  f as f3,
  l as l2,
  m as m2,
  s as s3,
  u as u2,
  v
} from "./chunk-T4XWQYGC.js";
import {
  a as a2,
  o2 as o,
  p
} from "./chunk-TCASQSKO.js";
import {
  M,
  i,
  k,
  q,
  s as s2,
  u
} from "./chunk-5HAVROZG.js";
import {
  l
} from "./chunk-XN5VV437.js";
import {
  d as d2,
  f as f2
} from "./chunk-SFV6XLDZ.js";
import {
  m,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  d,
  f,
  s
} from "./chunk-HNHXEGH2.js";
import {
  r
} from "./chunk-DWOEYHKS.js";
import {
  R,
  has,
  n
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DirtyMap.js
var t2 = -1;
var e3 = class {
  constructor() {
    this._dirties = [{ vertexFrom: t2, vertexCount: t2, indexFrom: t2, indexCount: t2, allDirty: false }, { vertexFrom: t2, vertexCount: t2, indexFrom: t2, indexCount: t2, allDirty: false }, { vertexFrom: t2, vertexCount: t2, indexFrom: t2, indexCount: t2, allDirty: false }, { vertexFrom: t2, vertexCount: t2, indexFrom: t2, indexCount: t2, allDirty: false }, { vertexFrom: t2, vertexCount: t2, indexFrom: t2, indexCount: t2, allDirty: false }];
  }
  hasDirty() {
    return this._dirties.some((e9) => e9.indexCount !== t2 || e9.allDirty);
  }
  markAllClean() {
    for (const e9 of this._dirties)
      e9.indexFrom = t2, e9.indexCount = t2, e9.vertexFrom = t2, e9.vertexCount = t2, e9.allDirty = false;
  }
  markAllDirty() {
    for (const t7 of this._dirties)
      t7.allDirty = true;
  }
  forEach(e9) {
    for (let r8 = 0; r8 < this._dirties.length; ++r8) {
      const { indexCount: i5, indexFrom: o9, vertexCount: n6, vertexFrom: x5, allDirty: l4 } = this._dirties[r8], s8 = {};
      let d7, m5 = false;
      (l4 || x5 !== t2 && n6 > 0) && (s8.geometry = { count: n6, from: x5, allDirty: l4 }, m5 = true), (l4 || o9 !== t2 && i5 > 0) && (d7 = { count: i5, from: o9, allDirty: l4 }, m5 = true), m5 && e9({ indices: d7, vertices: s8 }, r8);
    }
  }
  markDirtyIndices(e9, r8, i5) {
    const o9 = this._dirties[e9], n6 = r8, x5 = i5;
    if (!o9.allDirty)
      if (o9.indexCount !== t2) {
        const t7 = Math.min(o9.indexFrom, n6), e10 = Math.max(o9.indexFrom + o9.indexCount, n6 + x5) - t7;
        o9.indexFrom = t7, o9.indexCount = e10;
      } else
        o9.indexFrom = n6, o9.indexCount = x5;
  }
  markDirtyVertices(e9, r8, i5, o9) {
    const n6 = this._dirties[e9], x5 = i5, l4 = o9;
    if (!n6.allDirty)
      if (n6.vertexCount !== t2) {
        const t7 = Math.min(n6.vertexFrom, x5), e10 = Math.max(n6.vertexFrom + n6.vertexCount, x5 + l4) - t7;
        n6.vertexFrom = t7, n6.vertexCount = e10;
      } else
        n6.vertexFrom = x5, n6.vertexCount = l4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/FreeList.js
var e4 = class {
  get largestRange() {
    return this._largestRange;
  }
  constructor(e9) {
    this._largestRange = null, this._parent = e9, this._updateLargestRange();
  }
  rangeCreated(e9) {
    (!this._largestRange || e9.count > this._largestRange.count) && (this._largestRange = e9);
  }
  rangeResized(e9, t7) {
    e9 === this._largestRange ? e9.count < t7 && this._updateLargestRange() : (!this._largestRange || e9.count > this._largestRange.count) && (this._largestRange = e9);
  }
  findBestRange(e9) {
    let t7 = this._parent._freeHead, n6 = null;
    for (; null !== t7; )
      t7.count >= e9 && (!n6 || t7.count - e9 < n6.count - e9) && (n6 = t7), t7 = t7.next;
    return n6;
  }
  findAdjacentRanges(e9, t7) {
    let n6 = true, r8 = false, s8 = null, o9 = this._parent._freeHead;
    for (; n6 && !r8; ) {
      const a7 = null !== s8 ? s8.from + s8.count : 0, l4 = null !== o9 ? o9.from : this._parent._size;
      e9 >= a7 && e9 + t7 <= l4 ? (n6 = false, r8 = true) : null !== o9 ? (s8 = o9, o9 = o9.next) : n6 = false;
    }
    return [s8, o9];
  }
  _updateLargestRange() {
    let e9 = null, t7 = this._parent._freeHead;
    for (; null !== t7; )
      (!e9 || t7.count > e9.count) && (e9 = t7), t7 = t7.next;
    this._largestRange = e9;
  }
};
var t3 = class _t {
  constructor(t7, n6) {
    this._allocated = 0, this._size = t7, this._freeHead = t7 > 0 ? { from: 0, count: t7, prev: null, next: null } : null, this._bookKeeper = n6 || new e4(this), this._freeHead && this._bookKeeper.rangeCreated(this._freeHead);
  }
  allocate(e9) {
    const n6 = this._bookKeeper.findBestRange(e9);
    if (null == n6)
      return -1;
    const r8 = n6.from, s8 = n6.count;
    if (n6.from += e9, n6.count -= e9, this._bookKeeper.rangeResized(n6, r8, s8), this._allocated += e9, 0 === n6.count) {
      const e10 = null !== n6.prev ? this._freeHead : n6.next;
      _t._removeRange(n6), this._freeHead = e10;
    }
    return r8;
  }
  free(e9, n6) {
    const [r8, s8] = this._bookKeeper.findAdjacentRanges(e9, n6), o9 = { from: e9, count: n6, prev: r8 ?? null, next: s8 ?? null };
    if (null != r8 && (r8.next = o9), null != s8 && (s8.prev = o9), this._bookKeeper.rangeCreated(o9), this._allocated -= n6, null != s8 && o9.from + o9.count === s8.from) {
      const e10 = o9.from, n7 = o9.count;
      _t._fuse(o9, s8), _t._removeRange(s8), this._bookKeeper.rangeResized(o9, e10, n7), this._bookKeeper.rangeResized(s8, void 0, 0);
    }
    if (null != r8 && r8.from + r8.count === o9.from) {
      const e10 = r8.from, n7 = r8.count;
      _t._fuse(r8, o9), _t._removeRange(o9), this._bookKeeper.rangeResized(r8, e10, n7), this._bookKeeper.rangeResized(o9, void 0, 0);
    }
    this._freeHead = null !== o9.prev ? this._freeHead : o9;
  }
  get fragmentation() {
    const e9 = this._size - this._allocated;
    if (0 === e9)
      return 0;
    return 1 - this._bookKeeper.largestRange.count / e9;
  }
  static _removeRange(e9) {
    null !== e9.prev ? null !== e9.next ? (e9.prev.next = e9.next, e9.next.prev = e9.prev) : e9.prev.next = null : null !== e9.next && (e9.next.prev = null);
  }
  static _fuse(e9, t7) {
    e9.count += t7.count, e9.next = t7.next, t7.from += t7.count, t7.count = 0, null !== t7.next && (t7.next.prev = e9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecordStore.js
var s5 = ["FILL", "LINE", "MARKER", "TEXT", "LABEL"];
function o4(e9) {
  const t7 = e9.getStrides(), r8 = {};
  for (let i5 = 0; i5 < t7.length; i5++)
    r8[s5[i5]] = t7[i5];
  return r8;
}
var n3 = 0.5;
var d4 = class _d {
  constructor(r8, i5, s8, o9) {
    this._strides = r8, this._displayList = i5, this._freeListsAndStorage = {}, this._dirtyMap = null, this._dirtyMap = s8;
    for (const n6 in r8) {
      this._freeListsAndStorage[n6] = { vtxFreeList: o9 ? new t3(o9) : null, idxFreeList: o9 ? new t3(o9) : null, vertexBuffers: {}, indexBuffer: o9 ? new Uint32Array(o9) : null };
      for (const e9 in r8[n6])
        this._freeListsAndStorage[n6].vertexBuffers[e9] = { data: o9 ? x(o9, r8[n6][e9]) : null, stride: r8[n6][e9] };
    }
  }
  static fromTileData(t7, i5) {
    var _a;
    const n6 = o4(t7), a7 = [0, 0, 0, 0, 0], x5 = [0, 0, 0, 0, 0];
    for (const e9 of t7.tileDisplayData.displayObjects)
      for (const t8 of e9.displayRecords)
        a7[t8.geometryType] = Math.max(a7[t8.geometryType], t8.vertexFrom + t8.vertexCount), x5[t8.geometryType] = Math.max(x5[t8.geometryType], t8.indexFrom + t8.indexCount);
    const u6 = new _d(n6, t7.tileDisplayData.displayList, i5, void 0), f9 = ((_a = t7.tileBufferData) == null ? void 0 : _a.geometries) ?? [];
    for (let o9 = 0; o9 < f9.length; ++o9) {
      const t8 = a7[o9], i6 = x5[o9], n7 = f9[o9], d7 = s5[o9], c3 = u6._storageFor(d7), l4 = f9[o9].indexBuffer;
      c3.indexBuffer = l4, c3.idxFreeList = new t3(l4.length), c3.idxFreeList.allocate(i6);
      let m5 = 0;
      for (const e9 in n7.vertexBuffer) {
        const t9 = f9[o9].vertexBuffer[e9];
        c3.vertexBuffers[e9].data = t9.data, c3.vertexBuffers[e9].stride = t9.stride;
        const i7 = F2(t9.stride), s8 = t9.data.length * i7 / t9.stride;
        m5 || (m5 = s8);
      }
      c3.vtxFreeList = new t3(m5), c3.vtxFreeList.allocate(t8);
    }
    return u6;
  }
  delete(e9) {
    const t7 = s5[e9.geometryType];
    this._freeVertices(t7, e9.vertexFrom, e9.vertexCount), this._freeIndices(t7, e9.indexFrom, e9.indexCount), this._displayList.removeFromList(e9), e9.vertexFrom = void 0, e9.indexFrom = void 0;
  }
  setMeshData(e9, t7, r8, o9, n6) {
    const d7 = s5[e9.geometryType];
    let a7, x5;
    e9.meshData = null, void 0 === e9.vertexFrom ? (x5 = t7.vertexCount, a7 = this._allocateVertices(d7, x5)) : t7.vertexCount > e9.vertexCount ? (this._freeVertices(d7, e9.vertexFrom, e9.vertexCount), x5 = t7.vertexCount, a7 = this._allocateVertices(d7, x5)) : t7.vertexCount === e9.vertexCount ? (a7 = e9.vertexFrom, x5 = e9.vertexCount) : (this._freeVertices(d7, e9.vertexFrom + t7.vertexCount, e9.vertexCount - t7.vertexCount), a7 = e9.vertexFrom, x5 = t7.vertexCount);
    let u6, f9, c3, l4 = true;
    if (void 0 === e9.indexFrom ? (u6 = n6, c3 = t7.indexCount, f9 = this._allocateIndices(d7, c3)) : t7.indexCount > e9.indexCount ? (u6 = this._displayList.removeFromList(e9), this._freeIndices(d7, e9.indexFrom, e9.indexCount), c3 = t7.indexCount, f9 = this._allocateIndices(d7, c3)) : t7.indexCount === e9.indexCount ? (l4 = false, f9 = e9.indexFrom, c3 = e9.indexCount) : (u6 = this._displayList.removeFromList(e9), this._freeIndices(d7, e9.indexFrom + t7.indexCount, e9.indexCount - t7.indexCount), f9 = e9.indexFrom, c3 = t7.indexCount), -1 !== a7 && -1 !== f9) {
      const s8 = this._storageFor(d7);
      if (j(a7, f9, s8.vertexBuffers, s8.indexBuffer, t7, r8, o9), e9.vertexFrom = a7, e9.indexFrom = f9, e9.vertexCount = t7.vertexCount, e9.indexCount = t7.indexCount, this._dirtyMap) {
        this._dirtyMap.markDirtyIndices(e9.geometryType, e9.indexFrom, e9.indexCount);
        for (const t8 in r8)
          this._dirtyMap.markDirtyVertices(e9.geometryType, t8, e9.vertexFrom, e9.vertexCount);
      }
      return l4 && this._displayList.addToList(e9, u6), true;
    }
    return -1 !== a7 && this._freeVertices(d7, a7, x5), -1 !== f9 && this._freeIndices(d7, f9, c3), e9.setMeshDataFromBuffers(t7, r8, o9), e9.vertexFrom = void 0, e9.vertexCount = 0, e9.indexFrom = void 0, e9.indexCount = 0, false;
  }
  tryAddMeshData(e9, t7) {
    const r8 = t7.vertexBuffer, o9 = t7.indexBuffer, n6 = s5[e9.geometryType], d7 = this._allocateVertices(n6, e9.vertexCount);
    if (-1 === d7)
      return this._freeVertices(n6, d7, e9.vertexCount), false;
    const a7 = this._allocateIndices(n6, e9.indexCount);
    if (-1 === a7)
      return this._freeVertices(n6, d7, e9.vertexCount), this._freeIndices(n6, a7, e9.indexCount), false;
    const x5 = this._storageFor(n6);
    if (j(d7, a7, x5.vertexBuffers, x5.indexBuffer, e9, r8, o9), e9.vertexFrom = d7, e9.indexFrom = a7, this._dirtyMap) {
      this._dirtyMap.markDirtyIndices(e9.geometryType, e9.indexFrom, e9.indexCount);
      for (const t8 in r8)
        this._dirtyMap.markDirtyVertices(e9.geometryType, t8, d7, e9.vertexCount);
    }
    return this._displayList.addToList(e9), true;
  }
  _allocateVertices(e9, t7) {
    var _a, _b;
    const r8 = this._storageFor(e9), i5 = (_a = r8.vtxFreeList) == null ? void 0 : _a.allocate(t7);
    if (null == i5 || -1 === i5)
      return -1;
    const s8 = (_b = r8.vtxFreeList) == null ? void 0 : _b.fragmentation;
    return null == s8 || s8 > n3 ? -1 : i5;
  }
  _freeVertices(e9, t7, r8) {
    var _a;
    const i5 = this._storageFor(e9);
    (_a = i5.vtxFreeList) == null ? void 0 : _a.free(t7, r8);
  }
  _freeIndices(e9, t7, r8) {
    var _a;
    const i5 = this._storageFor(e9);
    (_a = i5.idxFreeList) == null ? void 0 : _a.free(t7, r8);
  }
  _allocateIndices(e9, t7) {
    var _a, _b;
    const r8 = this._storageFor(e9), i5 = (_a = r8.idxFreeList) == null ? void 0 : _a.allocate(t7);
    if (null == i5 || -1 === i5)
      return -1;
    const s8 = (_b = r8.idxFreeList) == null ? void 0 : _b.fragmentation;
    return null == s8 || s8 > n3 ? -1 : i5;
  }
  _storageFor(e9) {
    return this._freeListsAndStorage[e9];
  }
  _stridesFor(e9, t7) {
    return this._strides[e9][t7];
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLBuffers.js
var o5 = class {
  constructor(a7) {
    this.geometryMap = H(() => ({ indexBuffer: c.createIndex(a7, F.STATIC_DRAW), vao: null }), (e9, s8) => ({ vertexBuffer: c.createVertex(a7, Y[s8]) }));
  }
  dispose() {
    var _a, _b, _c;
    for (let e9 = 0; e9 < 5; e9++) {
      const t7 = this.geometryMap[e9];
      if (t7) {
        (_a = t7.data.vao) == null ? void 0 : _a.disposeVAOOnly(), (_b = t7.data.indexBuffer) == null ? void 0 : _b.dispose();
        for (const e10 in t7.buffers)
          (_c = t7.buffers[e10]) == null ? void 0 : _c.data.vertexBuffer.dispose();
      }
    }
  }
  get(e9) {
    const t7 = this.geometryMap[e9];
    return { getVAO(e10, r8, s8) {
      if (!t7.data.vao) {
        const o9 = {};
        for (const e11 in t7.buffers)
          o9[e11] = t7.buffers[e11].data.vertexBuffer;
        t7.data.vao = new u4(e10, s8, r8, o9, t7.data.indexBuffer);
      }
      return t7.data.vao;
    } };
  }
  has(e9) {
    return null != this.geometryMap[e9];
  }
  upload(e9, t7) {
    t7.forEach((t8, r8) => {
      this._upload(t8, r8, e9);
    });
  }
  _upload(e9, t7, r8) {
    if (e9.indices && (e9.indices.allDirty ? this._uploadIndices(r8, t7) : null != e9.indices.from && null != e9.indices.count && this._uploadIndices(r8, t7, e9.indices.from, e9.indices.count)), e9.vertices) {
      const s8 = e9.vertices;
      for (const e10 in s8) {
        const a7 = s8[e10];
        a7.allDirty ? this._uploadVertices(r8, t7, e10) : null != a7.from && null != a7.count && this._uploadVertices(r8, t7, e10, a7.from, a7.count);
      }
    }
  }
  _uploadVertices(e9, t7, r8, s8, a7) {
    const o9 = this.geometryMap[t7];
    if (!o9)
      return;
    const f9 = e9.geometries[t7].vertexBuffer[r8];
    if (!f9)
      return;
    const { data: i5, stride: n6 } = f9;
    if (o9.buffers[r8] && i5.length > 0) {
      const e10 = n6 / i5.BYTES_PER_ELEMENT;
      null != s8 && null != a7 ? o9.buffers[r8].data.vertexBuffer.setSubData(i5, s8 * e10, s8 * e10, (s8 + a7) * e10) : o9.buffers[r8].data.vertexBuffer.setData(i5);
    }
  }
  _uploadIndices(e9, t7, r8, s8) {
    const a7 = this.geometryMap[t7];
    if (!a7)
      return;
    const o9 = e9.geometries[t7].indexBuffer;
    a7.data.indexBuffer && o9.length > 0 && (null != r8 && null != s8 ? a7.data.indexBuffer.setSubData(o9, r8, r8, r8 + s8) : a7.data.indexBuffer.setData(o9));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicTile.js
var a6 = class extends m3 {
  constructor() {
    super(...arguments), this._data = null, this._displayList = null, this._lastCommitTime = 0, this._hasData = false, this._invalidated = false, this._wglBuffers = null, this._dirtyMap = new e3();
  }
  destroy() {
    super.destroy(), this.clear();
  }
  get hasData() {
    return !!this._hasData;
  }
  get displayObjects() {
    return this._displayObjects ?? [];
  }
  getGeometry(t7) {
    return this._wglBuffers && this._wglBuffers.has(t7) ? this._wglBuffers.get(t7) : null;
  }
  getDisplayList() {
    return this._displayList;
  }
  patch(s8) {
    var _a2, _b;
    if (true === s8.clear)
      return this.clear(), void (this._hasData = false);
    const i5 = s8.addOrUpdate, a7 = s8.remove;
    !this._data && i5 && ((_a2 = i5.tileDisplayData) == null ? void 0 : _a2.displayObjects.length) ? (i5.tileDisplayData.computeDisplayList(), this._dirtyMap = new e3(), this._dispRecStore = d4.fromTileData(i5, this._dirtyMap), this._data = i5, this._dirtyMap.markAllDirty(), this._hasData = true, s8.end && this.ready()) : this._data && (i5 && ((_b = i5.tileDisplayData) == null ? void 0 : _b.displayObjects.length) || a7.length) ? this._doPatchData(s8) : s8.end && this.ready(), s8.end && !this._data && this.clear(), this.requestRender(), this.emit("change");
  }
  commit(t7) {
    t7.time && t7.time === this._lastCommitTime || (this._lastCommitTime = t7.time, this.visible && this._data && (this._wglBuffers || (this._wglBuffers = new o5(t7.context)), (this._dirtyMap.hasDirty() || this._invalidated) && (this._invalidated = false, this._wglBuffers.upload(this._data.tileBufferData, this._dirtyMap), this._displayList = this._data.tileDisplayData.displayList.clone(), this._displayObjects = this._data.tileDisplayData.displayObjects.slice(), this._dirtyMap.markAllClean())));
  }
  clear() {
    this._data = null, this._displayList = null, this._dispRecStore = null, this._wglBuffers && (this._wglBuffers.dispose(), this._wglBuffers = null);
  }
  _doPatchData(t7) {
    this._invalidated = true, this._patchData(t7) || (this._dirtyMap.markAllDirty(), this._data.reshuffle(), this._dispRecStore = d4.fromTileData(this._data, this._dirtyMap)), this.requestRender();
  }
  _patchData(t7) {
    let e9 = true;
    const s8 = t7.addOrUpdate && t7.addOrUpdate.tileDisplayData && t7.addOrUpdate.tileDisplayData.displayObjects || [], i5 = (t7.remove || []).slice();
    for (const r8 of s8)
      null != r8.insertAfter && i5.push(r8.id);
    let a7;
    i5.length > 0 && (a7 = new Set(i5));
    const l4 = this._data.tileDisplayData;
    for (const r8 of i5) {
      const t8 = l4.displayObjectRegistry.get(r8);
      if (t8) {
        l4.displayList.removeFromList(t8.displayRecords);
        for (const e10 of t8.displayRecords)
          this._dispRecStore.delete(e10);
        l4.displayObjectRegistry.delete(r8);
      }
    }
    (a7 == null ? void 0 : a7.size) && (l4.displayObjects = l4.displayObjects.filter((t8) => !a7.has(t8.id)));
    for (const r8 of s8) {
      let s9, i6 = l4.displayObjectRegistry.get(r8.id);
      if (i6) {
        const t8 = i6.displayRecords;
        i6.set(r8), i6.displayRecords = t8;
        const e10 = i6.displayRecords.length;
        for (let s10 = 0; s10 < e10; ++s10) {
          const t9 = i6.displayRecords[s10], e11 = r8.displayRecords[s10];
          (s10 >= r8.displayRecords.length || t9.geometryType !== e11.geometryType || t9.symbolLevel !== e11.symbolLevel || t9.zOrder !== e11.zOrder || t9.materialKey !== e11.materialKey) && (this._dispRecStore.delete(i6.displayRecords[s10]), s10 < r8.displayRecords.length && (i6.displayRecords[s10] = void 0));
        }
        i6.displayRecords.length = r8.displayRecords.length;
      } else {
        let t8;
        i6 = r8.copy(), i6.displayRecords = [], l4.displayObjectRegistry.set(r8.id, i6);
        const e10 = l4.displayObjects;
        if (null != i6.insertAfter)
          if (s9 = {}, i6.insertAfter >= 0) {
            const s10 = l4.displayObjectRegistry.get(i6.insertAfter);
            s10 ? (t8 = e10.indexOf(s10) + 1, t8 < e10.length ? e10.splice(t8, 0, i6) : (e10.push(i6), t8 = e10.length)) : (e10.push(i6), t8 = e10.length);
          } else
            e10.unshift(i6), t8 = 0;
        else
          e10.push(i6), t8 = e10.length;
        if (s9) {
          const i7 = r8.displayRecords.length > 0 ? 1 : 0;
          let a9 = 0;
          for (let r9 = t8 - 1; r9 >= 0 && a9 < i7; --r9)
            for (let t9 = e10[r9].displayRecords.length - 1; t9 >= 0 && a9 < i7; --t9) {
              const i8 = e10[r9].displayRecords[t9], d7 = l4.displayList.getDPInfoType();
              s9[d7] || (s9[d7] = i8, ++a9);
            }
        }
      }
      const a8 = r8.displayRecords.length;
      for (let d7 = 0; d7 < a8; ++d7) {
        const a9 = r8.displayRecords[d7];
        let o9 = i6.displayRecords[d7];
        o9 ? (o9.meshData = a9.meshData, o9.materialKey = a9.materialKey) : (o9 = a9.copy(), o9.vertexFrom = void 0, o9.indexFrom = void 0, i6.displayRecords[d7] = o9);
        const h4 = a9.geometryType, p6 = l4.displayList.getDPInfoType(), y6 = t7.addOrUpdate.tileBufferData.geometries[h4], c3 = y6.vertexBuffer, n6 = y6.indexBuffer;
        let f9;
        s9 && (f9 = s9[p6] ? l4.displayList.splitAfter(s9[p6]) : -1), e9 = this._dispRecStore.setMeshData(o9, a9, c3, n6, f9) && e9, s9 && null != o9.indexFrom && null != o9.indexFrom && (s9[p6] = o9);
      }
    }
    return e9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MemoryRequirements.js
var e5 = class {
  constructor() {
    this._byGeometryType = null;
  }
  get satisfied() {
    return !this._byGeometryType;
  }
  reset() {
    this._byGeometryType = null;
  }
  verticesFor(e9) {
    return this._byGeometryType ? this._byGeometryType[e9].vertices : 0;
  }
  indicesFor(e9) {
    return this._byGeometryType ? this._byGeometryType[e9].indices : 0;
  }
  needMore(e9, t7, i5) {
    if (!t7 && !i5)
      return;
    this._byGeometryType || (this._byGeometryType = [{ vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }, { vertices: 0, indices: 0 }]);
    const s8 = this._byGeometryType[e9];
    s8.vertices += t7, s8.indices += i5;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileBufferData.js
var r5 = 5;
var f6 = class _f {
  constructor() {
    this.geometries = [{ indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }, { indexBuffer: void 0, vertexBuffer: {} }];
  }
  clone() {
    const e9 = new _f();
    for (let r8 = 0; r8 < this.geometries.length; r8++) {
      const f9 = this.geometries[r8], t7 = e9.geometries[r8];
      t7.indexBuffer = f9.indexBuffer.slice(), t7.vertexBuffer = {};
      for (const e10 in f9.vertexBuffer) {
        const { data: r9, stride: i5 } = f9.vertexBuffer[e10];
        t7.vertexBuffer[e10] = { data: r9.slice(), stride: i5 };
      }
    }
    return e9;
  }
  static deserialize(t7) {
    const i5 = new _f();
    for (let f9 = 0; f9 < r5; ++f9) {
      i5.geometries[f9].indexBuffer = new Uint32Array(t7.geometries[f9].indexBuffer), i5.geometries[f9].vertexBuffer = {};
      for (const r8 in t7.geometries[f9].vertexBuffer)
        i5.geometries[f9].vertexBuffer[r8] = { data: P(t7.geometries[f9].vertexBuffer[r8].data, t7.geometries[f9].vertexBuffer[r8].stride), stride: t7.geometries[f9].vertexBuffer[r8].stride };
    }
    return i5;
  }
  serialize() {
    const e9 = { geometries: [{ indexBuffer: this.geometries[0].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[1].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[2].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[3].indexBuffer.buffer, vertexBuffer: {} }, { indexBuffer: this.geometries[4].indexBuffer.buffer, vertexBuffer: {} }] };
    for (let f9 = 0; f9 < r5; ++f9)
      for (const r8 in this.geometries[f9].vertexBuffer)
        e9.geometries[f9].vertexBuffer[r8] = { data: this.geometries[f9].vertexBuffer[r8].data.buffer, stride: this.geometries[f9].vertexBuffer[r8].stride };
    return e9;
  }
  getBuffers() {
    const e9 = [];
    for (let f9 = 0; f9 < r5; ++f9) {
      e9.push(this.geometries[f9].indexBuffer.buffer);
      for (const r8 in this.geometries[f9].vertexBuffer)
        e9.push(this.geometries[f9].vertexBuffer[r8].data.buffer);
    }
    return e9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GraphicDisplayList.js
function t4(e9, t7, n6, ...o9) {
  t7 < e9.length ? e9.splice(t7, n6, ...o9) : e9.push(...o9);
}
var n4 = class _n {
  constructor() {
    this.symbolLevels = [];
  }
  replay(t7, n6, o9) {
    for (const i5 of this.symbolLevels)
      for (const r8 of i5.zLevels) {
        const i6 = r8.geometryDPInfo.unified;
        if (i6)
          for (const r9 of i6) {
            const { geometryType: i7, materialKey: l4, indexFrom: s8, indexCount: m5 } = r9, y6 = U.load(l4).symbologyType, d7 = t7.painter.getBrush(i7, y6), u6 = { geometryType: i7, materialKey: l4, indexFrom: s8, indexCount: m5, target: n6.getGeometry(i7) };
            d7.prepareState(t7), d7.drawGeometry(t7, n6, u6, o9);
          }
      }
  }
  get empty() {
    return !this.symbolLevels || 0 === this.symbolLevels.length;
  }
  clear() {
    this.symbolLevels.length = 0;
  }
  addToList(e9, t7) {
    if (Array.isArray(e9))
      for (const n6 of e9)
        this._addToList(n6, t7);
    else
      this._addToList(e9, t7);
  }
  removeFromList(e9) {
    Array.isArray(e9) || (e9 = [e9]);
    let t7 = null;
    for (const n6 of e9)
      t7 = this._removeFromList(n6);
    return t7;
  }
  clone() {
    const e9 = new _n();
    for (const t7 of this.symbolLevels)
      e9.symbolLevels.push(t7.clone());
    return e9;
  }
  splitAfter(e9) {
    const t7 = this._getDisplayList(e9.symbolLevel, e9.zOrder), n6 = t7.length, i5 = e9.indexFrom + e9.indexCount;
    for (let r8 = 0; r8 < n6; ++r8) {
      const n7 = t7[r8];
      if (n7.geometryType === e9.geometryType && i5 > n7.indexFrom && i5 <= n7.indexFrom + n7.indexCount) {
        if (i5 < n7.indexFrom + n7.indexCount) {
          const e10 = new o6();
          e10.geometryType = n7.geometryType, e10.materialKey = n7.materialKey, e10.indexFrom = i5, e10.indexCount = n7.indexFrom + n7.indexCount - i5, t7.splice(r8 + 1, 0, e10), n7.indexCount = i5 - n7.indexFrom;
        }
        return r8;
      }
    }
  }
  _addToList(e9, n6) {
    const i5 = e9.symbolLevel, r8 = e9.zOrder, l4 = this._getDisplayList(i5, r8), s8 = null != n6 ? n6 : l4.length - 1, m5 = s8 >= 0 && s8 < l4.length ? l4[s8] : null;
    if (null !== m5 && m5.materialKey === e9.materialKey && m5.indexFrom + m5.indexCount === e9.indexFrom && m5.geometryType === e9.geometryType)
      m5.indexCount += e9.indexCount;
    else {
      const n7 = new o6();
      n7.indexFrom = e9.indexFrom, n7.indexCount = e9.indexCount, n7.materialKey = e9.materialKey, n7.geometryType = e9.geometryType, t4(l4, s8 + 1, 0, n7);
    }
  }
  _removeFromList(e9) {
    const n6 = e9.symbolLevel, i5 = e9.zOrder, r8 = this._getDisplayList(n6, i5), l4 = r8.length;
    let s8;
    for (let t7 = 0; t7 < l4; ++t7) {
      const n7 = r8[t7];
      if (e9.indexFrom + e9.indexCount > n7.indexFrom && e9.indexFrom < n7.indexFrom + n7.indexCount && n7.geometryType === e9.geometryType) {
        s8 = t7;
        break;
      }
    }
    if (void 0 !== s8) {
      const n7 = r8[s8];
      if (e9.indexFrom === n7.indexFrom)
        return n7.indexCount -= e9.indexCount, n7.indexFrom += e9.indexCount, 0 === n7.indexCount && t4(r8, s8, 1), s8 - 1;
      if (e9.indexFrom + e9.indexCount === n7.indexFrom + n7.indexCount)
        return n7.indexCount -= e9.indexCount, 0 === n7.indexCount ? (t4(r8, s8, 1), s8 - 1) : s8;
      {
        const i6 = n7.indexFrom, l5 = e9.indexFrom - n7.indexFrom, m5 = e9.indexCount, y6 = n7.indexFrom + n7.indexCount - (e9.indexFrom + e9.indexCount);
        n7.indexCount = l5;
        const d7 = new o6();
        return d7.geometryType = n7.geometryType, d7.materialKey = n7.materialKey, d7.indexFrom = i6 + l5 + m5, d7.indexCount = y6, t4(r8, s8 + 1, 0, d7), s8;
      }
    }
    return null;
  }
  _getDisplayList(e9, t7) {
    let n6;
    const o9 = this.symbolLevels.length;
    for (let i5 = 0; i5 < o9; i5++)
      if (this.symbolLevels[i5].symbolLevel === e9) {
        n6 = this.symbolLevels[i5];
        break;
      }
    let s8;
    n6 || (n6 = new l3(), n6.symbolLevel = e9, this.symbolLevels.push(n6));
    const m5 = n6.zLevels.length;
    for (let i5 = 0; i5 < m5; i5++)
      if (n6.zLevels[i5].zLevel === t7) {
        s8 = n6.zLevels[i5];
        break;
      }
    return s8 || (s8 = new r6(), s8.geometryDPInfo = new i4(), s8.zLevel = t7, n6.zLevels.push(s8)), s8.geometryDPInfo.unified || (s8.geometryDPInfo.unified = []), s8.geometryDPInfo.unified;
  }
  getDPInfoType() {
    return "unified";
  }
};
var o6 = class _o {
  constructor() {
    this.materialKey = null, this.indexFrom = 0, this.indexCount = 0;
  }
  clone() {
    const e9 = new _o();
    return e9.geometryType = this.geometryType, e9.materialKey = this.materialKey, e9.indexFrom = this.indexFrom, e9.indexCount = this.indexCount, e9;
  }
};
var i4 = class _i {
  constructor() {
    this.fill = null, this.line = null, this.marker = null, this.text = null, this.label = null, this.unified = null;
  }
  clone() {
    const e9 = new _i();
    return e9.fill = this.fill && this.fill.map((e10) => e10.clone()), e9.line = this.line && this.line.map((e10) => e10.clone()), e9.marker = this.marker && this.marker.map((e10) => e10.clone()), e9.text = this.text && this.text.map((e10) => e10.clone()), e9.label = this.label && this.label.map((e10) => e10.clone()), e9.unified = this.unified && this.unified.map((e10) => e10.clone()), e9;
  }
};
var r6 = class _r {
  constructor() {
    this.geometryDPInfo = new i4();
  }
  clone() {
    const e9 = new _r();
    return e9.zLevel = this.zLevel, e9.geometryDPInfo = this.geometryDPInfo.clone(), e9;
  }
};
var l3 = class _l {
  constructor() {
    this.zLevels = [];
  }
  clone() {
    const e9 = new _l();
    e9.symbolLevel = this.symbolLevel;
    for (const t7 of this.zLevels)
      e9.zLevels.push(t7.clone());
    return e9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MeshData.js
var t5 = class {
  constructor() {
    this.vertexData = /* @__PURE__ */ new Map(), this.vertexCount = 0, this.indexData = [];
  }
  clear() {
    this.vertexData.clear(), this.vertexCount = 0, this.indexData = [];
  }
  update(t7, e9, a7) {
    for (const s8 in t7)
      this.vertexData.set(s8, t7[s8]);
    for (const s8 in this.vertexData)
      null === t7[s8] && this.vertexData.delete(s8);
    this.vertexCount = e9, this.indexData = a7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayRecord.js
var s6 = class _s {
  constructor(t7, e9, s8, i5 = 0, r8 = 0) {
    this.id = t7, this.geometryType = e9, this.materialKey = s8, this.minZoom = i5, this.maxZoom = r8, this.meshData = null, this.symbolLevel = 0, this.zOrder = 0, this.vertexFrom = 0, this.vertexCount = 0, this.indexFrom = 0, this.indexCount = 0, this._sortKey = null;
  }
  get sortKey() {
    return null == this._sortKey && this._computeSortKey(), this._sortKey;
  }
  clone() {
    return this.copy();
  }
  copy() {
    const t7 = new _s(this.id, this.geometryType, this.materialKey);
    return t7.vertexFrom = this.vertexFrom, t7.vertexCount = this.vertexCount, t7.indexFrom = this.indexFrom, t7.indexCount = this.indexCount, t7.zOrder = this.zOrder, t7.symbolLevel = this.symbolLevel, t7.meshData = this.meshData, t7.minZoom = this.minZoom, t7.maxZoom = this.maxZoom, t7;
  }
  setMeshDataFromBuffers(s8, i5, r8) {
    const o9 = new t5();
    for (const t7 in i5) {
      const r9 = i5[t7].stride, a7 = i5[t7].data;
      if (!a7)
        continue;
      const h4 = [], n6 = F2(r9);
      for (let t8 = 0; t8 < r9 * s8.vertexCount / n6; ++t8)
        h4[t8] = a7[t8 + r9 * s8.vertexFrom / n6];
      o9.vertexData.set(t7, h4);
    }
    o9.indexData.length = 0;
    for (let t7 = 0; t7 < s8.indexCount; ++t7)
      o9.indexData[t7] = r8[t7 + s8.indexFrom] - s8.vertexFrom;
    o9.vertexCount = s8.vertexCount, this.meshData = o9;
  }
  readMeshDataFromBuffers(s8, i5) {
    this.meshData ? this.meshData.clear() : this.meshData = new t5();
    for (const t7 in s8) {
      const i6 = s8[t7].stride, r8 = s8[t7].data, o9 = [], a7 = F2(i6);
      for (let t8 = 0; t8 < i6 * this.vertexCount / a7; ++t8)
        o9[t8] = r8[t8 + i6 * this.vertexFrom / a7];
      this.meshData.vertexData.set(t7, o9);
    }
    this.meshData.indexData.length = 0;
    for (let t7 = 0; t7 < this.indexCount; ++t7)
      this.meshData.indexData[t7] = i5[t7 + this.indexFrom] - this.vertexFrom;
    this.meshData.vertexCount = this.vertexCount;
  }
  writeMeshDataToBuffers(t7, s8, i5, r8) {
    if (this.meshData) {
      for (const i6 in s8) {
        const r9 = s8[i6].stride, o9 = this.meshData.vertexData.get(i6), a7 = s8[i6].data, h4 = F2(r9);
        for (let e9 = 0; e9 < r9 * this.meshData.vertexCount / h4; ++e9)
          a7[e9 + r9 * t7 / h4] = o9[e9];
      }
      for (let e9 = 0; e9 < this.meshData.indexData.length; ++e9)
        r8[e9 + i5] = this.meshData.indexData[e9] + t7;
      this.vertexFrom = t7, this.vertexCount = this.meshData.vertexCount, this.indexFrom = i5, this.indexCount = this.meshData.indexData.length;
    }
  }
  static writeAllMeshDataToBuffers(t7, e9, s8) {
    let i5 = 0, r8 = 0;
    for (const o9 of t7)
      o9.writeMeshDataToBuffers(i5, e9, r8, s8), i5 += o9.vertexCount, r8 += o9.indexCount;
  }
  _computeSortKey() {
    this._sortKey = (31 & this.symbolLevel) << 12 | (127 & this.zOrder) << 4 | 7 & this.geometryType;
  }
  serialize(t7) {
    return t7.push(this.geometryType), t7.push(this.materialKey), t7.push(this.vertexFrom), t7.push(this.vertexCount), t7.push(this.indexFrom), t7.push(this.indexCount), t7.push(this.minZoom), t7.push(this.maxZoom), t7;
  }
  static deserialize(t7, e9) {
    const i5 = t7.readInt32(), r8 = t7.readInt32(), o9 = new _s(e9.id, i5, r8);
    return o9.vertexFrom = t7.readInt32(), o9.vertexCount = t7.readInt32(), o9.indexFrom = t7.readInt32(), o9.indexCount = t7.readInt32(), o9.minZoom = t7.readInt32(), o9.maxZoom = t7.readInt32(), o9;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e6(e9, n6) {
  if (null !== n6) {
    e9.push(n6.length);
    for (const r8 of n6)
      r8.serialize(e9);
    return e9;
  }
  e9.push(0);
}
function n5(e9, n6, r8) {
  const t7 = e9.readInt32(), o9 = new Array(t7);
  for (let i5 = 0; i5 < o9.length; i5++)
    o9[i5] = n6.deserialize(e9, r8);
  return o9;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/WGLDisplayObject.js
var e7 = class _e {
  constructor(s8) {
    this.insertAfter = null, this.id = s8, this.displayRecords = [];
  }
  copy() {
    const s8 = new _e(this.id);
    return s8.set(this), s8;
  }
  clone() {
    const s8 = new _e(this.id);
    return s8.displayRecords = this.displayRecords.map((s9) => s9.clone()), s8.insertAfter = this.insertAfter, s8;
  }
  set(s8) {
    this.id = s8.id, this.displayRecords = s8.displayRecords, this.insertAfter = s8.insertAfter;
  }
  serialize(s8) {
    return s8.push(this.id), e6(s8, this.displayRecords), s8;
  }
  static deserialize(i5) {
    const r8 = i5.readInt32(), d7 = new _e(r8), o9 = { id: r8 };
    return d7.displayRecords = n5(i5, s6, o9) ?? [], d7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileDisplayData.js
var e8 = class _e {
  constructor() {
    this.displayObjects = [], this._displayList = null;
  }
  get displayObjectRegistry() {
    if (!this._displayObjectRegistry) {
      this._displayObjectRegistry = /* @__PURE__ */ new Map();
      for (const s8 of this.displayObjects)
        this._displayObjectRegistry.set(s8.id, s8);
    }
    return this._displayObjectRegistry;
  }
  get displayList() {
    return this._displayList;
  }
  computeDisplayList() {
    this._displayList = new n4();
    for (const s8 of this.displayObjects)
      for (const t7 of s8.displayRecords)
        this._displayList.addToList(t7);
  }
  clone() {
    const s8 = new _e();
    return this.displayObjects && (s8.displayObjects = this.displayObjects.map((s9) => s9.clone())), s8;
  }
  serialize(s8) {
    return e6(s8, this.displayObjects), s8;
  }
  _deserializeObjects(s8) {
    const i5 = s8.readInt32(), e9 = new Array(i5), a7 = /* @__PURE__ */ new Map();
    for (let l4 = 0; l4 < e9.length; ++l4) {
      const i6 = e7.deserialize(s8);
      e9[l4] = i6, a7.set(i6.id, i6);
    }
    this.displayObjects = e9, this._displayList = null, this._displayObjectRegistry = a7;
  }
  static deserialize(s8) {
    const t7 = new _e();
    return t7._deserializeObjects(s8), t7;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexBuffer.js
var t6 = class _t {
  constructor(e9, t7) {
    this.data = e9, this.stride = t7;
  }
  static decode(r8) {
    const s8 = P(r8.data, r8.stride), n6 = r8.stride;
    return new _t(s8, n6);
  }
  static fromVertexVector(r8) {
    const s8 = P(r8.data.buffer(), r8.stride), n6 = r8.stride;
    return new _t(s8, n6);
  }
};
var r7 = class _r {
  constructor(e9, t7, r8) {
    this.geometryType = e9, this.indexBuffer = new Uint32Array(t7), this.namedBuffers = r8;
  }
  static decode(e9) {
    const s8 = e9.geometryType, n6 = e9.indexBuffer, o9 = {};
    for (const r8 in e9.namedBuffers)
      o9[r8] = t6.decode(e9.namedBuffers[r8]);
    return new _r(s8, n6, o9);
  }
  static fromVertexData(s8, n6) {
    const o9 = s8.indices, c3 = P(s8.vertices, s8.stride), i5 = s8.stride, d7 = { geometry: new t6(c3, i5) };
    return new _r(n6, o9, d7);
  }
  static fromVertexVectors(e9) {
    const s8 = e9.geometryType, n6 = e9.indexVector.buffer(), o9 = {};
    let c3;
    for (c3 in e9.namedVectors)
      o9[c3] = t6.fromVertexVector(e9.namedVectors[c3]);
    return new _r(s8, n6, o9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexVector.js
var s7 = class {
  get vertexCount() {
    const t7 = this.stride / 4, e9 = this.data.length / t7;
    return e9 !== (0 | e9) && console.debug("Corrupted stride"), e9;
  }
  constructor(t7, e9) {
    this.data = t7, this.stride = e9;
  }
  transfer(t7, e9) {
    const r8 = this.data.buffer();
    t7.vertexCount = this.vertexCount, t7.data = r8, t7.stride = this.stride, e9.push(r8);
  }
};
var o7 = class {
  constructor(e9, o9, n6) {
    this.geometryType = e9, this.indexVector = new e2(Uint32Array, 6 * o9), this.namedVectors = {};
    const i5 = R2(e9, n6);
    for (const t7 in i5) {
      const e10 = i5[t7];
      let n7;
      switch (e10 % 4) {
        case 0:
        case 2:
          n7 = new e2(Uint32Array, e10 * o9);
          break;
        case 1:
        case 3:
          n7 = new e2(Uint8Array, e10 * o9);
      }
      this.namedVectors[t7] = new s7(n7, e10);
    }
  }
  get(t7) {
    return this.namedVectors[t7].data;
  }
  getVector(t7) {
    return this.namedVectors[t7];
  }
  transfer(t7, e9) {
    const r8 = this.indexVector.buffer(), s8 = {};
    let o9;
    for (o9 in e9.push(r8), this.namedVectors) {
      const t8 = this.namedVectors[o9];
      s8[o9] = {}, t8.transfer(s8[o9], e9);
    }
    t7.geometryType = this.geometryType, t7.indexBuffer = r8, t7.namedBuffers = s8, this.destroy();
  }
  intoBuffers() {
    const t7 = r7.fromVertexVectors(this);
    return this.destroy(), t7;
  }
  destroy() {
    this.indexVector = null, this.namedVectors = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TileData.js
var d5 = new e5();
var p3 = new e5();
var D = 5;
function h3(e9, t7) {
  const r8 = {};
  for (const s8 in e9) {
    const i5 = { data: x(t7, e9[s8]), stride: e9[s8] };
    r8[s8] = i5;
  }
  return r8;
}
function x4(e9) {
  return [e9.fill || {}, e9.line || {}, e9.icon || {}, e9.text || {}, e9.label || {}];
}
function y3(e9) {
  const t7 = [[], [], [], [], []], r8 = e9;
  for (const s8 of r8)
    for (const e10 of s8.displayRecords)
      t7[e10.geometryType].push(e10);
  return t7;
}
var B2 = class _B {
  constructor() {
    this.tileDisplayData = null, this.tileBufferData = null;
  }
  reshuffle() {
    var _a, _b, _c;
    if (d5.reset(), !this.tileDisplayData)
      return;
    const t7 = y3(this.tileDisplayData.displayObjects);
    for (const e9 of t7)
      for (const t8 of e9)
        t8 && d5.needMore(t8.geometryType, t8.meshData ? t8.meshData.vertexCount : t8.vertexCount, t8.meshData ? t8.meshData.indexData.length : t8.indexCount);
    const r8 = t7.length, i5 = new f6();
    for (let s8 = 0; s8 < r8; ++s8) {
      i5.geometries[s8].indexBuffer = new Uint32Array(Math.round(n * d5.indicesFor(s8)));
      const t8 = [], r9 = (_a = this.tileBufferData) == null ? void 0 : _a.geometries[s8].vertexBuffer;
      if (!r9)
        continue;
      for (const e9 in r9)
        t8.push(r9[e9].stride);
      const a7 = _B._computeVertexAlignment(t8), n7 = Math.round(n * d5.verticesFor(s8)), f10 = _B._align(n7, a7);
      for (const e9 in r9) {
        const t9 = r9[e9].stride;
        i5.geometries[s8].vertexBuffer[e9] = { stride: t9, data: x(f10, t9) };
      }
    }
    p3.reset(), (_b = this.tileDisplayData.displayList) == null ? void 0 : _b.clear();
    for (let e9 = 0; e9 < r8; ++e9) {
      const r9 = t7[e9];
      for (const t8 of r9) {
        if (t8.meshData)
          t8.writeMeshDataToBuffers(p3.verticesFor(e9), i5.geometries[e9].vertexBuffer, p3.indicesFor(e9), i5.geometries[e9].indexBuffer), t8.meshData = null;
        else {
          const r10 = (_c = this.tileBufferData) == null ? void 0 : _c.geometries[e9];
          if (r10) {
            const s8 = r10.vertexBuffer, o9 = r10.indexBuffer, n7 = i5.geometries[e9].vertexBuffer, f10 = i5.geometries[e9].indexBuffer, l4 = p3.verticesFor(e9), u6 = p3.indicesFor(e9);
            j(l4, u6, n7, f10, t8, s8, o9), t8.vertexFrom = l4, t8.indexFrom = u6;
          }
        }
        p3.needMore(e9, t8.vertexCount, t8.indexCount);
      }
    }
    const { displayList: n6, displayObjects: f9 } = this.tileDisplayData;
    if (n6)
      for (const e9 of f9)
        n6.addToList(e9.displayRecords);
    this.tileBufferData = i5;
  }
  getStrides() {
    var _a;
    const e9 = [], t7 = (_a = this.tileBufferData) == null ? void 0 : _a.geometries;
    if (!t7)
      return e9;
    for (let r8 = 0; r8 < t7.length; ++r8) {
      const s8 = t7[r8];
      e9[r8] = {};
      for (const t8 in s8.vertexBuffer)
        e9[r8][t8] = s8.vertexBuffer[t8].stride;
    }
    return e9;
  }
  clone() {
    var _a, _b;
    const e9 = new _B();
    return e9.tileBufferData = ((_a = this.tileBufferData) == null ? void 0 : _a.clone()) ?? null, e9.tileDisplayData = ((_b = this.tileDisplayData) == null ? void 0 : _b.clone()) ?? null, e9;
  }
  _guessSize() {
    var _a;
    const e9 = ((_a = this.tileDisplayData) == null ? void 0 : _a.displayObjects) ?? [], t7 = Math.min(e9.length, 4), r8 = 12, s8 = 40;
    let i5 = 0;
    for (let o9 = 0; o9 < t7; o9++)
      i5 = Math.max(i5, e9[o9].displayRecords.length);
    return 2 * (e9.length * r8 + e9.length * i5 * s8);
  }
  serialize() {
    const e9 = this.tileBufferData.serialize(), t7 = this.tileBufferData.getBuffers(), r8 = this.tileDisplayData.serialize(new e2(Int32Array, this._guessSize())).buffer();
    return t7.push(r8), { result: { displayData: r8, bufferData: e9 }, transferList: t7 };
  }
  static fromVertexData(e9, r8) {
    const s8 = {}, i5 = /* @__PURE__ */ new Map();
    for (const t7 of r8)
      i5.set(t7.id, t7);
    return te((r9) => {
      const o9 = e9.data[r9];
      if (null != o9) {
        const e10 = r4.from(o9.records).getCursor();
        for (; e10.next(); ) {
          const t7 = e10.id, s9 = e10.materialKey, o10 = e10.indexFrom, a7 = e10.indexCount, n6 = e10.vertexFrom, l4 = e10.vertexCount, u6 = i5.get(t7), c3 = new s6(t7, r9, s9);
          c3.indexFrom = o10, c3.indexCount = a7, c3.vertexFrom = n6, c3.vertexCount = l4, u6.displayRecords.push(c3);
        }
        s8[r9] = r7.fromVertexData(o9, r9);
      } else
        s8[r9] = new o7(r9, 0, S.DEFAULT).intoBuffers();
    }), _B.fromMeshData({ displayObjects: r8, vertexBuffersMap: s8 });
  }
  static fromMeshData(e9) {
    const t7 = new _B(), r8 = new e8(), o9 = new f6();
    r8.displayObjects = e9.displayObjects;
    for (const s8 in e9.vertexBuffersMap) {
      const t8 = s8, r9 = e9.vertexBuffersMap[t8];
      o9.geometries[t8].indexBuffer = r9.indexBuffer, o9.geometries[t8].vertexBuffer = r9.namedBuffers;
    }
    return t7.tileDisplayData = r8, t7.tileBufferData = o9, t7;
  }
  static bind(e9, t7) {
    const r8 = new _B();
    return r8.tileDisplayData = e9, r8.tileBufferData = t7, r8;
  }
  static create(e9, t7) {
    const r8 = new _B();
    r8.tileDisplayData = new e8(), r8.tileDisplayData.displayObjects = e9;
    const o9 = [0, 0, 0, 0, 0], a7 = [0, 0, 0, 0, 0], n6 = [[], [], [], [], []];
    for (const s8 of e9)
      for (const e10 of s8.displayRecords)
        n6[e10.geometryType].push(e10), o9[e10.geometryType] += e10.meshData.vertexCount, a7[e10.geometryType] += e10.meshData.indexData.length;
    const l4 = new f6(), u6 = x4(t7);
    for (let s8 = 0; s8 < D; s8++) {
      const e10 = new Uint32Array(a7[s8]), t8 = h3(u6[s8], o9[s8]);
      s6.writeAllMeshDataToBuffers(n6[s8], t8, e10), l4.geometries[s8] = { indexBuffer: e10, vertexBuffer: t8 };
    }
    return r8.tileBufferData = l4, r8;
  }
  static _align(e9, t7) {
    const r8 = e9 % t7;
    return 0 === r8 ? e9 : e9 + (t7 - r8);
  }
  static _computeVertexAlignment(e9) {
    let t7 = false, r8 = false;
    for (const s8 of e9)
      s8 % 4 == 2 ? t7 = true : s8 % 4 != 0 && (r8 = true);
    return r8 ? 4 : t7 ? 2 : 1;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var o8 = class _o extends h {
  static from(s8, n6, i5) {
    const c3 = I.createInstance(), u6 = [], a7 = s8.filter((r8) => !!r8.geometry);
    for (const e9 of a7) {
      const s9 = v(e9.geometry);
      ot(u6, [e9], s9, false, false, n6);
    }
    return new _o(c3, u6, i5);
  }
  constructor(r8, t7, e9) {
    super(r8, t7, null), this._transform = e9;
  }
  get geometryType() {
    const r8 = this._current;
    return r8 ? r8.geometryType : null;
  }
  get insertAfter() {
    return this._current.insertAfter;
  }
  readGraphic() {
    return this._current;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const r8 = new _o(this.instance, this._features, this._transform);
    return this.copyInto(r8), r8;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var p4 = new t();
var y4 = new t();
var g3 = "esriGeometryPolyline";
function f7(t7) {
  t7.coords.length = 0, t7.lengths.length = 0;
}
var d6 = class _d {
  constructor() {
    this.bounds = i(), this.graphic = null;
  }
  static acquire(t7 = null, e9, s8, r8, i5) {
    let o9;
    return 0 === _d._pool.length ? o9 = new _d() : (o9 = _d._pool.pop(), this._set.delete(o9)), o9.acquire(t7, e9, s8, r8, i5), o9;
  }
  static release(t7) {
    t7 && !this._set.has(t7) && (t7.release(), this._pool.push(t7), this._set.add(t7));
  }
  static getCentroidQuantized(t7, e9) {
    if (f3(t7.geometry)) {
      const r8 = t7.symbol;
      if (null == r8)
        return null;
      if ((r8 == null ? void 0 : r8.layers.length) > 0 && r8.layers.some((t8) => "text" === t8.type || "marker" === t8.type)) {
        const r9 = o(t7.geometry);
        return null !== r9 ? L(e9, {}, { x: r9[0], y: r9[1] }, false, false) : null;
      }
    }
    return null;
  }
  acquire(t7 = null, e9, s8, r8, i5) {
    t7 && this.set(t7, e9, s8, r8, i5);
  }
  release() {
    this.graphic = null, this.symbolResource = null, this.geometry = null;
  }
  get symbol() {
    return this.symbolResource.symbol;
  }
  set(t7, e9, s8, r8, i5) {
    this.graphic = t7, this.geometry = s8, this.symbolResource = e9, this.bounds = r8, i5 && (this.size = i5);
  }
  getGeometryQuantized(t7, s8, r8, o9) {
    const c3 = this.geometry, d7 = v(c3);
    if (null == d7)
      return null;
    switch (d7) {
      case "esriGeometryPolygon": {
        const e9 = c3, { rings: s9 } = e9;
        if (!s9 || 0 === s9.length)
          return null;
        let r9;
        if (r9 = 1 === s9.length && 2 === s9[0].length ? d3(t7, { paths: [[s9[0][0], s9[0][1]]] }) : d3(t7, this.geometry), !r9) {
          const e10 = { x: s9[0][0][0], y: s9[0][0][1] };
          if (r9 = d3(t7, e10), r9) {
            const { x: t8, y: e11 } = r9;
            return { rings: [[[t8 - 1, e11], [1, -1], [1, 1], [-1, 1], [-1, -1]]] };
          }
        }
        return r9;
      }
      case "esriGeometryPolyline": {
        const e9 = c3;
        f7(p4), f7(y4);
        const s9 = e9.hasZ ?? false, r9 = e9.hasM ?? false;
        return C(p4, e9), dt(y4, p4, s9, r9, g3, t7.scale[0]), ht(p4, y4, s9, r9, g3, t7), $(p4, e9.hasZ ?? false, e9.hasM ?? false);
      }
      case "esriGeometryMultipoint": {
        const i5 = c3, u6 = 0.5 * o9 * Math.max(Math.abs(this.size[0]) + this.size[2] - this.size[0], Math.abs(this.size[1]) + this.size[3] - this.size[1]), h4 = d2(r8);
        let a7 = i5.points;
        if (h4) {
          const [t8, r9] = h4.valid, i6 = r9 - t8;
          a7 = a7.filter((o10) => {
            if (o10[0] + u6 > r9 || o10[0] - u6 < t8) {
              const t9 = [...o10];
              return o10[0] + u6 > r9 ? t9[0] -= i6 : t9[0] += i6, k(s8, o10, u6) || k(s8, t9, u6);
            }
            return k(s8, o10, u6);
          });
        }
        return 0 === a7.length ? { points: a7 } : d3(t7, { points: a7 });
      }
    }
    return d3(t7, this.geometry);
  }
};
d6._pool = [], d6._set = /* @__PURE__ */ new Set();

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var m4 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
var p5 = i();
var g4 = 1e-5;
function f8(e9, t7, i5, r8, s8) {
  return m4.minX = t7, m4.minY = i5, m4.maxX = r8, m4.maxY = s8, e9.search(m4);
}
function _2(e9) {
  return { minX: e9.bounds[0], minY: e9.bounds[1], maxX: e9.bounds[2], maxY: e9.bounds[3] };
}
var b = class {
  constructor(e9, i5, r8, s8, o9, n6, l4) {
    this._graphics = s8, this._onAdd = o9, this._onRemove = n6, this._hashToCIM = l4, this._index = i3(9, _2), this._itemByGraphic = /* @__PURE__ */ new Map(), this._inflatedSizeHelper = new se(), this._tileInfoView = e9, this._uidFieldName = r8;
    const u6 = e9.getClosestInfoForScale(i5);
    u6 && (this._resolution = this._tileInfoView.getTileResolution(u6.level));
  }
  setResourceManager(e9) {
    this._cimResourceManager = e9, this._hittestDrawHelper = new tt(e9);
  }
  hitTest(e9, t7, s8, o9, l4) {
    var _a;
    e9 = v2(e9, this._tileInfoView.spatialReference);
    const u6 = 0.5 * o9 * window.devicePixelRatio * s8;
    p5[0] = e9 - u6, p5[1] = t7 - u6, p5[2] = e9 + u6, p5[3] = t7 + u6;
    const h4 = 0.5 * o9 * (s8 + f5), a7 = f8(this._index, e9 - h4, t7 - h4, e9 + h4, t7 + h4);
    if (!a7 || 0 === a7.length)
      return [];
    const d7 = [], m5 = i(), g5 = i();
    for (const i5 of a7) {
      const { geometry: e10, symbolResource: t8 } = i5;
      this._getSymbolBounds(m5, t8, e10, g5, l4), g5[3] = g5[2] = g5[1] = g5[0] = 0, q(m5, p5) && ((_a = i5.graphic) == null ? void 0 : _a.visible) && d7.push(i5);
    }
    if (0 === d7.length)
      return [];
    const _3 = this._hittestDrawHelper, b2 = [];
    for (const i5 of d7) {
      const { geometry: e10, symbolResource: t8 } = i5, { hash: r8, textInfo: s9 } = t8, n6 = this._hashToCIM.get(r8);
      n6 && (_3.hitTest(p5, n6.symbol, e10, s9, l4, o9) && b2.push(i5));
    }
    return b2.sort(y5), b2.map((e10) => e10.graphic);
  }
  getGraphicsData(e9, t7, i5) {
    const r8 = this._searchForItems(t7);
    if (0 === r8.length || 0 === i5.length)
      return [];
    r8.sort((e10, t8) => e10.zorder - t8.zorder), r8[0].insertAfter = -1;
    for (let a7 = 1; a7 < r8.length; a7++)
      r8[a7].insertAfter = r8[a7 - 1].graphic.uid;
    r8.sort((e10, t8) => e10.graphic.uid - t8.graphic.uid), i5.sort((e10, t8) => e10.uid - t8.uid);
    let s8, o9 = 0, n6 = 0;
    const l4 = t7.resolution, u6 = [], h4 = { originPosition: "upperLeft", scale: [l4, l4], translate: [t7.bounds[0], t7.bounds[3]] };
    for (const c3 of i5) {
      for (n6 = -2; o9 < r8.length; )
        if (s8 = r8[o9], o9++, c3.uid === s8.graphic.uid) {
          n6 = s8.insertAfter;
          break;
        }
      if (!(s8 == null ? void 0 : s8.geometry) || -2 === n6)
        continue;
      const i6 = s8.getGeometryQuantized(h4, t7.bounds, this._tileInfoView.spatialReference, l4), d7 = { ...s8.graphic.attributes };
      d7[this._uidFieldName] = c3.uid, null == s8.groupId && (s8.groupId = e9.createTemplateGroup(s8.symbol, null)), u6.push({ centroid: d6.getCentroidQuantized(s8, h4), geometry: i6, attributes: d7, symbol: s8.symbol, groupId: s8.groupId, insertAfter: n6, zorder: s8.zorder });
    }
    return u6.sort((e10, t8) => e10.zorder - t8.zorder), u6;
  }
  queryTileData(e9, t7) {
    if (0 === this._graphics.length)
      return [];
    const { bounds: i5, resolution: r8 } = t7, s8 = this._searchForItems(t7), o9 = [];
    return 0 === s8.length || this._createTileGraphics(o9, e9, s8, { originPosition: "upperLeft", scale: [r8, r8], translate: [i5[0], i5[3]] }, t7), o9;
  }
  has(e9) {
    return this._itemByGraphic.has(e9);
  }
  getBounds(e9) {
    const t7 = this._itemByGraphic.get(e9);
    return t7 ? t7.bounds : null;
  }
  getAllBounds() {
    return Array.from(this._itemByGraphic.values()).filter((e9) => e9.graphic.visible).map((e9) => e9.bounds);
  }
  addOrModify(e9, t7, i5) {
    if (!e9 || null == t7)
      return;
    this.has(e9) && this.remove(e9), this._onAdd(e9);
    const r8 = [0, 0, 0, 0], s8 = this._getSymbolBounds(null, t7, i5, r8, 0), o9 = d6.acquire(e9, t7, i5, null != s8 ? s8 : null, r8);
    return this._itemByGraphic.set(e9, o9), i5 && this._index.insert(o9), o9.bounds;
  }
  remove(e9) {
    if (!this._itemByGraphic.has(e9))
      return;
    this._onRemove(e9);
    const t7 = this._itemByGraphic.get(e9);
    (t7 == null ? void 0 : t7.bounds) && this._index.remove(t7), this._itemByGraphic.delete(e9);
  }
  updateZ() {
    const e9 = this._graphics.items;
    let t7, i5;
    for (let r8 = 0; r8 < e9.length; r8++)
      i5 = e9[r8], t7 = this._itemByGraphic.get(i5), t7 && (t7.zorder = r8);
  }
  update(e9, t7, i5) {
    const r8 = this._itemByGraphic.get(e9);
    r8.groupId = null;
    const o9 = u(r8.bounds);
    this._index.remove(r8);
    const n6 = this._getSymbolBounds(r8.bounds, t7, i5, r8.size, 0);
    return null != n6 && r8.set(e9, t7, i5, n6, r8.size), i5 && this._index.insert(r8), { oldBounds: o9, newBounds: r8.bounds };
  }
  updateLevel(e9) {
    if (this._resolution === e9)
      return;
    this._resolution = e9, this._index.clear();
    const t7 = this._itemByGraphic, i5 = [];
    for (const [r8, s8] of t7) {
      const e10 = this._getSymbolBounds(s8.bounds, s8.symbolResource, s8.geometry, s8.size, 0);
      s8.geometry && null != e10 && (s8.bounds = e10, i5.push(s8));
    }
    this._index.load(i5);
  }
  clear() {
    this._itemByGraphic.clear(), this._index.clear();
  }
  _createTileGraphics(e9, t7, i5, r8, s8) {
    const o9 = this._uidFieldName, n6 = this._tileInfoView.spatialReference, { bounds: l4, resolution: u6 } = s8;
    let h4, c3, d7, m5;
    i5.sort((e10, t8) => e10.zorder - t8.zorder);
    for (let p6 = 0; p6 < i5.length; p6++) {
      d7 = i5[p6], h4 = d7.graphic, c3 = d7.getGeometryQuantized(r8, l4, n6, u6), m5 = 0 === p6 ? -1 : i5[p6 - 1].graphic.uid;
      const s9 = { ...d7.graphic.attributes };
      s9[o9] = h4.uid, null == d7.groupId && (d7.groupId = t7.createTemplateGroup(d7.symbol, null)), e9.push({ centroid: d6.getCentroidQuantized(d7, r8), geometry: c3, attributes: s9, symbol: d7.symbol, groupId: d7.groupId, insertAfter: m5, zorder: d7.zorder });
    }
  }
  _searchForItems(e9) {
    const t7 = this._tileInfoView.spatialReference, r8 = e9.bounds, s8 = d2(t7);
    if (s8 && t7.isWrappable) {
      const [t8, o9] = s8.valid, n6 = Math.abs(r8[2] - o9) < g4, l4 = Math.abs(r8[0] - t8) < g4;
      if ((!n6 || !l4) && (n6 || l4)) {
        const s9 = e9.resolution;
        let l5;
        l5 = i(n6 ? [t8, r8[1], t8 + s9 * f5, r8[3]] : [o9 - s9 * f5, r8[1], o9, r8[3]]);
        const u6 = f8(this._index, r8[0], r8[1], r8[2], r8[3]), h4 = f8(this._index, l5[0], l5[1], l5[2], l5[3]);
        return [.../* @__PURE__ */ new Set([...u6, ...h4])];
      }
    }
    return f8(this._index, r8[0], r8[1], r8[2], r8[3]);
  }
  _getSymbolBounds(t7, r8, s8, n6, l4) {
    if (!r8 || !r8.symbol || !s8)
      return null;
    if (t7 || (t7 = i()), a2(t7, s8), !n6 || 0 === n6[0] && 0 === n6[1] && 0 === n6[2] && 0 === n6[3]) {
      const { hash: t8, textInfo: i5 } = r8, s9 = this._hashToCIM.get(t8);
      if (!s9)
        return null;
      n6 || (n6 = [0, 0, 0, 0]);
      const o9 = this._inflatedSizeHelper.getSymbolInflateSize(n6, s9.symbol, this._cimResourceManager, l4, i5);
      n6[0] = u3(o9[0]), n6[1] = u3(o9[1]), n6[2] = u3(o9[2]), n6[3] = u3(o9[3]);
    }
    const u6 = this._resolution, a7 = se.safeSize(n6);
    return t7[0] -= a7 * u6, t7[1] -= a7 * u6, t7[2] += a7 * u6, t7[3] += a7 * u6, t7;
  }
};
var y5 = (e9, t7) => {
  const i5 = h2(e9.graphic), r8 = h2(t7.graphic);
  return i5 === r8 ? t7.zorder - e9.zorder : i5 - r8;
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var se2 = has("esri-2d-graphic-debug");
function ie(e9, t7, s8) {
  let i5 = s8.get(e9);
  return i5 || (i5 = { tile: t7, addedOrModified: [], removed: [] }, s8.set(e9, i5)), i5;
}
var re = class extends s4(a3(m)) {
  constructor(e9) {
    super(e9), this._storage = new r3(), this._displayIds = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._tiles = /* @__PURE__ */ new Map(), this._graphicStoreUpdate = false, this._graphicsSet = /* @__PURE__ */ new Set(), this._matcher = Promise.resolve(null), this._tileUpdateSet = /* @__PURE__ */ new Set(), this._tilesToUpdate = /* @__PURE__ */ new Map(), this._graphicIdToAbortController = /* @__PURE__ */ new Map(), this._attached = false, this._updatingGraphicsTimer = null, this._hashToExpandedSymbol = /* @__PURE__ */ new Map(), this._hashToExpandedSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIMSymbolPromise = /* @__PURE__ */ new Map(), this._hashToCIM = /* @__PURE__ */ new Map(), this._processing = false, this._needsProcessing = false, this._pendingUpdate = { added: /* @__PURE__ */ new Set(), updated: /* @__PURE__ */ new Set(), removed: /* @__PURE__ */ new Set() }, this.lastUpdateId = -1, this.renderer = null, this.updateRequested = false, this.defaultPointSymbolEnabled = true, this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this._updatingGraphicsTimer && (clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = null, this.notifyChange("updating")), this._controller.abort(), this.container.destroy(), this._set("graphics", null), this._graphicStore.clear(), this._attributeStore = null, this._hashToExpandedSymbol.clear(), this.view = null, this.renderer = null, this._hashToCIM.clear(), this._hashToCIMSymbolPromise.clear(), this._hashToExpandedSymbolPromise.clear();
  }
  _createMatcher(e9, t7, s8) {
    if (e9) {
      const i5 = T(e9), r8 = _({ indexCount: 0, fields: {} }, "feature", e9, i5);
      this._matcher = o3(r8, t7, null, s8);
    }
  }
  _createDisplayId(e9) {
    let t7 = this._displayIds.get(e9);
    return t7 || (t7 = this._storage.createDisplayId(), this._displayIds.set(e9, t7)), t7;
  }
  initialize() {
    this._attributeStore = new B({ type: "local", initialize: (e10) => Promise.resolve(this.container.attributeView.initialize(e10)), update: (e10) => this.container.attributeView.requestUpdate(e10), render: () => this.container.requestRender() }, n2("2d")), this.container.hasHighlight = () => this._attributeStore.hasHighlight;
    const e9 = (e10) => {
      this._createDisplayId(e10.uid), this._setFilterState(e10.uid, e10.visible);
    }, t7 = (e10) => {
      const t8 = this._displayIds.get(e10.uid);
      this._displayIds.delete(e10.uid), this._storage.releaseDisplayId(t8);
    }, s8 = new x2(this.container.getMaterialItems.bind(this.container), this.view.featuresTilingScheme.tileInfo);
    this._graphicStore = new b(this.view.featuresTilingScheme, this.view.state.scale, this.uid, this.graphics, e9, t7, this._hashToCIM), this._meshFactory = new a4(null, this.uid, s8), this._templateStore = s8, this.handles.add([l(() => this._effectiveRenderer, (e10) => {
      this._createMatcher(e10, s8, this.container.stage.resourceManager);
      for (const t8 of this.graphics)
        this._pendingUpdate.updated.add(t8);
      this.requestUpdate();
    }), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      se2 && this.container.enableRenderingBounds(() => this._graphicStore.getAllBounds()), this.graphics.items.length > 0 && this._graphicsChangeHandler({ target: this.graphics, added: this.graphics.items, removed: [], moved: [] }), this.handles.add(this.graphics.on("change", (e11) => this._graphicsChangeHandler(e11)), "graphics");
      const e10 = this.container.stage.resourceManager;
      this._createMatcher(this._effectiveRenderer, s8, e10), this._graphicStore.setResourceManager(e10), this._attached = true, this.notifyChange("updating");
    })]);
    const i5 = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: i5, removed: [] });
  }
  get _effectiveRenderer() {
    return "function" == typeof this.renderer ? this.renderer() : this.renderer;
  }
  get updating() {
    var _a;
    return !this._attached || null !== this._updatingGraphicsTimer || this._pendingUpdate.added.size > 0 || this._pendingUpdate.removed.size > 0 || this._pendingUpdate.updated.size > 0 || this._tileUpdateSet.size > 0 || this._tilesToUpdate.size > 0 || ((_a = this._attributeStore) == null ? void 0 : _a.updatingHandles.updating) || this._processing;
  }
  hitTest(e9) {
    if (!this.view || this.view.suspended)
      return [];
    const { resolution: t7, rotation: s8 } = this.view.state;
    return this._graphicStore.hitTest(e9.x, e9.y, 2, t7, s8);
  }
  update(e9) {
    s(this._controller.signal);
    const t7 = e9.state, { resolution: s8 } = t7;
    if (this._graphicStore.updateLevel(s8), this._graphicStoreUpdate = true, this.updateRequested = false, this._pendingUpdate.updated.size > 0) {
      if (!this._processing)
        return void this._updateGraphics();
      this._needsProcessing = true;
    }
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback());
  }
  processUpdate(e9) {
    this.updateRequested && (this.updateRequested = false, this.update(e9));
  }
  graphicUpdateHandler(e9) {
    const { graphic: t7, property: s8 } = e9;
    switch (s8) {
      case "attributes":
      case "geometry":
      case "symbol":
        this._pendingUpdate.updated.add(t7), this.requestUpdate();
        break;
      case "visible":
        this._setFilterState(t7.uid, t7.visible), this._attributeStore.sendUpdates();
    }
  }
  setHighlight(e9) {
    const t7 = e9.map((e10) => this._displayIds.get(e10)).filter(R);
    this._attributeStore.setHighlight(e9, t7);
  }
  _getIntersectingTiles(e9) {
    const t7 = this._graphicStore.getBounds(e9);
    if (!t7 || 0 === M(t7) || 0 === s2(t7))
      return [];
    const s8 = g2(t7, this.view.spatialReference);
    return null != s8 ? [.../* @__PURE__ */ new Set([...this.view.graphicsTileStore.boundsIntersections(s8[0]), ...this.view.graphicsTileStore.boundsIntersections(s8[1])])] : this.view.graphicsTileStore.boundsIntersections(t7);
  }
  async _updateTile(e9) {
    s(this._controller.signal);
    const t7 = e9.tile, s8 = this._getGraphicsData(this._templateStore, t7, e9.addedOrModified), i5 = await this._processGraphics(t7, s8);
    return s(this._controller.signal), this._patchTile(t7.key, { type: "update", addOrUpdate: i5, remove: e9.removed, end: true, clear: false, sort: false }), i5;
  }
  _patchTile(e9, t7) {
    const s8 = this._tiles.get(e9);
    s8 && (this.container.onTileData(s8, t7), this.container.requestRender());
  }
  _graphicsChangeHandler(e9) {
    const t7 = this._pendingUpdate;
    for (const s8 of e9.added)
      t7.added.add(s8);
    for (const s8 of e9.moved)
      t7.updated.add(s8);
    for (const s8 of e9.removed)
      this._pendingUpdate.added.has(s8) ? t7.added.delete(s8) : t7.removed.add(s8);
    this._processing ? this._needsProcessing = true : this._updateGraphics();
  }
  _getGraphicsToUpdate() {
    const e9 = { added: [], removed: [], updated: [] };
    if (!this.graphics)
      return e9;
    const t7 = this._pendingUpdate;
    for (const s8 of this.graphics.items)
      t7.added.has(s8) ? e9.added.push(s8) : t7.updated.has(s8) && e9.updated.push(s8);
    for (const s8 of t7.removed)
      this._graphicStore.has(s8) && e9.removed.push(s8);
    return t7.added.clear(), t7.removed.clear(), t7.updated.clear(), e9;
  }
  async _updateGraphics() {
    this._processing = true;
    const { added: e9, removed: t7, updated: s8 } = this._getGraphicsToUpdate(), i5 = this._tilesToUpdate;
    let r8;
    try {
      if (!this._graphicStoreUpdate) {
        const e10 = this.view.state, { resolution: t8 } = e10;
        this._graphicStore.updateLevel(t8);
      }
      const o9 = [], a7 = new Array(e9.length + t7.length);
      for (let e10 = 0; e10 < s8.length; e10++) {
        const t8 = s8[e10], n7 = this._getIntersectingTiles(t8);
        for (const e11 of n7) {
          r8 = e11.id;
          ie(r8, e11, i5).removed.push(this._displayIds.get(t8.uid));
        }
        o9.push(this._updateGraphic(t8, null)), a7[e10] = t8;
      }
      const n6 = s8.length;
      for (let t8 = 0; t8 < e9.length; t8++) {
        const s9 = e9[t8];
        a7[n6 + t8] = s9, this._graphicsSet.add(s9), o9.push(this._addGraphic(s9));
      }
      for (const e10 of t7) {
        this._abortProcessingGraphic(e10.uid);
        const t8 = this._getIntersectingTiles(e10);
        for (const s9 of t8) {
          r8 = s9.id;
          ie(r8, s9, i5).removed.push(this._displayIds.get(e10.uid));
        }
        this._graphicsSet.delete(e10), this._graphicStore.remove(e10);
      }
      let h4;
      this._flipUpdatingGraphics(), await Promise.all(o9);
      for (let e10 = 0; e10 < a7.length; e10++) {
        h4 = a7[e10];
        const t8 = this._getIntersectingTiles(h4);
        for (const e11 of t8) {
          r8 = e11.id;
          ie(r8, e11, i5).addedOrModified.push(h4);
        }
      }
      this._graphicStore.updateZ();
      const l4 = [];
      for (const [e10, t8] of i5)
        l4.push(this._updateTile(t8));
      await Promise.all(l4);
    } catch (o9) {
      d(o9), 0;
    }
    for (const a7 of t7)
      try {
        const e10 = await this._getSymbolForGraphic(a7, null);
        if (e10) {
          const t8 = e10.hash();
          this._hashToExpandedSymbol.delete(t8);
        }
      } catch (o9) {
        d(o9), 0;
      }
    i5.clear(), this.notifyChange("updating"), this._processing = false, this._needsProcessing && (this._needsProcessing = false, this._updateGraphics());
  }
  _getArcadeInfo(e9) {
    const t7 = (e9.attributes ? Object.keys(e9.attributes) : []).map((t8) => ({ name: t8, alias: t8, type: "string" == typeof e9.attributes[t8] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
    return null == e9.geometry ? null : { geometryType: v(e9.geometry), spatialReference: f2.fromJSON(e9.geometry.spatialReference), fields: t7 };
  }
  _getSymbolForGraphic(e9, t7) {
    return s(this._controller.signal), null != e9.symbol ? Promise.resolve(e9.symbol) : null != this._effectiveRenderer ? this._effectiveRenderer.getSymbolAsync(e9, { scale: this.view.state.scale, signal: null != t7 ? t7.signal : null }) : Promise.resolve(this._getNullSymbol(e9));
  }
  _getCIMSymbol(e9, t7, s8) {
    let i5 = this._hashToCIM.get(t7);
    if (i5)
      return Promise.resolve(i5);
    const r8 = ee(e9);
    if (null != r8) {
      if ("CIMSymbolReference" === r8.type)
        return i5 = r8, this._hashToCIM.set(t7, i5), Promise.resolve(i5);
      let e10 = this._hashToCIMSymbolPromise.get(t7);
      return e10 || (e10 = r8.fetchCIMSymbol(s8).then((e11) => (this._hashToCIM.set(t7, e11.data), this._hashToCIMSymbolPromise.delete(t7), e11)).catch((e11) => (this._hashToCIMSymbolPromise.delete(t7), f(e11), null)), this._hashToCIMSymbolPromise.set(t7, e10), e10);
    }
    return Promise.resolve(null);
  }
  _expandCIMSymbol(e9, t7, s8, i5) {
    const r8 = this._hashToExpandedSymbol.get(s8);
    if (r8)
      return Promise.resolve(r8);
    let o9 = this._hashToExpandedSymbolPromise.get(s8);
    if (o9)
      return o9;
    const a7 = this.container.stage, n6 = this._getArcadeInfo(t7), h4 = T(null), l4 = o2(e9, h4);
    return o9 = r2(l4, n6, a7.resourceManager, i5), this._hashToExpandedSymbolPromise.set(s8, o9), o9.then((e10) => (this._hashToExpandedSymbol.set(s8, e10), this._hashToExpandedSymbolPromise.delete(s8), e10)), o9;
  }
  async _getSymbolResources(e9, t7) {
    s(this._controller.signal);
    return this.container.stage ? this._getSymbolForGraphic(e9, t7).then((s8) => {
      if (!s8)
        return null;
      const r8 = s8.hash();
      return this._getCIMSymbol(s8, r8, t7).then((s9) => null == s9 ? null : this._expandCIMSymbol(s9, e9, r8, t7).then((e10) => {
        const t8 = e10.layers.filter((e11) => "text" === e11.type && "string" == typeof e11.text);
        if (t8 && t8.length > 0) {
          const s10 = new Array(t8.length);
          for (let e11 = 0; e11 < t8.length; e11++) {
            const r9 = t8[e11], o10 = [], [a7] = i2(r9.text);
            r9.text = a7;
            for (let e12 = 0; e12 < a7.length; e12++)
              o10.push(a7.charCodeAt(e12));
            s10[e11] = { symbol: r9, id: e11, glyphIds: o10 };
          }
          const o9 = /* @__PURE__ */ new Map();
          return this.container.getMaterialItems(s10).then((s11) => {
            r(s11);
            for (let e11 = 0; e11 < t8.length; e11++) {
              const i5 = t8[e11];
              o9.set(i5.cim, { text: i5.text, mosaicItem: s11[e11].mosaicItem });
            }
            return { symbol: e10, textInfo: o9, hash: r8 };
          });
        }
        return { symbol: e10, hash: r8 };
      }));
    }).catch((e10) => (f(e10), null)) : null;
  }
  async _projectAndNormalizeGeometry(e9, t7) {
    if (s(this._controller.signal), null == e9.geometry || "mesh" === e9.geometry.type)
      return null;
    let s8 = e9.geometry;
    if (f3(s8)) {
      const e10 = s8.rings;
      s8.rings = e10;
    } else if (s3(s8)) {
      const e10 = s8.paths;
      s8.paths = e10;
    } else if (m2(s8)) {
      const i6 = await this._getSymbolForGraphic(e9, t7);
      if (s(this._controller.signal), i6 && (p2(i6.type) || u5(i6.type))) {
        s8 = s8.center;
      } else
        s8 = x3(s8);
    }
    await f4(s8.spatialReference, this.view.spatialReference);
    const i5 = a5(s8), r8 = g(i5, s8.spatialReference, this.view.spatialReference);
    return r8 && p(r8), r8;
  }
  _onTileUpdate(e9) {
    const t7 = d2(this.view.spatialReference);
    if (e9.added && e9.added.length > 0)
      for (const s8 of e9.added)
        this._addNewTile(s8, t7);
    if (e9.removed && e9.removed.length > 0)
      for (const s8 of e9.removed)
        this._removeTile(s8.key);
  }
  async _addGraphic(e9) {
    this._abortProcessingGraphic(e9.uid), s(this._controller.signal);
    const t7 = new AbortController();
    this._graphicIdToAbortController.set(e9.uid, t7);
    const s8 = { signal: t7.signal };
    try {
      await this._addOrUpdateGraphic(e9, s8), s(this._controller.signal), this._graphicIdToAbortController.delete(e9.uid);
    } catch (i5) {
      if (this._graphicIdToAbortController.delete(e9.uid), !d(i5))
        throw i5;
    }
  }
  _updateGraphic(e9, t7) {
    s(this._controller.signal);
    const s8 = this._projectAndNormalizeGeometry(e9, t7), i5 = this._getSymbolResources(e9, t7);
    return Promise.all([s8, i5]).then(([t8, s9]) => {
      s(this._controller.signal), this._graphicStore.addOrModify(e9, s9, t8);
    });
  }
  _addOrUpdateGraphic(e9, t7) {
    s(this._controller.signal);
    const s8 = this._projectAndNormalizeGeometry(e9, t7), i5 = this._getSymbolResources(e9, t7);
    return Promise.all([s8, i5]).then(([t8, s9]) => {
      s(this._controller.signal), this._graphicsSet.has(e9) && this._graphicStore.addOrModify(e9, s9, t8);
    });
  }
  _addTile(e9) {
    const t7 = this.view.featuresTilingScheme.getTileBounds(i(), e9), s8 = this.view.featuresTilingScheme.getTileResolution(e9.level), i5 = new a6(e9, s8, t7[0], t7[3]);
    return this._tiles.set(e9, i5), this.container.addChild(i5), i5;
  }
  async _addNewTile(e9, t7) {
    const s8 = this._addTile(e9.key), i5 = this._graphicStore.queryTileData(this._templateStore, e9);
    if (0 === i5.length)
      return;
    if (t7) {
      const s9 = Math.round((t7.valid[1] - t7.valid[0]) / e9.resolution);
      for (const e10 of i5)
        e10.geometry && (l2(e10.geometry) || u2(e10.geometry)) && this._wrapPoints(e10, s9);
    }
    const r8 = e9.key;
    this._tileUpdateSet.add(e9.key), this.notifyChange("updating");
    try {
      const t8 = { type: "update", clear: false, addOrUpdate: await this._processGraphics(e9, i5), remove: [], end: true, sort: false };
      s8.patch(t8), this._tileUpdateSet.delete(r8), this.notifyChange("updating");
    } catch (o9) {
      if (this._tileUpdateSet.delete(r8), this.notifyChange("updating"), !d(o9))
        throw o9;
    }
  }
  _removeTile(e9) {
    if (!this._tiles.has(e9))
      return;
    const t7 = this._tiles.get(e9);
    this.container.removeChild(t7), t7.destroy(), this._tiles.delete(e9);
  }
  _setFilterState(e9, t7) {
    const s8 = this._displayIds.get(e9), i5 = this._attributeStore.getHighlightFlag(e9);
    this._attributeStore.setData(s8, 0, 0, i5 | (t7 ? X : 0));
  }
  _getGraphicsData(e9, t7, s8) {
    const i5 = this.view, r8 = d2(i5.spatialReference), o9 = this._graphicStore.getGraphicsData(e9, t7, s8);
    if (r8) {
      const e10 = Math.round((r8.valid[1] - r8.valid[0]) / t7.resolution);
      for (const t8 of o9)
        t8.geometry && (l2(t8.geometry) || u2(t8.geometry)) && this._wrapPoints(t8, e10);
    }
    return o9;
  }
  _wrapPoints(e9, t7) {
    const s8 = e9.geometry;
    u2(s8) ? this._wrapMultipoint(s8, t7) : this._wrapPoint(e9, t7);
  }
  _wrapMultipoint(e9, t7) {
    const s8 = e9.points, i5 = [];
    let r8 = 0, o9 = 0;
    for (const [a7, n6] of s8) {
      if (i5.push([a7 + r8, n6]), r8 = 0, t7 === c2) {
        const e10 = 5 * f5;
        a7 + o9 < e10 ? (i5.push([t7, 0]), r8 = -t7) : a7 + o9 > c2 - e10 && (i5.push([-t7, 0]), r8 = t7);
      } else
        a7 + o9 < -f5 ? (i5.push([t7, 0]), r8 = -t7) : a7 + o9 > c2 + f5 && (i5.push([-t7, 0]), r8 = t7);
      o9 += a7;
    }
    e9.points = i5;
  }
  _wrapPoint(e9, t7) {
    const s8 = e9.geometry;
    if (t7 === c2) {
      const i5 = 5 * f5;
      s8.x < i5 ? e9.geometry = { points: [[s8.x, s8.y], [t7, 0]] } : s8.x > c2 - i5 && (e9.geometry = { points: [[s8.x, s8.y], [-t7, 0]] });
    } else
      s8.x < -f5 ? e9.geometry = { points: [[s8.x, s8.y], [t7, 0]] } : s8.x > c2 + f5 && (e9.geometry = { points: [[s8.x, s8.y], [-t7, 0]] });
  }
  _processGraphics(e9, t7, s8) {
    if (!(t7 && t7.length) || !this._meshFactory)
      return Promise.resolve(null);
    const i5 = o8.from(t7, this.uid, e9.transform), r8 = this._meshFactory;
    return this._matcher.then((t8) => r8.analyzeGraphics(i5, this.container.stage.resourceManager, t8, null, null, s8).then(() => (this._attributeStore.sendUpdates(), this._processAnalyzedGraphics(e9, i5))));
  }
  _processAnalyzedGraphics(e9, t7) {
    const s8 = this._meshFactory, i5 = t7.getSize(), r8 = t7.getCursor(), o9 = { features: i5, records: i5, metrics: 0 }, a7 = new E(e9.key.id, o9, S.DEFAULT, false, false), n6 = [];
    for (; r8.next(); ) {
      const t8 = r8.readGraphic();
      t8.insertAfter = -1 === t8.insertAfter ? -1 : this._displayIds.get(t8.insertAfter), t8.displayId = this._displayIds.get(t8.attributes[this.uid]);
      const i6 = new e7(t8.displayId);
      i6.insertAfter = t8.insertAfter, n6.push(i6), s8.writeGraphic(a7, r8, e9.level, this.container.stage.resourceManager);
    }
    const h4 = e9.tileInfoView.tileInfo.isWrappable, l4 = a7.serialize(h4);
    if (1 !== l4.length)
      return new B2();
    const d7 = l4[0].message;
    return B2.fromVertexData(d7, n6);
  }
  _abortProcessingGraphic(e9) {
    var _a;
    (_a = this._graphicIdToAbortController.get(e9)) == null ? void 0 : _a.abort();
  }
  _getNullSymbol(e9) {
    const t7 = e9.geometry;
    return s3(t7) ? O : f3(t7) || m2(t7) ? y2 : this.defaultPointSymbolEnabled ? N : null;
  }
  _flipUpdatingGraphics() {
    this._updatingGraphicsTimer && clearTimeout(this._updatingGraphicsTimer), this._updatingGraphicsTimer = setTimeout(() => {
      this._updatingGraphicsTimer = null, this.notifyChange("updating");
    }, 160), this.notifyChange("updating");
  }
};
e([y()], re.prototype, "_effectiveRenderer", null), e([y({ constructOnly: true })], re.prototype, "requestUpdateCallback", void 0), e([y()], re.prototype, "container", void 0), e([y({ constructOnly: true })], re.prototype, "graphics", void 0), e([y()], re.prototype, "renderer", void 0), e([y()], re.prototype, "updating", null), e([y()], re.prototype, "view", void 0), e([y()], re.prototype, "updateRequested", void 0), e([y()], re.prototype, "defaultPointSymbolEnabled", void 0), re = e([a("esri.views.2d.layers.support.GraphicsView2D")], re);
var oe = re;

export {
  oe
};
//# sourceMappingURL=chunk-HVNVJMIO.js.map
