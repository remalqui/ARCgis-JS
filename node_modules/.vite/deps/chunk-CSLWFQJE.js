// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GeometryUtils.js
var n = Number.POSITIVE_INFINITY;
var t = Math.PI;
var r = 2 * t;
var u = 128 / t;
var o = 256 / 360;
var e = t / 180;
var c = 1 / Math.LN2;
function f(n3, t3) {
  return (n3 %= t3) >= 0 ? n3 : n3 + t3;
}
function i(n3) {
  return f(n3 * u, 256);
}
function N(n3) {
  return Math.log(n3) * c;
}
function h(n3, t3, r2) {
  return n3 * (1 - r2) + t3 * r2;
}

// node_modules/@arcgis/core/geometry/support/TileClipper.js
var i2 = 512;
var t2;
var s;
!function(i3) {
  i3[i3.Unknown = 0] = "Unknown", i3[i3.Point = 1] = "Point", i3[i3.LineString = 2] = "LineString", i3[i3.Polygon = 3] = "Polygon";
}(t2 || (t2 = {}));
var h2 = class _h {
  constructor(i3, t3) {
    this.x = i3, this.y = t3;
  }
  clone() {
    return new _h(this.x, this.y);
  }
  equals(i3, t3) {
    return i3 === this.x && t3 === this.y;
  }
  isEqual(i3) {
    return i3.x === this.x && i3.y === this.y;
  }
  setCoords(i3, t3) {
    this.x = i3, this.y = t3;
  }
  normalize() {
    const i3 = this.x, t3 = this.y, s2 = Math.sqrt(i3 * i3 + t3 * t3);
    this.x /= s2, this.y /= s2;
  }
  rightPerpendicular() {
    const i3 = this.x;
    this.x = this.y, this.y = -i3;
  }
  move(i3, t3) {
    this.x += i3, this.y += t3;
  }
  assign(i3) {
    this.x = i3.x, this.y = i3.y;
  }
  assignAdd(i3, t3) {
    this.x = i3.x + t3.x, this.y = i3.y + t3.y;
  }
  assignSub(i3, t3) {
    this.x = i3.x - t3.x, this.y = i3.y - t3.y;
  }
  rotate(i3, t3) {
    const s2 = this.x, h3 = this.y;
    this.x = s2 * i3 - h3 * t3, this.y = s2 * t3 + h3 * i3;
  }
  scale(i3) {
    this.x *= i3, this.y *= i3;
  }
  length() {
    const i3 = this.x, t3 = this.y;
    return Math.sqrt(i3 * i3 + t3 * t3);
  }
  static distance(i3, t3) {
    const s2 = t3.x - i3.x, h3 = t3.y - i3.y;
    return Math.sqrt(s2 * s2 + h3 * h3);
  }
  static add(i3, t3) {
    return new _h(i3.x + t3.x, i3.y + t3.y);
  }
  static sub(i3, t3) {
    return new _h(i3.x - t3.x, i3.y - t3.y);
  }
};
var n2 = class {
  constructor(i3, t3, s2) {
    this.ratio = i3, this.x = t3, this.y = s2;
  }
};
var e2 = class {
  constructor(t3, s2, h3, n3 = 8, e3 = 8) {
    this._lines = [], this._starts = [], this.validateTessellation = true, this._pixelRatio = n3, this._pixelMargin = e3, this._tileSize = i2 * n3, this._dz = t3, this._yPos = s2, this._xPos = h3;
  }
  setPixelMargin(i3) {
    i3 !== this._pixelMargin && (this._pixelMargin = i3, this.setExtent(this._extent));
  }
  setExtent(i3) {
    this._extent = i3, this._finalRatio = this._tileSize / i3 * (1 << this._dz);
    let t3 = this._pixelRatio * this._pixelMargin;
    t3 /= this._finalRatio;
    const s2 = i3 >> this._dz;
    t3 > s2 && (t3 = s2), this._margin = t3, this._xmin = s2 * this._xPos - t3, this._ymin = s2 * this._yPos - t3, this._xmax = this._xmin + s2 + 2 * t3, this._ymax = this._ymin + s2 + 2 * t3;
  }
  reset(i3) {
    this._type = i3, this._lines = [], this._starts = [], this._line = null, this._start = 0;
  }
  moveTo(i3, t3) {
    this._pushLine(), this._prevIsIn = this._isIn(i3, t3), this._moveTo(i3, t3, this._prevIsIn), this._prevPt = new h2(i3, t3), this._firstPt = new h2(i3, t3), this._dist = 0;
  }
  lineTo(i3, t3) {
    const s2 = this._isIn(i3, t3), e3 = new h2(i3, t3), _2 = h2.distance(this._prevPt, e3);
    let l2, x2, a, y, o2, r2, m, u2;
    if (s2)
      this._prevIsIn ? this._lineTo(i3, t3, true) : (l2 = this._prevPt, x2 = e3, a = this._intersect(x2, l2), this._start = this._dist + _2 * (1 - this._r), this._lineTo(a.x, a.y, true), this._lineTo(x2.x, x2.y, true));
    else if (this._prevIsIn)
      x2 = this._prevPt, l2 = e3, a = this._intersect(x2, l2), this._lineTo(a.x, a.y, true), this._lineTo(l2.x, l2.y, false);
    else {
      const i4 = this._prevPt, t4 = e3;
      if (i4.x <= this._xmin && t4.x <= this._xmin || i4.x >= this._xmax && t4.x >= this._xmax || i4.y <= this._ymin && t4.y <= this._ymin || i4.y >= this._ymax && t4.y >= this._ymax)
        this._lineTo(t4.x, t4.y, false);
      else {
        const s3 = [];
        if ((i4.x < this._xmin && t4.x > this._xmin || i4.x > this._xmin && t4.x < this._xmin) && (y = (this._xmin - i4.x) / (t4.x - i4.x), u2 = i4.y + y * (t4.y - i4.y), u2 <= this._ymin ? r2 = false : u2 >= this._ymax ? r2 = true : s3.push(new n2(y, this._xmin, u2))), (i4.x < this._xmax && t4.x > this._xmax || i4.x > this._xmax && t4.x < this._xmax) && (y = (this._xmax - i4.x) / (t4.x - i4.x), u2 = i4.y + y * (t4.y - i4.y), u2 <= this._ymin ? r2 = false : u2 >= this._ymax ? r2 = true : s3.push(new n2(y, this._xmax, u2))), (i4.y < this._ymin && t4.y > this._ymin || i4.y > this._ymin && t4.y < this._ymin) && (y = (this._ymin - i4.y) / (t4.y - i4.y), m = i4.x + y * (t4.x - i4.x), m <= this._xmin ? o2 = false : m >= this._xmax ? o2 = true : s3.push(new n2(y, m, this._ymin))), (i4.y < this._ymax && t4.y > this._ymax || i4.y > this._ymax && t4.y < this._ymax) && (y = (this._ymax - i4.y) / (t4.y - i4.y), m = i4.x + y * (t4.x - i4.x), m <= this._xmin ? o2 = false : m >= this._xmax ? o2 = true : s3.push(new n2(y, m, this._ymax))), 0 === s3.length)
          o2 ? r2 ? this._lineTo(this._xmax, this._ymax, true) : this._lineTo(this._xmax, this._ymin, true) : r2 ? this._lineTo(this._xmin, this._ymax, true) : this._lineTo(this._xmin, this._ymin, true);
        else if (s3.length > 1 && s3[0].ratio > s3[1].ratio)
          this._start = this._dist + _2 * s3[1].ratio, this._lineTo(s3[1].x, s3[1].y, true), this._lineTo(s3[0].x, s3[0].y, true);
        else {
          this._start = this._dist + _2 * s3[0].ratio;
          for (let i5 = 0; i5 < s3.length; i5++)
            this._lineTo(s3[i5].x, s3[i5].y, true);
        }
        this._lineTo(t4.x, t4.y, false);
      }
    }
    this._dist += _2, this._prevIsIn = s2, this._prevPt = e3;
  }
  close() {
    if (this._line.length > 2) {
      const i3 = this._firstPt, t3 = this._prevPt;
      i3.x === t3.x && i3.y === t3.y || this.lineTo(i3.x, i3.y);
      const s2 = this._line;
      let h3 = s2.length;
      for (; h3 >= 4 && (s2[0].x === s2[1].x && s2[0].x === s2[h3 - 2].x || s2[0].y === s2[1].y && s2[0].y === s2[h3 - 2].y); )
        s2.pop(), s2[0].x = s2[h3 - 2].x, s2[0].y = s2[h3 - 2].y, --h3;
    }
  }
  result(i3 = true) {
    return this._pushLine(), 0 === this._lines.length ? null : (this._type === t2.Polygon && i3 && l.simplify(this._tileSize, this._margin * this._finalRatio, this._lines), this._lines);
  }
  resultWithStarts() {
    if (this._type !== t2.LineString)
      throw new Error("Only valid for lines");
    this._pushLine();
    const i3 = this._lines, s2 = i3.length;
    if (0 === s2)
      return null;
    const h3 = [];
    for (let t3 = 0; t3 < s2; t3++)
      h3.push({ line: i3[t3], start: this._starts[t3] || 0 });
    return h3;
  }
  _isIn(i3, t3) {
    return i3 >= this._xmin && i3 <= this._xmax && t3 >= this._ymin && t3 <= this._ymax;
  }
  _intersect(i3, t3) {
    let s2, n3, e3;
    if (t3.x >= this._xmin && t3.x <= this._xmax)
      n3 = t3.y <= this._ymin ? this._ymin : this._ymax, e3 = (n3 - i3.y) / (t3.y - i3.y), s2 = i3.x + e3 * (t3.x - i3.x);
    else if (t3.y >= this._ymin && t3.y <= this._ymax)
      s2 = t3.x <= this._xmin ? this._xmin : this._xmax, e3 = (s2 - i3.x) / (t3.x - i3.x), n3 = i3.y + e3 * (t3.y - i3.y);
    else {
      n3 = t3.y <= this._ymin ? this._ymin : this._ymax, s2 = t3.x <= this._xmin ? this._xmin : this._xmax;
      const h3 = (s2 - i3.x) / (t3.x - i3.x), _2 = (n3 - i3.y) / (t3.y - i3.y);
      h3 < _2 ? (e3 = h3, n3 = i3.y + h3 * (t3.y - i3.y)) : (e3 = _2, s2 = i3.x + _2 * (t3.x - i3.x));
    }
    return this._r = e3, new h2(s2, n3);
  }
  _pushLine() {
    this._line && (this._type === t2.Point ? this._line.length > 0 && (this._lines.push(this._line), this._starts.push(this._start)) : this._type === t2.LineString ? this._line.length > 1 && (this._lines.push(this._line), this._starts.push(this._start)) : this._type === t2.Polygon && this._line.length > 3 && (this._lines.push(this._line), this._starts.push(this._start))), this._line = [], this._start = 0;
  }
  _moveTo(i3, s2, n3) {
    this._type !== t2.Polygon ? n3 && (i3 = Math.round((i3 - (this._xmin + this._margin)) * this._finalRatio), s2 = Math.round((s2 - (this._ymin + this._margin)) * this._finalRatio), this._line.push(new h2(i3, s2))) : (n3 || (i3 < this._xmin && (i3 = this._xmin), i3 > this._xmax && (i3 = this._xmax), s2 < this._ymin && (s2 = this._ymin), s2 > this._ymax && (s2 = this._ymax)), i3 = Math.round((i3 - (this._xmin + this._margin)) * this._finalRatio), s2 = Math.round((s2 - (this._ymin + this._margin)) * this._finalRatio), this._line.push(new h2(i3, s2)), this._isH = false, this._isV = false);
  }
  _lineTo(i3, s2, n3) {
    let e3, _2;
    if (this._type !== t2.Polygon)
      if (n3) {
        if (i3 = Math.round((i3 - (this._xmin + this._margin)) * this._finalRatio), s2 = Math.round((s2 - (this._ymin + this._margin)) * this._finalRatio), this._line.length > 0 && (e3 = this._line[this._line.length - 1], e3.equals(i3, s2)))
          return;
        this._line.push(new h2(i3, s2));
      } else
        this._line && this._line.length > 0 && this._pushLine();
    else if (n3 || (i3 < this._xmin && (i3 = this._xmin), i3 > this._xmax && (i3 = this._xmax), s2 < this._ymin && (s2 = this._ymin), s2 > this._ymax && (s2 = this._ymax)), i3 = Math.round((i3 - (this._xmin + this._margin)) * this._finalRatio), s2 = Math.round((s2 - (this._ymin + this._margin)) * this._finalRatio), this._line && this._line.length > 0) {
      e3 = this._line[this._line.length - 1];
      const t3 = e3.x === i3, n4 = e3.y === s2;
      if (t3 && n4)
        return;
      this._isH && t3 || this._isV && n4 ? (e3.x = i3, e3.y = s2, _2 = this._line[this._line.length - 2], _2.x === i3 && _2.y === s2 ? (this._line.pop(), this._line.length <= 1 ? (this._isH = false, this._isV = false) : (_2 = this._line[this._line.length - 2], this._isH = _2.x === i3, this._isV = _2.y === s2)) : (this._isH = _2.x === i3, this._isV = _2.y === s2)) : (this._line.push(new h2(i3, s2)), this._isH = t3, this._isV = n4);
    } else
      this._line.push(new h2(i3, s2));
  }
};
var _ = class {
  setExtent(i3) {
    this._ratio = 4096 === i3 ? 1 : 4096 / i3;
  }
  get validateTessellation() {
    return this._ratio < 1;
  }
  reset(i3) {
    this._lines = [], this._line = null;
  }
  moveTo(i3, t3) {
    this._line && this._lines.push(this._line), this._line = [];
    const s2 = this._ratio;
    this._line.push(new h2(i3 * s2, t3 * s2));
  }
  lineTo(i3, t3) {
    const s2 = this._ratio;
    this._line.push(new h2(i3 * s2, t3 * s2));
  }
  close() {
    const i3 = this._line;
    i3 && !i3[0].isEqual(i3[i3.length - 1]) && i3.push(i3[0]);
  }
  result() {
    return this._line && this._lines.push(this._line), 0 === this._lines.length ? null : this._lines;
  }
};
!function(i3) {
  i3[i3.sideLeft = 0] = "sideLeft", i3[i3.sideRight = 1] = "sideRight", i3[i3.sideTop = 2] = "sideTop", i3[i3.sideBottom = 3] = "sideBottom";
}(s || (s = {}));
var l = class _l {
  static simplify(i3, t3, h3) {
    if (!h3)
      return;
    const n3 = -t3, e3 = i3 + t3, _2 = -t3, x2 = i3 + t3, a = [], y = [], o2 = h3.length;
    for (let l2 = 0; l2 < o2; ++l2) {
      const i4 = h3[l2];
      if (!i4 || i4.length < 2)
        continue;
      let t4, o3 = i4[0];
      const r3 = i4.length;
      for (let h4 = 1; h4 < r3; ++h4)
        t4 = i4[h4], o3.x === t4.x && (o3.x <= n3 && (o3.y > t4.y ? (a.push(l2), a.push(h4), a.push(s.sideLeft), a.push(-1)) : (y.push(l2), y.push(h4), y.push(s.sideLeft), y.push(-1))), o3.x >= e3 && (o3.y < t4.y ? (a.push(l2), a.push(h4), a.push(s.sideRight), a.push(-1)) : (y.push(l2), y.push(h4), y.push(s.sideRight), y.push(-1)))), o3.y === t4.y && (o3.y <= _2 && (o3.x < t4.x ? (a.push(l2), a.push(h4), a.push(s.sideTop), a.push(-1)) : (y.push(l2), y.push(h4), y.push(s.sideTop), y.push(-1))), o3.y >= x2 && (o3.x > t4.x ? (a.push(l2), a.push(h4), a.push(s.sideBottom), a.push(-1)) : (y.push(l2), y.push(h4), y.push(s.sideBottom), y.push(-1)))), o3 = t4;
    }
    if (0 === a.length || 0 === y.length)
      return;
    _l.fillParent(h3, y, a), _l.fillParent(h3, a, y);
    const r2 = [];
    _l.calcDeltas(r2, y, a), _l.calcDeltas(r2, a, y), _l.addDeltas(r2, h3);
  }
  static fillParent(i3, t3, h3) {
    const n3 = h3.length, e3 = t3.length;
    for (let _2 = 0; _2 < e3; _2 += 4) {
      const e4 = t3[_2], l2 = t3[_2 + 1], a = t3[_2 + 2], y = i3[e4][l2 - 1], o2 = i3[e4][l2];
      let r2 = 8092, m = -1;
      for (let t4 = 0; t4 < n3; t4 += 4) {
        if (h3[t4 + 2] !== a)
          continue;
        const n4 = h3[t4], e5 = h3[t4 + 1], _3 = i3[n4][e5 - 1], l3 = i3[n4][e5];
        switch (a) {
          case s.sideLeft:
          case s.sideRight:
            if (x(y.y, _3.y, l3.y) && x(o2.y, _3.y, l3.y)) {
              const i4 = Math.abs(l3.y - _3.y);
              i4 < r2 && (r2 = i4, m = t4);
            }
            break;
          case s.sideTop:
          case s.sideBottom:
            if (x(y.x, _3.x, l3.x) && x(o2.x, _3.x, l3.x)) {
              const i4 = Math.abs(l3.x - _3.x);
              i4 < r2 && (r2 = i4, m = t4);
            }
        }
      }
      t3[_2 + 3] = m;
    }
  }
  static calcDeltas(i3, t3, s2) {
    const h3 = t3.length;
    for (let n3 = 0; n3 < h3; n3 += 4) {
      const h4 = [], e3 = _l.calcDelta(n3, t3, s2, h4);
      i3.push(t3[n3]), i3.push(t3[n3 + 1]), i3.push(t3[n3 + 2]), i3.push(e3);
    }
  }
  static calcDelta(i3, t3, s2, h3) {
    const n3 = t3[i3 + 3];
    if (-1 === n3)
      return 0;
    const e3 = h3.length;
    return e3 > 1 && h3[e3 - 2] === n3 ? 0 : (h3.push(n3), _l.calcDelta(n3, s2, t3, h3) + 1);
  }
  static addDeltas(i3, t3) {
    const h3 = i3.length;
    let n3 = 0;
    for (let s2 = 0; s2 < h3; s2 += 4) {
      const t4 = i3[s2 + 3];
      t4 > n3 && (n3 = t4);
    }
    for (let e3 = 0; e3 < h3; e3 += 4) {
      const h4 = t3[i3[e3]], _2 = i3[e3 + 1], l2 = n3 - i3[e3 + 3];
      switch (i3[e3 + 2]) {
        case s.sideLeft:
          h4[_2 - 1].x -= l2, h4[_2].x -= l2, 1 === _2 && (h4[h4.length - 1].x -= l2), _2 === h4.length - 1 && (h4[0].x -= l2);
          break;
        case s.sideRight:
          h4[_2 - 1].x += l2, h4[_2].x += l2, 1 === _2 && (h4[h4.length - 1].x += l2), _2 === h4.length - 1 && (h4[0].x += l2);
          break;
        case s.sideTop:
          h4[_2 - 1].y -= l2, h4[_2].y -= l2, 1 === _2 && (h4[h4.length - 1].y -= l2), _2 === h4.length - 1 && (h4[0].y -= l2);
          break;
        case s.sideBottom:
          h4[_2 - 1].y += l2, h4[_2].y += l2, 1 === _2 && (h4[h4.length - 1].y += l2), _2 === h4.length - 1 && (h4[0].y += l2);
      }
    }
  }
};
var x = (i3, t3, s2) => i3 >= t3 && i3 <= s2 || i3 >= s2 && i3 <= t3;

export {
  t2 as t,
  h2 as h,
  e2 as e,
  _,
  n,
  t as t2,
  r,
  e as e2,
  f,
  i,
  N,
  h as h2
};
//# sourceMappingURL=chunk-CSLWFQJE.js.map
