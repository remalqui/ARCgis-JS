import {
  T as T3
} from "./chunk-KMPUORBS.js";
import {
  n as n7,
  n2 as n8
} from "./chunk-TBMS67KR.js";
import {
  e as e6
} from "./chunk-44OKOXKA.js";
import {
  e as e7,
  e2 as e8
} from "./chunk-N5CR6S5Y.js";
import {
  c as c4
} from "./chunk-AHVENFMO.js";
import {
  T as T2,
  e2 as e5
} from "./chunk-NE5U5H4D.js";
import {
  t as t3
} from "./chunk-PM77FW2O.js";
import {
  t as t4
} from "./chunk-AC3INPLN.js";
import {
  o as o4
} from "./chunk-QVFTB6AS.js";
import {
  e2 as e4
} from "./chunk-4BRWSSYR.js";
import {
  e as e2
} from "./chunk-NVZXNBIH.js";
import {
  e as e3,
  i as i3,
  o as o3
} from "./chunk-GTENSI4J.js";
import {
  o as o2
} from "./chunk-CN3PB7HS.js";
import {
  f as f2
} from "./chunk-NLX3GR5V.js";
import {
  t as t2
} from "./chunk-XYJMHUDA.js";
import {
  Ie,
  de,
  fe,
  ie,
  le,
  me,
  ne,
  oe,
  pe,
  re,
  se,
  ue
} from "./chunk-3VTULECI.js";
import {
  d as d2
} from "./chunk-TDXHXKUI.js";
import {
  T,
  _
} from "./chunk-TBHRKIAA.js";
import {
  Ae,
  B,
  C,
  X,
  Y,
  ae,
  ce
} from "./chunk-JSMUQBPG.js";
import {
  D,
  G,
  L,
  R
} from "./chunk-BCDDCNQ2.js";
import {
  n as n5
} from "./chunk-FN5LEP6H.js";
import {
  _ as _2
} from "./chunk-L6LEC3UI.js";
import {
  Rt,
  X as X2,
  _ as _3,
  dt,
  gt,
  l as l2,
  lt,
  wt
} from "./chunk-34BWOTUS.js";
import {
  n as n6
} from "./chunk-5KLICR5E.js";
import {
  u as u2
} from "./chunk-PNA6D76Z.js";
import {
  n as n4
} from "./chunk-VZAEQ6CY.js";
import {
  a as a2,
  r as r2,
  s as s6
} from "./chunk-X4Y5OF5X.js";
import {
  a as a3
} from "./chunk-LNMNRMVX.js";
import {
  c as c3,
  i as i2,
  u
} from "./chunk-EIE3W25Z.js";
import {
  c as c2,
  i
} from "./chunk-MOPR7RFH.js";
import {
  g,
  n as n3,
  o,
  r,
  s as s5
} from "./chunk-KW3ZNPTA.js";
import {
  f
} from "./chunk-XN5VV437.js";
import {
  n as n2
} from "./chunk-WBSPL6CJ.js";
import {
  x2 as x
} from "./chunk-SFV6XLDZ.js";
import {
  m as m2,
  n3 as n,
  y3 as y
} from "./chunk-OYBXMT5R.js";
import {
  a2 as a
} from "./chunk-CIDWM2UN.js";
import {
  e
} from "./chunk-PD5Q7TDW.js";
import {
  j
} from "./chunk-HKVL2MJK.js";
import {
  c,
  d,
  m,
  s as s4,
  w
} from "./chunk-HNHXEGH2.js";
import {
  l,
  t
} from "./chunk-DWOEYHKS.js";
import {
  s,
  s2,
  s3
} from "./chunk-W2N7YT6I.js";
import {
  has
} from "./chunk-I4U7MQNO.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e9 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o5(e13) {
  let o9 = e9;
  return e13.split("/").forEach((r12) => {
    o9 && (o9 = o9[r12]);
  }), o9;
}
var t5 = new e7(o5);
function n9(r12) {
  return t5.resolveIncludes(r12);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BitBlitPrograms.js
var e10 = { shaders: { vertexShader: n8("bitBlit/bitBlit.vert"), fragmentShader: n8("bitBlit/bitBlit.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t6 = class {
  constructor(t12, e13) {
    this._width = 0, this._height = 0, this._free = [], this._width = t12, this._height = e13, this._free.push(new t2(0, 0, t12, e13));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t12, e13) {
    if (t12 > this._width || e13 > this._height)
      return new t2();
    let i7 = null, s11 = -1;
    for (let h5 = 0; h5 < this._free.length; ++h5) {
      const r12 = this._free[h5];
      t12 <= r12.width && e13 <= r12.height && (null === i7 || r12.y <= i7.y && r12.x <= i7.x) && (i7 = r12, s11 = h5);
    }
    return null === i7 ? new t2() : (this._free.splice(s11, 1), i7.width < i7.height ? (i7.width > t12 && this._free.push(new t2(i7.x + t12, i7.y, i7.width - t12, e13)), i7.height > e13 && this._free.push(new t2(i7.x, i7.y + e13, i7.width, i7.height - e13))) : (i7.width > t12 && this._free.push(new t2(i7.x + t12, i7.y, i7.width - t12, i7.height)), i7.height > e13 && this._free.push(new t2(i7.x, i7.y + e13, t12, i7.height - e13))), new t2(i7.x, i7.y, t12, e13));
  }
  release(h5) {
    for (let t12 = 0; t12 < this._free.length; ++t12) {
      const e13 = this._free[t12];
      if (e13.y === h5.y && e13.height === h5.height && e13.x + e13.width === h5.x)
        e13.width += h5.width;
      else if (e13.x === h5.x && e13.width === h5.width && e13.y + e13.height === h5.y)
        e13.height += h5.height;
      else if (h5.y === e13.y && h5.height === e13.height && h5.x + h5.width === e13.x)
        e13.x = h5.x, e13.width += h5.width;
      else {
        if (h5.x !== e13.x || h5.width !== e13.width || h5.y + h5.height !== e13.y)
          continue;
        e13.y = h5.y, e13.height += h5.height;
      }
      this._free.splice(t12, 1), this.release(h5);
    }
    this._free.push(h5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n10 = 256;
var o6 = (t12) => Math.floor(t12 / 256);
function c5(t12) {
  const e13 = /* @__PURE__ */ new Set();
  for (const i7 of t12)
    e13.add(o6(i7));
  return e13;
}
function l3(e13, i7, h5) {
  return e13.has(i7) || e13.set(i7, h5().then(() => {
    e13.delete(i7);
  }).catch((h6) => {
    e13.delete(i7), m(h6);
  })), e13.get(i7);
}
var g2 = (t12) => ({ rect: new t2(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t12, sdf: true });
var p = class {
  constructor(t12, e13, h5) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t12, this.height = e13, this._glyphSource = h5, this._binPack = new t6(t12 - 4, e13 - 4), this._glyphData.push(new Uint8Array(t12 * e13)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t12 of this._textures)
      t12 && t12.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t12 = [117, 149, 181, 207, 207, 181, 149, 117], e13 = [], i7 = [];
    for (let r12 = 0; r12 < t12.length; r12++) {
      const h6 = t12[r12];
      for (let t13 = 0; t13 < 11; t13++) {
        const s12 = r12 >= 3 && r12 < 5 && t13 >= 3 && t13 < 8 ? 255 : 0;
        e13.push(h6), i7.push(s12);
      }
    }
    const h5 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e13) }, s11 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i7) };
    this._recordGlyph(h5), this._recordGlyph(s11);
  }
  async getGlyphItems(t12, e13, i7) {
    const h5 = this._getGlyphCache(t12);
    return await this._fetchRanges(t12, e13, i7), e13.map((e14) => this._getMosaicItem(h5, t12, e14));
  }
  bind(t12, e13, i7, h5) {
    const s11 = this._getTexture(t12, i7);
    s11.setSamplingMode(e13), this._dirties[i7] && (s11.setData(this._glyphData[i7]), this._dirties[i7] = false), t12.bindTexture(s11, h5);
  }
  preloadASCIIGlyphCache(t12) {
    const e13 = this._preloadCache[t12];
    if (null != e13)
      return e13;
    const i7 = this._glyphSource.preloadASCIIRange(t12).then(() => {
      const e14 = this._getGlyphCache(t12);
      for (let i8 = 0; i8 < 256; i8++)
        this._getMosaicItem(e14, t12, i8);
    });
    return this._preloadCache[t12] = i7, i7;
  }
  _getGlyphCache(t12) {
    return this._glyphCache[t12] || (this._glyphCache[t12] = {}), this._glyphCache[t12];
  }
  _getTexture(t12, e13) {
    if (!this._textures[e13]) {
      const i7 = new e5();
      i7.pixelFormat = G.ALPHA, i7.wrapMode = D.CLAMP_TO_EDGE, i7.width = this.width, i7.height = this.height, this._textures[e13] = new T2(t12, i7, new Uint8Array(this.width * this.height));
    }
    return this._textures[e13];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t12, e13, i7) {
    const h5 = c5(e13), s11 = [];
    h5.forEach((e14) => {
      s11.push(this._fetchRange(t12, e14, i7));
    }), await Promise.all(s11);
  }
  async _fetchRange(t12, e13, i7) {
    if (e13 > n10)
      return;
    const h5 = t12 + e13;
    return l3(this._rangePromises, h5, () => this._glyphSource.getRange(t12, e13, i7));
  }
  _getMosaicItem(t12, e13, i7) {
    if (!t12[i7]) {
      const h5 = this._glyphSource.getGlyph(e13, i7);
      if (!h5 || !h5.metrics)
        return g2(i7);
      const s11 = this._recordGlyph(h5), r12 = this._currentPage, a10 = h5.metrics;
      t12[i7] = { rect: s11, page: r12, metrics: a10, code: i7, sdf: true }, this._invalidate();
    }
    return t12[i7];
  }
  _recordGlyph(t12) {
    const h5 = t12.metrics;
    let s11;
    if (0 === h5.width)
      s11 = new t2(0, 0, 0, 0);
    else {
      const e13 = 3, r12 = h5.width + 2 * e13, a10 = h5.height + 2 * e13;
      s11 = this._binPack.allocate(r12, a10), s11.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t6(this.width - 4, this.height - 4), s11 = this._binPack.allocate(r12, a10));
      const n16 = this._glyphData[this._currentPage], o9 = t12.bitmap;
      let c12, l9;
      if (o9)
        for (let t13 = 0; t13 < a10; t13++) {
          c12 = r12 * t13, l9 = this.width * (s11.y + t13) + s11.x;
          for (let t14 = 0; t14 < r12; t14++)
            n16[l9 + t14] = o9[c12 + t14];
        }
      has("esri-glyph-debug") && this._showDebugPage(n16);
    }
    return s11;
  }
  _showDebugPage(t12) {
    const e13 = document.createElement("canvas"), i7 = e13.getContext("2d"), h5 = new ImageData(this.width, this.height), s11 = h5.data;
    e13.width = this.width, e13.height = this.height, e13.style.border = "1px solid black";
    for (let r12 = 0; r12 < t12.length; ++r12)
      s11[4 * r12] = t12[r12], s11[4 * r12 + 1] = 0, s11[4 * r12 + 2] = 0, s11[4 * r12 + 3] = 255;
    i7.putImageData(h5, 0, 0), document.body.appendChild(e13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a4 = class {
  constructor(e13) {
    for (this._metrics = [], this._bitmaps = []; e13.next(); )
      switch (e13.tag()) {
        case 1: {
          const t12 = e13.getMessage();
          for (; t12.next(); )
            switch (t12.tag()) {
              case 3: {
                const e14 = t12.getMessage();
                let a10, s11, r12, n16, i7, c12, g6;
                for (; e14.next(); )
                  switch (e14.tag()) {
                    case 1:
                      a10 = e14.getUInt32();
                      break;
                    case 2:
                      s11 = e14.getBytes();
                      break;
                    case 3:
                      r12 = e14.getUInt32();
                      break;
                    case 4:
                      n16 = e14.getUInt32();
                      break;
                    case 5:
                      i7 = e14.getSInt32();
                      break;
                    case 6:
                      c12 = e14.getSInt32();
                      break;
                    case 7:
                      g6 = e14.getUInt32();
                      break;
                    default:
                      e14.skip();
                  }
                e14.release(), a10 && (this._metrics[a10] = { width: r12, height: n16, left: i7, top: c12, advance: g6 }, this._bitmaps[a10] = s11);
                break;
              }
              default:
                t12.skip();
            }
          t12.release();
          break;
        }
        default:
          e13.skip();
      }
  }
  getMetrics(e13) {
    return this._metrics[e13];
  }
  getBitmap(e13) {
    return this._bitmaps[e13];
  }
};
var s7 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e13) {
    return this._ranges[e13];
  }
  addRange(e13, t12) {
    this._ranges[e13] = t12;
  }
};
var r3 = class {
  constructor(e13) {
    this._glyphInfo = {}, this._baseURL = e13;
  }
  getRange(s11, r12, n16) {
    const i7 = this._getFontStack(s11);
    if (i7.getRange(r12))
      return Promise.resolve();
    const c12 = 256 * r12, g6 = c12 + 255, o9 = this._baseURL.replace("{fontstack}", s11).replace("{range}", c12 + "-" + g6);
    return j(o9, { responseType: "array-buffer", ...n16 }).then((e13) => {
      i7.addRange(r12, new a4(new n5(new Uint8Array(e13.data), new DataView(e13.data))));
    });
  }
  async preloadASCIIRange(s11) {
    const r12 = this._getFontStack(s11), n16 = 0, i7 = 255, c12 = this._baseURL.replace("{fontstack}", s11).replace("{range}", n16 + "-" + i7), g6 = await j(c12, { responseType: "array-buffer" }), o9 = new a4(new n5(new Uint8Array(g6.data), new DataView(g6.data)));
    for (let e13 = n16; e13 <= i7; e13++)
      r12.getRange(e13) || r12.addRange(e13, o9);
  }
  getGlyph(e13, t12) {
    const a10 = this._getFontStack(e13);
    if (!a10)
      return;
    const s11 = Math.floor(t12 / 256), r12 = a10.getRange(s11);
    return r12 ? { metrics: r12.getMetrics(t12), bitmap: r12.getBitmap(t12) } : void 0;
  }
  _getFontStack(e13) {
    let t12 = this._glyphInfo[e13];
    return t12 || (t12 = this._glyphInfo[e13] = new s7()), t12;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var i4 = 1e20;
var r4 = class {
  constructor(t12) {
    this._svg = null, this.size = t12;
    const e13 = document.createElement("canvas");
    e13.width = e13.height = t12, this._context = e13.getContext("2d"), this._gridOuter = new Float64Array(t12 * t12), this._gridInner = new Float64Array(t12 * t12), this._f = new Float64Array(t12), this._d = new Float64Array(t12), this._z = new Float64Array(t12 + 1), this._v = new Int16Array(t12);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r12, h5, n16 = 31) {
    this._initSVG();
    const o9 = this.createSVGString(r12);
    return new Promise((r13, a10) => {
      const d9 = new Image();
      d9.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(o9), d9.onload = () => {
        d9.onload = null, this._context.clearRect(0, 0, this.size, this.size), this._context.drawImage(d9, 0, 0, this.size, this.size);
        const e13 = this._context.getImageData(0, 0, this.size, this.size), s11 = new Uint8Array(this.size * this.size * 4);
        for (let t12 = 0; t12 < this.size * this.size; t12++) {
          const s12 = e13.data[4 * t12 + 3] / 255;
          this._gridOuter[t12] = 1 === s12 ? 0 : 0 === s12 ? i4 : Math.max(0, 0.5 - s12) ** 2, this._gridInner[t12] = 1 === s12 ? i4 : 0 === s12 ? 0 : Math.max(0, s12 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, this.size, this.size), this._edt(this._gridInner, this.size, this.size);
        for (let i7 = 0; i7 < this.size * this.size; i7++) {
          const e14 = this._gridOuter[i7] - this._gridInner[i7];
          o2(0.5 - e14 / (2 * n16), s11, 4 * i7);
        }
        r13(s11);
      };
      const l9 = h5 && h5.signal;
      l9 && w(l9, () => a10(c()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t12 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t12.setAttribute("style", "position: absolute;"), t12.setAttribute("width", "0"), t12.setAttribute("height", "0"), t12.setAttribute("aria-hidden", "true"), t12.setAttribute("role", "presentation"), document.body.appendChild(t12), this._svg = t12;
    }
    return this._svg;
  }
  createSVGString(t12) {
    const e13 = this._initSVG(), s11 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s11.setAttribute("d", t12), e13.appendChild(s11);
    const i7 = s11.getBBox(), r12 = i7.width / i7.height, h5 = this.size / 2;
    let n16, o9, a10, d9;
    if (r12 > 1) {
      o9 = n16 = h5 / i7.width;
      const t13 = h5 * (1 / r12);
      a10 = this.size / 4, d9 = h5 - t13 / 2;
    } else {
      n16 = o9 = h5 / i7.height;
      a10 = h5 - h5 * r12 / 2, d9 = this.size / 4;
    }
    const l9 = -i7.x * n16 + a10, _6 = -i7.y * o9 + d9;
    s11.setAttribute("style", `transform: matrix(${n16}, 0, 0, ${o9}, ${l9}, ${_6})`);
    const g6 = `<svg style="fill:red;" height="${this.size}" width="${this.size}" xmlns="http://www.w3.org/2000/svg">${e13.innerHTML}</svg>`;
    return e13.removeChild(s11), g6;
  }
  _edt(t12, e13, s11) {
    const i7 = this._f, r12 = this._d, h5 = this._v, n16 = this._z;
    for (let o9 = 0; o9 < e13; o9++) {
      for (let r13 = 0; r13 < s11; r13++)
        i7[r13] = t12[r13 * e13 + o9];
      this._edt1d(i7, r12, h5, n16, s11);
      for (let i8 = 0; i8 < s11; i8++)
        t12[i8 * e13 + o9] = r12[i8];
    }
    for (let o9 = 0; o9 < s11; o9++) {
      for (let s12 = 0; s12 < e13; s12++)
        i7[s12] = t12[o9 * e13 + s12];
      this._edt1d(i7, r12, h5, n16, e13);
      for (let s12 = 0; s12 < e13; s12++)
        t12[o9 * e13 + s12] = Math.sqrt(r12[s12]);
    }
  }
  _edt1d(t12, e13, s11, r12, h5) {
    s11[0] = 0, r12[0] = -i4, r12[1] = +i4;
    for (let n16 = 1, o9 = 0; n16 < h5; n16++) {
      let e14 = (t12[n16] + n16 * n16 - (t12[s11[o9]] + s11[o9] * s11[o9])) / (2 * n16 - 2 * s11[o9]);
      for (; e14 <= r12[o9]; )
        o9--, e14 = (t12[n16] + n16 * n16 - (t12[s11[o9]] + s11[o9] * s11[o9])) / (2 * n16 - 2 * s11[o9]);
      o9++, s11[o9] = n16, r12[o9] = e14, r12[o9 + 1] = +i4;
    }
    for (let i7 = 0, n16 = 0; i7 < h5; i7++) {
      for (; r12[n16 + 1] < i7; )
        n16++;
      e13[i7] = (i7 - s11[n16]) * (i7 - s11[n16]) + t12[s11[n16]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c6(t12) {
  return t12 && "static" === t12.type;
}
var n11 = class _n {
  constructor(t12, e13, i7 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, (t12 <= 0 || e13 <= 0) && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t12, this._pageHeight = e13, i7 > 0 && (this._maxItemSize = i7), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t6(this._pageWidth, this._pageHeight);
    const s11 = Math.floor(this._pageWidth), o9 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s11 * o9) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t12) {
    return t12 >= this._mosaicPages.length ? -1 : this._mosaicPages[t12].size[0];
  }
  getHeight(t12) {
    return t12 >= this._mosaicPages.length ? -1 : this._mosaicPages[t12].size[1];
  }
  getPageTexture(t12) {
    return t12 < this._mosaicPages.length ? this._mosaicPages[t12].texture : null;
  }
  has(t12) {
    return this._mosaicRects.has(t12);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t12) {
    return this._mosaicRects.get(t12);
  }
  addSpriteItem(t12, i7, a10, o9, r12, h5, n16 = 1) {
    if (this._mosaicRects.has(t12))
      return this._mosaicRects.get(t12);
    let g6, p3, m5;
    if (c6(a10))
      [g6, p3, m5] = this._allocateImage(i7[0], i7[1]);
    else {
      g6 = new t2(0, 0, i7[0], i7[1]), p3 = this._mosaicPages.length;
      const t13 = void 0;
      this._mosaicPages.push({ mosaicsData: a10, size: [i7[0] + 2 * ae, i7[1] + 2 * ae], dirty: true, texture: t13 });
    }
    if (g6.width <= 0 || g6.height <= 0)
      return null;
    const d9 = { rect: g6, width: i7[0], height: i7[1], sdf: r12, simplePattern: h5, pixelRatio: n16, page: p3 };
    return this._mosaicRects.set(t12, d9), c6(a10) && (has("esri-mosaic-debug") && this._showDebugSprite(i7, a10.data), this._copy({ rect: g6, spriteSize: i7, spriteData: a10.data, page: p3, pageSize: m5, repeat: o9, sdf: r12 })), d9;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t12 = this._spriteCopyQueue.pop();
    t12 && this._copy(t12);
  }
  getSpriteItems(t12) {
    const e13 = {};
    for (const i7 of t12)
      e13[i7] = this.getSpriteItem(i7);
    return e13;
  }
  getMosaicItemPosition(t12) {
    const i7 = this.getSpriteItem(t12), s11 = i7 && i7.rect;
    if (!s11)
      return null;
    s11.width = i7.width, s11.height = i7.height;
    const a10 = i7.width, o9 = i7.height, r12 = ae, h5 = this._mosaicPages[i7.page].size;
    return { size: [i7.width, i7.height], tl: [(s11.x + r12) / h5[0], (s11.y + r12) / h5[1]], br: [(s11.x + r12 + a10) / h5[0], (s11.y + r12 + o9) / h5[1]], page: i7.page };
  }
  bind(t12, e13, i7 = 0, s11 = 0) {
    const a10 = this._mosaicPages[i7], o9 = a10.mosaicsData;
    let r12 = a10.texture;
    if (r12 || (r12 = p2(t12, a10.size), a10.texture = r12), r12.setSamplingMode(e13), c6(o9))
      t12.bindTexture(r12, s11), a10.dirty && (r12.setData(new Uint8Array(o9.data.buffer)), r12.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i7));
    else {
      o9.data.bindFrame(t12, r12, s11), r12.generateMipmap();
    }
    a10.dirty = false;
  }
  dispose() {
    this._binPack = null;
    for (const t12 of this._mosaicPages) {
      const e13 = t12.texture;
      e13 && e13.dispose();
      const i7 = t12.mosaicsData;
      if (!c6(i7)) {
        i7.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t12, e13, i7, s11, a10, o9, r12, h5, c12, n16, g6) {
    let p3 = s11 * e13 + i7, m5 = h5 * o9 + r12;
    if (g6) {
      m5 -= o9;
      for (let r13 = -1; r13 <= n16; r13++, p3 = ((r13 + n16) % n16 + s11) * e13 + i7, m5 += o9)
        for (let e14 = -1; e14 <= c12; e14++)
          a10[m5 + e14] = t12[p3 + (e14 + c12) % c12];
    } else
      for (let d9 = 0; d9 < n16; d9++) {
        for (let e14 = 0; e14 < c12; e14++)
          a10[m5 + e14] = t12[p3 + e14];
        p3 += e13, m5 += o9;
      }
  }
  _copy(i7) {
    if (i7.page >= this._mosaicPages.length)
      return;
    const s11 = this._mosaicPages[i7.page], a10 = s11.mosaicsData;
    if (!c6(s11.mosaicsData))
      throw new s3("mapview-invalid-resource", "unsuitable data type!");
    const o9 = i7.spriteData, r12 = a10.data;
    r12 && o9 || console.error("Source or target images are uninitialized!"), _n._copyBits(o9, i7.spriteSize[0], 0, 0, r12, i7.pageSize[0], i7.rect.x + ae, i7.rect.y + ae, i7.spriteSize[0], i7.spriteSize[1], i7.repeat), s11.dirty = true;
  }
  _allocateImage(t12, o9) {
    t12 += 2 * ae, o9 += 2 * ae;
    const r12 = Math.max(t12, o9);
    if (this._maxItemSize && this._maxItemSize < r12) {
      const e13 = 2 ** Math.ceil(e2(t12)), a10 = 2 ** Math.ceil(e2(o9)), r13 = new t2(0, 0, t12, o9);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e13 * a10) }, size: [e13, a10], dirty: true, texture: void 0 }), [r13, this._mosaicPages.length - 1, [e13, a10]];
    }
    const h5 = this._binPack.allocate(t12, o9);
    if (h5.width <= 0) {
      const e13 = this._mosaicPages[this._currentPage];
      return !e13.dirty && c6(e13.mosaicsData) && (e13.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t6(this._pageWidth, this._pageHeight), this._allocateImage(t12, o9);
    }
    return [h5, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t12, e13], i7) {
    const s11 = document.createElement("canvas");
    s11.width = t12, s11.height = e13, s11.setAttribute("style", `position: absolute; top: ${4 + 204 * g3++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a10 = s11.getContext("2d"), o9 = new ImageData(t12, e13);
    o9.data.set(new Uint8Array(i7.buffer)), a10.putImageData(o9, 0, 0), document.body.appendChild(s11);
  }
  _showDebugPage(t12) {
    const e13 = this._mosaicPages[t12], { size: [i7, s11], mosaicsData: a10 } = e13;
    if (!c6(a10))
      return void console.error("Could not show sprite mosaic debug for non-static resource");
    const o9 = `mosaicDebugPage${t12}`, r12 = document.getElementById(o9) ?? document.createElement("canvas");
    r12.id = o9, r12.width = i7, r12.height = s11, r12.setAttribute("style", `position: absolute; top: ${4 + 204 * t12}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h5 = r12.getContext("2d"), n16 = new ImageData(i7, s11);
    n16.data.set(new Uint8Array(a10.data.buffer)), h5.putImageData(n16, 0, 0), document.body.appendChild(r12);
  }
};
var g3 = 0;
function p2(t12, e13) {
  const i7 = new e5();
  return i7.width = e13[0], i7.height = e13[1], i7.wrapMode = D.CLAMP_TO_EDGE, new T2(t12, i7, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/utils.js
function n12(e13) {
  return n(e13.frameDurations.reduce((t12, e14) => t12 + e14, 0));
}
function s8(t12) {
  const { width: e13, height: r12 } = t12;
  return { frameDurations: t12.frameDurations.reverse(), getFrame: (e14) => {
    const r13 = t12.frameDurations.length - 1 - e14;
    return t12.getFrame(r13);
  }, width: e13, height: r12 };
}
function o7(e13, r12) {
  const { width: i7, height: a10, getFrame: s11 } = e13, o9 = r12 / n12(e13);
  return { frameDurations: e13.frameDurations.map((e14) => n(e14 * o9)), getFrame: s11, width: i7, height: a10 };
}
function m3(e13, r12) {
  const { width: i7, height: a10, getFrame: n16 } = e13, s11 = e13.frameDurations.slice(), o9 = s11.shift();
  return s11.unshift(n(o9 + r12)), { frameDurations: s11, getFrame: n16, width: i7, height: a10 };
}
function h(e13, r12) {
  const { width: i7, height: a10, getFrame: n16 } = e13, s11 = e13.frameDurations.slice(), o9 = s11.pop();
  return s11.push(n(o9 + r12)), { frameDurations: s11, getFrame: n16, width: i7, height: a10 };
}
var c7 = class {
  constructor(t12, e13, r12, i7) {
    this._animation = t12, this._repeatType = r12, this._onFrameData = i7, this._direction = 1, this._currentFrame = 0, this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    let a10 = 0;
    for (; e13 > a10; )
      a10 += this.timeToFrame, this.nextFrame();
    const n16 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(n16);
  }
  nextFrame() {
    if (this._currentFrame += this._direction, this._direction > 0) {
      if (this._currentFrame === this._animation.frameDurations.length)
        switch (this._repeatType) {
          case d2.None:
            this._currentFrame -= this._direction;
            break;
          case d2.Loop:
            this._currentFrame = 0;
            break;
          case d2.Oscillate:
            this._currentFrame -= this._direction, this._direction = -1;
        }
    } else if (-1 === this._currentFrame)
      switch (this._repeatType) {
        case d2.None:
          this._currentFrame -= this._direction;
          break;
        case d2.Loop:
          this._currentFrame = this._animation.frameDurations.length - 1;
          break;
        case d2.Oscillate:
          this._currentFrame -= this._direction, this._direction = 1;
      }
    this.timeToFrame = this._animation.frameDurations[this._currentFrame];
    const t12 = this._animation.getFrame(this._currentFrame);
    this._onFrameData(t12);
  }
};
function u3(e13, u5, f4, l9) {
  let g6, { repeatType: F2 } = u5;
  if (null == F2 && (F2 = d2.Loop), true === u5.reverseAnimation && (e13 = s8(e13)), null != u5.duration && (e13 = o7(e13, n(1e3 * u5.duration))), null != u5.repeatDelay) {
    const i7 = 1e3 * u5.repeatDelay;
    F2 === d2.Loop ? e13 = h(e13, n(i7)) : F2 === d2.Oscillate && (e13 = m3(h(e13, n(i7 / 2)), n(i7 / 2)));
  }
  if (null != u5.startTimeOffset)
    g6 = n(1e3 * u5.startTimeOffset);
  else if (null != u5.randomizeStartTime) {
    const r12 = o3(f4), s11 = 82749913, o9 = null != u5.randomizeStartSeed ? u5.randomizeStartSeed : s11, m5 = e3(r12, o9);
    g6 = n(m5 * n12(e13));
  } else
    g6 = n(0);
  return new c7(e13, g6, F2, l9);
}
function f3(t12, e13, r12, i7) {
  const a10 = null == e13.playAnimation || e13.playAnimation, n16 = u3(t12, e13, r12, i7);
  let s11, o9 = n16.timeToFrame;
  function m5() {
    s11 = a10 ? setTimeout(() => {
      n16.nextFrame(), o9 = n16.timeToFrame, m5();
    }, o9) : void 0;
  }
  return m5(), { remove: () => {
    a10 && clearTimeout(s11);
  } };
}
var l4 = document.createElement("canvas");
var g4 = l4.getContext("2d");
function F(t12, r12, i7) {
  l4.width = r12, l4.height = i7;
  const a10 = [], n16 = t12.frameDurations.length;
  for (let s11 = 0; s11 < n16; s11++) {
    const n17 = t12.getFrame(s11);
    g4.clearRect(0, 0, r12, i7), n17 instanceof ImageData ? g4.drawImage(o4(n17), 0, 0, r12, i7) : g4.drawImage(n17, 0, 0, r12, i7), a10.push(g4.getImageData(0, 0, r12, i7));
  }
  return { width: r12, height: i7, frameDurations: t12.frameDurations, getFrame: (t13) => a10[t13] };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var i5 = class {
  constructor(t12, i7, e13, s11) {
    this._animation = t12, this._frameData = null;
    const h5 = (t13) => {
      this._frameData = t13, i7.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = f3(this._animation, e13, s11, h5);
  }
  destroy() {
    this._playHandle.remove();
  }
  bindFrame(a10, i7, e13) {
    a10.bindTexture(i7, e13), null != this._frameData && (i7.updateData(0, ae, ae, this._frameData.width, this._frameData.height, this._frameData), this._frameData = null);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/symbolUtils.js
function e11(e13) {
  switch (e13.type) {
    case "esriSMS":
      return `${e13.style}.${e13.path}`;
    case "esriSLS":
      return `${e13.style}.${e13.cap}`;
    case "esriSFS":
      return `${e13.style}`;
    case "esriPFS":
    case "esriPMS":
      return e13.imageData ? `${e13.imageData}${e13.width}${e13.height}` : `${e13.url}${e13.width}${e13.height}`;
    default:
      return "mosaicHash" in e13 ? e13.mosaicHash : JSON.stringify(e13);
  }
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var $ = n6();
var k = "arial-unicode-ms-regular";
var H = s2.getLogger("esri.views.2d.engine.webgl.TextureManager");
function O(e13, t12) {
  const i7 = Math.round(u(t12) * window.devicePixelRatio), s11 = i7 >= 128 ? 2 : 4;
  return Math.min(e13, i7 * s11);
}
var Q = (e13, t12, i7) => H.error(new s3(e13, t12, i7));
var V = class _V {
  static fromMosaic(e13, t12) {
    return new _V(e13, t12.page, t12.sdf);
  }
  constructor(e13, t12, i7) {
    this.mosaicType = e13, this.page = t12, this.sdf = i7;
  }
};
var Y2 = class {
  constructor(i7, r12, o9) {
    this._requestRender = i7, this.resourceManager = r12, this._allowNonPowerOfTwo = o9, this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r4(ce), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new u2({ concurrency: 10, process: async (e13, i8) => {
      s4(i8);
      try {
        return await j(e13, { responseType: "image", signal: i8 });
      } catch (r13) {
        if (!d(r13))
          throw new s3("mapview-invalid-resource", `Could not fetch requested resource at ${e13}`, r13);
        throw r13;
      }
    } }), this._spriteMosaic = new n11(2048, 2048, 500), this._glyphSource = new r3(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p(1024, 1024, this._glyphSource), this._rasterizer = new c4(r12);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null;
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  async rasterizeItem(e13, t12, i7, s11) {
    if (null == e13)
      return Q("mapview-null-resource", "Unable to rasterize null resource"), null;
    switch (e13.type) {
      case "text":
      case "esriTS": {
        const t13 = await this._rasterizeText(e13, i7, s11);
        return t13.forEach((e14) => this._setTextureBinding(_.GLYPH, e14)), { glyphMosaicItems: t13 };
      }
      default: {
        if (ue(e13))
          return Q("mapview-invalid-type", `MapView does not support symbol type: ${e13.type}`, e13), null;
        const i8 = await this._rasterizeSpriteSymbol(e13, t12, s11);
        return e4(i8) && i8 && this._setTextureBinding(_.SPRITE, i8), { spriteMosaicItem: i8 };
      }
    }
  }
  bindTextures(e13, t12, i7, s11 = false) {
    if (0 === i7.textureBinding)
      return;
    const r12 = this._bindingInfos[i7.textureBinding - 1], o9 = r12.page, n16 = s11 ? L.LINEAR_MIPMAP_LINEAR : L.LINEAR;
    switch (r12.mosaicType) {
      case _.SPRITE: {
        const i8 = this.sprites.getWidth(o9), s12 = this.sprites.getHeight(o9), r13 = r2($, i8, s12);
        return this._spriteMosaic.bind(e13, n16, o9, B), t12.setUniform1i("u_texture", B), void t12.setUniform2fv("u_mosaicSize", r13);
      }
      case _.GLYPH: {
        const i8 = this.glyphs.width, s12 = this.glyphs.height, r13 = r2($, i8, s12);
        return this._glyphMosaic.bind(e13, n16, o9, C), t12.setUniform1i("u_texture", C), void t12.setUniform2fv("u_mosaicSize", r13);
      }
      default:
        H.error("mapview-texture-manager", `Cannot handle unknown type ${r12.mosaicType}`);
    }
  }
  _hashMosaic(e13, t12) {
    return 1 | e13 << 1 | (t12.sdf ? 1 : 0) << 2 | t12.page << 3;
  }
  _setTextureBinding(e13, t12) {
    const i7 = this._hashMosaic(e13, t12);
    if (!this._hashToBindingIndex.has(i7)) {
      const s11 = V.fromMosaic(e13, t12), r12 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i7, r12), this._bindingInfos.push(s11);
    }
    t12.textureBinding = this._hashToBindingIndex.get(i7);
  }
  async _rasterizeText(e13, t12, s11) {
    let o9, n16;
    if ("cim" in e13) {
      const t13 = e13;
      o9 = t13.fontName, n16 = t13.text;
    } else {
      const t13 = e13;
      o9 = f2(t13.font), n16 = t13.text;
    }
    const a10 = this._invalidFontsMap.has(o9), h5 = t12 || pe(i3(n16)[0]);
    try {
      const e14 = a10 ? k : o9;
      return has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e14), await this._glyphMosaic.getGlyphItems(e14, h5, s11);
    } catch (c12) {
      return Q("mapview-invalid-resource", `Couldn't find font ${o9}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(o9, true), this._glyphMosaic.getGlyphItems(k, h5, s11);
    }
  }
  async _rasterizeSpriteSymbol(e13, t12, i7) {
    if (le(e13))
      return;
    const r12 = e11(e13);
    if (this._spriteMosaic.has(r12))
      return this._spriteMosaic.getSpriteItem(r12);
    if (ne(e13) || re(e13) && !Ie(e13))
      return this._handleAsyncResource(r12, e13, i7);
    const o9 = Ae, n16 = this._rasterizer.rasterizeJSONResource(e13, o9);
    if (n16) {
      const { size: t13, image: i8, sdf: s11, simplePattern: o10, rasterizationScale: a10 } = n16;
      return this._addItemToMosaic(r12, t13, { type: "static", data: i8 }, fe(e13), s11, o10, a10);
    }
    return new s3("TextureManager", "unrecognized or null rasterized image");
  }
  async _handleAsyncResource(e13, t12, i7) {
    if (this._ongoingRasterizations.has(e13))
      return this._ongoingRasterizations.get(e13);
    let s11;
    s11 = ne(t12) ? this._handleSVG(t12, e13, i7) : this._handleImage(t12, e13, i7), this._ongoingRasterizations.set(e13, s11);
    try {
      await s11, this._ongoingRasterizations.delete(e13);
    } catch {
      this._ongoingRasterizations.delete(e13);
    }
    return s11;
  }
  async _handleSVG(e13, t12, i7) {
    const s11 = [ce, ce], r12 = await this._sdfConverter.draw(e13.path, i7);
    return this._addItemToMosaic(t12, s11, { type: "static", data: new Uint32Array(r12.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e13, t12, i7) {
    const r12 = se(e13);
    await this.resourceManager.fetchResource(r12, i7);
    let o9 = this.resourceManager.getResource(r12);
    if (null == o9)
      return new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r12}.`);
    let a10 = o9.width, h5 = o9.height;
    if (o9 instanceof HTMLImageElement) {
      "esriPMS" === e13.type && (a10 = Math.round(O(o9.width, de(e13))), h5 = Math.round(o9.height * (a10 / o9.width)));
      const i8 = "cim" in e13 ? e13.cim.colorSubstitutions : void 0, { size: s11, sdf: r13, image: n16 } = this._rasterizer.rasterizeImageResource(a10, h5, o9, i8);
      return this._addItemToMosaic(t12, s11, { type: "static", data: n16 }, fe(e13), r13, false);
    }
    this._allowNonPowerOfTwo || (a10 = c2(o9.width + 2 * ae) - 2 * ae, h5 = c2(o9.height + 2 * ae) - 2 * ae), a10 === o9.width && h5 === o9.height || (o9 = F(o9, a10, h5));
    const c12 = e13.animatedSymbolProperties || {}, u5 = e13.objectId, d9 = new i5(o9, this._requestRender, c12, u5);
    return this._addItemToMosaic(t12, [d9.width, d9.height], { type: "animated", data: d9 }, fe(e13), false, false);
  }
  async _handleImage(e13, t12, i7) {
    if (ie(e13) || oe(e13))
      return this._handleGIFOrPNG(e13, t12, i7);
    const r12 = se(e13);
    try {
      let s11;
      const o9 = this.resourceManager.getResource(r12);
      if (null != o9 && o9 instanceof HTMLImageElement)
        s11 = o9;
      else {
        const { data: e14 } = await this._imageRequestQueue.push(r12, { ...i7 });
        s11 = e14;
      }
      if (me(r12)) {
        if ("width" in e13 && "height" in e13)
          s11.width = u(e13.width), s11.height = u(e13.height);
        else if ("cim" in e13) {
          const t13 = e13.cim;
          s11.width = u(t13.width ?? t13.scaleX * t13.size), s11.height = u(t13.size);
        }
      }
      if (!s11.width || !s11.height)
        return null;
      let n16 = s11.width, a10 = s11.height;
      "esriPMS" === e13.type && (n16 = Math.round(O(s11.width, de(e13))), a10 = Math.round(s11.height * (n16 / s11.width)));
      const h5 = "cim" in e13 ? e13.cim.colorSubstitutions : void 0, { size: u5, sdf: d9, image: l9 } = this._rasterizer.rasterizeImageResource(n16, a10, s11, h5);
      return this._addItemToMosaic(t12, u5, { type: "static", data: l9 }, fe(e13), d9, false);
    } catch (Q2) {
      if (!d(Q2))
        return new s3("mapview-invalid-resource", `Could not fetch requested resource at ${r12}. ${Q2.message}`);
    }
  }
  _addItemToMosaic(e13, t12, i7, s11, r12, o9, n16) {
    return this._spriteMosaic.addSpriteItem(e13, t12, i7, s11, r12, o9, n16);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/StencilPrograms.js
var r5 = { shaders: { vertexShader: n8("stencil/stencil.vert"), fragmentShader: n8("stencil/stencil.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r6 = (e13) => e13.replace("-", "_").toUpperCase();
var t7 = (e13) => `#define ${r6(e13)}
`;
function n13(r12) {
  return { attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]), shaders: { vertexShader: t7(r12) + n8("blend/blend.vert"), fragmentShader: t7(r12) + n8("blend/blend.frag") } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var c8 = s2.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var m4 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e13) {
    this._backBufferTexture = t(this._backBufferTexture), this._quad = t(this._quad);
  }
  draw(r12, t12, i7, a10, d9) {
    const { context: u5, drawPhase: f4 } = r12;
    if (this._setupShader(u5), a10 && "normal" !== a10 && f4 !== T.LABEL)
      return void this._drawBlended(r12, t12, i7, a10, d9);
    const m5 = n13("normal"), h5 = u5.programCache.acquire(m5.shaders.vertexShader, m5.shaders.fragmentShader, m5.attributes);
    if (!h5)
      return void c8.error(new s3("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u5.useProgram(h5), t12.setSamplingMode(i7), u5.bindTexture(t12, 0), h5.setUniform1i("u_layerTexture", 0), h5.setUniform1f("u_opacity", d9), u5.setBlendingEnabled(true), u5.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
    const l9 = this._quad;
    l9.draw(), l9.unbind(), h5.dispose();
  }
  _drawBlended(r12, t12, s11, i7, a10) {
    const { context: d9, state: u5, pixelRatio: f4, inFadeTransition: m5 } = r12, { size: h5 } = u5, l9 = d9.getBoundFramebufferObject();
    let _6, p3;
    null != l9 ? (_6 = l9.width, p3 = l9.height) : (_6 = Math.round(f4 * h5[0]), p3 = Math.round(f4 * h5[1])), this._createOrResizeTexture(r12, _6, p3);
    const b = this._backBufferTexture;
    l9.copyToTexture(0, 0, _6, p3, 0, 0, b), d9.setStencilTestEnabled(false), d9.setStencilWriteMask(0), d9.setBlendingEnabled(true), d9.setDepthTestEnabled(false), d9.setDepthWriteEnabled(false);
    const g6 = n13(i7), x2 = d9.programCache.acquire(g6.shaders.vertexShader, g6.shaders.fragmentShader, g6.attributes);
    if (!x2)
      return void c8.error(new s3("mapview-BlendEffect", `Error creating shader program for blend mode ${i7}`));
    d9.useProgram(x2), b.setSamplingMode(s11), d9.bindTexture(b, 0), x2.setUniform1i("u_backbufferTexture", 0), t12.setSamplingMode(s11), d9.bindTexture(t12, 1), x2.setUniform1i("u_layerTexture", 1), x2.setUniform1f("u_opacity", a10), x2.setUniform1f("u_inFadeOpacity", m5 ? 1 : 0), d9.setBlendFunction(R.ONE, R.ZERO);
    const T5 = this._quad;
    T5.draw(), T5.unbind(), x2.dispose(), d9.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e13) {
    this._quad || (this._quad = new n7(e13, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e13, r12, t12) {
    const { context: s11 } = e13;
    if (null === this._backBufferTexture || r12 !== this._size[0] || t12 !== this._size[1]) {
      if (this._backBufferTexture)
        this._backBufferTexture.resize(r12, t12);
      else {
        const e14 = new e5();
        e14.internalFormat = G.RGBA, e14.wrapMode = D.CLAMP_TO_EDGE, e14.width = r12, e14.height = t12, this._backBufferTexture = new T2(s11, e14);
      }
      this._size[0] = r12, this._size[1] = t12;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/HighlightPrograms.js
var t8 = { shaders: { vertexShader: n8("highlight/textured.vert"), fragmentShader: n8("highlight/highlight.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };
var r7 = { shaders: { vertexShader: n8("highlight/textured.vert"), fragmentShader: n8("highlight/blur.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/Profiler.js
var r8 = has("esri-2d-profiler");
var n14 = class {
  constructor(n16, i7) {
    if (this._events = new n2(), this._entries = /* @__PURE__ */ new Map(), this._timings = new t3(10), this._currentContainer = null, this._currentPass = null, this._currentBrush = null, this._currentSummary = null, !r8)
      return;
    this._ext = T3(n16.gl, {}), this._debugOutput = i7;
    const o9 = n16.gl;
    if (!this.enableCommandLogging)
      return;
    let a10;
    for (a10 in o9)
      if ("function" == typeof o9[a10]) {
        const e13 = o9[a10], t12 = a10.includes("draw");
        o9[a10] = (...s11) => (this._events.emit("command", { container: this._currentContainer, pass: this._currentPass, brush: this._currentBrush, method: a10, args: s11, isDrawCommand: t12 }), this._currentSummary && (this._currentSummary.commands++, t12 && this._currentSummary.drawCommands++), e13.apply(o9, s11));
      }
  }
  get enableCommandLogging() {
    return !("object" == typeof r8 && r8.disableCommands);
  }
  recordContainerStart(e13) {
    r8 && (this._currentContainer = e13);
  }
  recordContainerEnd() {
    r8 && (this._currentContainer = null);
  }
  recordPassStart(e13) {
    r8 && (this._currentPass = e13, this._initSummary());
  }
  recordPassEnd() {
    r8 && (this._currentPass = null, this._emitSummary());
  }
  recordBrushStart(e13) {
    r8 && (this._currentBrush = e13);
  }
  recordBrushEnd() {
    r8 && (this._currentBrush = null);
  }
  recordStart(e13) {
    if (r8 && null != this._ext) {
      if (this._entries.has(e13)) {
        const t13 = this._entries.get(e13), s11 = this._ext.resultAvailable(t13.query), r12 = this._ext.disjoint();
        if (s11 && !r12) {
          const s12 = this._ext.getResult(t13.query) / 1e6;
          let r13 = 0;
          if (null != this._timings.enqueue(s12)) {
            const e14 = this._timings.entries, t14 = e14.length;
            let s13 = 0;
            for (const r14 of e14)
              s13 += r14;
            r13 = s13 / t14;
          }
          const n16 = s12.toFixed(2), i7 = r13 ? r13.toFixed(2) : "--";
          this.enableCommandLogging ? (console.groupCollapsed(`Frame report for ${e13}, ${n16} ms (${i7} last 10 avg)
${t13.commandsLen} Commands (${t13.drawCommands} draw)`), console.log("RenderPass breakdown: "), console.table(t13.summaries), console.log("Commands: ", t13.commands), console.groupEnd()) : console.log(`Frame report for ${e13}, ${n16} ms (${i7} last 10 avg)`), this._debugOutput.innerHTML = `${n16} (${i7})`;
        }
        for (const e14 of t13.handles)
          e14.remove();
        this._ext.deleteQuery(t13.query), this._entries.delete(e13);
      }
      const t12 = { name: e13, query: this._ext.createQuery(), commands: [], commandsLen: 0, drawCommands: 0, summaries: [], handles: [] };
      this.enableCommandLogging && (t12.handles.push(this._events.on("command", (e14) => {
        t12.commandsLen++, t12.commands.push(e14), e14.isDrawCommand && t12.drawCommands++;
      })), t12.handles.push(this._events.on("summary", (e14) => {
        t12.summaries.push(e14);
      }))), this._ext.beginTimeElapsed(t12.query), this._entries.set(e13, t12);
    }
  }
  recordEnd(e13) {
    r8 && null != this._ext && this._entries.has(e13) && this._ext.endTimeElapsed();
  }
  _initSummary() {
    this.enableCommandLogging && (this._currentSummary = { container: this._currentContainer, pass: this._currentPass, drawCommands: 0, commands: 0 });
  }
  _emitSummary() {
    this.enableCommandLogging && this._currentSummary && this._events.emit("summary", this._currentSummary);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionGrid.js
var e12 = 2;
var i6 = 1;
var o8 = 0;
var h2 = 1;
var r9 = 2;
var l5 = class {
  constructor(t12, e13, o9) {
    this._debugMap = /* @__PURE__ */ new Map(), this._width = t12 * o9, this._height = e13 * o9, this._pixelRatio = o9;
    const h5 = Math.ceil(this._width / i6), r12 = Math.ceil(this._height / i6);
    this._cols = h5, this._rows = r12, this._cells = t4.create(h5 * r12);
  }
  insertMetrics(t12) {
    const s11 = this._hasCollision(t12);
    return s11 === o8 && this._markMetrics(t12), s11;
  }
  getCellId(t12, s11) {
    return t12 + s11 * this._cols;
  }
  has(t12) {
    return this._cells.has(t12);
  }
  hasRange(t12, s11) {
    return this._cells.hasRange(t12, s11);
  }
  set(t12) {
    this._cells.set(t12);
  }
  setRange(t12, s11) {
    this._cells.setRange(t12, s11);
  }
  _collide(s11, e13, l9, n16) {
    const c12 = s11 - l9 / 2, a10 = e13 - n16 / 2, _6 = c12 + l9, d9 = a10 + n16;
    if (_6 < 0 || d9 < 0 || c12 > this._width || a10 > this._height)
      return h2;
    const u5 = i(Math.floor(c12 / i6), 0, this._cols), p3 = i(Math.floor(a10 / i6), 0, this._rows), M = i(Math.ceil(_6 / i6), 0, this._cols), f4 = i(Math.ceil(d9 / i6), 0, this._rows);
    for (let t12 = p3; t12 <= f4; t12++)
      for (let s12 = u5; s12 <= M; s12++) {
        const e14 = this.getCellId(s12, t12);
        if (this.has(e14))
          return r9;
      }
    return o8;
  }
  _mark(s11, e13, o9, h5, r12) {
    const l9 = s11 - o9 / 2, n16 = e13 - h5 / 2, c12 = l9 + o9, a10 = n16 + h5, _6 = i(Math.floor(l9 / i6), 0, this._cols), d9 = i(Math.floor(n16 / i6), 0, this._rows), u5 = i(Math.ceil(c12 / i6), 0, this._cols), p3 = i(Math.ceil(a10 / i6), 0, this._rows);
    for (let t12 = d9; t12 <= p3; t12++)
      for (let s12 = _6; s12 <= u5; s12++) {
        const e14 = this.getCellId(s12, t12);
        this._debugMap.set(e14, r12), this.set(e14);
      }
    return false;
  }
  _hasCollision(t12) {
    const s11 = t12.id;
    let i7 = 0, l9 = 0;
    t12.save();
    do {
      const s12 = t12.boundsCount;
      i7 += s12;
      for (let i8 = 0; i8 < s12; i8++) {
        const s13 = t12.boundsComputedAnchorX(i8), o9 = t12.boundsComputedAnchorY(i8), n16 = (t12.boundsWidth(i8) + e12) * this._pixelRatio, c12 = (t12.boundsHeight(i8) + e12) * this._pixelRatio;
        switch (this._collide(s13, o9, n16, c12)) {
          case r9:
            return r9;
          case h2:
            l9++;
        }
      }
    } while (t12.peekId() === s11 && t12.next());
    return t12.restore(), i7 === l9 ? h2 : o8;
  }
  _markMetrics(t12) {
    const s11 = t12.id;
    t12.save();
    do {
      const s12 = t12.boundsCount;
      for (let i7 = 0; i7 < s12; i7++) {
        const s13 = t12.boundsComputedAnchorX(i7), o9 = t12.boundsComputedAnchorY(i7), h5 = (t12.boundsWidth(i7) + e12) * this._pixelRatio, r12 = (t12.boundsHeight(i7) + e12) * this._pixelRatio;
        this._mark(s13, o9, h5, r12, t12.id);
      }
    } while (t12.peekId() === s11 && t12.next());
    t12.restore();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionEngine.js
var r10 = 254;
var l6 = 255;
var a5 = 0;
function d3(e13, i7) {
  const t12 = [];
  e13.forEachTile((e14) => t12.push(e14)), t12.sort((e14, i8) => e14.instanceId - i8.instanceId), t12.forEach((e14) => {
    null != e14.labelMetrics && e14.isReady && i7(e14, e14.labelMetrics.getCursor());
  });
}
var c9 = class {
  run(e13, i7, t12) {
    const o9 = [];
    for (let s11 = e13.length - 1; s11 >= 0; s11--) {
      const i8 = e13[s11];
      i8.labelingCollisionInfos && o9.push(...i8.labelingCollisionInfos);
    }
    this._transformMetrics(o9), this._runCollision(o9, i7, t12);
  }
  _runCollision(e13, i7, o9) {
    const [s11, n16] = i7.state.size, r12 = new l5(s11, n16, i7.pixelRatio);
    for (const { tileRenderer: t12, deconflictionEnabled: c12, visible: f4 } of e13) {
      const e14 = t12.featuresView.attributeView;
      c12 ? f4 ? (this._prepare(t12), this._collideVisible(r12, t12, o9), this._collideInvisible(r12, t12)) : d3(t12, (i8, t13) => {
        for (; t13.nextId(); )
          e14.setLabelMinZoom(t13.id, l6);
      }) : d3(t12, (i8, t13) => {
        for (; t13.nextId(); )
          e14.setLabelMinZoom(t13.id, a5), f4 && r12.insertMetrics(t13);
      });
    }
  }
  _isFiltered(t12, o9, s11) {
    const n16 = o9.getFilterFlags(t12), r12 = !s11.hasFilter || !!(n16 & X), l9 = null == s11.featureEffect || s11.featureEffect.excludedLabelsVisible || !!(n16 & Y);
    return !(r12 && l9);
  }
  _prepare(e13) {
    const i7 = e13.featuresView.attributeView, t12 = /* @__PURE__ */ new Set();
    d3(e13, (o9, s11) => {
      for (; s11.nextId(); ) {
        if (t12.has(s11.id))
          continue;
        if (t12.add(s11.id), this._isFiltered(s11.id, i7, e13.layerView)) {
          i7.setLabelMinZoom(s11.id, r10);
          continue;
        }
        i7.getLabelMinZoom(s11.id) !== a5 ? i7.setLabelMinZoom(s11.id, l6) : i7.setLabelMinZoom(s11.id, a5);
      }
    });
  }
  _collideVisible(e13, i7, t12) {
    const l9 = i7.featuresView.attributeView, c12 = /* @__PURE__ */ new Set();
    d3(i7, (i8, d9) => {
      for (; d9.nextId(); )
        if (!c12.has(d9.id))
          if (i8.key.level === t12) {
            if (0 === l9.getLabelMinZoom(d9.id)) {
              switch (e13.insertMetrics(d9)) {
                case h2:
                  break;
                case r9:
                  l9.setLabelMinZoom(d9.id, r10), c12.add(d9.id);
                  break;
                case o8:
                  l9.setLabelMinZoom(d9.id, a5), c12.add(d9.id);
              }
            }
          } else
            l9.setLabelMinZoom(d9.id, r10);
    });
  }
  _collideInvisible(e13, i7) {
    const t12 = i7.featuresView.attributeView, r12 = /* @__PURE__ */ new Set();
    d3(i7, (i8, d9) => {
      for (; d9.nextId(); )
        if (!r12.has(d9.id) && t12.getLabelMinZoom(d9.id) === l6) {
          switch (e13.insertMetrics(d9)) {
            case h2:
              break;
            case r9:
              t12.setLabelMinZoom(d9.id, l6), r12.add(d9.id);
              break;
            case o8:
              t12.setLabelMinZoom(d9.id, a5), r12.add(d9.id);
          }
        }
    });
  }
  _transformMetrics(e13) {
    for (const { tileRenderer: i7, geometryType: t12, vvEvaluators: o9 } of e13)
      d3(i7, (e14, s11) => {
        const n16 = i7.featuresView.attributeView, r12 = e14.transforms.labelMat2d;
        r12[4] = Math.round(r12[4]), r12[5] = Math.round(r12[5]);
        const l9 = "polyline" === t12;
        for (; s11.next(); ) {
          const e15 = s11.boundsCount, i8 = s11.anchorX, t13 = s11.anchorY;
          let a10 = s11.size;
          const d9 = o9[0];
          if (null != d9) {
            const e16 = d9(n16.getVVSize(s11.id));
            a10 = isNaN(e16) || null == e16 || e16 === 1 / 0 ? a10 : e16;
          }
          const c12 = s11.directionX * (a10 / 2), f4 = s11.directionY * (a10 / 2);
          for (let o10 = 0; o10 < e15; o10++) {
            let e16 = i8, n17 = s11.anchorY;
            if (l9) {
              let i9 = e16 + s11.boundsX(o10) + c12, t14 = n17 + s11.boundsY(o10) + f4;
              i9 = r12[0] * i9 + r12[2] * t14 + r12[4], t14 = r12[1] * i9 + r12[3] * t14 + r12[5], s11.setBoundsComputedAnchorX(o10, Math.floor(i9)), s11.setBoundsComputedAnchorY(o10, Math.floor(t14));
            } else {
              e16 = r12[0] * i8 + r12[2] * t13 + r12[4], n17 = r12[1] * i8 + r12[3] * t13 + r12[5];
              const l10 = e16 + s11.boundsX(o10) + c12, a11 = n17 + s11.boundsY(o10) + f4;
              s11.setBoundsComputedAnchorX(o10, l10), s11.setBoundsComputedAnchorY(o10, a11);
            }
          }
        }
      });
  }
};

// node_modules/@arcgis/core/views/2d/LabelManager.js
var a6 = 32;
var d4 = class extends a3(m2) {
  constructor(e13) {
    super(e13), this.collisionEngine = new c9(), this.lastUpdateId = -1, this.updateRequested = false, this.view = null, this._applyVisibilityPass = e6((e14) => {
      const t12 = this.view;
      if (t12)
        try {
          const s11 = t12.featuresTilingScheme.getClosestInfoForScale(e14.state.scale).level;
          this.collisionEngine.run(t12.allLayerViews.items, e14, s11);
        } catch (s11) {
        }
    }, a6, this), this.addHandles(this._applyVisibilityPass);
  }
  get updating() {
    return has("esri-2d-log-updating") && console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`), this.updateRequested;
  }
  update(e13) {
    this._applyVisibilityPass(e13);
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    var _a;
    this.updateRequested || (this.updateRequested = true, (_a = this.view) == null ? void 0 : _a.requestUpdate());
  }
  processUpdate(e13) {
    this.updateRequested && (this.updateRequested = false, this.update(e13));
  }
};
e([y()], d4.prototype, "updateRequested", void 0), e([y()], d4.prototype, "updating", null), e([y()], d4.prototype, "view", void 0), d4 = e([a("esri.views.2d.LabelManager")], d4);

// node_modules/@arcgis/core/views/2d/navigation/ZoomBox.js
var a7 = "esri-zoom-box";
var n15 = { container: `${a7}__container`, overlay: `${a7}__overlay`, background: `${a7}__overlay-background`, box: `${a7}__outline` };
var h3 = { zoom: "Shift", counter: "Ctrl" };
var l7 = class extends m2 {
  constructor(t12) {
    super(t12), this._container = null, this._overlay = null, this._backgroundShape = null, this._boxShape = null, this._box = { x: 0, y: 0, width: 0, height: 0 }, this._rafId = null, this._handles = null, this._redraw = this._redraw.bind(this);
  }
  destroy() {
    this.view = null;
  }
  set view(t12) {
    this._handles && this._handles.forEach((t13) => {
      t13.remove();
    }), this._handles = null, this._destroyOverlay(), this._set("view", t12), t12 && (t12.on("drag", [h3.zoom], (t13) => this._handleDrag(t13, 1), _2.INTERNAL), t12.on("drag", [h3.zoom, h3.counter], (t13) => this._handleDrag(t13, -1), _2.INTERNAL));
  }
  _start() {
    this._createContainer(), this._createOverlay(), this.navigation.begin();
  }
  _update(t12, e13, i7, r12) {
    this._box.x = t12, this._box.y = e13, this._box.width = i7, this._box.height = r12, this._rafId || (this._rafId = requestAnimationFrame(this._redraw));
  }
  _end(t12, e13, r12, s11, o9) {
    const a10 = this.view, n16 = a10.toMap(c3(t12 + 0.5 * r12, e13 + 0.5 * s11));
    let h5 = Math.max(r12 / a10.width, s11 / a10.height);
    -1 === o9 && (h5 = 1 / h5), this._destroyOverlay(), this.navigation.end(), a10.goTo({ center: n16, scale: a10.scale * h5 });
  }
  _updateBox(t12, e13, i7, r12) {
    const s11 = this._boxShape;
    s11.setAttributeNS(null, "x", "" + t12), s11.setAttributeNS(null, "y", "" + e13), s11.setAttributeNS(null, "width", "" + i7), s11.setAttributeNS(null, "height", "" + r12), s11.setAttributeNS(null, "class", n15.box);
  }
  _updateBackground(t12, e13, i7, r12) {
    this._backgroundShape.setAttributeNS(null, "d", this._toSVGPath(t12, e13, i7, r12, this.view.width, this.view.height));
  }
  _createContainer() {
    const t12 = document.createElement("div");
    t12.className = n15.container, this.view.root.appendChild(t12), this._container = t12;
  }
  _createOverlay() {
    const t12 = this.view.width, e13 = this.view.height, i7 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i7.setAttributeNS(null, "d", "M 0 0 L " + t12 + " 0 L " + t12 + " " + e13 + " L 0 " + e13 + " Z"), i7.setAttributeNS(null, "class", n15.background);
    const r12 = document.createElementNS("http://www.w3.org/2000/svg", "rect"), s11 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    s11.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), s11.setAttributeNS(null, "class", n15.overlay), s11.appendChild(i7), s11.appendChild(r12), this._container.appendChild(s11), this._backgroundShape = i7, this._boxShape = r12, this._overlay = s11;
  }
  _destroyOverlay() {
    this._container && this._container.parentNode && this._container.parentNode.removeChild(this._container), this._container = this._backgroundShape = this._boxShape = this._overlay = null;
  }
  _toSVGPath(t12, e13, i7, r12, s11, o9) {
    const a10 = t12 + i7, n16 = e13 + r12;
    return "M 0 0 L " + s11 + " 0 L " + s11 + " " + o9 + " L 0 " + o9 + " ZM " + t12 + " " + e13 + " L " + t12 + " " + n16 + " L " + a10 + " " + n16 + " L " + a10 + " " + e13 + " Z";
  }
  _handleDrag(t12, e13) {
    const i7 = t12.x, r12 = t12.y, s11 = t12.origin.x, o9 = t12.origin.y;
    let a10, n16, h5, l9;
    switch (i7 > s11 ? (a10 = s11, h5 = i7 - s11) : (a10 = i7, h5 = s11 - i7), r12 > o9 ? (n16 = o9, l9 = r12 - o9) : (n16 = r12, l9 = o9 - r12), t12.action) {
      case "start":
        this._start();
        break;
      case "update":
        this._update(a10, n16, h5, l9);
        break;
      case "end":
        this._end(a10, n16, h5, l9, e13);
    }
    t12.stopPropagation();
  }
  _redraw() {
    if (!this._rafId)
      return;
    if (this._rafId = null, !this._overlay)
      return;
    const { x: t12, y: e13, width: i7, height: r12 } = this._box;
    this._updateBox(t12, e13, i7, r12), this._updateBackground(t12, e13, i7, r12), this._rafId = requestAnimationFrame(this._redraw);
  }
};
e([y()], l7.prototype, "navigation", void 0), e([y()], l7.prototype, "view", null), l7 = e([a("esri.views.2d.navigation.ZoomBox")], l7);
var c10 = l7;

// node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t9 = class {
  constructor(t12) {
    this._gain = t12, this.lastValue = void 0, this.filteredDelta = void 0;
  }
  update(t12) {
    if (this.hasLastValue()) {
      const e13 = this.computeDelta(t12);
      this._updateDelta(e13);
    }
    this.lastValue = t12;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  hasLastValue() {
    return void 0 !== this.lastValue;
  }
  hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t12) {
    return void 0 === this.lastValue ? NaN : t12 - this.lastValue;
  }
  _updateDelta(t12) {
    void 0 !== this.filteredDelta ? this.filteredDelta = (1 - this._gain) * this.filteredDelta + this._gain * t12 : this.filteredDelta = t12;
  }
};

// node_modules/@arcgis/core/views/navigation/Momentum.js
var t10 = class {
  constructor(t12, i7, o9) {
    this._initialVelocity = t12, this._stopVelocity = i7, this._friction = o9, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t12) {
    return t12 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t12) {
    return this.valueFromInitialVelocity(this._initialVelocity, t12);
  }
  valueDelta(t12, i7) {
    const o9 = this.value(t12);
    return this.value(t12 + i7) - o9;
  }
  valueFromInitialVelocity(t12, i7) {
    i7 = Math.min(i7, this.duration);
    const o9 = 1 - this.friction;
    return t12 * (o9 ** i7 - 1) / Math.log(o9);
  }
};

// node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var c11 = class extends t10 {
  constructor(e13, t12, i7, s11, n16) {
    super(e13, t12, i7), this._sceneVelocity = s11, this.direction = n16;
  }
  value(e13) {
    return super.valueFromInitialVelocity(this._sceneVelocity, e13);
  }
};
var l8 = class {
  constructor(e13 = 300, t12 = 12, i7 = 0.84) {
    this._minimumInitialVelocity = e13, this._stopVelocity = t12, this._friction = i7, this.enabled = true, this._time = new t9(0.6), this._screen = [new t9(0.4), new t9(0.4)], this._scene = [new t9(0.6), new t9(0.6), new t9(0.6)], this._tmpDirection = n3();
  }
  add(e13, t12, i7) {
    if (this.enabled) {
      if (this._time.hasLastValue()) {
        if (this._time.computeDelta(i7) < 0.015)
          return;
      }
      this._screen[0].update(e13[0]), this._screen[1].update(e13[1]), this._scene[0].update(t12[0]), this._scene[1].update(t12[1]), this._scene[2].update(t12[2]), this._time.update(i7);
    }
  }
  reset() {
    this._screen[0].reset(), this._screen[1].reset(), this._scene[0].reset(), this._scene[1].reset(), this._scene[2].reset(), this._time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this._screen[0].hasFilteredDelta() || !this._time.hasFilteredDelta())
      return null;
    const e13 = this._screen[0].filteredDelta, t12 = this._screen[1].filteredDelta, i7 = null == e13 || null == t12 ? 0 : Math.sqrt(e13 * e13 + t12 * t12), s11 = this._time.filteredDelta, n16 = null == s11 || null == i7 ? 0 : i7 / s11;
    return Math.abs(n16) < this._minimumInitialVelocity ? null : this.createMomentum(n16, this._stopVelocity, this._friction);
  }
  createMomentum(s11, n16, r12) {
    o(this._tmpDirection, this._scene[0].filteredDelta ?? 0, this._scene[1].filteredDelta ?? 0, this._scene[2].filteredDelta ?? 0);
    const l9 = s5(this._tmpDirection);
    l9 > 0 && g(this._tmpDirection, this._tmpDirection, 1 / l9);
    const h5 = this._time.filteredDelta;
    return new c11(s11, n16, r12, null == h5 ? 0 : l9 / h5, this._tmpDirection);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pan.js
var v = class extends m2 {
  constructor(t12) {
    super(t12), this.animationTime = 0, this.momentumEstimator = new l8(500, 6, 0.92), this.momentum = null, this.tmpMomentum = n3(), this.momentumFinished = false, this.viewpoint = new l2({ targetGeometry: new x(), scale: 0, rotation: 0 }), this._previousDrag = null, f(() => this.momentumFinished, () => this.navigation.stop());
  }
  begin(t12, i7) {
    this.navigation.begin(), this.momentumEstimator.reset(), this.addToEstimator(i7), this._previousDrag = i7;
  }
  update(t12, i7) {
    this.addToEstimator(i7);
    let o9 = i7.center.x, s11 = i7.center.y;
    const e13 = this._previousDrag;
    o9 = e13 ? e13.center.x - o9 : -o9, s11 = e13 ? s11 - e13.center.y : s11, t12.viewpoint = Rt(this.viewpoint, t12.viewpoint, [o9 || 0, s11 || 0]), this._previousDrag = i7;
  }
  end(t12, i7) {
    this.addToEstimator(i7);
    const o9 = t12.navigation.momentumEnabled;
    this.momentum = o9 ? this.momentumEstimator.evaluateMomentum() : null, this.animationTime = 0, this.momentum && this.onAnimationUpdate(t12), this._previousDrag = null, this.navigation.end();
  }
  addToEstimator(t12) {
    const i7 = t12.center.x, o9 = t12.center.y, s11 = i2(-i7, o9), m5 = r(-i7, o9, 0);
    this.momentumEstimator.add(s11, m5, 1e-3 * t12.timestamp);
  }
  onAnimationUpdate(t12) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinous(t12.viewpoint, (i7, o9) => {
      const { momentum: s11, animationTime: e13, tmpMomentum: m5 } = this, n16 = 1e-3 * o9;
      if (!(this.momentumFinished = !s11 || s11.isFinished(e13))) {
        const o10 = s11.valueDelta(e13, n16);
        g(m5, s11.direction, o10), Rt(i7, i7, m5), t12.constraints.constrainByGeometry(i7);
      }
      this.animationTime += n16;
    });
  }
  stopMomentumNavigation() {
    this.momentum && (this.momentumEstimator.reset(), this.momentum = null, this.navigation.stop());
  }
};
e([y()], v.prototype, "momentumFinished", void 0), e([y()], v.prototype, "viewpoint", void 0), e([y()], v.prototype, "navigation", void 0), v = e([a("esri.views.2d.navigation.actions.Pan")], v);
var d5 = v;

// node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s9 = class {
  constructor(t12 = 2.5, i7 = 0.01, s11 = 0.95, l9 = 12) {
    this._minimumInitialVelocity = t12, this._stopVelocity = i7, this._friction = s11, this._maxVelocity = l9, this.enabled = true, this.value = new t9(0.8), this.time = new t9(0.3);
  }
  add(t12, e13) {
    if (this.enabled && null != e13) {
      if (this.time.hasLastValue()) {
        if (this.time.computeDelta(e13) < 0.01)
          return;
        if (this.value.hasFilteredDelta()) {
          const e14 = this.value.computeDelta(t12);
          this.value.filteredDelta * e14 < 0 && this.value.reset();
        }
      }
      this.time.update(e13), this.value.update(t12);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta() || !this.time.hasFilteredDelta())
      return null;
    let e13 = this.value.filteredDelta / this.time.filteredDelta;
    return e13 = i(e13, -this._maxVelocity, this._maxVelocity), Math.abs(e13) < this._minimumInitialVelocity ? null : this.createMomentum(e13, this._stopVelocity, this._friction);
  }
  createMomentum(t12, e13, s11) {
    return new t10(t12, e13, s11);
  }
};

// node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a8 = class extends s9 {
  constructor(t12 = 3, a10 = 0.01, s11 = 0.95, o9 = 12) {
    super(t12, a10, s11, o9);
  }
  add(t12, a10) {
    const s11 = this.value.lastValue;
    if (null != s11) {
      let a11 = t12 - s11;
      for (; a11 > Math.PI; )
        a11 -= 2 * Math.PI;
      for (; a11 < -Math.PI; )
        a11 += 2 * Math.PI;
      t12 = s11 + a11;
    }
    super.add(t12, a10);
  }
};

// node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r11 = class extends t10 {
  constructor(e13, t12, r12) {
    super(e13, t12, r12);
  }
  value(e13) {
    const t12 = super.value(e13);
    return Math.exp(t12);
  }
  valueDelta(e13, t12) {
    const r12 = super.value(e13), s11 = super.value(e13 + t12) - r12;
    return Math.exp(s11);
  }
};
var s10 = class extends s9 {
  constructor(e13 = 2.5, t12 = 0.01, r12 = 0.95, s11 = 12) {
    super(e13, t12, r12, s11);
  }
  add(e13, t12) {
    super.add(Math.log(e13), t12);
  }
  createMomentum(e13, t12, s11) {
    return new r11(e13, t12, s11);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pinch.js
var _4 = class extends m2 {
  constructor(t12) {
    super(t12), this._animationTime = 0, this._momentumFinished = false, this._previousAngle = 0, this._previousRadius = 0, this._previousCenter = null, this._rotationMomentumEstimator = new a8(0.6, 0.15, 0.95), this._rotationDirection = 1, this._startAngle = 0, this._startRadius = 0, this._updateTimestamp = null, this._zoomDirection = 1, this._zoomMomentumEstimator = new s10(), this._zoomOnly = null, this.zoomMomentum = null, this.rotateMomentum = null, this.viewpoint = new l2({ targetGeometry: new x(), scale: 0, rotation: 0 }), this.addHandles(f(() => this._momentumFinished, () => this.navigation.stop()));
  }
  begin(t12, o9) {
    this.navigation.begin(), this._rotationMomentumEstimator.reset(), this._zoomMomentumEstimator.reset(), this._zoomOnly = null, this._previousAngle = this._startAngle = o9.angle, this._previousRadius = this._startRadius = o9.radius, this._previousCenter = o9.center, this._updateTimestamp = null, t12.constraints.rotationEnabled && this.addToRotateEstimator(0, o9.timestamp), this.addToZoomEstimator(o9, 1);
  }
  update(t12, o9) {
    null === this._updateTimestamp && (this._updateTimestamp = o9.timestamp);
    const i7 = o9.angle, s11 = o9.radius, e13 = o9.center, n16 = Math.abs(180 * (i7 - this._startAngle) / Math.PI), m5 = Math.abs(s11 - this._startRadius), a10 = this._startRadius / s11;
    if (this._previousRadius && this._previousCenter) {
      const r12 = s11 / this._previousRadius;
      let h5 = 180 * (i7 - this._previousAngle) / Math.PI;
      this._rotationDirection = h5 >= 0 ? 1 : -1, this._zoomDirection = r12 >= 1 ? 1 : -1, t12.constraints.rotationEnabled ? (null === this._zoomOnly && o9.timestamp - this._updateTimestamp > 200 && (this._zoomOnly = m5 - n16 > 0), null === this._zoomOnly || this._zoomOnly ? h5 = 0 : this.addToRotateEstimator(i7 - this._startAngle, o9.timestamp)) : h5 = 0, this.addToZoomEstimator(o9, a10), this.navigation.setViewpoint([e13.x, e13.y], 1 / r12, h5, [this._previousCenter.x - e13.x, e13.y - this._previousCenter.y]);
    }
    this._previousAngle = i7, this._previousRadius = s11, this._previousCenter = e13;
  }
  end(t12) {
    this.rotateMomentum = this._rotationMomentumEstimator.evaluateMomentum(), this.zoomMomentum = this._zoomMomentumEstimator.evaluateMomentum(), this._animationTime = 0, (this.rotateMomentum || this.zoomMomentum) && this.onAnimationUpdate(t12), this.navigation.end();
  }
  addToRotateEstimator(t12, o9) {
    this._rotationMomentumEstimator.add(t12, 1e-3 * o9);
  }
  addToZoomEstimator(t12, o9) {
    this._zoomMomentumEstimator.add(o9, 1e-3 * t12.timestamp);
  }
  canZoomIn(t12) {
    const o9 = t12.scale, i7 = t12.constraints.effectiveMaxScale;
    return 0 === i7 || o9 > i7;
  }
  canZoomOut(t12) {
    const o9 = t12.scale, i7 = t12.constraints.effectiveMinScale;
    return 0 === i7 || o9 < i7;
  }
  onAnimationUpdate(t12) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinous(t12.viewpoint, (o9, i7) => {
      const s11 = !this.canZoomIn(t12) && this._zoomDirection > 1 || !this.canZoomOut(t12) && this._zoomDirection < 1, e13 = !this.rotateMomentum || this.rotateMomentum.isFinished(this._animationTime), n16 = s11 || !this.zoomMomentum || this.zoomMomentum.isFinished(this._animationTime), p3 = 1e-3 * i7;
      if (this._momentumFinished = e13 && n16, !this._momentumFinished) {
        const i8 = this.rotateMomentum ? Math.abs(this.rotateMomentum.valueDelta(this._animationTime, p3)) * this._rotationDirection * 180 / Math.PI : 0;
        let s12 = this.zoomMomentum ? Math.abs(this.zoomMomentum.valueDelta(this._animationTime, p3)) : 1;
        const e14 = n4(), n17 = n4();
        if (this._previousCenter) {
          r2(e14, this._previousCenter.x, this._previousCenter.y), _3(n17, t12.size, t12.padding), s6(e14, e14, n17);
          const { constraints: r12, scale: p4 } = t12, l9 = p4 * s12;
          s12 < 1 && !r12.canZoomInTo(l9) ? (s12 = p4 / r12.effectiveMaxScale, this.zoomMomentum = null, this.rotateMomentum = null) : s12 > 1 && !r12.canZoomOutTo(l9) && (s12 = p4 / r12.effectiveMinScale, this.zoomMomentum = null, this.rotateMomentum = null), wt(o9, t12.viewpoint, s12, i8, e14, t12.size), t12.constraints.constrainByGeometry(o9);
        }
      }
      this._animationTime += p3;
    });
  }
  stopMomentumNavigation() {
    (this.rotateMomentum || this.zoomMomentum) && (this.rotateMomentum && (this._rotationMomentumEstimator.reset(), this.rotateMomentum = null), this.zoomMomentum && (this._zoomMomentumEstimator.reset(), this.zoomMomentum = null), this.navigation.stop());
  }
};
e([y()], _4.prototype, "_momentumFinished", void 0), e([y()], _4.prototype, "viewpoint", void 0), e([y()], _4.prototype, "navigation", void 0), _4 = e([a("esri.views.2d.navigation.actions.Pinch")], _4);
var d6 = _4;

// node_modules/@arcgis/core/views/2d/navigation/actions/Rotate.js
var u4 = n4();
var d7 = n4();
var j2 = class extends m2 {
  constructor(t12) {
    super(t12), this._previousCenter = n4(), this.viewpoint = new l2({ targetGeometry: new x(), scale: 0, rotation: 0 });
  }
  begin(t12, e13) {
    this.navigation.begin(), r2(this._previousCenter, e13.center.x, e13.center.y);
  }
  update(t12, e13) {
    const { state: { size: o9, padding: r12 } } = t12;
    r2(u4, e13.center.x, e13.center.y), X2(d7, o9, r12), t12.viewpoint = gt(this.viewpoint, t12.state.paddedViewState.viewpoint, lt(d7, this._previousCenter, u4)), a2(this._previousCenter, u4);
  }
  end() {
    this.navigation.end();
  }
};
e([y()], j2.prototype, "viewpoint", void 0), e([y()], j2.prototype, "navigation", void 0), j2 = e([a("esri.views.2d.actions.Rotate")], j2);
var h4 = j2;

// node_modules/@arcgis/core/views/2d/navigation/MapViewNavigation.js
var v2 = 10;
var w2 = 1;
var g5 = new l2({ targetGeometry: new x() });
var _5 = [0, 0];
var d8 = 250;
var T4 = class extends m2 {
  constructor(t12) {
    super(t12), this._endTimer = null, this._lastEventTimestamp = null, this.animationManager = null, this.interacting = false;
  }
  initialize() {
    this.pan = new d5({ navigation: this }), this.rotate = new h4({ navigation: this }), this.pinch = new d6({ navigation: this }), this.zoomBox = new c10({ view: this.view, navigation: this });
  }
  destroy() {
    this.pan = l(this.pan), this.rotate = l(this.rotate), this.pinch = l(this.pinch), this.zoomBox = l(this.zoomBox), this.animationManager = null;
  }
  begin() {
    this._set("interacting", true);
  }
  end() {
    this._lastEventTimestamp = performance.now(), this._startTimer(d8);
  }
  async zoom(t12, i7 = this._getDefaultAnchor()) {
    if (this.stop(), this.begin(), this.view.constraints.snapToZoom && this.view.constraints.effectiveLODs)
      return t12 < 1 ? this.zoomIn(i7) : this.zoomOut(i7);
    this.setViewpoint(i7, t12, 0, [0, 0]);
  }
  async zoomIn(t12) {
    const i7 = this.view, o9 = i7.constraints.snapToNextScale(i7.scale);
    return this._zoomToScale(o9, t12);
  }
  async zoomOut(t12) {
    const i7 = this.view, o9 = i7.constraints.snapToPreviousScale(i7.scale);
    return this._zoomToScale(o9, t12);
  }
  setViewpoint(t12, i7, o9, n16) {
    this.begin(), this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, t12, i7, o9, n16), this.end();
  }
  setViewpointImmediate(t12, i7 = 0, o9 = [0, 0], n16 = this._getDefaultAnchor()) {
    this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, n16, t12, i7, o9);
  }
  continousRotateClockwise() {
    var _a;
    const t12 = this.get("view.viewpoint");
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(t12, (t13) => {
      gt(t13, t13, -w2);
    });
  }
  continousRotateCounterclockwise() {
    var _a;
    const t12 = this.get("view.viewpoint");
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(t12, (t13) => {
      gt(t13, t13, w2);
    });
  }
  resetRotation() {
    this.view.rotation = 0;
  }
  continousPanLeft() {
    this._continuousPan([-v2, 0]);
  }
  continousPanRight() {
    this._continuousPan([v2, 0]);
  }
  continousPanUp() {
    this._continuousPan([0, v2]);
  }
  continousPanDown() {
    this._continuousPan([0, -v2]);
  }
  stop() {
    var _a;
    this.pan.stopMomentumNavigation(), (_a = this.animationManager) == null ? void 0 : _a.stop(), this.end(), null !== this._endTimer && (clearTimeout(this._endTimer), this._endTimer = null, this._set("interacting", false));
  }
  _continuousPan(t12) {
    var _a;
    const i7 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinous(i7, (i8) => {
      Rt(i8, i8, t12), this.view.constraints.constrainByGeometry(i8);
    });
  }
  _startTimer(t12) {
    return null !== this._endTimer || (this._endTimer = setTimeout(() => {
      this._endTimer = null;
      const t13 = performance.now() - (this._lastEventTimestamp ?? 0);
      t13 < d8 ? this._endTimer = this._startTimer(t13) : this._set("interacting", false);
    }, t12)), this._endTimer;
  }
  _getDefaultAnchor() {
    const { size: t12, padding: { left: i7, right: o9, top: n16, bottom: e13 } } = this.view;
    return _5[0] = 0.5 * (t12[0] - o9 + i7), _5[1] = 0.5 * (t12[1] - e13 + n16), _5;
  }
  async _zoomToScale(t12, i7 = this._getDefaultAnchor()) {
    const { view: o9 } = this, { constraints: n16, scale: e13, viewpoint: s11, size: a10, padding: r12 } = o9, c12 = n16.canZoomInTo(t12), m5 = n16.canZoomOutTo(t12);
    if (!(t12 < e13 && !c12 || t12 > e13 && !m5))
      return dt(g5, s11, t12 / e13, 0, i7, a10, r12), n16.constrainByGeometry(g5), o9.goTo(g5, { animate: true });
  }
  _scaleRotateTranslateViewpoint(t12, i7, o9, n16, e13) {
    const { view: s11 } = this, { size: a10, padding: r12, constraints: m5, scale: p3, viewpoint: u5 } = s11, l9 = p3 * o9, v3 = m5.canZoomInTo(l9), w3 = m5.canZoomOutTo(l9);
    return (o9 < 1 && !v3 || o9 > 1 && !w3) && (o9 = 1), Rt(u5, u5, e13), dt(t12, u5, o9, n16, i7, a10, r12), m5.constrainByGeometry(t12);
  }
};
e([y()], T4.prototype, "animationManager", void 0), e([y({ type: Boolean, readOnly: true })], T4.prototype, "interacting", void 0), e([y()], T4.prototype, "pan", void 0), e([y()], T4.prototype, "pinch", void 0), e([y()], T4.prototype, "rotate", void 0), e([y()], T4.prototype, "view", void 0), e([y()], T4.prototype, "zoomBox", void 0), T4 = e([a("esri.views.2d.navigation.MapViewNavigation")], T4);
var y2 = T4;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MagnifierPrograms.js
var a9 = { shaders: { vertexShader: n8("magnifier/magnifier.vert"), fragmentShader: n8("magnifier/magnifier.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };
function t11(r12) {
  return e8(r12, a9);
}

export {
  n9 as n,
  e10 as e,
  Y2 as Y,
  r5 as r,
  m4 as m,
  t8 as t,
  r7 as r2,
  n14 as n2,
  d4 as d,
  y2 as y,
  a9 as a,
  t11 as t2
};
//# sourceMappingURL=chunk-WRD2ODFQ.js.map
